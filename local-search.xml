<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>概率论与随机过程</title>
    <link href="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>2024/9/20 17:46 实在是懒得打公式了...干脆截图吧。</p><h1 id="一概率论">一、概率论</h1><h2 id="概率空间">2.概率空间</h2><h3 id="初等概率论的瑕疵">2.1 初等概率论的瑕疵</h3><p>我们首先来回顾本科学到的一些概念：</p><ul><li>样本空间<span class="math inline">\(\Omega\)</span>——随机试验所有可能出现的结果组成的集合。</li><li>样本点<span class="math inline">\(\omega\)</span>——<span class="math inline">\(\Omega\)</span>中的元素。</li><li><strong>随机事件——样本空间<span class="math inline">\(\Omega\)</span>的子集合，称为事件？</strong></li><li>基本事件——<span class="math inline">\(\Omega\)</span>中每个样本点所构成的单点集（基本事件不一定是随机事件）。</li><li>必然事件——<span class="math inline">\(\Omega\)</span>本身。</li><li>不可能事件——不包含任何元素的空集合<span class="math inline">\(\Phi\)</span>。</li></ul><p>我们对加粗的随机事件的定义保持怀疑，因为并不是所有样本空间的子集合都是随机事件，这是本科初等概率论中一个不严谨的地方。</p><p>接着是本科阶段对概率的定义：若E是随机试验，<span class="math inline">\(\Omega\)</span>是其样本空间，对于E的一事件A赋予一个实数，记为P(A)，如果集合函数P(.)满足以下条件：</p><ol type="1"><li>对于每一个事件A，P(A)≥0（非负性）</li><li>P(<span class="math inline">\(\Omega\)</span>)=1（归一性）</li><li>若<span class="math inline">\(A_i(i=1,2,\cdots)\)</span>是两两互不相容的事件，则：<span class="math inline">\(P(\cup_{k=1}^{\infty}A_k)=\displaystyle\sum_{k=1}^{\infty}P(A_k)\)</span>（可列可加性）</li></ol><p>称P(A)为事件A的概率。</p><p>若按照上面随机事件的定义，样本空间的子集合都是随机事件，那么概率的定义就会存在漏洞。若任一样本空间的子集合都是随机事件，在它们满足两两互不相容的情况下，会出现下面两个问题：</p><ol type="1"><li>可列求和后不一定封闭</li><li>求和与求P函数，不一定可以交换顺序</li></ol><p>那么该随机事件一定不能满足条件三，故该随机事件一定没有概率，这个说法显然是错误的。所以不是所有样本空间的子集和都是随机事件，我们要对随机事件进行更加严谨的定义。</p><h3 id="随机事件与概率空间">2.2 随机事件与概率空间</h3><p><mark>随机事件</mark>的定义：设<span class="math inline">\(\Omega\)</span>是任一非空集合，$ <span class="math inline">\(是由\)</span><span class="math inline">\(的一些子集组成的非空集合类，若\)</span>$满足：</p><ol type="1"><li><span class="math inline">\(\Omega\in \mathcal{F}\)</span></li><li>若<span class="math inline">\(A\in \mathcal{F}\)</span>，有<span class="math inline">\(\overline{A}\in\mathcal{F}\)</span>（补运算封闭）</li><li>若<span class="math inline">\(A_k\in\mathcal{F}(k=1,2,\cdots)\)</span>，有<span class="math inline">\(\cup_{k=1}^{\infty}A_k\in\mathcal{F}\)</span>（<strong>可列并运算封闭</strong>）</li></ol><p>则称<span class="math inline">\(\mathcal{F}\)</span>是<span class="math inline">\(\Omega\)</span>上的一个<span class="math inline">\(\sigma\)</span>-代数，<span class="math inline">\((\Omega,\mathcal{F})\)</span>称为可测空间。若<span class="math inline">\(\Omega\)</span>是一个随机试验所对应的样本空间，则<span class="math inline">\(\mathcal{F}\)</span>称为随机事件域，<span class="math inline">\(\mathcal{F}\)</span>中的元素A称为随机事件。</p><blockquote><p>显然：最简单的<span class="math inline">\(\sigma\)</span>-代数为：<span class="math inline">\(\mathcal{F}=\{\Phi,\Omega\}\)</span>；次简单的<span class="math inline">\(\sigma\)</span>-代数为：<span class="math inline">\(\mathcal{F}=\{\Phi,A,\overline{A},\Omega\}\)</span></p><p>根据上述条件，显然有：</p><p><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920103831276.png"></p></blockquote><p>测度的定义：设<span class="math inline">\((\Omega,\mathcal{F})\)</span>为可测空间，若<span class="math inline">\(\nu\)</span>满足：</p><ol type="1"><li><span class="math inline">\(\nu\ge0\)</span></li><li><span class="math inline">\(\nu\)</span>满足<span class="math inline">\(\sigma\)</span>-可加性，即：<span class="math inline">\(A_1,A_2\cdots\in\mathcal{F}\)</span>，且<span class="math inline">\(A_i\capA_j=\Phi,(i\not=j,其中i,j=1,2,\cdots)\)</span>，即：<span class="math inline">\(\nu(\cup_{i=1}^{\infty}A_i)\displaystyle=\sum_{i=1}^{\infty}v(A_i)\)</span></li></ol><p>则称<span class="math inline">\(\nu\)</span>是<span class="math inline">\(\mathcal{F}\)</span>上的测度，则称<span class="math inline">\((\Omega,\mathcal{F},\nu)\)</span>为测度空间。</p><p><mark>概率空间</mark>的定义：若<span class="math inline">\((\Omega,\mathcal{F})\)</span>称为可测空间，<strong>P(A)是定义在<span class="math inline">\(\mathcal{F}\)</span>上的实函数</strong>，如果：</p><ol type="1"><li><span class="math inline">\(\forall A\in\mathcal{F}，0\le P(A)\le1\)</span>（非负性）</li><li><span class="math inline">\(P(\Omega)=1\)</span>（归一性）</li><li>若<span class="math inline">\(A_i\in\mathcal{F}(i=1,2,\cdots)\)</span>，且<span class="math inline">\(A_i\cap A_j=\Phi(i\not=j)\)</span>，则：<span class="math inline">\(P(\cup_{k=1}^{\infty}A_k)=\displaystyle\sum_{k=1}^{\infty}P(A_k)\)</span>(<strong><span class="math inline">\(\sigma\)</span>-可加性</strong>)</li></ol><p>称P(A)为事件A的概率，<span class="math inline">\((\Omega,\mathcal{F},P)\)</span>称为概率空间。</p><blockquote><p><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920111448087.png"></p><p>8.多除少补原理：若<span class="math inline">\(A_i\in\mathcal{F}(i=1,2,\cdotsn)\)</span>，则<span class="math inline">\(P(\cup_{i=1}^{n}A_i)=S_1-S_2+S_3-S_4+\cdots+(-1)^{n+1}S_n\)</span></p><p>其中<span class="math inline">\(S_1=\displaystyle\sum_{i=1}^{n}P(A_i)\)</span>，<span class="math inline">\(S_2=\displaystyle\sum_{1\le i&lt;j\le n}P(A_i\capA_j)\)</span>，<span class="math inline">\(S_3=\displaystyle\sum_{1\lei&lt;j&lt;k\le n}P(A_i\cap A_j\cap A_k)\)</span>……<span class="math inline">\(S_n=P(A_1\cap A_2\cap\cdots A_n)\)</span></p><p>9.<img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920173012244.png"></p><p><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920173037340.png"></p><p><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920173109921.png"></p></blockquote><h3 id="一些重要概念">2.3 一些重要概念</h3><p>古典概型：若随机试验E具有下列特征：</p><ol type="1"><li>有限性：样本空间含有限个样本点<span class="math inline">\(\Omega=\{e_1,e_2\cdots e_n\}\)</span></li><li>等可能性：每一个样本点出现的概率相同，即<span class="math inline">\(P(e_1)=P(e_2)=\cdotsP(e_n)=\frac{1}{n}\)</span></li></ol><p>则称E为古典概型。</p><p>设事件A包含<span class="math inline">\(\Omega\)</span>中的k个样本点，则： <span class="math display">\[P(A)=\frac{k}{n}=\frac{事件A包含的样本点数}{样本点总数}\]</span> <img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920174204315.png" alt="条件概率"></p><figure><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920174359469.png" alt="乘法公式"><figcaption aria-hidden="true">乘法公式</figcaption></figure><figure><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920174515364.png" alt="全概率公式"><figcaption aria-hidden="true">全概率公式</figcaption></figure><figure><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920174748283.png" alt="贝叶斯公式"><figcaption aria-hidden="true">贝叶斯公式</figcaption></figure><figure><img src="/2024/09/19/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/image-20240920174913993.png" alt="n个事件的独立性"><figcaption aria-hidden="true">n个事件的独立性</figcaption></figure><h2 id="随机变量及其概率分布">3.随机变量及其概率分布</h2><p>一维随机变量：设<span class="math inline">\((\Omega,\mathcal{F},P)\)</span>是概率空间，X=X(e)是定义在<span class="math inline">\(\Omega\)</span>上的实函数，如果对任意实数<span class="math inline">\(x,\{e:X(e)\lex\}\in\mathcal{F}\)</span>，则X(e)是<span class="math inline">\(\mathcal{F}\)</span>上的随机变量，简记为随机变量X。</p><blockquote><ul><li><p><strong>X</strong> 是定义在样本空间 Ω上的<strong>实值函数</strong>，也就是说，随机变量 X 将 Ω中的每个元素（即随机实验的每个结果）映射为一个实数。</p></li><li><p><strong>e</strong> 代表 Ω中的一个元素（即某个具体的实验结果）。因此，X(e)是一个实数，表示随机变量在特定实验结果 e 下的取值。</p></li></ul></blockquote><p>二维随机变量：设<span class="math inline">\((\Omega,\mathcal{F},P)\)</span>是概率空间，(X,Y)=(X(e),Y(e))是定义在<span class="math inline">\(\Omega\)</span>上的二维空间中取值的实向量函数，如果对任意实数，<span class="math inline">\((x,y)\in R^2,\{e:X(e)\le x,Y(e)\ley\}\in\mathcal{F}\)</span>，则（X(e),Y(e)）是<span class="math inline">\(\mathcal{F}\)</span>上的二维随机变量。</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论与随机过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近世代数及其应用</title>
    <link href="/2024/09/17/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <url>/2024/09/17/%E8%BF%91%E4%B8%96%E4%BB%A3%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="一预备知识">一、预备知识</h1><p>幂集：A是集合，A的所有子集构成的集合，记P(A)。</p><p>集合的对称差：<span class="math inline">\(A\oplus B=(A\cup B)-(A\capB)\)</span></p><p><strong>容斥原理</strong>：设<span class="math inline">\(A_1,A_2,\cdots ,A_n\)</span>​是有限集合，则 <span class="math display">\[|\overline{A_1}\cap\overline{A_2}\cap\cdots\overline{A_n}|=|\overline{A_1\cup A_2\cup\cdots\cup A_n}|=N-|A_1\cupA_2\cup\cdots\cupA_n|\\=N-\Bigg(\displaystyle\sum_{i=1}^n|A_i|-\displaystyle\sum_{i=1}^n\displaystyle\sum_{j&gt;i}|A_i\capA_j|+\displaystyle\sum_{i=1}^n\displaystyle\sum_{j&gt;i}\displaystyle\sum_{k&gt;j}|A_i\capA_j\cap A_k|-\cdots+(-1)^{n-1}|A_1\cap A_2\cap\cdots\cap A_n|\Bigg)\]</span></p><blockquote><p>|A|表示集合A中元素的个数。</p></blockquote><p>二元关系：设A,B是两个集合，A×B的子集R称为A,B间的一个二元关系。当<span class="math inline">\((a,b)\inR\)</span>时，称a与b具有关系R，记作aRb；当<span class="math inline">\((a,b)\not\inR\)</span>时，称a与b不具有关系R，记作aR'b。</p><blockquote><p>A×B中的元素可看成由A和B中的元素所张成的平面上的点。</p></blockquote><p>集合A的二元关系R = A×A的某个子集 = <span class="math inline">\(\{(a,b)|a,b\in A\}\)</span>，记作：aRb</p><p>集合A的元素间的一个二元关系R，若满足：</p><ol type="1"><li>反身性：<span class="math inline">\(\forall a\in A,aRa\)</span></li><li>对称性：<span class="math inline">\(aRb\Rightarrow bRa\)</span></li><li>传递性：<span class="math inline">\(aRb,bRc\RightarrowaRc\)</span></li></ol><p>则称R是一个等价关系，记为<span class="math inline">\(\sim\)</span>。</p><p>设R是集合上的二元关系，如果R满足反身性、对称性和传递性，则称R为A上的等价关系，记作：<span class="math inline">\(\sim\)</span>。</p><p>若<span class="math inline">\(\sim\)</span>是A上的等价关系，<span class="math inline">\(\forall a,b\in A\)</span>，若<span class="math inline">\(a\sim b\)</span>，则称a与b是等价的，称：<span class="math inline">\([a]=\{x|x\in A且x\sima\}\)</span>为包含元素a的等价类。</p><blockquote><p>注：等价类是集合。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>近世代数及其应用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>定位和通感相关的基础知识</title>
    <link href="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一ofdm系统收发过程">一、OFDM系统收发过程</h1><p>OFDM系统将多个高速传输的数据流经过串并变换之后，分配到若干个低速率子信道上进行传输，由于多个子信道的<strong>子载波频率</strong>之间严格正交，因此各子信道频谱之间可以互相重叠，如此便可大大提高频谱利用率。若各子载波频率未能达到严格正交，则会引起符号间干扰（InterSymbol Interference，ISI）和子载波间干扰（Inter CarrierInterference，ICI）,导致接收端解调失败，对系统性能会产生很大的影响。</p><p>本节首先介绍无时频偏的情况下理想接收的OFDM信号模型，然后在此基础上介绍存在时频偏情况下的OFDM接收信号模型，最后对载波相位估计算法中使用的定位参考信号（PositioningReference Signal，PRS）进行概括性的介绍。</p><h2 id="无时频偏ofdm信号模型">1.无时频偏OFDM信号模型</h2><p>记OFDM信号传输的子载波数为K，子载波间隔为<span class="math inline">\(\Deltaf_{SCS}\)</span>，对一个OFDM符号的时域采样点个数为<strong>N</strong>，<strong>n表示第n个时间采样点</strong>，由此可以表示出时域采样间隔<span class="math inline">\(T_S=1/(N\Deltaf_{SCS})=T/N\)</span>。第<strong>l</strong>个待发送OFDM符号中的第<strong>k</strong>个子载波上携带的频域数据为<span class="math inline">\(X_k^l,k\in\{0,1,\cdots,K-1\}\)</span>（也可以说是第m个OFDM符号中第n个子载波所传输的QAM符号），即第l个符号内的数据矢量可表示为<span class="math inline">\(X^l=[X_0^l,\cdots,X_{K-1}^l]^T\)</span>。针对该频域数据进行快速傅里叶逆变换（InverseFast FourierTransition，IFFT），可得到时域的基带离散信号，然后上变频至载波发送频率<span class="math inline">\(f_c\)</span>，便可得到<strong>待发送的OFDM信号</strong>，如下式所示。也可按照其物理意义理解，先将频域数据放至各子载波上，随后各子载波信号相加得到时域信号，然后采样获得离散信号，<span class="math inline">\(1/\sqrt{(N)}\)</span>为功率归一因子。</p><blockquote><p>总采样率：<span class="math inline">\(Fs\)</span></p><p>总子载波个数=时域采样点个数：<span class="math inline">\(N\)</span>（有下面可知<span class="math inline">\(N=Fs×T\)</span>）</p><p>子载波间隔：<span class="math inline">\(\Deltaf_{SCS}=Fs/N=1/T\)</span></p><p>时域采样间隔（时域采一个点需要的时间）：<span class="math inline">\(T_S=1/Fs=1/(N\Delta f_{SCS})\)</span></p><p>信号总时间：<span class="math inline">\(T=T_S×N=N/Fs=1/\Deltaf_{SCS}\)</span></p></blockquote><p>第l个OFDM符号上的第n个采样点可以表示为： <span class="math display">\[x_n^l=x^l(t_n)=\frac{1}{\sqrtN}\displaystyle\sum_{k=0}^{K-1}X_k^le^{j2\pi(f_c+k\Deltaf_{SCS})t_n}\\=\frac{1}{\sqrtN}\displaystyle\sum_{k=0}^{K-1}X_k^le^{j2\pi(f_c+k\Deltaf_{SCS})nT_S}=\frac{1}{\sqrtN}\displaystyle\sum_{k=0}^{K-1}X_k^le^{j2\pi(f_c+k\Deltaf_{SCS})n/(N\Delta f_{SCS})}\\=\frac{1}{\sqrtN}\displaystyle\sum_{k=0}^{K-1}X_k^le^{j2\pi f_cnT_S}e^{j2\pi kn/N}\]</span></p><blockquote><p>子载波间隔既确定了子载波本身，又确定了待发信号的传输时间，从而决定了信号频谱的主瓣宽度以及旁瓣为0的位置。这也意味着，OFDM系统中一旦选定了子载波间隔，时域上的正交性以及频域上的正交性也就顺理成章的联系起来了。</p><p>在时域上不同子载波需要正交，以正弦信号为例，<span class="math inline">\(\{sin(2\pi·\Delta f·t),sin(2\pi·\Delta f·2t),\cdots,sin(2\pi·\Delta f·kt)\}\)</span>在区间<span class="math inline">\([0,1/\Delta f]\)</span>上正交，<span class="math inline">\(1/\Deltaf\)</span>等于每个码元的传输时长T。所以其在频域上的带宽为<span class="math inline">\(\Delta f\)</span>。</p><p>在频域上，在经过傅里叶变换后，各个子载波在频谱上表现为对sinc信号的搬移，不同子载波的频谱形状相同，只是频谱被搬移的位置变了。具体表现为每个子载波的抽样点上，其它的子载波信号抽样值均为0，不同子载波的间隔为<span class="math inline">\(\Deltaf\)</span>，如下图所示。这也就保证了频域上的正交性。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/d0fbc7b2007845958fe18d5d2893bbbd.jpeg" alt="i"><figcaption aria-hidden="true">i</figcaption></figure></blockquote><blockquote><p>时域采样点个数等于总的子载波数，一般都是一样的，都记作</p></blockquote><p>信号经过信道到达接收机处，记信道脉冲响应为h(t)，表达式如下 <span class="math display">\[h(t)=\displaystyle\sum_{i=0}^{L-1}h_ie^{-j\phi_i}\delta(t-\tau_i)\]</span> 其中，L表示多径数，<span class="math inline">\(h_i\)</span>表示第i条多径的衰减系数，<span class="math inline">\(\delta(·)\)</span>表示狄利克雷函数，<span class="math inline">\(\tau_i\)</span>表示第i条多径的传播时延，<span class="math inline">\(\phi_i\)</span>表示信号传输过程中的相位偏转，包括传输时延引起的相位旋转及相位噪声等，考虑理想接收的情况，即传播过程不存在相位噪声，因此相位偏转可以表示为<span class="math display">\[\phi_i=2\pi(f_c+k\Delta f_{SCS})\tau_i\]</span></p><blockquote><p>狄利克雷函数：值域为{0,1}，即当自变量为有理数时，函数值为1；当自变量为无理数时，函数值为0。</p></blockquote><p>信号经过信道（即与h(t)卷积)后，先进行下变频，将载波信号换至基带，得到离散时域信号。然后进行快速傅里叶变换（FastFourier Transition，FFT），获得频域数据。</p><p>接收机处的离散时域信号可表示为 <span class="math display">\[y_n^l=[x^l_n*h(t)]_{下变频}=\displaystyle\sum_{i=0}^{L-1}h_ie^{-j\phi_i}x^l_{n}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{i=0}^{L-1}\displaystyle\sum_{k=0}^{K-1}h_ie^{-j\phi_i}X_k^le^{j2\pikn/N}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}(\displaystyle\sum_{i=0}^{L-1}h_ie^{-j\phi_i})X_k^le^{j2\pikn/N}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pikn/N}+\omega_n\\\]</span> 其中，<span class="math inline">\(n_{\tau_i}\)</span>表示时延<span class="math inline">\(\tau_i\)</span>对应的时域采样间隔<span class="math inline">\(T_S\)</span>的倍数，<span class="math inline">\(\omega_n\)</span>表示高斯白噪声信号，<span class="math inline">\(H_k\)</span>表示信道频率响应，表示为 <span class="math display">\[H_k=\displaystyle\sum_{i=0}^{L-1}h_ie^{-j\phi_i}=\displaystyle\sum_{i=0}^{L-1}h_ie^{-j2\pi(f_c+k\Deltaf_{SCS})\tau_i}\]</span> 对时域接收信号进行FFT变换，便可得到接收信号的频域形式， <span class="math display">\[R_k^m=FFT[y_n^l]=\displaystyle\sum_{n=0}^{N-1}y_n^le^{-j2\pikn/N}=H_kX_k^m+W_k,k=0,\cdots,N-1\]</span></p><h2 id="存在时频偏ofdm信号模型">2.存在时频偏OFDM信号模型</h2><p>当收发两端时钟不同步、且存在载波频率偏移（包括多普勒频移）时，接收信号的时域形式和频域形式将会产生较大的相位偏转，从而无法解调出正确的信号，严重时可能导致OFDM信号完全不可用。</p><p>记载波频率偏移（Carrier Frequency Offset，CFO）为<span class="math inline">\(\Delta f\)</span>，<span class="math inline">\(\delta_f=\Delta f/\Delta f_{SCS}\)</span>表示归一化频偏，收发两端采样时钟偏移（Sampling Time Offset，STO）为<span class="math inline">\(\Deltat\)</span>。在前一小节中，由于考虑的场景是理想情况下的信号接收，为简化叙述，未引入循环前缀（CyclicPrefix，CP），本小节中的CFO和STO会对循环前缀部分的数据产生影响从而影响信号整体的载波相位，因此在此处需要引入CP，记循环前缀的长度为<span class="math inline">\(N_{CP}\)</span>。</p><p>由于公式表述较为复杂，本章将时偏与频偏分开讨论，最后整合，存在频偏情况下的接收信号表达式为</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240620210647811.png" alt="存在频偏情况下的频域接收信号表达式" style="zoom: 67%;"><span class="math display">\[y_n^l=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pikn/N}e^{j2\pi\Deltaft_n}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pikn/N}e^{j2\pi \delta f\Deltaf_{SCS}nT_S}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pikn/N}e^{j2\pi \delta f \frac{\Delta f_{SCS}n}{N\Deltaf_{SCS}}}+\omega_n\\=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pikn/N}e^{j2\pi \delta f \frac{n}{N}}+\omega_n\]</span> 其中，<span class="math inline">\(ICI_k\)</span>为频偏造成的子载波间干扰，具体表达式为<span class="math display">\[ICI_k=e^{j\pi\delta_f(N-1)/N}\displaystyle\sum_{k&#39;=0,k&#39;≠k}^{K-1}\frac{sin(\pi(k&#39;-k+\delta_f))}{\sqrt{N}sin(\pi(k&#39;-k+\delta_f)/N)}H_{k&#39;}X_{k&#39;}^le^{j\pi(k&#39;-k)(N-1)/N}\]</span>由于OFDM符号是连续发送的，因此频偏造成的相位旋转会随着符号数的增加而不断累积，第l个符号的累积相位偏移为<span class="math display">\[\nu^l=2\pi\delta_f(\displaystyle\sum_{i=0}^{l-1}(N+N_{CP})+N_{CP})/N=2\pi\delta_f(lN_S+N_{CP})/N\]</span> 其中，<span class="math inline">\(N_S=N+N_{CP}\)</span>表示加上循环前缀后的一个OFDM符号长度。接下来考虑由采样时钟偏差导致的相位偏转，令<span class="math inline">\(\Delta n=\Deltat/T_S\)</span>表示采样时钟偏差跨越的采样间隔数，引入时钟偏差后的时域接收信号就是在上一章的时域接收信号的基础上，采样点延迟<span class="math inline">\(\Delta n\)</span>，即 <span class="math display">\[y&#39;^l_n=y^l_{n-\Deltan}=\frac{1}{\sqrt{N}}\displaystyle\sum_{k=0}^{K-1}H_kX_k^le^{j2\pik(n-\Delta n)/N}+\omega_n\\\]</span> 因此频域接收信号可表示为</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240620223122624.png" alt="存在时偏情况下的频域接收信号表达式" style="zoom: 67%;"></p><p>更正，上述结果应为<span class="math inline">\(Y&#39;^l_k=\sqrt{N}e^{-j2\pi k\Delta f_{SCS}\Deltat}H_kX_k^l+ICI&#39;_k+W_k\)</span></p><p>其中，<span class="math inline">\(ICI&#39;_k\)</span>为时钟不同步造成的子载波间干扰，具体表达式为<span class="math display">\[ICI&#39;_k=\displaystyle\sum_{k&#39;=0,k&#39;≠k}^{K-1}\frac{sin(\pi(k&#39;-k))}{\sqrt{N}sin(\pi(k&#39;-k)/N)}H_{k&#39;}X_{k&#39;}^le^{j\pi(k&#39;-k)(N-1)/N}e^{-j2\pik&#39;\Delta n/N}\]</span></p><blockquote><p>无论是时偏还是频偏导致的相位偏转，都是在前一章得到的时域接收信号<span class="math inline">\(y_n^l\)</span>上进行改动，再对其进行FFT得到其频域接收信号。</p></blockquote><p>综合上面三个式子，可以得出存在时偏及频偏情况下的频域接收信号表达式为<span class="math display">\[Y_k^l=e^{\frac{j\pi\delta_f(N-1)}{N}}e^{\frac{j2\pi\delta_f(lN_S+N_{CP})}{N}}e^{-j2\pik\Delta f_{SCS}\Deltat}\frac{sin(\pi\delta_f)}{sin(\frac{\pi\delta_f}{N})}H_kX_k^l+ICI_k+ICI&#39;_k+W_k\]</span>由上式可以看出，由载波间频率偏移造成的相位旋转在相邻符号间的增加量是相同的，即频偏导致的相位偏移与OFDM符号数m成正比，同样，由时偏造成的相位偏移在同一符号内是与子载波数k成正比的，该比例关系可以作为后续计算CFO和STO的依据。</p><h2 id="ofdm波形的matlab仿真">3.OFDM波形的MATLAB仿真</h2><h3 id="ofdm概述">3.1 OFDM概述</h3><p>OFDM（Orthogonal Frequency DivisionMultiplexing）即正交频分复用技术，是一种特殊的多载波传输方案，它可以被看作是一种调制技术，也可以被当作一种复用技术。简而言之就是用多个相互正交的子载波搭载信息进行传输。</p><p>下面对<strong>正交频分复用</strong>字面意思进行理解：</p><ul><li><strong>正交</strong>：可区分</li><li><strong>频分</strong>：多个载波</li><li><strong>复用</strong>：频率可重复使用</li></ul><p>为了形象的理解，下面以 OFDM 频谱图进行讲解</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/73563a00cfd949f5aac7a4a4cb2bcf86.png"></p><p>图中每一种颜色的“小山包”都是代表一个子载波，图中有 6 个子载波</p><p>①、那么如何体现出的正交呢？也就是上面提出的可区分答：其中一个子载波的中心频率是其他子载波的信号的零点，也就是说在每一个子载波中心频率处，当前子载波的具有巨大的信号强度，可以检测到最大的能量，其他子载波信号强度都为0，检测到的能量为 0，如此达到了可区分的目的，即为正交。</p><p>②、如何体现出了频分呢？也就是上面说的多个载波答：图中不仅一个子载波，具有 6个子载波，每个子载波的中心频率不同，达到了一个频分的目的，即为频分。</p><p>③、如何体现出了复用呢？也就是上面说的频率可重复使用答：从图中前两个子载波可以看到它们在频率上有重叠的部分，也就是达到了频率可重复使用的目的，即为复用。</p><h3 id="用matlab实现离散傅里叶变换dft">3.2用Matlab实现离散傅里叶变换DFT</h3><p>对fc=100Hz的余弦信号进行离散傅里叶变换：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义参数</span><br>T = <span class="hljs-number">1</span>;                <span class="hljs-comment">% 信号的总时间（秒）</span><br>Fs = <span class="hljs-number">1000</span>;             <span class="hljs-comment">% 采样频率（每秒采样点数）</span><br><br><span class="hljs-comment">% 计算采样点数</span><br>N = T * Fs;           <span class="hljs-comment">% 总的采样点数</span><br><br><span class="hljs-comment">% 生成时间向量</span><br>t = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, T, N);  <span class="hljs-comment">% 在 0 到 T 之间生成 N 个时间点</span><br><br><span class="hljs-comment">% 定义信号</span><br>x = <span class="hljs-built_in">cos</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*<span class="hljs-number">100</span>*t) ;  <span class="hljs-comment">% 信号是两个正弦波的叠加</span><br><br><span class="hljs-comment">% 计算离散傅里叶变换</span><br>X = fft(x);<br><br><span class="hljs-comment">% 计算频率向量</span><br>f = <span class="hljs-built_in">linspace</span>(-Fs/<span class="hljs-number">2</span>, Fs/<span class="hljs-number">2</span>, N);  <span class="hljs-comment">% 生成频率向量</span><br><br><span class="hljs-comment">% 计算双边谱（即实际频率范围）</span><br>X = fftshift(<span class="hljs-built_in">abs</span>(X)) / N  ;   <span class="hljs-comment">% 移动零频率成分到中心并归一化FFT结果</span><br><br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">plot</span>(f, X);<br>title(<span class="hljs-string">&#x27;FFT 结果&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;频率 (Hz)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度&#x27;</span>);<br>grid on;<br></code></pre></td></tr></table></figure><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/DFT.jpeg" alt="DFT的结果"><figcaption aria-hidden="true">DFT的结果</figcaption></figure><h3 id="ofdm时域及频域仿真">3.3 OFDM时域及频域仿真</h3><p><strong>对于OFDM信号，形象点说在时域上是信号的叠加，在频域上是多个子载波并列。</strong></p><p>时域波形仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% ======================== 绘制时域波形图=======================</span><br>Fs = <span class="hljs-number">1000</span>;                                <span class="hljs-comment">% 总的采样率</span><br>N = <span class="hljs-number">1024</span>;                                <span class="hljs-comment">% 总的子载波数</span><br>T = N / Fs;                              <span class="hljs-comment">% 信号绘制为一个周期的长度</span><br>x = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, T, N) ;                 <span class="hljs-comment">% 生成时间向量，用于绘制波形</span><br>Numscr = <span class="hljs-number">4</span>;                              <span class="hljs-comment">% 绘制的子载波数量</span><br>s_data = <span class="hljs-number">1</span>;                              <span class="hljs-comment">% 初始相位</span><br>y = <span class="hljs-built_in">zeros</span>(Numscr, N);             <span class="hljs-comment">% 初始化存储每个子载波的复数值的矩阵</span><br>ini_phase = <span class="hljs-built_in">repmat</span>(s_data, <span class="hljs-number">1</span>, N);  <span class="hljs-comment">% 生成与时间长度相匹配的初始相位向量</span><br><span class="hljs-keyword">for</span> k = <span class="hljs-number">0</span> : Numscr<span class="hljs-number">-1</span>                      <span class="hljs-comment">% 循环遍历要绘制的子载波数量</span><br>    <span class="hljs-keyword">for</span> n = <span class="hljs-number">0</span> : N<span class="hljs-number">-1</span>                <span class="hljs-comment">% 循环遍历时间序列</span><br>        y(k+<span class="hljs-number">1</span>, n+<span class="hljs-number">1</span>) = ini_phase(n+<span class="hljs-number">1</span>) * <span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span><span class="hljs-built_in">i</span> * <span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * k * n / N);  <span class="hljs-comment">% 计算每个时间点上每个子载波的复数值</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">plot</span>(x, <span class="hljs-built_in">real</span>(y));                         <span class="hljs-comment">% 绘制时域波形</span><br>xlabel(<span class="hljs-string">&#x27;时间/s&#x27;</span>);                          <span class="hljs-comment">% 设置 X 轴标签为“时间”</span><br>ylabel(<span class="hljs-string">&#x27;幅度/V&#x27;</span>);                          <span class="hljs-comment">% 设置 Y 轴标签为“幅度”</span><br></code></pre></td></tr></table></figure><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%97%B6%E5%9F%9F%E6%B3%A2%E5%BD%A2.jpeg" alt="时域波形"><figcaption aria-hidden="true">时域波形</figcaption></figure><p>可以验证上面的那句话：“对于OFDM信号，形象点说在时域上是信号的叠加”。目前的图形是子载波分别绘制出来的结果，还未相加。</p><blockquote><p>绘制时域那里，时域表达式是直接写出的，不是由频域表达式进行反傅里叶变换得到的。</p></blockquote><p>频域波形仿真：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% ======================== 绘制频域波形图=======================</span><br>a = <span class="hljs-number">20</span>;<br>y1 = <span class="hljs-built_in">zeros</span>(Numscr, a * N);                <span class="hljs-comment">%时域尾部补零等效于频域插值，让频谱图形变得圆滑</span><br>y_combined = horzcat(y, y1);              <span class="hljs-comment">% 水平拼接两个矩阵</span><br>f = <span class="hljs-built_in">linspace</span>(-Fs/<span class="hljs-number">2</span>, Fs/<span class="hljs-number">2</span>, N*(a+<span class="hljs-number">1</span>));<br>y_fft = <span class="hljs-built_in">zeros</span>(Numscr, (a+<span class="hljs-number">1</span>)*N);<br><span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span> : Numscr<br>    y_fft(k, :) = <span class="hljs-built_in">real</span>(fftshift(fft(y_combined(k,:)))) / N;  <span class="hljs-comment">% 计算每个子载波的频谱</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>)<br><span class="hljs-built_in">plot</span>(f, y_fft(<span class="hljs-number">1</span>,:), f, y_fft(<span class="hljs-number">2</span>,:), f, y_fft(<span class="hljs-number">3</span>,:), f, y_fft(<span class="hljs-number">4</span>,:));<br>grid on;<br>xlim([<span class="hljs-number">-10</span>, <span class="hljs-number">10</span>]);                          <span class="hljs-comment">% 将 x 轴范围限制在 -10 到 10 之间</span><br>xlabel(<span class="hljs-string">&#x27;频率/Hz&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;幅度/V&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%A2%91%E5%9F%9F%E6%B3%A2%E5%BD%A2_.png" alt="频域波形"><figcaption aria-hidden="true">频域波形</figcaption></figure><h1 id="二doa估计music算法">二、DoA估计：MUSIC算法</h1><p>波达方向（Direction ofArrival，DOA）估计是指根据天线阵列的接收信号估计出单个或多个信号源的方位信息。由于激励信号和方向图之间存在傅里叶关系，DoA估计也可以等效为谱估计问题。</p><blockquote><p>激励信号就是输入信号。</p></blockquote><p>多重信号分类（Mutiple Signal Classification）算法，简称 <strong>MUSIC算法</strong>，是一种常用的 DoA估计方法。它的基本思想是基于接收信号协方差矩阵的特征值分解，利用分解后得到的特征矢量构造信号子空间和噪声子空间，<strong>由于天线阵列对于信号的流型矢量与构造的噪声子空间正交</strong>，该正交性便可用来估计信号的波达方向。天线阵列的流型矢量表示天线阵列对于接收信号产生的与波达方向有关的相位旋转。</p><h2 id="远场信源传播模型">1.远场信源传播模型</h2><p>假设有D个窄带远场不相关信号<span class="math inline">\(s_1(t),\cdots,s_D(t)\)</span>到达接收天线处，天线阵列为均匀线性阵列（UniformLinearArray，ULA），阵元数为M，相邻天线阵元间距表示为d，信号到达天线阵列的示意图如下图所示。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240621213148696.png" alt="天线接收信号模型"><figcaption aria-hidden="true">天线接收信号模型</figcaption></figure><p>记D个信号到达天线阵列的到达角分别为<span class="math inline">\(\{\theta_1,\cdots,\theta_D\}\)</span>，信号波长为<span class="math inline">\(\lambda\)</span>，则上图中信号<span class="math inline">\(s_i(t)\)</span>到达相邻天线接收信号的波程差<span class="math inline">\(\Delta\)</span>可表示为： <span class="math display">\[\Delta=dcos\theta_i\qquad(1)\]</span> 假设第i个待估计信号以角度<span class="math inline">\(\theta_i\)</span>入射至阵列，将均匀线阵中第一个阵元视为参考阵元。则与到达下标为m的阵元相比，时间差为：<span class="math inline">\(\frac{m·d·cos\theta_i}{c}=\frac{m·\Delta}{c}\)</span></p><p>每个信号的角频率为：<span class="math inline">\(\omega=2\pif=2\pi/T=\frac{2\pi c}{\lambda}\)</span></p><p>角频率乘以时间差就得到了相位差为：<span class="math inline">\(\frac{m·\Delta}{c}×\frac{2\pic}{\lambda}=\frac{2\pi m\Delta}{\lambda}\)</span></p><blockquote><p>到达第一个阵元的信号与到达阵元m的信号的相位差，下面需要后者到参考单元的相位差，所以需要加一个负号。</p></blockquote><p>天线阵列的流型矢量表示天线阵列对于接收信号产生的与波达方向有关的相位旋转。因此，天线阵列的流型矩阵可表示为：<span class="math display">\[A=[a(\theta_1),\cdots,a(\theta_D)]\qquad(2)\]</span> 其中， <span class="math display">\[a(\theta_i)=[1,e^{-j2\pi\frac{\Delta}{\lambda}},\cdots,e^{-j2\pi(M-1)\frac{\Delta}{\lambda}}]^T\qquad(3)\]</span></p><blockquote><p><span class="math inline">\(\Delta\)</span>中包含参数i。</p></blockquote><p>因此，天线阵列接收到的第i个到达信号可表示为： <span class="math display">\[x_i(t)=a(\theta_i)s_i(t)+n_i(t),i=1,\cdots,D,t=0,\cdots,T-1\qquad(4)\]</span> 其中，T表示信号快拍数，即时域信号的采样点数，<span class="math inline">\(n_i(t)\)</span>表示接收信号中混入的高斯白噪声信号。根据式(4)，接收信号的矩阵形式可写作：<span class="math display">\[X=AS+N\qquad(5)\]</span> 其中，<span class="math inline">\(S=[s_1(t),\cdots,s_D(t)]^T,S\inC^{D×T}\)</span>表示来波信号的矩阵形式，<span class="math inline">\(A\inC^{M×D}\)</span>表示天线阵列的流型矩阵，<span class="math inline">\(X\inC^{M×T}\)</span>表示接收信号的矩阵形式，<span class="math inline">\(N\inC^{M×T}\)</span>为高斯白噪声矩阵。</p><blockquote><p>X中的一个元素代表在T时刻在第m个天线单元上的接收信号（该时刻该天线单元上D个信号的和）</p></blockquote><h2 id="music算法思想">2.MUSIC算法思想</h2><p>假设<mark>不同信号源的信号之间是相互正交的，噪声与信号之间是正交的</mark>，则接收信号的协方差矩阵为：<span class="math display">\[R_X=E[XX^H]=E[(AS+N)(AS+N)^H]=E[(AS+N)[(AS)^H+N^H]]\\=E[(AS+N)((S^HA^H+N^H)]=E[ASS^HA^H+NN^H+ASN^H+NS^HA^H]\\=AR_SA^H+\sigma^2I_M\qquad(6)\]</span> 其中，上标<span class="math inline">\((·)^H\)</span>表示矩阵的共轭转置，<span class="math inline">\(\sigma^2\)</span>表示高斯白噪声功率，<span class="math inline">\(I_M\)</span>表示维度为M×M的单位阵，<span class="math inline">\(R_S\)</span>表示来波信号S的协方差矩阵，由于假设来波信号的信号之间是相互正交的，则<span class="math inline">\(R_S\)</span>理想情况下应为对角阵： <span class="math display">\[R_S = \begin{bmatrix}E[|s_1(t)|^2] &amp; 0 &amp; \cdots &amp; 0 \\0 &amp; E[|s_2(t)|^2] &amp; \cdots &amp; 0 \\\vdots &amp; \vdots &amp;\ddots &amp; 0\\0 &amp; 0 &amp; \cdots &amp; E[|s_D(t)|^2] \\\end{bmatrix}\]</span> <span class="math inline">\(R_X\)</span>进行特征分解，表示为：<span class="math display">\[R_X=E_S\Lambda_SE_S^H+E_N\Lambda_NE_N^H\qquad(7)\]</span> 其中，<span class="math inline">\(\Lambda_S\inC^{D×D}\)</span>为<span class="math inline">\(R_X\)</span>进行特征分解后产生的M个特征值中,以较大的前D个特征值为对角线元素组成的对角矩阵，这D个特征值的数值与信号功率之间应有对应关系，<span class="math inline">\(E_S\inC^{M×D}\)</span>为与这前D个较大的特征值相对应的特征向量矩阵，表示信号子空间；同理，<span class="math inline">\(\Lambda_N\inC^{(M-D)×(M-D)}\)</span>为以剩下的<strong>(M-D)个较小的特征值</strong>为对角元素组成的对角阵，该(M-D)个特征值的数值与噪声功率应有对应关系，<span class="math inline">\(E_N\inC^{M×(M-D)}\)</span>为与之对应的特征向量矩阵，表示噪声子空间。可以看出，若要使用MUSIC算法进行DoA估计，要求天线阵元数大于来波信号数量，即M&gt;D。</p><p>式(6)和式(7)相等，因此有： <span class="math display">\[AR_SA^H+\sigma^2I_M=E_S\Lambda_SE_S^H+E_N\Lambda_NE_N^H\qquad(8)\]</span>由上述描述可知，噪声子空间的特征值理想情况下应与噪声功率相等，即<span class="math inline">\(\Lambda_N\)</span>可表示为<span class="math inline">\(\sigma^2I_{M-D}\)</span>，因此噪声子空间部分可表示为：<span class="math display">\[E_N\Lambda_NE_N^H=\sigma^2E_NI_{M-D}E_N^H=\sigma^2I_M\qquad(9)\]</span> 基于式(9)，式(8)可简化为<span class="math inline">\(AR_SA^H=E_S\Lambda_SE_S^H\)</span>。</p><p>令<span class="math inline">\(R_X=AR_SA^H+\sigma^2I_M=R_A+\sigma^2I_M\)</span>。</p><p><span class="math inline">\(A\in C^{M×D},r(A)=D\)</span>，<span class="math inline">\(R_S\in C^{D×D}，r(R_S)=D\)</span>，故<span class="math inline">\(r(R_A)=D\)</span>。但<span class="math inline">\(R_A\inC^{M×M}\)</span>，<strong>故其有M-D个特征值为0</strong>。</p><p>对于<span class="math inline">\(R_A\)</span>的任意特征向量<span class="math inline">\(q_m\)</span>有： <span class="math display">\[R_Aq_m=\lambda_mq_m\RightarrowR_Xq_m=R_Aq_m+\sigma^2I_Mq_m=(\lambda_m+\sigma^2)q_m\]</span> 因此，信号协方差矩阵<span class="math inline">\(R_A\)</span>的特征值<span class="math inline">\(\lambda_m\)</span>对应的特征向量与输出信号协方差矩阵<span class="math inline">\(R_X\)</span>的特征值<span class="math inline">\(\lambda_m+\sigma^2\)</span>对应的特征向量相同。</p><p>所以，将输出信号矩阵<span class="math inline">\(R_X\)</span>进行特征分解，得到的M-D个<strong>较小且相等</strong>的特征值对应的特征向量构成的<span class="math inline">\(E_N\)</span>，<strong>对应着<span class="math inline">\(R_A\)</span>的特征值为0的特征向量组</strong>。</p><p>故可以得到<span class="math inline">\(R_AE_N=0·E_N=0\RightarrowAR_SA^HE_N=0\Rightarrow A^HE_N=0\)</span>。</p><blockquote><p>来波信号协方差矩阵<span class="math inline">\(R_S\)</span>一定不为零矩阵</p></blockquote><p><span class="math display">\[A^HE_N=0\qquad(10)\]</span>即，天线阵列流型矩阵与噪声子空间正交，此正交性便可用来构造空间谱函数从而进行DoA估计。利用该正交性构造谱函数如下：<span class="math display">\[P_{MUSIC}=\frac{1}{||E_N^Ha(\theta)||^2}=\frac{1}{a^H(\theta)E_NE_N^Ha(\theta)}\qquad(11)\]</span></p><blockquote><p><span class="math inline">\(||A||\)</span>是取矩阵A的模，就是求A中所有元素的平方和再开根号。<span class="math inline">\(E_N^H\in C^{(M-D)×M}\)</span>，<span class="math inline">\(a(\theta)\in C^{T×1}\)</span>，故<span class="math inline">\(E_N^Ha(\theta)\inC^{(M-D)×1}\)</span>，后面将其转置再乘以原矩阵就是一个求所有元素平方和的过程。</p></blockquote><p>其中，<span class="math inline">\(a(\theta)=[1,e^{-j2\pi\frac{dcos\theta}{\lambda}},\cdots,e^{-j2\pi(M-1)\frac{dcos\theta}{\lambda}}]^T\)</span>为以待测角度值<span class="math inline">\(\theta\)</span>构造的阵列流型矢量，以<span class="math inline">\(\theta\)</span>为自变量在一定角度范围内对谱函数<span class="math inline">\(P_{MUSIC}\)</span>进行谱峰搜索，当上式中的<span class="math inline">\(\theta\)</span>与信号源方向相同时，分母为零，此时MUSIC 谱估计为无穷大。因此，<strong>MUSIC谱估计的尖峰数目与信源数目相同，尖峰对应的方向即为信号源的方向</strong>，其峰值点对应的角度值即为DoA估计值。</p><h2 id="代码实现">3.代码实现</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs matlab">clc; clear; close all;<br><br><span class="hljs-comment">%% 参数设置</span><br><span class="hljs-comment">%%% 工作频率</span><br>c = <span class="hljs-number">3e8</span>;<br>freq = <span class="hljs-number">10e9</span>;<br>lambda = c/freq;    <span class="hljs-comment">% 波长</span><br><span class="hljs-comment">%%% 阵列参数</span><br>M = <span class="hljs-number">10</span>;                 <span class="hljs-comment">% 阵元数量</span><br>d = <span class="hljs-number">0.5</span>*lambda;         <span class="hljs-comment">% 阵元间隔 </span><br>z = (<span class="hljs-number">0</span>:<span class="hljs-number">1</span>:M<span class="hljs-number">-1</span>)&#x27;;     <span class="hljs-comment">% 阵元坐标分布</span><br><span class="hljs-comment">%%% 信号源参数</span><br>phi = [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">60</span> ,<span class="hljs-number">90</span> ,<span class="hljs-number">140</span>]&#x27;*<span class="hljs-built_in">pi</span>/<span class="hljs-number">180</span>;   <span class="hljs-comment">% 来波方向</span><br>D = <span class="hljs-built_in">length</span>(phi);                <span class="hljs-comment">% 信号源数目</span><br><span class="hljs-comment">%%% 仿真参数</span><br>SNR = <span class="hljs-number">10</span>;             <span class="hljs-comment">% 信噪比(dB)</span><br>T = <span class="hljs-number">1000</span>;     <span class="hljs-comment">% 采样点数</span><br><br><span class="hljs-comment">%% 阵列接收信号仿真模拟</span><br>A = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">j</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*z*d*<span class="hljs-built_in">cos</span>(phi&#x27;)/lambda);          <span class="hljs-comment">% 流型矩阵</span><br>Alpha = <span class="hljs-built_in">randn</span>(D, T);        <span class="hljs-comment">% 输入信号</span><br>X = A*Alpha;                        <span class="hljs-comment">% 阵列接收信号</span><br>X1 = awgn(X, SNR, <span class="hljs-string">&#x27;measured&#x27;</span>);      <span class="hljs-comment">% 加载高斯白噪声</span><br><br><span class="hljs-comment">%% MUSIC 算法</span><br><span class="hljs-comment">%%% 阵列接收信号的协方差矩阵的特征分解</span><br>R = X1*X1&#x27;/T;    <span class="hljs-comment">% 阵列接收信号的协方差矩阵</span><br>[EV, DIAG] = eig(R);       <span class="hljs-comment">% 特征值分解</span><br>EVA = <span class="hljs-built_in">diag</span>(DIAG);          <span class="hljs-comment">% 提取特征值</span><br>[EVA, I] = <span class="hljs-built_in">sort</span>(EVA, <span class="hljs-string">&#x27;descend&#x27;</span>);   <span class="hljs-comment">% 降序排序</span><br>E = EV(:, I);           <span class="hljs-comment">% 特征向量构成的矩阵</span><br>E_n = E(:, D+<span class="hljs-number">1</span>:M);      <span class="hljs-comment">% 噪声子空间</span><br><span class="hljs-comment">%%% 计算MUSIC谱估计函数</span><br>phi_list = <span class="hljs-built_in">linspace</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">pi</span>, <span class="hljs-number">200</span>)&#x27;;<br>A1 = <span class="hljs-built_in">exp</span>(<span class="hljs-number">-1</span><span class="hljs-built_in">j</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*z*d*<span class="hljs-built_in">cos</span>(phi_list&#x27;)/lambda);    <span class="hljs-comment">% 不同方向对应的流型矢量构成矩阵</span><br>sum(<span class="hljs-built_in">abs</span>(E_n&#x27;*A1).^<span class="hljs-number">2</span>)<br>P_MUSIC = <span class="hljs-number">1.</span>/sum(<span class="hljs-built_in">abs</span>(E_n&#x27;*A1).^<span class="hljs-number">2</span>);     <span class="hljs-comment">% MUSIC 谱估计公式</span><br><span class="hljs-comment">%%% 转换为dB</span><br>P_MUSIC = <span class="hljs-built_in">abs</span>(P_MUSIC);<br>P_MUSIC_max = <span class="hljs-built_in">max</span>(P_MUSIC);<br>P_MUSIC_dB = <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(P_MUSIC/P_MUSIC_max);<br><span class="hljs-comment">%%% 提取信号源方向</span><br>[P_peaks, P_peaks_idx] = findpeaks(P_MUSIC_dB);     <span class="hljs-comment">% 提取峰值</span><br>[P_peaks, I] = <span class="hljs-built_in">sort</span>(P_peaks, <span class="hljs-string">&#x27;descend&#x27;</span>);    <span class="hljs-comment">% 峰值降序排序</span><br>P_peaks_idx = P_peaks_idx(I);<br>P_peaks = P_peaks(<span class="hljs-number">1</span>:D);             <span class="hljs-comment">% 提取前D个</span><br>P_peaks_idx = P_peaks_idx(<span class="hljs-number">1</span>:D);<br>phi_e = phi_list(P_peaks_idx)*<span class="hljs-number">180</span>/<span class="hljs-built_in">pi</span>;   <span class="hljs-comment">% 估计方向</span><br><span class="hljs-built_in">disp</span>(<span class="hljs-string">&#x27;信号源估计方向为：&#x27;</span>);<br><span class="hljs-built_in">disp</span>(phi_e);<br><span class="hljs-comment">%%% 绘图</span><br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">plot</span>(phi_list*<span class="hljs-number">180</span>/<span class="hljs-built_in">pi</span>, P_MUSIC_dB, <span class="hljs-string">&#x27;k&#x27;</span>, <span class="hljs-string">&#x27;Linewidth&#x27;</span>, <span class="hljs-number">2</span>);<br>xlabel(<span class="hljs-string">&#x27;\phi (deg)&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;Pseudo-spectrum (dB)&#x27;</span>);<br>axis([<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">-40</span>, <span class="hljs-number">0</span>]);<br>grid on;<br><span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">plot</span>(phi_e, P_peaks, <span class="hljs-string">&#x27;r.&#x27;</span>, <span class="hljs-string">&#x27;MarkerSize&#x27;</span>, <span class="hljs-number">25</span>);<br><span class="hljs-built_in">hold</span> on;<br><span class="hljs-keyword">for</span> idx = <span class="hljs-number">1</span>:D<br>    text(phi_e(idx)+<span class="hljs-number">3</span>, P_peaks(idx), sprintf(<span class="hljs-string">&#x27;%0.1f°&#x27;</span>, phi_e(idx)));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/result.png" alt="result"><figcaption aria-hidden="true">result</figcaption></figure><h1 id="三克拉美劳下界cramer-rao-lower-bound">三、克拉美劳下界(Cramer-RaoLower Bound)</h1><h2 id="引言">1.引言</h2><h3 id="估计器性能">1.1 估计器性能</h3><p>对于一个参数估计问题，我们主要从以下三个方面来衡量估计器的性能：</p><ol type="1"><li><strong>无偏性</strong>：满足 <span class="math inline">\(𝐸(\hat{𝜃})=𝜃\)</span>，确保估计值不存在系统偏差，在多次重复试验中能够收敛于真值。</li><li><strong>有效性</strong>：刻画估计量与真实值的偏离程度，若存在多种无偏估计器，认为方差最小的估计器是最有效的。</li><li><strong>一致性</strong>：当样本总数逐渐增加时，估计量应收敛于真实值。</li></ol><p>我们已经知道仅满足无偏性的估计器并不能对一个未知参数进行很好地估计。因此我们考虑估计器的有效性，也就是考虑估计器的方差。进一步考虑用方差来衡量估计器的性能是一件自然的事情，因为对于同一个待估计值，不同估计量产生的方差是不一样的。</p><p>统计信号处理理论中的 <strong>克拉美劳下界（Cramer-Rao LowerBound，CRLB）</strong> 就是衡量一个无偏估计器的有力工具。</p><p>举一种最简单的情况：</p><blockquote><p>一个物理量为A，我们使用某种方式去观测它，观测值为x，由于存在噪声，此时x=A+w，w为高斯噪声<span class="math inline">\(w\simN(0,\sigma^2)\)</span>。由于我们很自然地会直接使用观测值x去估计A，所以这时候就会存在估计误差。直观地理解，噪声w的方差<span class="math inline">\(\sigma^2\)</span>越大，估计就可能越不准确。</p></blockquote><h3 id="为什么要讨论克拉美劳界">1.2 为什么要讨论克拉美劳界？</h3><p>上面例子的方式，使用<span class="math inline">\(\hat{A}=x\)</span>去估计A，按第1个标准，它是无偏的，估计值会在真实值附近波动；按第2个标准，这个估计值波动的剧烈程度，也就是方差。在这个例子里，克拉美劳界就等于方差。</p><p>为什么不直接讨论方差而要去计算克拉美劳界呢？</p><ul><li>因为方差是针对某一种特定的估计量（或理解为估计方式）而言的，上面的例子中方差是估计量<span class="math inline">\(\hat{A}=x\)</span>的方差。</li><li>在更复杂的问题里，对A可以有各种不同的估计量，他们分别的方差是不同的。</li><li>显然，对于无偏估计量而言，方差越小的估计方式性能越好，但是这些方差都有一个下界，就是克拉美劳界。</li></ul><h3 id="直观地理解克拉美劳界">1.3 直观地理解克拉美劳界</h3><p>克拉美劳界本身不关心具体的估计方式，只是去反映：利用已有信息所能估计参数的最好效果。</p><p>还是上面那个参数估计的例子：</p><blockquote><p><span class="math display">\[p(x;A)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-A)^2}{2\sigma^2})\]</span></p></blockquote><p>我们把PDF中的 𝑥 取值固定时，PDF是未知参数 𝐴的函数，称为<strong>似然函数(LikelihoodFunction)</strong>。从下图来看，似然函数越“尖锐”，估计未知参数 𝐴的精度越高。</p><blockquote><p><strong>似然函数<span class="math inline">\(L(\theta;x)\)</span></strong>：一个关于总体参数θ的函数，反映了在给定观测数据x时，不同参数值θ对应的概率大小。在数值上等于给定参数θ后变量X的概率：<span class="math inline">\(L(\theta|x)=P(X=x|\theta)\)</span>。</p><p>在这里，似然函数表示：在我观测到X=x=0的情况下，我要估计的参数A=x=0的可能性是多少？在数值上，似然函数的值 = 已知真实的参数A=0的情况下，观测到x=0的概率（即概率密度函数）。</p></blockquote><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200120111313352.jpg" style="zoom: 25%;"></p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/20200120111405552.jpg" style="zoom:25%;"></p><p>定量描述这种“尖锐性”可以帮助我们比较出哪一种估计方法的精度更高。这个“尖锐”性可以用对数似然函数峰值处的负的二阶导数来度量，即<strong>对数似然函数的曲率</strong>。（用对数是为了便于计算。）曲率越大，越“尖锐”。<span class="math display">\[似然函数:L(A;x)=p(x|A)=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x-A)^2}{2\sigma^2})\\\Rightarrow取对数:\lnL(A;x)=-\ln\sqrt{2\pi}\sigma-\frac{1}{2\sigma^2}(x-A)^2\\\Rightarrow对参数A求一阶导:\frac{\partial\lnL(A;x)}{\partialA}=\frac{1}{\sigma^2}(x-A)\\\Rightarrow对参数A求二阶导:\frac{\partial^2\lnL(A;x)}{\partialA^2}=-\frac{1}{\sigma^2}\\\Rightarrow再取负号:\frac{1}{\sigma^2}\]</span></p><p><span class="math display">\[曲率=-\frac{\partial^2\ln L(A;x)}{\partial A^2}=\frac{1}{\sigma^2}\]</span></p><p>也就是说噪声越小，曲率越大，对数似然函数越尖锐。</p><h3 id="不同的估计量估计方式是什么意思">1.4不同的估计量（估计方式）是什么意思？</h3><p>举一个稍微复杂一点点的参数估计问题：</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240629121551569.png"></p><p>对同一个待估计值，不同估计方式产生的方差是不一样的。但是数学家们已经证明了：<strong>任何无偏估计量的方差必定大于等于克拉美劳界</strong>。</p><h2 id="克拉美劳界的基本计算">2.克拉美劳界的基本计算</h2><p>假设两次观察相互独立，仅受相同的高斯白噪声影响，则真实参数A的似然函数应该为两个正态的概率密度分布相乘：<span class="math display">\[L(A;X)=\displaystyle\prod_{i=1}^N\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x_i-A)^2}{2\sigma^2})\]</span> 两次观测：<span class="math inline">\(X=[x_1,x_2]\)</span></p><p>似然函数： <span class="math display">\[L(A;X)=p(X=x_1|A)·p(X=x_2|A)\\=\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x_1-A)^2}{2\sigma^2})·\frac{1}{\sqrt{2\pi}\sigma}exp(-\frac{(x_2-A)^2}{2\sigma^2})\\=\frac{1}{2\pi\sigma^2}exp(-\frac{(x_1-A)^2+(x_2-A)^2}{2\sigma^2})\]</span> 取对数：<span class="math inline">\(\ln L(A;X)=-\ln2\pi\sigma^2-\frac{(x_1-A)^2+(x_2-A)^2}{2\sigma^2}\)</span></p><p>对A求一阶导：<span class="math inline">\(\frac{\partial\lnL(A;x)}{\partial A}=\frac{(x_1-A)+(x_2-A)}{\sigma^2}\)</span></p><p>对A求二阶导：<span class="math inline">\(\frac{\partial^2\lnL(A;x)}{\partial A^2}=-\frac{2}{\sigma^2}\)</span></p><p>取负号：<span class="math inline">\(\frac{2}{\sigma^2}\)</span></p><p>计算出来的对数似然函数的曲率为<span class="math inline">\(\frac{2}{\sigma^2}\)</span>。</p><p>实际上，当观测样本数为N时，这个值为<span class="math inline">\(\frac{N}{\sigma^2}\)</span>，观测样本数越多，获取的信息越多，曲率越大，对数似然函数越”尖锐“。</p><p>这个二阶导数（曲率）更一般的度量是（下面用 θ 来表示要估计的参数）：<span class="math display">\[曲率=-E[\frac{\partial^2\ln p(x;\theta)}{\partial \theta^2}]\]</span></p><ul><li>它度量了对数似然函数的平均曲率（很多情况下曲率与x有关，所以取数学期望使它仅为θ的函数）。</li><li>它被称为数据x的 Fisher信息<span class="math inline">\(I(\theta)\)</span>，具有信息测度的基本性质（非负性、独立观测的可加性）</li></ul><p>一般来说，Fisher 信息的倒数就是克拉美劳界了！任何无偏估计量<span class="math inline">\(\hat{\theta}\)</span>​的方差满足： <span class="math display">\[var(\hat{\theta})\ge\frac{1}{-E[\frac{\partial^2\lnp(x;\theta)}{\partial \theta^2}]}\]</span></p><ul><li>克拉美劳界是所有无偏估计方案中方差最小的一个（最有效的一个）；</li><li>是所有无偏估计量的方差的下界；</li><li>任何一个无偏估计量的方差都不会比它小，也就是不会比它更好；</li><li>离它越近表示估计越好，越有效；</li><li>另外，信息越多，克拉美劳界越小，这个下界越低，表示估计越有效！</li></ul><h2 id="克拉美劳界的标准定义">3.克拉美劳界的标准定义</h2><p>假设PDF<span class="math inline">\(p(x;\theta)\)</span>满足<strong>正则条件</strong>：<span class="math inline">\(E[\frac{\partial\ln p(x;\theta)}{\partial\theta}]=0(对于所有的\theta)\)</span>。其中数学期望是对<span class="math inline">\(p(x;\theta)\)</span>求取的。</p><blockquote><p>推导： <span class="math display">\[E[\frac{\partial\ln p(x;\theta)}{\partial \theta}]=\int\frac{\partial\lnp(x;\theta)}{\partial \theta}p(x;\theta)dx=\int\frac{\partialp(x;\theta)}{\partial \theta}dx=\frac{\partial }{\partial \theta}\intp(x;\theta)dx=\frac{\partial 1 }{\partial \theta}=0\]</span>求期望实际上就是对x求积分，所以左边两个表达式相等，注意这个概念，很多地方都需要这样来化简期望的。乍一看好像所有的PDF都应该满足上面的正则表达式才对，其实不是的，我们在运算的过程中忽略了一个很重要的前提——<strong>求偏导和积分可以互换，这就是正则条件的核心。这说明了x的PDF非零边界是和θ 无关的，也就是积分上下限不含θ</strong>，举个例子，U[−θ,θ]很明显就不满足正则条件，因为此时积分和求偏导的顺序不可以交换。</p></blockquote><p>那么任何无偏估计量<span class="math inline">\(\hat{\theta}\)</span>的方差必定满足： <span class="math display">\[var(\hat{\theta})\ge\frac{1}{-E[\frac{\partial^2\lnp(x;\theta)}{\partial \theta^2}]}\]</span> 其中导数是在 θ 的真值处计算的，数学期望是对<span class="math inline">\(p(x;\theta)\)</span>求取的。</p><p>而且，对于某个函数 𝑔 和 𝐼 ，当且仅当<span class="math inline">\(\frac{\partial\ln p(x;\theta)}{\partial\theta}=I(\theta)(g(x)-\theta)\)</span>时，对所有<span class="math inline">\(\theta\)</span>达到下限的无偏估计量就可以求得。这个估计量是<span class="math inline">\(\hat{\theta}=g(x)\)</span>，它是MVU估计量（最小方差无偏估计），最小方差是<span class="math inline">\(\frac{1}{I(\theta)}\)</span>。</p><p>一个达到了下界的无偏估计被称为 完全高效的（fullyefficient）。这样的估计达到了所有无偏估计中的最小均方误差（MSE，meansquare error），因此是最小方差无偏（MVU，minimum varianceunbiased）估计。</p><h1 id="四无线信号传播多径影响">四、无线信号传播多径影响</h1><p>多径传播：多径传播是从发射机天线发射的无线电波（信号），沿两个或多个路径到达接收机天线的传播现象。</p><h2 id="多径效应频率选择性衰落">1.多径效应：频率选择性衰落</h2><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240629162256649.png" alt="传输模型" style="zoom:50%;"></p><p>发送信号f(t)经过两径传输到达接收端，假设两径的衰减均为K、两径的传输时延分别为<span class="math inline">\(\tau_1\)</span>和<span class="math inline">\(\tau_2\)</span>。很容易我们能写出接收信号<span class="math inline">\(f_0(t)\)</span>的表达式为： <span class="math display">\[f_0(t)=Kf(t-\tau_1)+Kf(t-\tau_2)\]</span> 接着利用傅里叶变换的时移特性，我们能写出它的傅里叶变换： <span class="math display">\[F_0(\omega)=KF(\omega)e^{-j\omega\tau_1}+KF(\omega)e^{-j\omega(\tau_1+\tau)}\]</span> 其中<span class="math inline">\(\tau=\tau_1+\tau_2\)</span>，是传输时延差。</p><p>所以我们可以得到信道的传递函数为： <span class="math display">\[H(\omega)=\frac{F_0(\omega)}{F(\omega)}=Ke^{-j\omega\tau_1}(1+e^{-j\omega\tau})\]</span> 结果含有三项，从前往后分别是：常数衰减因子、与<span class="math inline">\(\tau_1\)</span>有关的确定的传输时延因子、与信号时延差有关的一个复因子。故我们可以得到信道的幅频特性：<span class="math display">\[|H(\omega)|=K|1+e^{-j\omega\tau}|=K|e^{-\frac{j\omega\tau}{2}}e^{\frac{j\omega\tau}{2}}+e^{-\frac{j\omega\tau}{2}}e^{-\frac{j\omega\tau}{2}}|=K|e^{-\frac{j\omega\tau}{2}}||e^{\frac{j\omega\tau}{2}}+e^{-\frac{j\omega\tau}{2}}|=K|e^{\frac{j\omega\tau}{2}}+e^{-\frac{j\omega\tau}{2}}|=K·2|cos\frac{\omega\tau}{2}|\]</span> 观察发现，幅频特性是关于<span class="math inline">\(\omega\)</span>的一个周期函数，因此我们画出<mark>信道的幅频特性曲线</mark>：</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240629165459850.png" alt="信道的幅频特性曲线" style="zoom:50%;"></p><p>通过观察该曲线，我们发现，如果用这样一个信道去传输信号，那么信号的不同频率分量所经历的衰减是不一样的，呈现出频率选择性。另外，波峰与波谷之间的频率间隔是<span class="math inline">\(1/\tau\)</span>赫兹，信号增强与信号减弱的频率间隔就是<span class="math inline">\(1/\tau\)</span>赫兹。</p><p>通过两径的例子推广到多径，对一个复杂信号f(t)，经过多径传输之后，信号的强弱会发生变化，变化与信号的频率<span class="math inline">\(\omega\)</span>有关，因此我们称之为频率选择性衰落。</p><h2 id="多径效应瑞利衰落">2.多径效应：瑞利衰落</h2><p>精确测量每条路径的衰减系数和传播时延并不可行，但我们可以去研究时变衰落信道的统计特性。</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240629170236780.png" alt="传输模型" style="zoom:50%;"></p><p>假设发送的是幅度恒定，频率单一的余弦波s(t)，经过n条路径的传播，到达接收端。假设n条路径中没有直射路径，且相互独立，n条路径的衰减和时延各不相同。那么接收信号r(t)的幅度和频率会怎么变化呢？</p><p>首先我们能写出r(t)的表达式： <span class="math display">\[r(t)=\displaystyle\sum_{i=1}^na_i(t)cos\omega_c[t-\tau_i(t)]=\displaystyle\sum_{i=1}^na_i(t)cos[\omega_ct+\varphi_i(t)]\\=\displaystyle\sum_{i=1}^na_i(t)cos\varphi_i(t)cos\omega_ct-\displaystyle\sum_{i=1}^na_i(t)sin\varphi_i(t)sin\omega_ct=X(t)cos\omega_ct-Y(t)sin\omega_ct\\=V(t)cos[\omega_ct+\varphi(t)]\]</span> 其中<span class="math inline">\(a_i(t)\)</span>是第i条路径上的衰减，<span class="math inline">\(\tau_i(t)\)</span>是第i条路径上的时延，<span class="math inline">\(\varphi_i(t)=-\omega_c\tau_i(t)\)</span>。再将cos函数展开，其中我们将两个求和项定义成X(t)与Y(t)，就得到了接收信号的同相正交分解形式。然后我们还能得到它的包络相位分解形式，其中V(t)是它的包络，<span class="math inline">\(\varphi(t)\)</span>就是它的相位。</p><p>根据中心极限定理，当n足够大时，多路随机信号的和服从正态分布，也就是说X(t)和Y(t)服从正态分布，那它们的<mark>包络</mark>V(t)就服从瑞利分布，是随机缓变的。</p><p>我们发送的是一个幅度恒定的余弦波，收到的是一个幅度随机缓变的余弦波，我们称这种现象就叫做<strong>瑞利衰落</strong>。</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240701110007142.png" alt="发送信号与接收信号的波形" style="zoom:50%;"></p><h2 id="多径效应频率扩展频率弥散">3.多径效应：频率扩展（频率弥散）</h2><p>将上面的多径传输类比幅度调制，V(t)就是调制信号，s(t)是载波，r(t)是已调信号。通过类比幅度调制，我们去学习接收信号r(t)的<mark>频谱特征</mark>。</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240701111703479.png" style="zoom:50%;"></p><p>幅度调制就是将调制信号的频谱线性搬移到载频<span class="math inline">\(\omega_c\)</span>处，那对于r(t)，调制信号V(t)是随机缓变的，是一个带宽较窄的低频信号。</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240701110724664.png" alt="V(t)频谱搬移得到r(t)的频谱" style="zoom:50%;"></p><p>频谱搬移后，带宽远小于载频<span class="math inline">\(\omega_c\)</span>，因此r(t)是一个窄带随机信号。</p><p>我们发送的是一个单频余弦函数，我们可以得到它的频谱：</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240701111342386.png" alt="频率扩展" style="zoom:50%;"></p><p>经过多径传输后，得到r(t)其频谱如上，可以发现在频率上发生了扩展，因此我们称这种现象叫做<strong>频率扩展或者频率弥散</strong>。</p><p>刚才的推导中，我们假设这n条路径中没有直射路径，但是当直射路径存在的情况下，他就是正弦波加窄带高斯的情况，包络服从莱斯分布（广义瑞利分布）。</p><h2 id="相干带宽和平坦衰落">4.相干带宽和平坦衰落</h2><p>观察信道的幅频特性曲线，可以看到每隔<span class="math inline">\(1/\tau\)</span>，会经历一个零点。如果传输信号的带宽<span class="math inline">\(B_s\)</span>大于<span class="math inline">\(1/\tau\)</span>，那么这个信号的不同频率分量必然会有着非常严重的衰减，从而引起失真。</p><p>我们将<span class="math inline">\(1/\tau\)</span>作为信道的<strong>相干带宽</strong>，对一个多径信道而言，<span class="math inline">\(\tau\)</span>取信道的最大传输时延差，我们就认为在信道的相干带宽之内，衰减是平坦的，这种现象就是<strong>平坦衰落</strong>，是一种成功解决多径效应的现象。</p><p>通过控制发送信号的带宽<span class="math inline">\(B_s\)</span>小于信道的相干带宽，那么利用调制技术</p><p>总能选取一段不经过零点的频带来传输信号，从而保证衰落是平坦的。而工程上的要求会更加严苛，会选取靠近峰值的这一段更加平坦的频带来传输信号，就要求带宽是1/5到1/3的信道相干带宽。对应的符号持续时间是3到5倍的最大传输时延差，也就是说，要降低传输速率来有效地避免多径效应。</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240701113943397.png" style="zoom:50%;"></p><h1 id="五基于钟差消除的室内载波相位定位方案">五、基于钟差消除的室内载波相位定位方案</h1><h2 id="系统模型">1.系统模型</h2><p>定位场景设定在一个长度为L、宽度为W、高度为H的室内三维空间，该空间内部署M个位置已知且固定的无线接入点，其中编号为i(i=1,2,3,…,M)的无线接入点的位置坐标为<span class="math inline">\(u^{(i)}=(a^{(i)},b^{(i)},c^{(i)})^T\)</span>，设置<strong>编号为1的无线接入点为参考无线接入点</strong>。一个在该三维空间内自由移动的位置未知的<strong>待定位移动终端s</strong>在移动过程中始终处于这M个无线接入点的通信范围内，假设在t时刻，待定位移动终端s的位置坐标为<span class="math inline">\(v_t=(x_t,y_t,z_t)^T\)</span>。此外，还需要在这M个无线接入点的通信范围内设置一个<strong>位置已知且固定的参考终端r</strong>用于后续钟差克服算法的实施。假设在定位过程中，待定位移动终端s和参考终端r可始终可以和各个无线接入点进行直接通信，各个无线接入点可以接收两个终端发射的频率为<span class="math inline">\(f_c\)</span>的载波相位定位参考信号，并利用相关技术获取参考信号的<strong>TDoA测量值和载波相位观测值</strong>。</p><blockquote><p>ToA即时间，TDoA即时间差值。</p></blockquote><h3 id="tdoa测距模型">1.1 TDoA测距模型</h3><p>TDoA测量值需要两个无线接入点参与，可以表示为待定位移动终端s到两个无线接入点的ToA测量值的差值。在t时刻，待定位移动终端s向各个无线接入点发送连续的载波相位定位参考信号，编号为i的无线接入点接收到信号并利用相关技术测量得到<mark>ToA值</mark>，可以表示为<span class="math display">\[d_{t,s}^{(i)}=c^{-1}r_{t,s}^{(i)}+n_{t,s}^{(i)}+b_{t,s}^{(i)}\qquad(1)\]</span>其中d表示ToA测量值，下角标t表示当前时刻，下角标s表示待定位移动终端s，上角标i表示编号为i的无线接入点，c表示载波相位定位参考信号的传播速度，<mark><span class="math inline">\(r_{t,s}^{(i)}=||v_t-u^{(i)}||\)</span></mark>表示在t时刻待定位移动终端s到编号为i的无线接入点的真实物理距离，<span class="math inline">\(n_{t,s}^{(i)}\)</span>表示在t时刻无线接入点在测量ToA时引入的<strong>测量误差</strong>，假设该测量误差服从方差为<span class="math inline">\(\sigma_\tau^2\)</span>的零均值高斯分布，即<span class="math inline">\(n_{t,s}^{(i)}\simN(0,\sigma_\tau^2)\)</span>，<span class="math inline">\(b_{t,s}^{(i)}\)</span>表示在t时刻待定位移动终端s和编号为i的无线接入点存在的<strong>时变钟差</strong>。<strong>将编号为i的无线接入点测量得到的ToA值分别与参考无线接入点测量得到的ToA值进行差分可以得到两个无线接入点的TDoA值</strong>，可以表示为<span class="math display">\[\Delta d_{t,s}^{(i,1)}=c^{-1}\Delta r_{t,s}^{(i,1)}+\Deltan_{t,s}^{(i,1)}+\Delta b_{t,s}^{(i,1)}\qquad(2)\]</span> 其中<span class="math inline">\(\Delta(·)^{(i,1)}=(·)^{(i)}-(·)^{(1)}\)</span>。参考终端r与待定位移动终端s在信号收发过程中扮演相同的角色，因此无线接入点观测到的关于参考终端r的TDoA值可以表示为<span class="math display">\[\Delta d_{t,r}^{(i,1)}=c^{-1}\Delta r_{t,r}^{(i,1)}+\Deltan_{t,r}^{(i,1)}+\Delta b_{t,r}^{(i,1)}\qquad(3)\]</span>为了方便后续整周模糊度解算算法的介绍，将编号为2,3,…,M的无线接入点分别在t时刻与参考无线接入点的TDoA值表示成向量形式<span class="math display">\[\Delta d_{t}=c^{-1}\Delta r_{t}+\Delta n_{t}+\Delta b_{t}\qquad(4)\]</span> 其中<span class="math inline">\(\Delta d_{t}=[\Deltad_{t,x}^{(2,1)},\cdots,\Delta d_{t,x}^{(M,1)}]^T\)</span>，<span class="math inline">\(\Delta n_{t}=[\Delta n_{t,x}^{(2,1)},\cdots,\Deltan_{t,x}^{(M,1)}]^T\)</span>，<span class="math inline">\(\Deltab_{t}=[\Delta b^{(2,1)},\cdots,\Deltab^{(M,1)}]^T\)</span>，x表示待定位移动终端s或参考终端r。注意，TDoA测量值降低了对于系统时钟同步的要求，引入的时变钟差项只与编号为i的无线接入点和参考无线接入点有关，而与终端无关。因此，公式（2）中的时变钟差项<span class="math inline">\(\Deltab_{t,s}^{(i,1)}\)</span>和公式（3）中的时变钟差项<span class="math inline">\(\Deltab_{t,r}^{(i,1)}\)</span>相等，为了方便后续算法推导，在这里将它们进行统一，即<span class="math inline">\(\Delta b_{t}^{(i,1)}=\Delta b_{t,s}^{(i,1)}=\Deltab_{t,r}^{(i,1)}\)</span>。</p><blockquote><p><span class="math display">\[\Delta b_{t,s}^{(i,1)}= b_{t,s}^{(i)}-b_{t,s}^{(1)}=\theta_t^i-\tau_t^s-(\theta_t^1-\tau_t^s)=\theta_t^i-\theta_t^1\]</span></p><p><span class="math display">\[\Delta b_{t,r}^{(i,1)}= b_{t,r}^{(i)}-b_{t,r}^{(1)}=\theta_t^i-\tau_t^r-(\theta_t^1-\tau_t^r)=\theta_t^i-\theta_t^1\]</span></p><p><span class="math inline">\(\theta_t^i\)</span>表示编号为i的无线接入点在t时刻的系统时钟，<span class="math inline">\(\tau_t^s\)</span>表示待定位移动终端s在t时刻的系统时钟，<span class="math inline">\(\tau_t^r\)</span>表示待定位移动终端r在t时刻的系统时钟。</p></blockquote><h3 id="载波相位测距模型">1.2 载波相位测距模型</h3><p>载波相位观测值需要接收机可以有效持续地追踪接收到信号的载波相位。接收机通过观测从发射机到接收机信号的载波相位变化来获取信号的传播距离信息，可以达到较高的测距精度。基于载波相位的测距原理下图所示</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240922173214794.png" alt="载波相位测距原理图"><figcaption aria-hidden="true">载波相位测距原理图</figcaption></figure><p>待定位移动终端发射载波相位定位参考信号后，无线接入点对信号的载波相位进行持续追踪并进行观测，无线接入点和待定位移动终端间的相位差可以分解成整数部分和小数部分，即<span class="math display">\[\Delta \varphi=2\pi N+\varphi\qquad(5)\]</span>其中相位的单位为弧度。因此，测量距离和相位差之间的对应关系可以表示为<span class="math display">\[l=\frac{\Delta\varphi}{2\pi}·\lambda=N·\lambda+\frac{\varphi}{2\pi}·\lambda\qquad(6)\]</span></p><blockquote><p><span class="math inline">\(\varphi=2\pift=2\pi\frac{c}{\lambda}\frac{l}{c}=\frac{2\pi l}{\lambda}\)</span></p></blockquote><p>将无线接入点和待定位移动终端间的相位差分解成整数部分和小数部分是因为接收机在进行载波相位观测时会在内部复制一个与发射信号同频同相的连续信号，用于计算发射信号和接收信号间的相位差。在初次观测时，因为载波相位定位参考信号具有周期性，接收机只能观测到一个小于一个周期的相位，即相位差的小数部分，而无法直接获得相位差的整数部分，该整数部分被称为<strong>整周模糊度</strong>。整周模糊度的解算是否准确将直接影响到载波相位的测距精度，进而影响基于载波相位定位方法的定位性能，因此，整周模糊度的解算是基于载波相位的定位技术中需要解决的关键问题，也是本节所提算法需要重点解决的。如果在定位过程中无线接入点和待定位移动终端间发生相对运动，接收机会对载波相位进行持续追踪，即使两者的相对位移距离超过一个周期的波长，相位变化也将被记录下来，因此只要接收机能够对载波相位保持持续有效的追踪不失锁，那么在初次观测时锁定的整周模糊度就不会改变，这也是本节所提算法中所作关键假设。</p><p>考虑到接收机的观测误差和系统间的时变钟差等因素，编号为i的无线接入点在t时刻观测到来自待定位移动终端s的载波相位可以表示为<span class="math display">\[\varphi_{t,s}^{(i)}=2\pi\lambda^{-1}r_{t,s}^{(i)}-2\piN_s^{(i)}+\gamma_{t,s}^{(i)}+2\pi f_cb_{t,s}^{(i)}\qquad(7)\]</span></p><blockquote><p><span class="math inline">\(\varphi\)</span>是小数部分。</p></blockquote><p>其中<span class="math inline">\(\lambda\)</span>表示载波相位定位参考信号的波长，<span class="math inline">\(r_{t,s}^{(i)}=||v_t-u^{(i)}||\)</span>表示在t时刻待定位移动终端s到编号为i的无线接入点的真实物理距离，<span class="math inline">\(N_s^{(i)}\)</span>表示编号为i的无线接入点接收机在初次锁定时遗留下来关于待定位移动终端ｓ的整周模糊度，且<span class="math inline">\(N_s^{(i)}\)</span>均为整数，<span class="math inline">\(\gamma_{t,s}^{(i)}\)</span>表示编号为i的无线接入点接收机在t时刻的载波相位<strong>观测误差</strong>，假设该观测误差服从方差为<span class="math inline">\(\sigma_{\phi}^2\)</span>的零均值高斯分布，即<span class="math inline">\(\gamma_{t,s}^{(i)}\simN(0,\sigma_\phi^2)\)</span>，<span class="math inline">\(f_c\)</span>表示载波相位定位参考信号的载频，<span class="math inline">\(b_{t,s}^{(i)}\)</span>表示在t时刻编号为i的无线接入点和待定位移动终端s间的<strong>时变钟差</strong>。</p><h2 id="基于钟差消除的室内载波相位定位方案设计">2.基于钟差消除的室内载波相位定位方案设计</h2><h3 id="钟差克服算法">2.1 钟差克服算法</h3><p>不管是TDoA测距模型还是载波相位测距模型均会受到系统中时变钟差的影响，而时变钟差对于测距的精度会产生负面影响，进而影响定位的性能，因此本节提出了一种钟差克服算法，目标是<strong>完全消除时变钟差的影响</strong>。下面对该算法进行介绍。</p><h4 id="时域终端域接入点域三差分">2.1.1 时域—终端域—接入点域三差分</h4><p>基于公式（7），将编号为i的无线接入点关于待定位移动终端s在t时刻和t-1时刻的载波相位观测值<strong>进行时间维度的差分</strong>，可以得到时域单差载波相位观测值<span class="math display">\[\varphi_{t,s}^{(i)}-\varphi_{t-1,s}^{(i)}=2\pi\lambda^{-1}(r_{t,s}^{(i)}-r_{t-1,s}^{(i)})+\gamma_{t,s}^{(i)}-\gamma_{t-1,s}^{(i)}+2\pif_c(b_{t,s}^{(i)}-b_{t-1,s}^{(i)})\qquad(8)\]</span>在定位过程中，接收机内锁相环对信号的载波相位进行持续追踪且不失锁，那么该链路的整周模糊度就是一个不随时间变化的定值。可见<strong>时间维度的差分可以临时消除未知的整周模糊度的影响</strong>。同理，编号为i的无线接入点关于参考终端r的时域单差载波相位观测值可以表示为<span class="math display">\[\varphi_{t,r}^{(i)}-\varphi_{t-1,r}^{(i)}=2\pi\lambda^{-1}(r_{t,r}^{(i)}-r_{t-1,r}^{(i)})+\gamma_{t,r}^{(i)}-\gamma_{t-1,r}^{(i)}+2\pif_c(b_{t,r}^{(i)}-b_{t-1,r}^{(i)})\qquad(9)\]</span><strong>由于参考终端r的位置固定，所以距离编号为i的无线接入点的真实物理距离不会改变，即<span class="math inline">\(r_{t,r}^{(i)}=r_{t-1,r}^{(i)}\)</span>，公式中这两项的差为零</strong>。基于公式（8）和（9），将编号为i的无线接入点关于待定位移动终端s和参考终端r的时域单差载波相位观测值<strong>进行终端维度的差分</strong>，可以得到时域-终端域双差载波相位观测值<span class="math display">\[\begin{array}{l}\varphi_{t,s}^{(i)}-\varphi_{t-1,s}^{(i)}-\varphi_{t,r}^{(i)}+\varphi_{t-1,r}^{(i)}\\=2\pi\lambda^{-1}(r_{t,s}^{(i)}-r_{t-1,s}^{(i)})+\gamma_{t,s}^{(i)}-\gamma_{t-1,s}^{(i)}-\gamma_{t,r}^{(i)}+\gamma_{t-1,r}^{(i)}+2\pif_c(b_{t,s}^{(i)}-b_{t-1,s}^{(i)}-b_{t,r}^{(i)}+b_{t-1,r}^{(i)})\end{array}\qquad(10)\]</span></p><blockquote><p>这步可以消除<span class="math inline">\(\theta\)</span>。</p></blockquote><p>将编号为i的无线接入点和参考无线接入点的时域-终端域双差载波相位观测值进一步<strong>做无线接入点维度的差分</strong>，可以得到时域-终端域-接入点域的三差载波相位观测值<span class="math display">\[\begin{array}{l}\Delta\varphi_{t,s}^{(i,1)}-\Delta\varphi_{t-1,s}^{(i,1)}-\Delta\varphi_{t,r}^{(i,1)}+\Delta\varphi_{t-1,r}^{(i,1)}\\=2\pi\lambda^{-1}(\Deltar_{t,s}^{(i,1)}-\Deltar_{t-1,s}^{(i,1)})+\Delta\gamma_{t,s}^{(i,1)}-\Delta\gamma_{t-1,s}^{(i,1)}-\Delta\gamma_{t,r}^{(i,1)}+\Delta\gamma_{t-1,r}^{(i,1)}\end{array}\qquad(11)\]</span></p><blockquote><p>这步可以消除<span class="math inline">\(\tau\)</span>。</p></blockquote><p>其中时变钟差项为 <span class="math display">\[\begin{array}{l}\Delta b_{t,s}^{(i,1)}-\Delta b_{t-1,s}^{(i,1)}-\Deltab_{t,r}^{(i,1)}+\Deltab_{t-1,r}^{(i,1)}\\=b_{t,s}^{(i)}-b_{t,s}^{(1)}-(b_{t-1,s}^{(i)}-b_{t-1,s}^{(1)})-(b_{t,r}^{(i)}-b_{t,r}^{(1)})+b_{t-1,r}^{(i)}-b_{t-1,r}^{(1)}\\=\theta_t^i-\tau_t^s-(\theta_t^1-\tau_t^s)-(\theta_{t-1}^i-\tau_t^s-(\theta_{t-1}^1-\tau_t^s))\\-(\theta_t^i-\tau_t^r-(\theta_t^1-\tau_t^r))+(\theta_{t-1}^i-\tau_t^r-(\theta_{t-1}^1-\tau_t^r))=0\end{array}\qquad(12)\]</span> <span class="math inline">\(\theta_t^i\)</span>表示编号为i的无线接入点在t时刻的系统时钟，<span class="math inline">\(\tau_t^s\)</span>表示待定位移动终端s在t时刻的系统时钟，<span class="math inline">\(\tau_t^r\)</span>表示待定位移动终端r在t时刻的系统时钟。经过推导可知，通过时域-终端域-接入点域的三差分可以完全消除系统时变钟差的影响，此外，该三差载波相位观测值中不存在未知的整周模糊度，为后续相对位置的精确解算奠定基础。</p><h4 id="tdoa单差分">2.1.2 TDoA单差分</h4><p>对照公式（2）和（3）可知，TDoA测量值降低了对于终端侧系统时钟的要求（即消除了<span class="math inline">\(\tau\)</span>），两个公式中的时变钟差只与无线接入点有关而与终端无关，因此也可以利用差分的方法对时变钟差进行处理。将公式（2）和（3）做差可得TDoA单差测量值<span class="math display">\[\Delta d_{t,s}^{(i,1)}-\Delta d_{t,r}^{(i,1)}=c^{-1}\Deltar_{t,s}^{(i,1)}-c^{-1}\Delta r_{t,r}^{(i,1)}+\Deltan_{t,s}^{(i,1)}-\Delta n_{t,r}^{(i,1)}\qquad(13)\]</span> 其中时变钟差项为<span class="math inline">\(\Deltab_{t,s}^{(i,1)}-\Deltab_{t,r}^{(i,1)}=0\)</span>。因为参考终端r的位置已知，所以<span class="math inline">\(\Deltar_{t,r}^{(i,1)}\)</span>为已知量。将公式（13）中的已知量进行移项可以得到完全消除时变钟差下待定位移动终端s的TDoA测量值<span class="math display">\[\Delta d_{t}^{(i,1)}=c^{-1}\Delta r_{t,s}^{(i,1)}+\Deltan_{t}^{(i,1)}\qquad(14)\]</span> 其中<span class="math inline">\(\Delta d_{t}^{(i,1)}=\Deltad_{t,s}^{(i,1)}-\Delta d_{t,r}^{(i,1)}+c^{-1}\Deltar_{t,r}^{(i,1)}\)</span>，<span class="math inline">\(\Deltan_{t}^{(i,1)}=\Delta n_{t,s}^{(i,1)}-\Deltan_{t,r}^{(i,1)}\)</span>。通过与未消除时变钟差的TDoA测量值，即公式（2）进行对比，可知消除时变钟差后会在测量值中引入更多的<strong>测量误差</strong>（即<span class="math inline">\(\Deltan_{t,r}^{(i,1)}\)</span>）。同理，通过三差分消除时变钟差的载波相位观测值也引入了更多的观测误差，但是由于系统节点间的钟差通常在50ns-100ns，转换成距离则在数米，要远大于引入的误差。因此，消除时变钟差仍然是十分必要的。</p><h3 id="融合定位算法">2.2 融合定位算法</h3><p>通过公式（11）和（14）可以得到完全消除时变钟差的三差载波相位观测值和TDoA测量值，接下来可以通过相关定位算法对位置进行估计。TDoA测量值乘上无线信号的传播速度可以得到距离差信息，进而可以代入基于距离差的定位算法进行定位，本节中基于距离差的定位算法采用Chan算法，这里不在赘述。下面详细介绍针对三差载波相位观测值设计的定位方案及融合定位方案。</p><p>基于公式（11），为了方便算法推导，<strong>暂时不在公式中显示观测误差项</strong>，考虑到待定位移动终端s在t时刻的位置坐标隐含在<span class="math inline">\(\Delta r_{t,s}^{(i,1)}\)</span>中的<span class="math inline">\(r_{t,s}^{i}\)</span>中，因此，将该项移项到公式的一侧，其余移项到公式的另一侧，并同时对等式两侧进行完全平方可得<span class="math display">\[(\Delta\varphi_{t,s}^{(i,1)}-\Delta\varphi_{t-1,s}^{(i,1)}-\Delta\varphi_{t,r}^{(i,1)}+\Delta\varphi_{t-1,r}^{(i,1)}+2\pi\lambda^{-1}\Deltar_{t-1,s}^{(i,1)}+2\pi\lambda^{-1}r_{t,s}^{(1)})^2=(2\pi\lambda^{-1}r_{t,s}^{(i)})^2\qquad(15)\]</span> 将<span class="math inline">\(r_{t,s}^{(i)}=||v_t-u^{(i)}||\)</span>代入公式（15）并做简单数学整理可得<span class="math display">\[-8\pi^2\lambda^{-2}\Delta a^{(i,1)}x_t--8\pi^2\lambda^{-2}\Deltab^{(i,1)}y_t-8\pi^2\lambda^{-2}\Deltac^{(i,1)}z_t-4\pi\lambda^{-1}\Delta U_t^{(i,1)}r_{t,s}^{(1)}=(\DeltaU_t^{(i,1)})^2-\Delta K^{(i,1)}\qquad(16)\]</span> <img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240923151324526.png" alt="简单数学整理"></p><p>其中 <span class="math display">\[U_t^{(i)}=2\pi\lambda^{-1}r_{t-1,s}^{(i)}+\varphi_{t,s}^{(i)}-\varphi_{t-1,s}^{(i)}-\varphi_{t,r}^{(i)}+\varphi_{t-1,r}^{(i)}\qquad(17)\]</span></p><p><span class="math display">\[K^{(i)}=4\pi^2\lambda^{-2}((a^{(i)})^2+(b^{(i)})^2+(c^{(i)})^2)\qquad(18)\]</span></p><p>公式（16）中存在两个未知量，一个是我们关系的在t时刻待定位移动终端s的位置坐标<span class="math inline">\(v_t\)</span>，另一个是隐含在<span class="math inline">\(r_{t-1,s}^{(i)}\)</span>中的在t-1时刻待定位移动终端s的位置坐标<span class="math inline">\(v_{t-1}\)</span>。这两个未知量分别对应待定位移动终端s在t和t-1两个相邻时刻的位置坐标，因此可以基于时间迭代的思想设计解算算法。假设在t-1时刻待定位移动终端s的位置坐标<span class="math inline">\(v_{t-1}\)</span>已经由前序迭代计算出，将编号为2,3,…,M的无线接入点所得关于公式（16）的方程进行联立并整理成向量矩阵形式<span class="math display">\[Cz_t=q_t\qquad(19)\]</span> 其中 <span class="math display">\[C=\begin{bmatrix}-8\pi^2\lambda^{-2}\Delta a^{(2,1)} &amp; -8\pi^2\lambda^{-2}\Deltab^{(2,1)} &amp; -8\pi^2\lambda^{-2}\Delta c^{(2,1)} &amp;-4\pi\lambda^{-1}\Delta U_t^{(2,1)}\\\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\-8\pi^2\lambda^{-2}\Delta a^{(M,1)} &amp; -8\pi^2\lambda^{-2}\Deltab^{(M,1)}&amp;-8\pi^2\lambda^{-2}\Deltac^{(M,1)}&amp;-4\pi\lambda^{-1}\Delta U_t^{(M,1)}\\\end{bmatrix}\qquad(20)\]</span></p><p><span class="math display">\[z_t=[v_t,r_{t,s}^{(1)}]\qquad(21)\]</span></p><blockquote><p><span class="math inline">\(v_t\)</span>是列向量，故<span class="math inline">\(z_t\)</span>也是列向量。</p></blockquote><p><span class="math display">\[q_t = \begin{bmatrix}(\Delta U_t^{(2,1)})^2-\Delta K^{(2,1)}\\\vdots \\(\Delta U_t^{(M,1)})^2-\Delta K^{(M,1)}\end{bmatrix}\qquad(22)\]</span></p><p>公式（19）可以利用最小二乘法进行解算，下面介绍一下最小二乘法的原理。</p><hr><h5 id="最小二乘法">最小二乘法</h5><p><span class="math inline">\(Xw=y\)</span>求解<span class="math inline">\(w\)</span>。</p><p>误差方程为： <span class="math display">\[Error(w|X,y)=(Xw-y)^T(Xw-y)\]</span> 求最优解<span class="math inline">\(w\)</span>，即求Error的最小值。其中X为m×n的样本输入矩阵：<span class="math display">\[X = \begin{bmatrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1n} \\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2n} \\\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{mn} \\\end{bmatrix}\]</span> y为m×1列向量，对应于简单函数，其实就是指函数值f(x)： <span class="math display">\[y=\begin{bmatrix}y_1 \\y_2 \\\vdots\\y_m \\\end{bmatrix}\]</span> <span class="math inline">\(w\)</span>为n×1列向量，就是待求的拟合权重参数：<span class="math display">\[w=\begin{bmatrix}w_1 \\w_2 \\\vdots\\w_m \\\end{bmatrix}\]</span> 将误差方程展开： <span class="math display">\[\begin{aligned}(Xw-y)^T(Xw-y)&amp;=((Xw)^T-y^T)(Xw-y)\\&amp;=w^TX^TXw-(Xw)^Ty-y^TXw+y^Ty\\&amp;=w^TX^TXw-2(Xw)^Ty+y^Ty\end{aligned}\]</span></p><blockquote><p><span class="math inline">\((AB)^T=B^TA^T\)</span></p><p>对于任意两个列向量<span class="math inline">\(\alpha^T\beta=\beta^T\alpha\)</span></p></blockquote><p>它的极小值在对<span class="math inline">\(w\)</span>求导为零处。对向量求导等价于以对向量的每个分量求偏导而形成新的向量。我们将上式展开分别对<span class="math inline">\(w\)</span>的每个分量求偏导，先看第二部分：</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240924213322284.png"></p><p>对每一个分量求偏导： <span class="math display">\[\frac{\partial P(w)}{\partialw_1}=2(x_{11}y_1+x_{21}y_2+\cdots+x_{m1}y_m)\]</span></p><p><span class="math display">\[\frac{\partial P(w)}{\partialw_2}=2(x_{12}y_1+x_{22}y_2+\cdots+x_{m2}y_m)\]</span></p><p><span class="math display">\[\vdots\]</span></p><p><span class="math display">\[\frac{\partial P(w)}{\partialw_n}=2(x_{1n}y_1+x_{2n}y_2+\cdots+x_{mn}y_m)\]</span></p><p>合并整理后可得： <span class="math display">\[\frac{\partial P(w)}{\partial w}=\frac{\partial [2(Xw)^Ty]}{\partialw}=2X^Ty\]</span> 同理展开第一部分有： <span class="math display">\[\frac{\partial Q(w)}{\partial w}=\frac{\partial [w^TX^TXw]}{\partialw}=2X^TXw\]</span> 所以求导可得： <span class="math display">\[2X^TXw-2X^Ty=0\]</span></p><p><span class="math display">\[w=(X^TX)^{-1}X^Ty\]</span></p><hr><p>故得到在t时刻待定位移动终端s的位置坐标<span class="math inline">\(v_t\)</span>可以估计为 <span class="math display">\[\tilde{v}_t=[(C^TC)^{-1}C^Tq_t]_{(1:3)}\qquad(23)\]</span> 其中<span class="math inline">\([·]_{(1:3)}\)</span>表示去向量<span class="math inline">\([·]\)</span>中的第1到第3个元素组成新的向量。可以看出，该绝对位置估计值<span class="math inline">\(\tilde{v}_t\)</span>受前序迭代解算结果<span class="math inline">\(\tilde{v}_{t-1}\)</span>的影响存在偏置，而将这两个估计值做差得到的相对位置变化估计却很准确，这是因为三差载波相位观测值临时消除了未知的整周模糊度。待定位移动终端s从t-1时刻到t时刻的位置变化可以表示为<span class="math display">\[\Delta v_{t,t-1}=v_t-v_{t-1}\qquad(24)\]</span>在t时刻利用TDoA测量值对待定位移动终端ｓ的位置坐标进行估计可以得到估计结果<span class="math inline">\(\xi_t=(x_t,y_t,z_t)\)</span>，<strong>该结果受环境影响较大，会产生较大波动</strong>，但是TDoA测量服从零均值高斯分布且定位过程是独立的，所以<strong>定位结果无偏的</strong>。而利用三差载波相位观测值<strong>估计待定位移动终端ｓ在相邻时刻的位置变化却非常准确</strong>，但会<strong>受到０时刻定位结果的影响而存在难以消除的偏置</strong>。因此考虑使用基于三差载波相位观测值的位置变化估计平滑基于TDoA观测值的绝对位置估计，来减小绝对位置估计的波动，进而得到较为精确的绝对位置估计。融合定位算法具体执行步骤总结如下：</p><ol type="1"><li><p>初始化定位结果：在定位开始前，即０时刻，初始化载波相位定位结果<span class="math inline">\(\tilde{v}_0=\xi_0\)</span>与融合定位结果<span class="math inline">\(\hat{v}_0=\xi_0\)</span>，其中<span class="math inline">\(\xi_0\)</span>为TDoA在０时刻的定位结果；</p></li><li><p>相对位置变化估计：在t（t为正整数）时刻，根据公式（23）计算得到载波相位定位结果<span class="math inline">\(\tilde{v}_t\)</span>，进一步根据公式（24）计算得到<span class="math inline">\(\Delta\tilde{v}_{t,t-1}\)</span>；（意思是根据（23）得到载波相位定位结果<span class="math inline">\(\tilde{v}_t\)</span>和<span class="math inline">\(\tilde{v}_{t-1}\)</span>，再根据（24）得到<span class="math inline">\(\Delta\tilde{v}_{t,t-1}\)</span>，步骤2都是根据载波相位定位结果计算的）</p></li><li><p>更新载波相位定位结果：根据前序迭代所得融合定位结果<span class="math inline">\(\hat{v}_{t-1}\)</span>和本轮所得相对位置变化估计<span class="math inline">\(\Delta\tilde{v}_{t,t-1}\)</span>，将<span class="math inline">\(\tilde{v}_t\)</span>更新为 <span class="math display">\[\tilde{v}_t=\hat{v}_{t-1}+\Delta\tilde{v}_{t,t-1}\qquad(25)\]</span></p></li><li><p>融合定位结果：在t时刻根据TDoA观测值计算得到定位结果<span class="math inline">\(\xi_t\)</span>，通过 <span class="math display">\[\hat{v}_t=w_{TDoA}\xi_t+w_{CARR}\tilde{v}_t\qquad(26)\]</span> 对TDoA定位结果和载波相位定位结果进行融合。其中<span class="math inline">\(w_{TDoA}\)</span>和<span class="math inline">\(w_{CARR}\)</span>分别为TDoA定位结果的权重和载波相位定位结果的权重，两个权重满足且为０到１之间的小数。不同的权重选取可能会导致不同的定位效果，为了达到更好的定位性能，应该根据室内定位场景的信道条件来选取最优的权重；</p></li><li><p>迭代解算：随着时间迭代执行上述步骤。</p></li></ol><blockquote><p>三差法重点关注的是载波相位（接收机测的是载波相位），在t=0时刻进行第一次载波相位的测量，由于只能观测到一个小于一个周期的相位，故存在整周模糊度，其定位结果就会存在偏置，导致后面时刻的定位结果都会不准，但由于偏置相同，两个时刻间目标位置的相对变化是准的。</p><p>TDoA重点关注的是时间（接收机测的是时间），能够实现每个时刻的准确定位，但正如文中所说其定位结果受环境影响较大，会产生较大的波动，故需要三差法的帮助。</p><p>至于为什么TDoA定位结果受环境影响较大，可能是对于接收机来说，载波相位比时间更加稳定。</p><p>三差法比TDoA多的就是一个时刻域上的差分，但TDoA每一个时刻的定位结果准确，但都会受到来自环境不同的影响，故对TDoA来说时刻域上的差分是没有意义的。而这就是为什么要用载波相位进行时刻域上的差分。</p><p>注意区分上面说的两个时间，一个是TDoA测得信号从目标到接收机之间的时间，一个是对目标进行定位的不同时刻。已用时间和时刻来区分。</p><p>总的来说，就是三差法和TDoA在优缺点上互补，进行融合定位，能得到更好的效果。</p></blockquote><h3 id="整周模糊度解算算法及最终定位">2.3整周模糊度解算算法及最终定位</h3><p>上一节介绍的<strong>融合定位算法输出结果</strong>相较于基于TDoA的定位算法在定位精度上有所提升，为方便后续算法介绍，将这个结果取名为<strong>绝对位置的粗估计</strong>。观察公式（7）可知，载波相位观测方程中存在未知的非线性元素<span class="math inline">\(r_{t,s}^{(i)}\)</span>，这不利于后续整周模糊度的解算。因此，在解算整周模糊度之前需要通过相关方法对载波相位观测方程进行线性化处理。由于己经得到待定位移动终端ｓ绝对位置的粗估计，该结果与待定位移动终端ｓ的真实位置较为接近，那么可以利用泰勒展开法对载波相位观测方程进行线性化，选取绝对位置粗估计为泰勒展开点可以有效降低载波相位观测方程中非线性元素在线性化过程中的高阶误差。</p><p>基于公式（7），在t时刻，将待定位移动终端s和参考终端r的载波相位观测值进行终端维度的差分可以得到<span class="math display">\[\varphi_{t,s}^{(i)}-\varphi_{t,r}^{(i)}=2\pi\lambda^{-1}(r_{t,s}^{(i)}-r_{t,r}^{(i)})-2\piN^{(i)}+\Delta\gamma^{(i)}+2\pi f_c\Delta b^{(i)}\qquad(27)\]</span> 其中<span class="math inline">\(N^{(i)}=N_s^{(i)}-N_r^{(i)}\)</span>，<span class="math inline">\(\Delta\gamma^{(i)}=\gamma_{t,s}^{(i)}-\gamma_{t,r}^{(i)}\)</span>，<span class="math inline">\(\Deltab^{(i)}=b_{t,s}^{(i)}-b_{t,r}^{(i)}\)</span>。将公式（27）中非线性元素展开并进行简单数学整理可得<span class="math display">\[\varphi_{t,s}^{(i)}-\varphi_{t,r}^{(i)}+2\pi\lambda^{-1}r_{t,r}^{(i)}=2\pi\lambda^{-1}||v_t-u^{(i)}||-2\piN^{(i)}+\Delta\gamma^{(i)}+2\pi f_c\Delta b^{(i)}\qquad(28)\]</span> 将公式（28）在绝对位置粗估计<span class="math inline">\(\hat{v}_t\)</span>上进行泰勒展开并忽略高阶项仅保留到一阶项可得<span class="math display">\[\varphi_{t,s}^{(i)}-\varphi_{t,r}^{(i)}+2\pi\lambda^{-1}(r_{t,r}^{(i)}-\theta_t^{(i)})=2\pi\lambda^{-1}(\alpha_t^{(i)}x_t+\beta_t^{(i)}y_t+\chi_t^{(i)}z_t)-2\piN^{(i)}+\Delta\gamma^{(i)}+2\pi f_c\Delta b^{(i)}\qquad(29)\]</span> 其中<span class="math inline">\(\theta_t^{(i)}=\frac{a^{(i)2}+b^{(i)2}+c^{(i)2}-a^{(i)}\hat{x}_t-b^{(i)}\hat{y}_t-c^{(i)}\hat{z}_t}{||\hat{v}_t-u^{(i)}||}\)</span>，<span class="math inline">\(\alpha_t^{(i)}=\frac{\hat{x}_t-a^{(i)}}{||\hat{v}_t-u^{(i)}||}\)</span>，<span class="math inline">\(\beta_t^{(i)}=\frac{\hat{y}_t-b^{(i)}}{||\hat{v}_t-u^{(i)}||}\)</span>，<span class="math inline">\(\chi_t^{(i)}=\frac{\hat{z}_t-c^{(i)}}{||\hat{v}_t-u^{(i)}||}\)</span>。</p><p>计算过程：</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240927114918426.png" alt="泰勒展开并保留到一阶项"><figcaption aria-hidden="true">泰勒展开并保留到一阶项</figcaption></figure><blockquote><p>向量内积： <span class="math display">\[\overrightarrow{a}·\overrightarrow{b}=|\overrightarrow{a}||\overrightarrow{b}|cos\theta=x_1x_2+y_1y_2\]</span>向量内积就相当于实数运算里的乘法，对向量求导，求导法则同样适用。</p></blockquote><p>基于公式（29），编号为i的无线接入点对参考无线接入点进行无线接入点维度的差分可得<span class="math display">\[\Delta\varPsi_t^{(i,1)}=2\pi\lambda^{-1}(\Delta\alpha_t^{(i,1)}x_t+\Delta\beta_t^{(i,1)}y_t+\Delta\chi_t^{(i,1)}z_t)-2\pi\DeltaN^{(i,1)}+\gamma^{(i,1)}\qquad(30)\]</span> 其中<span class="math inline">\(\gamma^{(i,1)}=\Delta\gamma^{(i)}-\Delta\gamma^{(1)}\)</span>，<span class="math inline">\(\varPsi_t^{(i)}=\varphi_{t,s}^{(i)}-\varphi_{t,r}^{(i)}+2\pi\lambda^{-1}(r_{t,r}^{(i)}-\theta_t^{(i)})\)</span>，<span class="math inline">\(\DeltaN^{(i,1)}\)</span>为终端域-接入点域双差整周模糊度。基于公式（30），将编号为2,3,…,M的无线接入点进行联立并写成向量矩阵形式<span class="math display">\[\boldsymbol{\varPsi_t}=\boldsymbol{H_t} v_t-2\pi\boldsymbol{N}+\boldsymbol{\gamma_t}\qquad(31)\]</span> 其中 <span class="math display">\[\boldsymbol{\varPsi_t}=[\Delta\varPsi_t^{(2,1)},\Delta\varPsi_t^{(3,1)},\cdots,\Delta\varPsi_t^{(M,1)}]^T\qquad(32)\]</span></p><p><span class="math display">\[\boldsymbol{H_t}=2\pi\lambda^{-1}\begin{bmatrix}\Delta\alpha_t^{(2,1)}&amp;\Delta\beta_t^{(2,1)}&amp;\Delta\chi_t^{(2,1)}\\\vdots&amp;\vdots&amp;\vdots \\\Delta\alpha_t^{(M,1)}&amp;\Delta\beta_t^{(M,1)}&amp;\Delta\chi_t^{(M,1)}\\\end{bmatrix}\qquad(33)\]</span></p><p><span class="math display">\[\boldsymbol{N}=[\Delta N^{(2,1)},\Delta N^{(3,1)},\cdots,\DeltaN^{(M,1)}]^T\qquad(34)\]</span></p><p><span class="math display">\[\boldsymbol{\gamma_t}=[\gamma^{(2,1)},\gamma^{(3,1)},\cdots,\gamma^{(M,1)}]^T\qquad(35)\]</span></p><p><span class="math inline">\(v_t=(x_t,y_t,z_t)^T\)</span>，公式（31）的未知变量<span class="math inline">\(v_t\)</span>和<span class="math inline">\(\boldsymbol{N}\)</span>，共M+2个未知数，而方程组中方程数为M-1，不可以唯一解算未知数的值。因此可以联立K个采样时间点的观测方程并整理成向量矩阵形式<span class="math display">\[\boldsymbol{\varPsi}=\boldsymbol{H}\boldsymbol{\zeta}+\boldsymbol{\gamma}\qquad(36)\]</span> 其中 <span class="math display">\[\boldsymbol{\varPsi}=[\boldsymbol{\varPsi_1},\boldsymbol{\varPsi_2},\cdots,\boldsymbol{\varPsi_K}]^T\qquad(37)\]</span></p><p><span class="math display">\[\boldsymbol{H}=\begin{bmatrix}\boldsymbol{H_1} &amp; \cdots &amp; 0 &amp; -2\pi \boldsymbol{I} \\\vdots &amp; \ddots &amp; \vdots &amp; \vdots \\0 &amp; \cdots &amp;\boldsymbol{H_K}&amp; -2\pi \boldsymbol{I}\\\end{bmatrix}\qquad(38)\]</span></p><p><span class="math display">\[\boldsymbol{\zeta}=[v_1,\cdots,v_K,\boldsymbol{N}]^T\qquad(39)\]</span></p><p><span class="math display">\[\boldsymbol{\gamma}=[\boldsymbol{\gamma_1},\boldsymbol{\gamma_2},\cdots,\boldsymbol{\gamma_K}]^T\qquad(40)\]</span></p><blockquote><p>把一个采样时间点的各种矩阵看成一个数，也就是在上面的这些式子里，矩阵里的元素都看成数，然后去做矩阵的转置运算还有乘除加减运算。然后再把各个元素看成它们本身的矩阵取算乘法。</p></blockquote><p>矩阵<span class="math inline">\(\boldsymbol{I}\)</span>表示(M-1)×(M-1)的单位矩阵。公式（36）使用加权最小二乘法进行求解可得<span class="math display">\[\hat{\boldsymbol{\zeta}}=(\boldsymbol{H}^T\boldsymbol{Q_{\varPsi}^{-1}}\boldsymbol{H})^{-1}\boldsymbol{H}^T\boldsymbol{Q_{\varPsi}^{-1}}\boldsymbol{\varPsi}\qquad(41)\]</span> 其中 <span class="math display">\[\boldsymbol{Q_{\varPsi}}=E(\boldsymbol{\gamma}\boldsymbol{\gamma}^T)\qquad(42)\]</span> <span class="math inline">\(E(·)\)</span>表示对该矩阵中的每一个元素取期望。整周模糊度的估计值位于<span class="math inline">\(\hat{\boldsymbol{\zeta}}\)</span>的后M-1个元素，且该估计值为实数，因此可以将该估计结果定义为整周模糊度的浮动解<span class="math display">\[\boldsymbol{N}_{float}=[\hat{\boldsymbol{\zeta}}]_{(3K+1):(3K+M-1)}\qquad(43)\]</span></p><blockquote><p>观测误差<span class="math inline">\(\boldsymbol{\gamma}\)</span>服从零均值高斯分布，不同观测时刻的<span class="math inline">\(\boldsymbol{\gamma_i}\)</span>相互独立，故<span class="math inline">\(\boldsymbol{Q_{\varPsi}}\)</span>为一对角矩阵，对角线上的元素为<span class="math inline">\(\boldsymbol{\gamma}_i^2\)</span>。因为<span class="math inline">\(\boldsymbol{\gamma}\)</span>均值为0，故<span class="math inline">\(E(\boldsymbol{\gamma}\boldsymbol{\gamma}^T)\)</span>也相当于在求<span class="math inline">\(\boldsymbol{\gamma}\)</span>的协方差矩阵。</p></blockquote><p>由于整周模糊度浮动解中各个元素可能不全为整数，因此需要进一步利用最小二乘模糊度解相关调整算法（Least-SquareAmbiguity DecorrelationAdjustment，LAMBDA）来确定整数向量形式的整周模糊度，并将其定义为整周模糊度的固定解。LAMBDA算法的原理是结合协方差矩阵去搜索一个与浮动解之差的加权平方和最小的整数向量<span class="math inline">\(N_{fix}\)</span>。利用最小二乘法可以得到<span class="math inline">\(\hat{\boldsymbol{\zeta}}\)</span>的协方差矩阵并写成分块矩阵的形式</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20240927182115760.png"></p><p>总之根据LAMBDA算法我们得到了整周模糊度的固定解<span class="math inline">\(N_{fix}\)</span>。根据上文可以得到N是终端域-接入点域双差的整周模糊度，故终端域-接入点域载波相位双差观测值<span class="math inline">\(\phi^{(t)}=[\Delta(\varphi_{t,s}-\varphi_{t,r})^{(2,1)},\cdots,\Delta(\varphi_{t,s}-\varphi_{t,r})^{(M,1)}]^T\)</span>可以被<span class="math inline">\(N_{fix}\)</span>修正为接入点间的距离差向量 <span class="math display">\[l_{modif}^{(t)}=\frac{\lambda\phi^{(t)}}{2\pi}+\lambdaN_{fix}+\boldsymbol{r_{r,t}}\qquad(45)\]</span> 其中 <span class="math display">\[\boldsymbol{r_{r,t}}=[\Delta r_{t,r}^{(2,1)},\cdots,\Deltar_{t,r}^{(M,1)}]^T\]</span>通过载波相位观测值转换的距离差和基于TDoA测量值转换的距离差相比具有更高的测距精度。</p><h1 id="六利用5g-nr信号进行室内定位的载波相位测距">六、利用5GNR信号进行室内定位的载波相位测距</h1><h2 id="g-nr标准和信号模型">1. 5G NR标准和信号模型</h2><h3 id="g-nr信号概述">1.1 5G NR信号概述</h3><p>5GNR标准使用正交频分复用（OFDM）调制来实现多径场景下的鲁棒传输。OFDM信号由三个参数指定，即子载波的数量或快速傅里叶变换（FFT）大小、采样周期、循环前缀（CP）的长度。为了在广泛的频率和部署上实现多样化的服务，5GNR具有可扩展的OFDM参数集和可扩展的CP-OFDM参数集，如下表所示。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241014104221178.png" alt="5G NR的可扩展OFDM参数集"><figcaption aria-hidden="true">5G NR的可扩展OFDM参数集</figcaption></figure><p>在5GNR中，物理层使用时频资源进行传输。最小物理时频资源由一个OFDM符号中的一个子载波组成，其被定义为资源元素（RE）。12个资源元素构成一个物理资源块（PRB）来进行调度传输。时间-频率资源在下图中示出，其中物理信号的传输在时域中被分成信号帧、子帧和时隙。每个信号帧具有10ms的持续时间，并且由十个持续时间为1ms的子帧组成。子帧由一个或多个相邻时隙形成。我们的实验采用了30kHz的子载波间隔的参数，因此一个子帧有两个时隙，每个时隙有14个OFDM符号。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241014105308448.png" alt="5G NR时频资源和帧结构"><figcaption aria-hidden="true">5G NR时频资源和帧结构</figcaption></figure><h3 id="信号模型">1.2 信号模型</h3><p>我们假设由<span class="math inline">\(N\)</span>个子载波组成的5GNR系统，其中中心频谱处的<span class="math inline">\(N_u\)</span>个子载波用于传输，并且两个边缘处的其他子载波形成保护频带。<span class="math inline">\(\{c_n|n=0,\cdots,N_u-1\}\)</span>表示调制的数据或子载波符号，其中n表示子载波号。在IFFT操作之后，通过为每个OFDM符号添加保护间隔，所发送的基带信号的样本可以表示为<span class="math display">\[s(k)=\frac{1}{\sqrt{N}}\displaystyle\sum_{n=0}^{N_u-1}c_ne^{j2\pikn/N},-N_g\le k\le(N-1)\]</span> 其中<span class="math inline">\(N_g\)</span>是保护样本的数量。</p><p>在典型的室内环境中，无线信号通常会被障碍物反射或散射，从而产生多径效应。因此，我们假设5GNR信号经历频率选择性衰落，并且长度为L的信道冲激响应（CIR）的复信道增益为<span class="math inline">\(\{h_l\}\)</span>，对应的路径延迟为<span class="math inline">\(\{\tau_l\}\)</span>，其中<span class="math inline">\(l=0,1,\cdots,L-1\)</span>。</p><p>在接收端，接收信号通常存在符号定时偏移（STO）、载波频率偏移（CFO）和采样时钟偏移（SCO）。更具体地，STO是一个OFDM符号的假定开始和真实的开始之间的时间差。CFO是由接收器的本地振荡器产生的频率与接收信号的载波之间的失配引起的。最后，SCO是由于多普勒效应引起的采样时钟的频率或相位与理想状态的偏差。</p><p>在考虑到所有这些因素之后，接收到的样本可以写为 <span class="math display">\[r(k)=e^{j(2\pi k\Deltaf/N+\varphi)}\displaystyle\sum_{l=0}^{L-1}h_ls(k-\tau_l)+n(k)\]</span> 其中，<span class="math inline">\(n(k)\)</span>是方差为<span class="math inline">\(\sigma^2\)</span>零均值复高斯噪声的样本，<span class="math inline">\(\Deltaf\)</span>是由子载波间隔归一化的CFO并且<span class="math inline">\(\varphi\)</span>是任意载波相位。FFT窗口开始处的定时点由定时同步确定为在样本<span class="math inline">\(r(\epsilon)\)</span>处，其中<span class="math inline">\(\epsilon\)</span>是以OFDM样本为单位的定时偏移。</p><p>已经认识到，道效应和定时/频率误差对信号解调产生重要影响。为了通信的目的，5GNR接收机提取定时测量并从接收到的信号中恢复频率偏移，这导致同步问题。虽然多载波通信系统对于实现可靠通信的定时和频率同步具有严格的要求，但是定位和导航需要实现更精细的同步以获得接收信号的更精细的时延估计，从而可以获得足够的定位精度。在下面的部分中，我们描述了我们提出的用于5GNR信号的ToA估计的方案，这对于实现高精度至关重要。</p><h2 id="基于载波相位测量的5g-nr定位toa估计">2.基于载波相位测量的5GNR定位TOA估计</h2><h1 id="七在wi-fi中使用载波相位实现毫米级差分测距精度">七、在Wi-Fi中使用载波相位实现毫米级差分测距精度</h1><h2 id="系统模型-1">1.系统模型</h2><p><strong>STA 1</strong>为固定Wi-Fi接入点，<strong>STA 2</strong>为移动设备，两者都具有单个天线，如上图所示。我们的目标是在<strong>STA1</strong>处估计<strong>STA 2</strong>在时间窗口上的差分范围。</p><ul><li>为了实现差分距离估计，<strong>STA 1</strong>发送<span class="math inline">\(P\)</span>个CP请求帧的序列，索引记为<span class="math inline">\(\mathcal{P}=\{p\in\mathbb{Z}|1\le p\leP\}\)</span>。假设<strong>STA 1</strong>所测量的第p帧的发送时间是<span class="math inline">\(t_p^{(1)}\)</span>。</li><li>在接收到第p个CP请求帧p后，<strong>STA2</strong>还发送第p个CP响应帧，并且它在时间<span class="math inline">\(t_p^{(4)}\)</span>（如<strong>STA1</strong>所测量的）被<strong>STA1</strong>接收。为了避免任何混淆，本文中提到的所有时间值都应在<strong>STA1</strong>的时间参考框架内。</li><li>索引为<span class="math inline">\(\mathcal{K}=\{k\in\mathbb{Z}|[\frac{-K+1}{2}]\lep\le [\frac{K-1}{2}]\}\)</span>的K个子载波具有符号持续时间<span class="math inline">\(T_s\)</span>和循环前缀持续时间<span class="math inline">\(T_{cy}\)</span>。使用正交频分复用（OFDM）在K个子载波上对这些CP帧的报头和有效载荷进行编码。根据第p个接收到的CP请求帧和响应帧的长训练字段，<strong>STA2</strong>和<strong>STA1</strong>可以将每个子载波k的信道状态信息（CSI）分别估计为<span class="math inline">\(\bar{h}^{(2)}_{p,k}\)</span>和<span class="math inline">\(\bar{h}^{(4)}_{p,k}\)</span>。</li><li>使用这些CSI测量值，STA可以进一步估计稍后在章节 中定义的CP值<span class="math inline">\(\hat{\psi}_p^{(2)}\)</span>和<span class="math inline">\(\hat{\psi}_p^{(4)}\)</span>。</li><li>我们假设<span class="math inline">\(\hat{\psi}_p^{(2)}\)</span>可以由<strong>STA2</strong>与<strong>STA 1</strong>共享作为后续帧的有效载荷。</li><li>此外，我们假设使用CP响应帧p的训练字段和导频子载波，<strong>STA1</strong>还可以获得对<strong>STA 2</strong>相对于<strong>STA1</strong>的载波频率偏移<span class="math inline">\(\bar{f}_{CFO,p}\)</span>的估计，精度为±F Hz。</li></ul><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241026114756234.png" alt="STA 1和STA 2执行的帧交换和步骤"><figcaption aria-hidden="true">STA 1和STA2执行的帧交换和步骤</figcaption></figure><h1 id="八nlos反射概述">八、NLoS反射概述</h1><h2 id="镜面反射与漫反射概述">1.镜面反射与漫反射概述</h2><p>路径的反射情况包含镜面反射（specular reflection）与漫反射（diffusescattering，一般漫反射路径可简称为scatteringpaths）两种。在绝对光滑的表面，仅存在镜面反射；然而，现实中的表面通常是粗糙的，此时镜面反射与漫反射同时存在，如下图所示。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241010205526043.png" alt="镜面反射与漫反射示意图"><figcaption aria-hidden="true">镜面反射与漫反射示意图</figcaption></figure><p>定义NLoS-n径为NLoS的n阶反射径（n≥1），即经历了n次反射的非视距路径。本这里，我们与主流方法保持一致，仅考虑LoS径与NLoS-1径。</p><blockquote><p>我们一般把基站直射手机的电磁波路径称为LoS(Line ofsight)路径，即电磁波在做视线传播；被障碍物折射或者绕射之后的路径称为NLoS路径。</p></blockquote><p>LoS径、NLoS-1镜面反射径与NLoS-1漫反射径的信道增益（即路径强度）如下：</p><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/clip_image002-17285657122511.png"></p><p>其中，<span class="math inline">\(\lambda\)</span>为信号波长；<span class="math inline">\(D_1\)</span>为LoS径长度；<span class="math inline">\(d_{1,m}\)</span>与<span class="math inline">\(d_{2,m}\)</span>分别为NLoS-1径的UE-反射点与反射点-BS的两段长度（以反射点为界）；<span class="math inline">\(\Gamma_R\)</span>为反射系数（即反射损耗）；<span class="math inline">\(\sigma_{RCS}^2\)</span>为雷达截面积。</p><h2 id="镜面反射与漫反射的联系与区别">2.镜面反射与漫反射的联系与区别</h2><p>为便于理解，这里假设镜面反射的表面为平面（如镜面、墙壁等；而非曲面，如圆柱表面等）。</p><ol type="1"><li><strong>联系：</strong>镜面反射与漫反射都遵循光的反射定律，漫反射可看作在反射点处（locally）的一种特殊的镜面反射。</li><li><strong>区别：</strong>定义反射面为在反射点处与法线垂直的平面。当表面为光滑平面时，镜面反射的反射面就是该光滑平面；与之相对的，当表面为凹凸不平的粗糙表面时，镜面反射的反射面仍为该平面，但漫反射的反射面则为该表面在反射点处的切面，此时反射面与平面并不相同。</li></ol><p>因此，对于镜面反射，即使不同路径在同一平面的不同反射点处发生反射，这些路径的反射面也都是相同的（均为平面本身）。由此，如果已知平面方程，可通过计算镜像点的方式将镜面反射路径等效为LoS径；反之，如果能够识别出多条镜面反射路径在同一平面发生反射，可准确恢复出平面方程，实现同步定位与地图测绘（SLAM）的功能。通过利用镜面反射的反射面，上述两种方法都可以提升定位精度，具体方法将在第三节中给出。</p><p>而由于漫反射的反射面与平面不同，基本是无迹可寻的。因此，我们至多仅能恢复出漫反射的反射点，但无法进一步地利用漫反射的反射面提升定位精度。</p><p><strong>综上，对于镜面反射，我们主要关注其反射面；对于漫反射，我们仅关注其反射点。</strong>因此，镜面反射路径与漫反射路径的区别就体现在反射面与反射点的区别上。由于反射面、入射信号与反射信号之间存在特殊的几何关系，我们可以对<strong>镜面反射路径</strong>实现更加精细的分析与利用（但可能用途不多）。</p><h2 id="nlos-1镜面反射反射面方程已知">3.NLoS-1镜面反射（反射面方程已知）</h2><h3 id="测量参数">3.1 测量参数</h3><p>由于反射面方程已知，通常仅需测量ToA或ToA与AoA即可。</p><h3 id="定位方法"><strong>3.2</strong> 定位方法</h3><p><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241010213355662.png" alt="image-20241010213355662" style="zoom:50%;"></p><p>如上图所示，通过如下镜像处理，可将NLoS-1镜面反射径（下方带箭头的黑色实线）等效转换为<strong>虚拟的LoS径</strong>（红色实线）：</p><ol type="1"><li>作BS关于反射面的镜像点<strong>VS</strong>（virtual BS）；</li><li>做AoA关于反射面的镜像角度<strong>AoAmir</strong>。</li></ol><blockquote><p>信号由用户发向基站。</p><p>AOA：一种基于角度的定位技术，通过测量信号到达的角度来确定设备的位置。</p><p>AOD：一种基于角度的定位技术，通过测量信号离开时的角度来确定设备的位置。</p></blockquote><p>获得虚拟LoS径后，可直接采用传统定位算法（如Chan算法）求解UE位置。</p><h2 id="nlos-1镜面反射反射面方程未知与nlos-1漫反射">4.NLoS-1镜面反射（反射面方程未知）与NLoS-1漫反射</h2><p>反射面方程未知时，镜面反射与漫反射路径均仅关注<strong>反射点</strong>即可（反射点未知），因此本节中我们将二者统一考虑为漫反射径。只有在恢复环境地图时可能会考虑镜面反射的反射面，我们将在后面单独分析。</p><h3 id="测量参数-1">4.1 测量参数</h3><p>对于UE定位，漫反射径必须测量<strong>ToA、AoA与AoD</strong>三种参数。原因分析如下：对于上述两种路径，除未知的UE位置外，每条路径额外引入了2维未知量（2维反射点坐标），因此至少需要测量3维参数才可对UE位置提供信息。</p><h3 id="定位方法-1">4.2 定位方法</h3><h4 id="确定性方法">4.2.1 确定性方法</h4><p>给定漫反射径的ToA、AoA与AoD，有如下结论：<strong>UE的可能位置一定分布在由上述三种参数确定的一条线段上</strong>，如下图所示。</p><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241011144219618.png" alt="漫反射示意图"><figcaption aria-hidden="true">漫反射示意图</figcaption></figure><p>图中已知的只有基站BS的位置，还有我们测量的ToA、AoA与AoD。其中，蓝色实线为NLoS-1漫反射路径，<span class="math inline">\(R_k\)</span>为反射点；<span class="math inline">\(VE_{aoa}\)</span>为以BS为基准，利用ToA与AoA计算出的VE位置；<span class="math inline">\(VE_{aod}\)</span>为以BS为基准，利用ToA与AoD计算出的VE位置。我们定义<strong>VE直线</strong>为与<span class="math inline">\(VE_{aoa}\)</span>与<span class="math inline">\(VE_{aod}\)</span>所连成的直线，则UE必定位于线段<span class="math inline">\(VE_{aoa}-VE_{aod}\)</span>上。该直线方程由ToA、AoA与AoD确定。</p><p>由此，每条NLoS-1漫反射路径可确定一条VE直线（即，关于UE二维坐标的线性方程），两条或多条漫反射路径的VE直线的交点即为UE位置，可直接利用加权最小二乘法计算UE位置的闭式解。</p><h2 id="收发端均为基站">5.收发端均为基站</h2><p>在收发端均为基站（单基/多基）的感知场景中，由于感知目标本身可能不具备信号处理能力，因此与三、四节中以UE为收/发端的处理方式存在不同。</p><h3 id="单基场景">5.1 单基场景</h3><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241011144152011.png" alt="单基感知场景"><figcaption aria-hidden="true">单基感知场景</figcaption></figure><p>如图所示，对于单基场景，由于目标处无法测量角度，因此测量参数最多仅能包括<strong>ToA与AoA</strong>。</p><ol type="1"><li>当NLoS径为镜面反射径时，根据我们之前的分析，UE定位的最低需求为2个：①已知的反射面；②测量ToA，或同时测量ToA与AoA。</li><li>当NLoS径为漫反射径时，此时只能通过LoS径计算目标位置（toa1），然后反推反射点<span class="math inline">\(R_k\)</span>的位置。即，在此情况下NLoS漫反射径无法对UE定位提供增益。</li></ol><h3 id="多基场景"><strong>5.2</strong> 多基场景</h3><figure><img src="/2024/06/19/%E5%AE%9A%E4%BD%8D%E5%92%8C%E9%80%9A%E6%84%9F%E7%9B%B8%E5%85%B3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20241011144254087.png" alt="多基感知场景"><figcaption aria-hidden="true">多基感知场景</figcaption></figure><p>如图7所示，我们用LoS-LoS，LoS-NLoS，NLoS-LoS与NLoS-NLoS表示四种可能的路径的ToA测量值，我们讨论的测量参数仍为<strong>ToA与AoA</strong>。只要前三种路径的ToA可测，那么目标与两反射点（R1与R2）的位置仍然可解。求解过程与单基类似，此处不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信感知一体化</tag>
      
      <tag>定位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信感知一体化</title>
    <link href="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/"/>
    <url>/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="一引言">一、引言</h1><h2 id="什么是通感一体化">1.什么是“通感一体化”？</h2><p>通感一体化，就是通信感知一体化。换句话说，就是<strong>通信</strong>和<strong>感知</strong>进行合体。话说，这世间的万事万物，大抵都是相通的。通信和感知这俩看似八竿子打不着的东西之所以能合体，必然是它们在最底层共享着同样的基因。</p><ul><li><p>对于通信，我们是非常熟悉的。通过基站和手机之间相互收发无线信号，我们就能在那块小小的屏幕上打电话，听音乐，刷视频，和这个世界紧密相连。</p></li><li><p>感知，顾名思义就是通过某些手段来探测周边环境的状态，物体的位置、方向、高度、速度、距离，还可以判断物体的形状，甚至人的动作手势。</p></li></ul><p>感知不就是雷达的工作职责吗？雷达的基本原理，就是发出无线电信号，然后通过探测和分析接收到的反射信号来进行高精度的感知工作。简单来说，当无线电信号遇到不同介质或物体时，它们会由于反射、折射、散射而产生不同的变化。如果我们能够准确地测量和分析这些变化，就可以得到物体或介质的特征信息，比如形状、大小、位置、材质等。这就相当于雷达用无线电波“感知”到了物体或介质。除了普通雷达，还有激光雷达、计算机断层扫描、磁共振成像等设备也能提供专业的感知能力。</p><p>这下发现通信和感知的相通之处了吗？</p><ul><li>首先，通信和感知<strong>都需要使用无线电频谱资源</strong>，而频谱资源是非常稀缺和宝贵的。如果能够让同一个无线信号既能传递信息又能进行感知，那么就可以节省频谱资源，并提高频谱利用率。</li><li>其次，通信和感知<strong>都需要使用类似的硬件设备</strong>（比如天线、放大器、滤波器等），而硬件设备也是非常昂贵和复杂的。如果能够让一套设备既能支持通信又能支持感知，相当于节省了硬件成本。</li><li>再次，通信和感知<strong>都需要进行类似的信息处理</strong>（比如编码、调制、解调、解码等），这个过程是非常复杂的。如果能够让一套算法既能实现通信又能实现感知，以有限的代价换来了翻倍的能力，想必也是极好的。</li></ul><p>可以看出，基站是为“通信”而生的专门设备，雷达则是专为“感知”而存在的，它们虽然在表面上看起来迥然相异，却早已将根紧握在地下，叶相触在云里。如果能<strong>在基站里面融入雷达的功能</strong>，采用一套设备同时实现通信和感知的功能，并达到通信辅助感知，感知辅助通信的化境，对两者均可谓是一种涅槃重生般的双赢。</p><p>如上所述，通信和感知系统的融合，就叫做“<strong>通信感知一体化</strong>”，简称“<strong>通感一体化</strong>”或者“<strong>通感</strong>”。如果我们需要阅读英文资料，则“通信感知一体化”写作IntegratedSensing And Communication，简称ISAC，读作“艾萨克”。</p><ul><li>狭义的通感一体化是指具有上面提到的有测距、测速、测角、成像、目标检测、目标跟踪和目标识别等能力的通信系统，早期也叫做“雷达通信一体化”。</li><li>而广义的通感一体化，则是指具有感知一切业务、网络、用户和终端，以及环境物体的属性与状态的通信系统，其在感知的上可具有超出传统雷达的能力。</li></ul><p>随着5G频谱从传统的Sub6G向毫米波拓展，波长的减少让感知的能力不断提升。因此，在5G的下半场，也就是5G-Advanced阶段，通信感知一体化被纳入了标准化的议程。在未来的6G，频谱将拓展到太赫兹，感知的能力会更进一步增强，给我们带来更大的想象空间。</p><h2 id="通信感知一体化有什么用处">2.通信感知一体化有什么用处？</h2><p>作为5G-Advanced阶段研究的关键技术，6G的核心愿景之一，通感一体化可以给通信基站和终端叠加Buff，帮我们做很多事情，实现很多以前想象不到的目标。通感一体化的目标不在于取代雷达、摄像头或者其他传感器，它的最大优势在于“顺势而为”。这是因为，基站作为通信基础设施是无处不在的，且在铁塔上，电源、天馈、传输等资源均具备，如果<strong>只需通过软件升级就可以拥有感知能力</strong>，何乐而不为呢？下面是一些典型的通感一体化应用场景。</p><h3 id="低空安防">2.1 低空安防</h3><p>随着消费级无人机的发展，由于难以监控，无人机随意乱飞现象越来越严重。这虽然对个人来说问题不大，但对一些需要保密的单位来说，再严密的地面安防，也挡不住无人机飞入飞出如入无人之境，未经允许在空中随意拍摄简直不要太轻松。</p><p>为防止无人机“黑飞”造成的泄密、碰撞及噪声等问题，需要高效、低成本地部署低空安防系统。目前无人机安防市场多种探测方案并存，但都面临技术、效率、成本等诸多限制。</p><p>通信感知一体化技术，可以让需部署低空安防区域的多个基站秒变雷达，再结合基站内部的算力资源，快速搭建低空安防系统，只要基站信号可达，就能实时定位和追踪入侵无人机，供安防系统下一步决策参考。</p><p>反过来，基于通感一体化提供的成像、地图构建和环境重构能力，系统可以化被动为主动，派出无人机进行侦察、物流派送等活动，并能根据多站感知能力，在未知的环境中执行自动导航和路径规划。</p><h3 id="智慧交通">2.2 智慧交通</h3><p>在车联网场景中，需要对道路本身和环境进行识别感知，对车辆位置、速度及运动方向进行识别，对道路上异常事件进行识别。通感一体系统可实时感知道路上的车流状态，实现人、车、路的高效协同，保障交通安全，提升交通系统运行效率。通感一体系统可利用通信基站站点高、覆盖广的特点，实时、大范围、感知车道流量和车速信息，同时检测行人或动物道路入侵，有效实施道路监管，保障交通安全和提升交通效率。</p><h3 id="智能家居">2.3 智能家居</h3><p>虽说基于摄像头对家里进行监控，分析人的动作以及行为在技术上都是可行的，但个人隐私泄露的风险也很大。想象一下，在你毫不知情的情况下，自己在家中的一举一动早已成了楚门的世界，是不是感觉不寒而栗。因此，基于摄像头的智能家居方案的适用范围有限，基于无线的解决方案已成为业内公认的发展趋势。</p><p>通信感知一体化系统可以利用基站或者Wi-Fi路由器发射的无线信号来实现对人的动作和行为的精细感知，为智能家居系统提供更加丰富的功能。比如，采用通感一体化，可实现人来灯亮，人走灯熄；可以通过不同姿势，可以切换操纵任意电器；当小孩爬到窗口阳台上，或者老人摔倒等危险发生时，给住户发送通知；在住户离家时有人进入，则会触发安防报警。</p><p>除了上述的家居控制，安防监控之外，室内的通感一体化还可以进行行为监测。系统通过表跟踪、定位和识别，可以对人的行为进行监测并进行分析与判断。比如，可通过对步态的精细化监测与识别判断是哪位家庭成员，还可以进一步分析每一个家庭成员看电脑、看电视、睡觉、走动等活动的时间比例，活动区间以及睡眠质量等。</p><h3 id="社会治理">2.4 社会治理</h3><p>通信感知一体化还有很多我们意想不到的用途，比如气候环境监测、公共安全管理等社会治理的重要方面。</p><p>在气候环境监测场景中，借助无线网络无处不在的特性，基站可通过发送通信感知一体化信号，结合水分子、灰尘及各类化学物质对无线信号衰落的特性，分析获得一体化信号强度等变化特性，实现降水量、污染气体排放和空气质量的实时监测等。在公共安全管理方面，通过感知功能的实时探测，可以实现诸如台风预警、洪水预警和沙尘暴预警等功能，为灾害防范提前预留时间。</p><h3 id="智慧医疗">2.5 智慧医疗</h3><p>健康医疗方面，通信感知一体化系统在实现高速通信的同时，还可以有效地实现健康监测和管理。</p><p>现有技术已经实现了利用通信信号实现人体的呼吸和心跳的监测。当发现呼吸和心率异常时，预警信息通过通信链路实时回传给用户，实现实时监测功能。同时，太赫兹成像和光谱检查也将赋予医疗保健领域极大的想象空间。例如，太赫兹可以进行癌变组织、龋齿的检测，以及对汗液、眼泪、唾液、外周血和组织液的监测。可以说，未来基于太赫兹的通感一体化系统，可以随时随地监控你的健康状态，让一切病症无所遁形。</p><h2 id="通信感知一体化的技术原理">3.通信感知一体化的技术原理</h2><p>感知，需要利用无线电信号进行目标检测、定位和信息提取，目的和我们司空见惯通信是不同的，因此其实现原理和评价体系也是不同的。</p><p>对于目标检测，雷达（支持通感的基站也一样）需要发射信号并接收由回波信号、噪声和其它干扰组成的混合信号，从这些蛛丝马迹中判断能否可以检测到未知目标是不是存在。</p><p>假设目标已经移动到了感知区域，系统随即成功检测到了，这当然是最好的；如果系统没有检测到，这就叫做“漏检”。而如果目标并不存在，系统却像“狼来了”一样上报自己检测到了，这就叫做“<strong>虚警</strong>”。因此我们对于感知系统目标检测功能的需求是在低虚警概率下，尽可能高地提升检测概率。一般来说，信噪比越高，检测概率也就越高。</p><h1 id="二感知目标的接收机检测算法">二、感知目标的接收机检测算法</h1><p>无线感知目标检测是指对天线硬件对其接收到的混合信号进行特定的信号处理和门限判决，以规定的检测概率发现未知目标的技术。混合信号由目标回波信号、噪声和其他干扰组成。在此过程中，噪声和其他干扰会以低概率产生随机虚警。衡量目标检测性能的两个常用：检测概率和虚警概率。检测概率<span class="math inline">\(P_d\)</span>是指在混合信号中存在目标回波且目标回波被判决为存在的正确概率。虚警概率<span class="math inline">\(P_{fa}\)</span>指的是混合信号中没有目标回波但被判决为有目标回波的错误概率。非平稳背景中若采取固定门限进行雷达目标检测,虚警率会<span class="math inline">\(P_{fa}\)</span>随杂波功率增加而急剧增加。</p><h2 id="广义似然比检测glrt">1.广义似然比检测（GLRT）</h2><p>在Neyman-Person准则下，最优检验统计量是似然比的形式： <span class="math display">\[l_{opt}(z)=\frac{P(z|H_1,\theta_1)}{P(z|H_0,\theta_0)}\]</span> 其中<strong>z</strong>表示观测数据，<span class="math inline">\(\theta_1\)</span>、<span class="math inline">\(\theta_0\)</span>分别表示在<span class="math inline">\(H_1\)</span>、<span class="math inline">\(H_0\)</span>假设条件下的未知参数，为了求解这些未知参数，可以利用这些参数的<strong>极大大似然估计值</strong>进行替代，此时检验统计量为：<span class="math display">\[l_{GLRT}(z)=\frac{\max\limits_{\theta_1}P(z|H_1,\theta_1)}{\max\limits_{\theta_0}P(z|H_0,\theta_0)}\]</span></p><h2 id="恒定虚警率算法constant-false-alarm-rate-cfar">2.恒定虚警率算法（ConstantFalse Alarm Rate, CFAR）</h2><p>虚警率是衡量雷达信号检测性能的重要指标,恒虚警目标检测技术是根据<strong>杂波水平的变化</strong>自适应地改变检测门限,以获得恒定虚警率条件下的最大检测概率。对不同杂波环境模型要采取不同的CFAR检测策略以尽可能逼近最优检测性能。杂波模型主要分为<strong>高斯和非高斯杂波</strong>两大类。早期雷达分辨力较低，认为雷达杂波幅度服从高斯分布，接收机包络检波输出服从瑞利分布，进行平方律检波后服从指数分布。在现代雷达中，尤其是在低俯仰角或高分辨率情况下，杂波的幅度统计特性明显偏离高斯分布，因而采用非高斯模型来更准确的描述实际雷达的杂波统计特性。非高斯模型有韦布分布、对数正态分布和K分布。</p><h3 id="经典一维cfar时域多普勒域">2.1 经典一维CFAR（时域/多普勒域）</h3><h4 id="均值类cfar">2.1.1 均值类CFAR</h4><p>CFAR检测器的输入一般包括检测单元D和2n个参考单元。参考单元位于检测单元两侧，前后各n个。保护单元主要用在单目标情况下，防止目标能量泄漏到参考单元影响检测效果。设参考门限电平S，S=T×Z，其中：Z为总的杂波功率水平的估计，T为门限因子，则当D&gt;S时，认为有目标；反之，认为没有目标。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240603144849479.png" alt="CFAR算法的处理流程"><figcaption aria-hidden="true">CFAR算法的处理流程</figcaption></figure><p>同类型CFAR算法的差异主要体现为<strong>对参考单元处理的不同</strong>，亦为Z选取的不同。在背景噪声独立同分布时，通过确定常数T来达到恒定的虚警概率。不同的检测算法，其确定常数T的方法也会相应的有所区别。为最大限度减少相邻单元对检测单元的干扰，需要在检测单元两侧设定合适长度的保护单元，长度在参考单元长度的10%左右。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240603221050166.png" alt="对参考单元不同的处理方式"><figcaption aria-hidden="true">对参考单元不同的处理方式</figcaption></figure><blockquote><p>杂波边缘描述的是检测背景不同特性区域间的过渡区情况，这种情况的典型例子是降雨区的边缘、海洋陆地交界处等。如果检测单元处于弱杂波区，而参考滑窗中其它一些参考单元处于强杂波区，那么即使信噪比很大也会对目标检测产生覆盖效应，那么虚警概率和检测概率都会下降。如果检测单元处于强杂波区，而其它一些参考单元处于弱杂波区，那么虚警概率会急剧上升。</p></blockquote><p>客观评价各种恒虚警CFAR（CA-CFAR,SO-CFAR,GO-CFAR）检测器的性能，将杂波分为三种典型情况:(1)均匀背景杂波(2)杂波边缘(3)多干扰目标杂波。</p><ul><li>在均匀杂波背景性能CA &gt; GO &gt; SO</li><li>在多目标环境下性能 WCA &gt; SO &gt; CA &gt; GO</li><li>在杂波边缘环境中，GO的虚警控制能力明显强于CA和SO，因此在杂波边缘环境中性能GO&gt;CA&gt;SO。</li></ul><ol type="1"><li><p><strong>单元平均CFAR (CA-CFAR)</strong></p><p>将待检测单元周围的临近参考单元数据作平均处理，作为背景杂波功率估计以获得检测门限。<span class="math display">\[T=N(P_{fa}^{-1/2n}-1), N=2n\]</span>GO、SO、OS三类CFAR检测算法的门限因子T难以用数学表达式表示，可以通过迭代运算的方式求解出来。</p></li><li><p><strong>最小值CFAR (SO-CFAR)</strong></p><p>当目标处于检测单元而其周围参考单元存在其他目标时，则可能会出现检测单元目标漏检，即遮蔽效应。为改善遮蔽效应，可以采取选择前后半窗求和后的较小者再取平均作为背景杂波估计，防止背景估计偏大从而避免目标漏检。</p><p>门限因子求解是一个非常复杂的高阶函数，基本上无法通过反函数求解，这里使用二分求解法解决。<span class="math display">\[P_{fa,so}=2\displaystyle\sum_{i=0}^{n-1}\begin{pmatrix}n+i-1\\i\end{pmatrix}(2+\frac{T}{n})^{-(n+i)}\]</span></p><blockquote><p><span class="math inline">\(\begin{pmatrix} n+i-1\\i\end{pmatrix}\)</span>表示排列组合中的组合，读作n+i-1中取i，计算式为<span class="math inline">\(\frac{(n+i-1)!}{i!(n-1)!}\)</span></p></blockquote></li><li><p><strong>最大值CFAR (GO-CFAR)</strong></p><p>当前后沿参考滑窗的杂波功率差异较大时会出现<strong>杂波边缘效应</strong>，此时采用CA算法与SO算法进行检测时均会出现杂波边缘处的虚警提升，为改善杂波边缘引起的虚警提升，可以采用单元最大(GO)-CFAR，通过选择杂波功率较大的半窗参考单元取平均作为背景杂波估计。</p><blockquote><p>杂波边缘效应：在杂波边缘或非均匀背景下，参考单元可能包含不同性质的回波（如海杂波和陆地杂波的交界处），这会导致噪声估计不准确，影响检测性能。</p></blockquote><p><span class="math display">\[P_{fa,go}=2(1+\frac{T}{n})^{-n}-2\displaystyle\sum_{i=0}^{n-1}\begin{pmatrix}n+i-1\\i\end{pmatrix}(2+\frac{T}{n})^{-(n+i)}\]</span></p></li><li><p><strong>加权单元平均CFAR(WCA-CFAR)（不常用）</strong></p><p>分别对前后窗按杂波强度加权得到杂波估计，即 <span class="math display">\[Z=\alpha x+\beta y\]</span></p><p><span class="math display">\[P_{fa,wca}=(1+\alpha×\frac{T}{n})^{-n}(1+\beta×\frac{T}{n})^{-n}\]</span></p></li></ol><h4 id="有序统计cfar-os-cfar">2.1.2 有序统计CFAR (OS-CFAR)</h4><p>为改善均值类CFAR在多目标环境中的检测性能下降问题，Rohling首次提出了有序统计(orderedstatistics，OS)-CFAR检测器，将参考单元内的数据排序处理，取排序后的第k个值作为背景杂波功率估计值来计算检测门限。</p><p>多目标环境中OS类CFAR表现优于均值类CFAR，但在杂波边缘环境中的性能也存在一定程度上的下降。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607112011670.png" alt="OS-CFAR算法的处理流程"> <span class="math display">\[P_{fa}=k\begin{pmatrix} N\\k\end{pmatrix}\frac{\Gamma[N-k+1+T]\Gamma(k)}{\Gamma[N+1+T]}\]</span></p><blockquote><p><span class="math inline">\(\Gamma(⋅)\)</span>是伽马函数，其定义<span class="math inline">\(\Gamma(n) =(n-1)!\)</span></p></blockquote><p>k的选取合适与否关系到检测结果的优劣，在关于OS的参考窗长度N及有序统计量k的取值问题上，Rohling总结了关于OS的双边参考滑窗长度N与k的取值对检测器性能的影响,即当k&lt;N/2时，杂波边缘效应的影响会较大,并建议k应取在3N/4左右,以获得多目标或混合杂波环境中的综合性能，但未有准确k的取值的方法。</p><h4 id="自适应cfar">2.1.3 自适应CFAR</h4><p>以上几种CFAR检测器只有在一定的杂波环境中才能接近最佳检测性能，且需获得数据的先验信息。自适应CFAR可以自适应地选择算法和参数。例如删除单元平均(censoredcell-averaging，CCA)-CFAR，自适应杂波边缘位置(heterogeneous clutterestimate，HCE)-CFAR，变化指数(variabilityindex，VI)-CFAR等等。其中，VI-CFAR和HCE-CFAR算法作为常规自适应恒虚警的研究较多。</p><p>VI算法首先计算参考窗的VI值和MR值，VI值用来判断参考窗采样值是否均匀，MR值用来判断前后参考窗功率均值是否一致。以下是VI-CFAR检测策略选择：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607114543077.png"></p><p>HCE-CFAR算法先估计杂波边缘位置，获得待测单元处在哪一个杂波区，再求得杂波区的背景功率作为相应的背景估计。不予考虑。</p><p>基于机器学习的CFAR算法不需要计算统计量,也无需其他参数,具有强大的自适应能力,通过改进训练策略,增大训练样本等方式能够让该类算法有更强的性能。基于机器学习的CFAR检测算法如下图所示。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607114658133.png" alt="基于机器学习的CFAR检测算法"><figcaption aria-hidden="true">基于机器学习的CFAR检测算法</figcaption></figure><h4 id="多普勒域一维cfar的输入前处理">2.1.4多普勒域一维CFAR的输入前处理</h4><p>在数据输入前可加其他算法处理，如动目标显示MTI/动目标检测MTD。</p><p>相当于在对多普勒域进行恒虚警检测前加滤波器。MTI简单理解就是一种抑制固定杂波或缓慢运动杂波的频域滤波器。MTD简单的来说就是在MTI的基础上增加了一组覆盖目标回波多普勒频率的所有范围的窄带滤波器。</p><h5 id="动目标显示moving-target-indicator-mti">2.1.4.1 动目标显示(MovingTarget Indicator, MTI)</h5><ol type="1"><li><p><strong>单延迟线对消器</strong></p><p>实现MTI滤波器常用的是单延迟线对消滤波器。由于单延迟线对消器/单对消器在读出输出前需要有两个不同的输入脉冲，因而经常称其为“双脉冲对消器”。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607122933438.png"></p><p>时域理解：静止目标的回波相位前后两次没有任何变化，基于此可以将前后两次回波信号进行相减就可以消除静止目标的回波，保留运动目标的回波。</p><p>频率理解：通常杂波谱集中在直流和雷达脉冲重复频率fr的整数倍处。如下图：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123052542.png"></p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240613163324251.png"></p><p>单延迟线对消器的频谱图可以发现在直流和fr的整数倍处，具有较深的阻碍。因此可以有效抑制杂波。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123114674.png"></p></li><li><p><strong>双延迟线对消器</strong></p><p>在大多数雷达应用中，单个对消器的响应无法让人接受，原因在于其阻带没有宽的槽口。双延迟线对消器/双对消器无论在阻带还是通带上都有较好的响应，因而比单个对消器得到了更广泛的应用。下图给出了双延迟线对消器的两种基础结构。双对消器常称为“三脉冲对消器”，原因是在读出输出之前，它们需要3个不同的输入脉冲。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123336566.png"></p><p>双对消器比单对消器具有更好的响应(更深的槽口和更平的通带响应)，两者对比如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123418266.png"></p></li><li><p><strong>递归滤波器</strong></p><p>带有反馈回路的延迟线对消器称为递归滤波器。递归滤波器的优点是，通过反馈回路，我们可以改变滤波器的频率响应形状。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123505225.png" alt="image-20240607123505225"><figcaption aria-hidden="true">image-20240607123505225</figcaption></figure><p>很明显，改变增益因子K可控制滤波器响应。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240607123523906.png" alt="image-20240607123523906"><figcaption aria-hidden="true">image-20240607123523906</figcaption></figure></li></ol><h5 id="动目标检测moving-target-detectionmtd">2.1.4.2 动目标检测(MovingTarget Detection，MTD)</h5><p>动目标检测是一种使用一组<strong>窄带多普勒滤波器</strong>将<strong>不同速度的目标</strong>分离出来的技术，其主要依据为不同速度产生的多普勒频移不同。当脉冲压缩处理后的信号通过多普勒滤波器组时，即进行速度维FFT时，由于不同速度产生的多普勒频移不同，各个速度的目标就会落入响应的多普勒通道，再乘以速度分辨率，由此可以计算出目标速度。</p><p>MTD是带通滤波器组。也就是多个输入多个输出，可以用FIR组实现，但是一般用FFT实现，即对不同脉冲组回波信号的相同距离单元做FFT处理（慢时间维），以N个输入得到N个输出。对于N点FFT，任一频率上的结果相当于N个多普勒滤波器在该频率上的频率响应的积累。随后CFAR对这些输出进行检测和判断目标，若存在目标，这个输出中比出现一个峰值最大的数，则这个可能就是目标的位置信息，根据位置信息，即可以得到运动目标的多普勒值。MTD雷达系统中区分运动目标和杂波在于它们速度上的差别。由于速度不同而引起回波信号的多普勒频率不相等，所以可以通过多普勒频率的不同将杂波和运动目标区分开来。动目标检测(MTD)不仅能滤除杂波，而且还可以将不同运动速度的目标区分开来，从而大大改善了在杂波背景下检测运动目标的能力。</p><p>下图为MTI+FFT形式的MTD滤波器结构（根据奈奎斯特采样定理，FFT只能显示其一半采样频率的信号）：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240610105529305.png"></p><blockquote><p>对消器就是MTI</p></blockquote><p>上图中，对消器在零频附近有凹口可实现对地杂波的近似白化滤波。FFT构成了一组在频率轴上相邻且部分重叠的窄带滤波器组，以完成对多普勒频率不同的目标信号的近似匹配滤波，如下图所示：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240610105541180.png"></p><p>由上图，地杂波频谱位于<span class="math inline">\(f=\pmnf_r,n=0,1,2,\dots\)</span>处，其谱峰正好处于MTI对消器的凹口，所以地杂波得到大的抑制。N点FFT形成的N个滤波器则均匀分布在（<span class="math inline">\(0\simf_r\)</span>）的频率区间内，动目标信号由于其多普勒频率的不同可能出现在频率轴上的不同位置，因而可能从0~N-1的多普勒滤波器输出。只要目标信号与地杂波从不同的多普勒滤波器输出，目标信号所在滤波器输出的信杂比将得到明显提高。</p><h2 id="雷达截面积radar-cross-sectionrcs">3.雷达截面积（Radar CrossSection，RCS）</h2><p>雷达截面积（Radar CrossSection）是雷达扫描到物体的等效可见面积。具体来讲，<strong>RCS是一个虚拟的平面</strong>，该平面可以拦截该区域覆盖范围内的全部雷达能量，并且以漫反射形式将能量反射给雷达。雷达接受到物体反射的实际能量和该平面反射的能量是一样的。是衡量雷达可探测到物体的程度的指标。</p><p>RCS表示为 𝜎，也称为雷达特征（radarsignature），定义为在指定方向上散射的单位立体角功率与从指定方向入射到散射体上的平面波单位面积功率之比的4<span class="math inline">\(\pi\)</span>倍。RCS用公式表达为： <span class="math display">\[\sigma=\lim_{R \to \infty}4\pi R^2\frac{S_s}{S_i}\]</span> 其中，R是雷达和目标之间的距离；<span class="math inline">\(S_s\)</span>是距离目标点R处的散射能量密度，<span class="math inline">\(S_i\)</span>​是目标接受到的雷达入射能量密度。 <span class="math display">\[\sigma=\lim_{R \to \infty}4\pi R^2\frac{|E_s|^2}{|E_i|^2}\]</span> 其中，<span class="math inline">\(E_s\)</span>是目标散射的电场强度，<span class="math inline">\(E_i\)</span>是入射电场强度。</p><blockquote><p>入射波（IncidentWave）：这是雷达发射的电磁波，到达目标物体前的状态。</p><p>散射波（ScatteredWave）：这是入射波与目标物体相互作用后产生的各个方向的反射和散射波。</p></blockquote><h1 id="三仿真比较几种雷达目标cfar检测算法">三、仿真比较几种雷达目标CFAR检测算法</h1><h2 id="概述">1.概述</h2><p>雷达的检测过程可用门限检测来描述。几乎所有的判断都是以接收机的输出与某个门限电平的比较为基础的，如果接收机输出的包络超过了某一设置门限，就认为出现了目标。雷达在探测时会受到噪声、杂波和干扰的影响，因而采用固定门限进行目标检测时会产生一定的虚警，特别是当<strong>杂波背景起伏变化时虚警率会急剧上升</strong>，严重影响雷达的检测性能。因此，<strong>根据雷达杂波数据动态调整检测门限，在虚警概率保持不变的情况下实现目标检测概率最大化</strong>，这种方法称为恒虚警率（ConstantFalse Alarm Rate，CFAR）检测技术。</p><p>雷达在判决过程中，可能会出现两类错误。第一类是在没有目标时判断为有目标，这类错误称为虚警。另一类是在有目标时判断为没有目标，这类错误称为漏警。以上两类错误以一定的概率出现，分别称为虚警概率和漏警概率。</p><p>目前，研究人员针对各种杂波环境下提出了许多高效的CFAR检测算法，大体可分为两类：一类是均值类CFAR(CA-CFAR)算法，该类算法应用的前提是假设背景杂波是均匀分布的；另一类是有序统计类CFAR(OS-CFAR)算法，这类算法是为了应对邻域内<strong>多目标情况</strong>而设计的。不同CFAR检测算法各有优劣，都是针对具体情况而设计，我们只需要学习CFAR的基本原理以及熟悉几种典型的CFAR检测算法即可。</p><h2 id="基本原理">2.基本原理</h2><p>CFAR检测器的输入一般包括检测单元Y和2n个参考单元。参考单元位于检测单元两侧，前后各n个。保护单元主要用在单目标情况下，防止目标能量泄漏到参考单元影响检测效果。设参考门限电平为V<sub>TH</sub>，V<sub>TH</sub>=T×Z，其中：Z为总的杂波功率水平的估计，T为门限因子，则当Y&gt;V<sub>TH</sub>时，认为有目标；反之，认为没有目标。</p><p>CFAR算法的处理流程如下图所示：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240615164843798.png"></p><p>一般情况下，杂波同噪声相互独立，且平方律检波后都满足指数分布。参考单元的概率密度函数为：<span class="math display">\[f(x)=\frac{1}{\mu}e^{-\frac{x}{\mu}},x\ge0\qquad (1)\]</span> 检测单元的概率密度函数为：<span class="math inline">\(f_Y(x)=\lambda e^{-\lambda x},x\ge0\)</span></p><p>杂波背景与热噪声加起来的总平均功率水平用<span class="math inline">\(\lambda\)</span>表示，在H<sub>0</sub>（没有目标）条件下，<span class="math inline">\(\lambda\)</span>用<span class="math inline">\(1/\mu\)</span>表示；在H<sub>1</sub>（有目标）条件下，<span class="math inline">\(\lambda=\frac{1}{\mu(1+\lambda&#39;)}\)</span>。其中<span class="math inline">\(\lambda&#39;\)</span>是一个比值，表示的是目标信号与噪声的平均功率的比，也就是信噪比。不难得出：<span class="math display">\[\lambda=\begin{cases}\frac{1}{\mu}&amp;H_0\\\frac{1}{\mu(1+\lambda&#39;)}&amp;H_1\end{cases}\]</span> 设<span class="math inline">\(H_0\)</span>表示为没有目标，<span class="math inline">\(P[Y&gt;TZ|H_0]\)</span>则表示为在没有目标的条件下判断为有目标的概率，从而得到虚警概率的表达式为：<span class="math display">\[P_{fa}=E_Z\{P[Y&gt;TZ|H_0]\}=E_Z\{\int_{TZ}^{\infty}f_Y(y)dy\}\\=E_Z\{\int_{TZ}^{\infty}(1/\mu)e^{(-y/\mu)}dy\}=E_Z\{e^{(-TZ/\mu)}\}=M_Z(u)|_{u=-T/\mu}\qquad (2)\]</span> 式中，<span class="math inline">\(\mu\)</span>是噪声功率；<span class="math inline">\(Z\)</span>为随机变量，它的分布取决于CFAR算法的类型以及参考单元的分布；<span class="math inline">\(M_Z(u)|_{u=-T/\mu}\)</span>为矩母函数。</p><blockquote><p>一个与随机变量Z相关的矩母函数是参数u的函数<span class="math inline">\(M_Z(u)\)</span></p><p>定义为：<span class="math inline">\(M_Z(u)=E\{e^{uZ}\}\)</span></p><p>当 Z 是离散随机变量时,相关矩母函数的计算为：<span class="math inline">\(M_Z(u)=\displaystyle\sum_xe^{uz}P_Z(z)\)</span></p><p>当 Z 是连续随机变量时,相关矩母函数的计算为：<span class="math inline">\(M_Z(u)=\int_{-\infty}^{\infty}e^{uz}f_Z(z)dz\)</span></p></blockquote><h2 id="几种典型的cfar检测算法">3.几种典型的CFAR检测算法</h2><p>不同类型CFAR算法的差异主要体现为对参考单元处理的不同，亦为Z值选取的不同。在背景噪声独立同分布时，通过确定常数T来达到恒定的虚警概率。不同的检测算法，其确定常数T的方法也会相应的有所区别。下面将对几种典型CFAR算法的虚警概率表达式进行推导。</p><h3 id="ca-cfar检测算法">3.1 CA-CFAR检测算法</h3><p>背景杂波功率水平Z的计算方式为2n个参考单元之和： <span class="math display">\[Z=\displaystyle\sum_{i=1}^nX_i+\displaystyle\sum_{i=n+1}^{2n}X_i=\displaystyle\sum_{i=1}^{2n}X_i\]</span></p><blockquote><p>在推导<span class="math inline">\(P_{fa}\)</span>与<span class="math inline">\(T\)</span>的关系之前，我们先给我伽马（<span class="math inline">\(\Gamma\)</span>）分布的相关知识。</p><p><span class="math inline">\(\Gamma\)</span>分布的概率密度函数为：<span class="math display">\[f(x)=\beta^{\alpha}x^{\alpha-1}e^{-\beta x}/\Gamma(\alpha)\thinspace,x\ge0,\alpha\ge0,\beta\ge0\qquad (3)\]</span> 其中，<span class="math inline">\(\alpha,\beta\)</span>是两个参数，当<span class="math inline">\(\alpha=1,\beta=1/\mu\)</span>时，式(3)就退化成为式(1)中的指数分布。<span class="math inline">\(\Gamma(\alpha)\)</span>就是数学中的伽马函数，对于正整数<span class="math inline">\(\alpha\)</span>有<span class="math inline">\(\Gamma(\alpha)=(\alpha-1)!\)</span>。</p></blockquote><p>设<span class="math inline">\(G(\alpha,\beta)\)</span>为<span class="math inline">\(\Gamma\)</span>分布的概率分布函数，若X为服从<span class="math inline">\(\Gamma\)</span>分布的随机变量，则有： <span class="math display">\[X\sim G(\alpha,\beta)\qquad (4)\]</span> X的矩母函数为： <span class="math display">\[M_X(u)=(1-u/\beta)^{-\alpha}\qquad (5)\]</span>假设输入信号中的各变量满足独立同分布的条件，则对于2n个随机变量之和的矩母函数等于各随机变量的矩母函数之积，所以有变量Z的矩母函数为：<span class="math display">\[M_Z(u)=(1-u/\beta)^{-\alpha·2n}\qquad (6)\]</span> 将式(6)和<span class="math inline">\(\alpha=1,\beta=1/\mu，u=-T/\mu\)</span>代入式(2)得：<span class="math display">\[P_{fa}=M_Z(-T/\mu)=[1-(-T/\mu)/(1/\mu)]^{-2n}=(1+T)^{-2n}\qquad (7)\]</span> 即可得到虚警概率<span class="math inline">\(P_{fa}\)</span>与门限因子<span class="math inline">\(T\)</span>的关系： <span class="math display">\[P_{fa}=(1+T)^{-2n}\iff T=(P_{fa})^{-1/2n}-1\qquad (8)\]</span></p><blockquote><p>直接把X看作为服从指数分布的随机变量<span class="math inline">\(f(x)=\lambda e^{-\lambdax},x\ge0\)</span>，其中<span class="math inline">\(\lambda=1/\mu\)</span>。</p><p>X的矩母函数为：<span class="math inline">\(M_X(u)=\frac{\lambda}{\lambda-u}\)</span>。</p><p>输入信号中的各变量满足独立同分布的条件，则对于2n个随机变量之和的矩母函数等于各随机变量的矩母函数之积。</p><p>所以有：<span class="math inline">\(M_Z(u)=(\frac{\lambda}{\lambda-u})^{2n}\)</span>。</p><p>将上式与<span class="math inline">\(\lambda=1/2\mu\)</span>代入式(2)得： <span class="math display">\[P_{fa}=M_Z(-T/\mu)=[1-\mu(-T/\mu)]^{-2n}=(1+T)^{-2n}\]</span></p></blockquote><h3 id="go-cfarso-cfar检测算法">3.2 GO-CFAR、SO-CFAR检测算法</h3><p>最大选择GO(Greatest Of)-CFAR是选取前面n个参考单元之和与后面n个参考单元之和中的大者作为背景杂波功率水平Z；而最小选择SO(SmallestOf)-CFAR是选取前面n个参考单元之和与后面n个参考单元之和中的小者作为背景杂波功率水平Z。<span class="math display">\[\begin{cases}Y_1=\displaystyle\sum_{i=1}^nX_i\\Y_2=\displaystyle\sum_{i=n+1}^{2n}X_i\\GO:max(Y_1,Y_2)\\SO:min(Y_1,Y_2)\end{cases}\]</span></p><p><span class="math display">\[P_{fa,go}=2(1+T)^{-n}-2\displaystyle\sum_{i=0}^{n-1}\begin{pmatrix}n+i-1\\i\end{pmatrix}(2+T)^{-(n+i)}\]</span></p><p><span class="math display">\[P_{fa,so}=2\displaystyle\sum_{i=0}^{n-1}\begin{pmatrix}n+i-1\\i\end{pmatrix}(2+T)^{-(n+i)}\]</span></p><h3 id="os-cfar检测算法">3.3 OS-CFAR检测算法</h3><p>顺序统计量OS(OrderStatistic)CFAR的原理是先对参考单元从小到大排序，再选取第k个样本作为Z。n是参考单元的总长度。<span class="math display">\[P_{fa}=k\begin{pmatrix} n\\k\end{pmatrix}\frac{\Gamma[n-k+1+T]\Gamma(k)}{\Gamma[n+1+T]}\]</span>GO、SO、OS三类CFAR检测算法的门限因子T难以用数学表达式表示，可以通过迭代运算的方式求解出来。当求解出门限因子T后，便可以将其代入检测概率的表达式，得到在不同信噪比的条件下，检测概率的变化情况。</p><h3 id="检测概率p_d的计算方法">3.4 检测概率<span class="math inline">\(P_d\)</span>的计算方法</h3><p>根据3.1我们求出在恒定虚警概率<span class="math inline">\(P_{fa}\)</span>下的门限因子<span class="math inline">\(T\)</span>，便可以接着求目标检测概率<span class="math inline">\(P_d\)</span>。根据第二节，此时是在H<sub>1</sub>（有目标）条件下，故单元和检测单元的概率密度函数为：<span class="math display">\[f_Y(x)=\frac{1}{\mu(1+\lambda&#39;)}e^{-\frac{x}{\mu(1+\lambda&#39;)}},x\ge0\]</span> 目标检测概率为： <span class="math display">\[P_{d}=E_Z\{P[Y&gt;TZ|H_0]\}=E_Z\{\int_{TZ}^{\infty}f_Y(y)dy\}\\=E_Z\{\int_{TZ}^{\infty}\frac{1}{\mu(1+\lambda&#39;)}e^{-\frac{y}{\mu(1+\lambda&#39;)}}dy\}=E_Z\{e^{-\frac{TZ}{\mu(1+\lambda&#39;)}}\}=M_Z(u)|_{u=-\frac{T}{\mu(1+\lambda&#39;)}}\qquad(2)\]</span> 其中，将3.1中的<span class="math inline">\(M_Z(u)=(1-u/\beta)^{-\alpha·2n}\)</span>，<span class="math inline">\(\alpha=1,\beta=1/\mu\)</span>，代入得 <span class="math display">\[P_d=(1+\frac{T}{1+\lambda&#39;})^{-2n}\]</span></p><blockquote><p>通过观察可以看到目标检测概率<span class="math inline">\(P_d\)</span>与虚警概率<span class="math inline">\(P_{fa}\)</span>的差别就在于矩母函数中，u的取值不同。即把<span class="math inline">\(T\)</span>换成<span class="math inline">\(\frac{T}{1+\lambda&#39;}\)</span>。</p><p>上述变换在其他检测算法中同样适用。</p></blockquote><h2 id="代码实现">4.代码实现</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% ------ 程序功能：四类CFAR检测算法的检测概率与SNR的关系 %</span><br>clc<br>clear all;<br>close all;<br><br><span class="hljs-comment">%% 参数设置</span><br>R = <span class="hljs-number">24</span>;                     <span class="hljs-comment">% 参考单元长度</span><br>n = R/<span class="hljs-number">2</span>;                    <span class="hljs-comment">% 半滑窗长度</span><br>k = R*<span class="hljs-number">3</span>/<span class="hljs-number">4</span>;                  <span class="hljs-comment">% os-cfar的参数</span><br>P_fa = <span class="hljs-number">1e-6</span>;                <span class="hljs-comment">% 虚警概率</span><br>SNR_dB = (<span class="hljs-number">0</span>:<span class="hljs-number">30</span>);            <span class="hljs-comment">% 信噪比</span><br>SNR = <span class="hljs-number">10.</span>^(SNR_dB./<span class="hljs-number">10</span>);     <span class="hljs-comment">% 信号功率与噪声功率的比值</span><br>syms T;                     <span class="hljs-comment">% 门限因子的符号变量</span><br><span class="hljs-comment">%% CA-CFAR</span><br>T_CA = P_fa^(<span class="hljs-number">-1</span>/R)<span class="hljs-number">-1</span>;           <span class="hljs-comment">% CA-CFAR的门限因子</span><br>Pd_CA = (<span class="hljs-number">1</span>+T_CA./(<span class="hljs-number">1</span>+SNR)).^(-R);    <span class="hljs-comment">% CA-CFAR的检测概率</span><br><br><span class="hljs-comment">%% SO-CFAR、GO-CFAR</span><br>Pfa_SO = <span class="hljs-number">0</span>;<br>syms T<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>:n<span class="hljs-number">-1</span><br>    Pfa_SO = Pfa_SO+<span class="hljs-number">2</span>*<span class="hljs-built_in">nchoosek</span>(n+<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">i</span>)*(<span class="hljs-number">2</span>+T)^(-(n+<span class="hljs-built_in">i</span>));     <span class="hljs-comment">% SO-CFAR的虚警概率表达式</span><br><span class="hljs-keyword">end</span><br>T1_SO = solve(Pfa_SO == P_fa, T);       <span class="hljs-comment">% 求解出虚警概率为P_fa时对应的门限因子T</span><br>T2_SO = double(T1_SO);<br>T_SO = T2_SO(T2_SO == <span class="hljs-built_in">abs</span>(T2_SO));      <span class="hljs-comment">% SO-CFAR的门限因子</span><br><br>Pfa_GO = <span class="hljs-number">2</span>*(<span class="hljs-number">1</span>+T)^(-n)-Pfa_SO;           <span class="hljs-comment">% GO-CFAR的虚警概率表达式</span><br>T1_GO = solve(Pfa_GO == P_fa, T);       <span class="hljs-comment">% 求解出虚警概率为P_fa时对应的门限因子T</span><br>T2_GO = double(T1_GO);<br>T_GO = T2_GO(T2_GO == <span class="hljs-built_in">abs</span>(T2_GO));      <span class="hljs-comment">% GO-CFAR的门限因子</span><br><br>Pd_SO = <span class="hljs-number">0</span>;<br>Pd_GO = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>:n<span class="hljs-number">-1</span><br>    Pd_SO = Pd_SO+<span class="hljs-number">2</span>*<span class="hljs-built_in">nchoosek</span>(n+<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">j</span>).*(<span class="hljs-number">2</span>+T_SO./(<span class="hljs-number">1</span>+SNR)).^(-(n+<span class="hljs-built_in">j</span>));     <span class="hljs-comment">% SO-CFAR的检测概率</span><br>    Pd_GO = Pd_GO+<span class="hljs-number">2</span>*<span class="hljs-built_in">nchoosek</span>(n+<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">j</span>).*(<span class="hljs-number">2</span>+T_GO./(<span class="hljs-number">1</span>+SNR)).^(-(n+<span class="hljs-built_in">j</span>));<br><span class="hljs-keyword">end</span><br>Pd_GO = <span class="hljs-number">2.</span>*(<span class="hljs-number">1</span>+T_GO./(<span class="hljs-number">1</span>+SNR)).^(-n)-Pd_GO;         <span class="hljs-comment">% GO-CFAR的检测概率</span><br><br><span class="hljs-comment">%% OS-CFAR</span><br>Pfa_OS = k*<span class="hljs-built_in">nchoosek</span>(R,k)*<span class="hljs-built_in">gamma</span>(R-k+<span class="hljs-number">1</span>+T)*<span class="hljs-built_in">gamma</span>(k)/<span class="hljs-built_in">gamma</span>(R+T+<span class="hljs-number">1</span>);           <span class="hljs-comment">% OS-CFAR的虚警概率表达式</span><br>T1_OS = solve(Pfa_OS == P_fa, T);       <span class="hljs-comment">% 求解出虚警概率为P_fa时对应的门限因子T</span><br>T2_OS = double(T1_OS);<br>T_OS = T2_OS(T2_OS == <span class="hljs-built_in">abs</span>(T2_OS));      <span class="hljs-comment">% OS-CFAR的门限因子</span><br>Pd_OS = k*<span class="hljs-built_in">nchoosek</span>(R,k)*<span class="hljs-built_in">gamma</span>(R-k+<span class="hljs-number">1</span>+T_OS./(<span class="hljs-number">1</span>+SNR))*<span class="hljs-built_in">gamma</span>(k)./<span class="hljs-built_in">gamma</span>(R+T_OS./(<span class="hljs-number">1</span>+SNR)+<span class="hljs-number">1</span>);      <span class="hljs-comment">% OS-CFAR的检测概率</span><br><br><span class="hljs-comment">%% 画图</span><br><span class="hljs-built_in">figure</span>;<br><span class="hljs-built_in">hold</span> on;<br><span class="hljs-built_in">plot</span>(SNR_dB,Pd_CA,<span class="hljs-string">&#x27;r-*&#x27;</span>);<br><span class="hljs-built_in">plot</span>(SNR_dB,Pd_SO,<span class="hljs-string">&#x27;k-^&#x27;</span>);<br><span class="hljs-built_in">plot</span>(SNR_dB,Pd_GO,<span class="hljs-string">&#x27;b-o&#x27;</span>);<br><span class="hljs-built_in">plot</span>(SNR_dB,Pd_OS,<span class="hljs-string">&#x27;m-.&#x27;</span>);<br>grid on;<br>xlabel(<span class="hljs-string">&#x27;SNR&#x27;</span>,<span class="hljs-string">&#x27;FontName&#x27;</span>,<span class="hljs-string">&#x27;Time New Romans&#x27;</span>,<span class="hljs-string">&#x27;FontAngle&#x27;</span>,<span class="hljs-string">&#x27;italic&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;P_&#123;d&#125;&#x27;</span>,<span class="hljs-string">&#x27;FontName&#x27;</span>,<span class="hljs-string">&#x27;Time New Romans&#x27;</span>,<span class="hljs-string">&#x27;FontAngle&#x27;</span>,<span class="hljs-string">&#x27;italic&#x27;</span>);<br>title([<span class="hljs-string">&#x27;恒虚警率 P_&#123;fa&#125;= &#x27;</span>,num2str(P_fa),<span class="hljs-string">&#x27;，参考单元 2n= &#x27;</span>,num2str(R)]);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;CA&#x27;</span>,<span class="hljs-string">&#x27;SO&#x27;</span>,<span class="hljs-string">&#x27;GO&#x27;</span>,<span class="hljs-string">&#x27;OS&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E5%87%A0%E7%A7%8DCFAR%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E6%A3%80%E6%B5%8B%E6%A6%82%E7%8E%87%E6%AF%94%E8%BE%83.png" alt="几种CFAR检测算法的检测概率比较"><figcaption aria-hidden="true">几种CFAR检测算法的检测概率比较</figcaption></figure><p>可以发现，在均匀杂波背景的条件下：CA-CFAR性能最好，GO-CFAR其次，OS-CFAR多目标检测性能较好，但其在均匀杂波环境下的性能有所下降，SO-CFAR的性能最差。</p><h1 id="四通感原理">四、通感原理</h1><h2 id="通感模型">1.通感模型</h2><h3 id="prs信号模型">1.1 PRS信号模型</h3><p>PRS有四种comb形式，如下</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241026205532552.png" alt="PRS支持的时域映射模式"><figcaption aria-hidden="true">PRS支持的时域映射模式</figcaption></figure><p>这里PRS选择comb4。一个时隙有14个OFDM符号，一个OFDM符号中的一个子载波组成，其被定义为资源元素（RE），一个物理资源块（PRB）中有12个资源元素。观察下图PRS映射的OFDM信号模型，横轴为1个时隙14个OFDM符号，纵轴为12个子载波</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241026210925946.png" alt="PRS映射OFDM信号模型"><figcaption aria-hidden="true">PRS映射OFDM信号模型</figcaption></figure><p>上图，由于PRS的comb是4，可以看到图中时间维有三个信号，频率维也是三个信号。一组PRS有12个符号，故4个时隙插入一个PRS。4个子载波插入PRS中的一个符号。</p><p>时域上占用M个OFDM信号，频域上占用N个子载波。并且承载PRS的子载波的数量是<span class="math inline">\(N_J(N/K^{PRS}_{comb})\)</span>，其中<span class="math inline">\(J\)</span>是承载PRS的子载波的集合（也就是上述第一列中的黄色方块）。</p><p>连续时域信号表达式为： <span class="math display">\[x(t)=\displaystyle\sum_{m=0}^{M-1}\displaystyle\sum_{k=0}^{N_J-1}s(k,m)×e^{j2\pif_kt}\text{rect}(\frac{t-mT_s}{T_s})\]</span> 其中<span class="math inline">\(s(k,m)\)</span>表示具有子载波索引k和OFDM符号索引m的调制PRS符号。<span class="math inline">\(T_s\)</span>是满足<span class="math inline">\(T_s=T+T_{CP}\)</span>的OFDM符号的总持续时间。<span class="math inline">\(f_k\)</span>是携带PRS符号的第k个子载波的频率。<span class="math inline">\(\text{rect}(t/T_s)\)</span>是矩形函数，当<span class="math inline">\(0\le t\le T_s\)</span>时为1，其他时刻为0。</p><blockquote><p>s(k,m)就相当于上图的每一个小黄方块，式子的目的就是把所有小黄方块加起来，先遍历每列，把每列中的有用点加起来。</p></blockquote><h3 id="接收端的雷达信号">1.2 接收端的雷达信号</h3><p>发送信号在时域上占用M个OFDM信号，频域上占用N个子载波。</p><p>雷达接受机接收到的回波信号（频域）如下，在下面第三节详细介绍该公式的推导：<span class="math display">\[S_{\text{Rx}}[m,k]=S_{\text{Tx}}[m,k]×e^{-j2\pi k\Deltaf\frac{2R_r}{c}}×e^{j2\pi mT_sf_{d,r}}\]</span> <span class="math inline">\(S_{\text{Tx}}[m,k]\)</span>表示发送信号的频域形式，具有子载波索引k和OFDM符号索引m。<span class="math inline">\(R_r\)</span>是目标的距离，<span class="math inline">\(f_{d,r}\)</span>是多普勒频移，c是光速。<span class="math inline">\(T_s\)</span>是OFDM符号的总持续时间。</p><p>将频域接收信号除以频域发送信号，获得信道频率响应（CFR），记为矩阵<span class="math inline">\((S_g)_{m,k}\)</span>，该矩阵(m,k)处的元素为：<span class="math display">\[(S_g)_{m,k}(m,k)=\frac{S_{\text{Rx}}[m,k]}{S_{\text{Tx}}[m,k]}=(\bar{k}_d*\bar{k}_r)\]</span> 其中其中<span class="math inline">\(\bar{k}_r=e^{-j2\pik\Delta f\frac{2R_r}{c}}\)</span>，<span class="math inline">\(\bar{k}_d=e^{j2\pi mT_sf_{d,r}}。\)</span></p><h2 id="雷达测速测距二维fft">2.雷达测速测距（二维fft)</h2><h3 id="距离估计">2.1 距离估计</h3><p>我们进行距离估计需要对CFR在频域进行N点IFFT。对矩阵<span class="math inline">\((S_g)_{m,k}\)</span>的第m行进行IFFT： <span class="math display">\[r(l)=\text{IFFT}(S_{g,m}(k))=\displaystyle\sum_{k=0}^{N-1}e^{-j2\pik\Delta f\frac{2R_r}{c}}×e^{j2\pi lk/N},l\in\{0,1,\cdots,N-1\}\]</span> <span class="math inline">\(l\)</span>是N点IFFT的第<span class="math inline">\(l\)</span>个结果的索引。当上式中的两个指数项彼此抵消时出现峰值。将第m行的峰值索引记为<span class="math inline">\(ind_{S_{g},m}\)</span>，故估计距离可以推导为：<span class="math display">\[\hat{R}_r=\frac{c\hat{l}}{2N\Delta f}=\frac{c·ind_{S_{g},m}}{2N\Deltaf},ind_{S_{g},m}\in\{0,1,\cdots,N-1\}\]</span> 距离分辨率<span class="math inline">\(\DeltaR\)</span>推导为： <span class="math display">\[\Delta R=\frac{c}{2N\Delta f}\]</span> 受<span class="math inline">\(ind_{S_{g,m}}\)</span>最大值的限制，最大无模糊距离<span class="math inline">\(R_{max}\)</span>可以表示为 <span class="math display">\[R_{max}=\frac{Nc}{2N\Delta f}=\frac{c}{2\Delta f}\]</span></p><blockquote><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241026145507385.png" alt="离散傅里叶变换"><figcaption aria-hidden="true">离散傅里叶变换</figcaption></figure></blockquote><h3 id="速度估计">2.2 速度估计</h3><p>我们进行速度估计需要对CFR在时域进行M点FFT。对矩阵<span class="math inline">\((S_g)_{m,k}\)</span>的第k列进行FFT： <span class="math display">\[v(d)=\text{FFT}(S_{g,k}(m))=\displaystyle\sum_{m=0}^{M-1}e^{j2\pimT_sf_{d,r}}×e^{-j2\pi dm/M},d\in\{0,1,\cdots,M-1\}\]</span>d是M点FFT的第d个结果的索引。当上式中的两个指数项彼此抵消时出现峰值。将第k列的峰值索引记为<span class="math inline">\(ind_{S_{g},k}\)</span>，则多普勒频移的估计为 <span class="math display">\[\hat{f}_{d,r}=\frac{ind_{S_{g},k}}{MT_s}\]</span> 根据速度与多普勒频移的关系 <span class="math display">\[v=\frac{c·ind_{S_{g},k}}{2MT_sf_c},ind_{S_{g},k}\in\{0,1,\cdots,M-1\}\]</span> 其中<span class="math inline">\(f_c\)</span>是发射信号的载波频率。可以得到速度分辨率<span class="math display">\[\Delta v=\frac{c}{2MT_sf_c}\]</span> 最大无模糊速度为 <span class="math display">\[v_{max}=\frac{Mc}{2MT_sf_c}=\frac{c}{2T_sf_c}\]</span></p><h2 id="基于ofdm的通感的波形设计与信号处理">3.基于OFDM的通感的波形设计与信号处理</h2><h3 id="ofdm波形设计">3.1 OFDM波形设计</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/v2-b034a1cf5d8e3dd1094a532d94419226_r.jpg"></p><p>OFDM多载波信号可以被视为具有正交载波波形的多个单载波信号的并行流，每个单载波信号用不同的发射数据调制。信号可以表示为：<span class="math display">\[x(t)=\displaystyle\sum_{\mu=0}^{N_{sym}-1}\displaystyle\sum_{n=0}^{N_{c}-1}a(\muN_c+n)\text{exp}(j2\pi f_nt)\text{rect}(\frac{t-\muT_{OFDM}}{T_{OFDM}})\qquad(1)\]</span> <span class="math inline">\(N_{sym}\)</span>是OFDM符号的总个数，<span class="math inline">\(N_c\)</span>是子载波的总个数；<span class="math inline">\(a\)</span>是复调制符号，<span class="math inline">\(f_n\)</span>是单独的子载波频率（<span class="math inline">\(n\Delta f\)</span>）；<span class="math inline">\(T_{OFDM}=T+T_G\)</span>是由基本符号持续时间<span class="math inline">\(T\)</span>和保护间隔持续时间<span class="math inline">\(T_G\)</span>组成的总OFDM符号持续时间。不同子载波和OFDM符号随时间对频谱的占用如下图所示：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241028112727716.png" alt="OFDM信号的时间和频率结构"><figcaption aria-hidden="true">OFDM信号的时间和频率结构</figcaption></figure><p>为了使各个子载波变得正交并且不干扰，以下条件必须成立： <span class="math display">\[f_n=n\Delta f=\frac{n}{T},n=0,\cdots,N_c-1\]</span> 即子载波间隔<span class="math inline">\(\Deltaf\)</span>和基本OFDM符号持续时间<span class="math inline">\(T\)</span>的关系需满足<span class="math inline">\(\Delta f=1/T\)</span>。</p><p>将上述<span class="math inline">\(x(t)\)</span>表示<span class="math inline">\(N_{sym}\)</span>个OFDM符号的集合，那发射端第m个OFDM符号的<strong>基带信号</strong>可以表示为：<span class="math display">\[x_m(t)=\displaystyle\sum_{n=0}^{N_{c}-1}a_m(n)\text{exp}(j2\pi n\Deltaft)\]</span> 其中<span class="math inline">\(a_m(n)\)</span>表示第m个OFDM符号中第n个子载波所传输的QAM符号。</p><p>我们看一下它在进行数模转换前的样子，即对x(t)进行采样，采样时间<span class="math inline">\(T_s=T/N\)</span>，第 m 个OFDM符号的第 l个采样点可以表示为： <span class="math display">\[x_m(l)=\displaystyle\sum_{n=0}^{N_{c}-1}a_m(n)\text{exp}(j2\pi n\DeltafnT_s)=\displaystyle\sum_{n=0}^{N_{c}-1}a_m(n)\text{exp}(j2\pi n\DeltaflT_s)=\displaystyle\sum_{n=0}^{N_{c}-1}a_m(n)\text{exp}(j2\pi nl/N)\]</span> 接收端的回波信号可以表示为： <span class="math display">\[y(t)=\displaystyle\sum_{i=0}^{K}\beta_ix(t-\tau_i)e^{j2\pi f_it}\]</span> 其中K待测目标的个数，<span class="math inline">\(\beta_i\)</span>是第i个目标回波的复幅度，<span class="math inline">\(\tau_i\)</span>和<span class="math inline">\(f_i\)</span>分别代表第i个目标回波的时延和多普勒频偏。</p><p>一个 OFDM符号周期内的相位旋转可以近似为常数，只考虑符号间的相位旋转，y(t)可以近似为： <span class="math display">\[y(t)=\displaystyle\sum_{i=0}^{K}\displaystyle\sum_{m=0}^{N_{sym}}\beta_ix_m(t-\tau_i)e^{j2\pim f_iT_{OFDM}}\]</span></p><h3 id="基于ofdm信号的雷达感知-调制符号域处理">3.2基于OFDM信号的雷达感知-调制符号域处理</h3><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241028113302012.png" alt="OFDM系统结构"><figcaption aria-hidden="true">OFDM系统结构</figcaption></figure><blockquote><p>具体来说，OFDM调制过程包括以下几个步骤：</p><ol type="1"><li>‌<strong>串并转换</strong>‌：将串行数据流转换为并行数据流，每个子信道分配一个数据流。</li><li>PSK调制</li><li>‌<strong>IFFT（Inverse Fast FourierTransform，快速傅里叶逆变换）</strong>‌：将并行数据流进行IFFT变换，从频域转换到时域。</li><li><strong>并串转换</strong>‌</li><li>‌<strong>D/A转换</strong>‌：将时域的数字信号转换为模拟信号，以便通过物理信道传输‌。</li></ol></blockquote><p>上图所示假定的OFDM系统结构的框图。</p><ol type="1"><li>二进制用户数据被划分为并行流（串并变换），并且被映射到复值PSK符号上，从而产生调制符号序列<span class="math inline">\(d_{Tx}(\mu,n)\)</span>。</li><li>经过快速傅里叶逆变换和随后的并串变换，然后经过D/A转换得到由正交载波波形<span class="math inline">\(f_n\)</span>组成的时域模拟信号(发送端的基带信号)<span class="math inline">\(x(t)\)</span>，如上一节所示。</li><li>接着经过信道，由目标物体反射后的得到<span class="math inline">\(y(t)\)</span>。</li><li>在接收机中，以相反的顺序执行相同的步骤，通过快速傅立叶变换操作从接收基带信号<span class="math inline">\(y(t)\)</span>恢复接收调制码元<span class="math inline">\(d_{Rx}(\mu,n)\)</span>。</li></ol><p>若(1)中所述的OFDM信号经由距离为<span class="math inline">\(R\)</span>、多普勒频偏为<span class="math inline">\(f_D\)</span>的物体反射后到达接收端，则接收信号y(t)为：<span class="math display">\[\begin{aligned}y(t)&amp;=\displaystyle\sum_{\mu=0}^{N_{sym}-1}\displaystyle\sum_{n=0}^{N_{c}-1}A(\mu,n)d_{Tx}(\muN_c+n)\\&amp;×\text{exp}(j2\pi f_n(t-\frac{2R}{c}))\text{exp}(j2\pif_Dt)\\&amp;\text{rect}(\frac{t-\muT_{OFDM}-\frac{2R}{c}}{T_{OFDM}})\end{aligned}\qquad(2)\]</span> 其中<span class="math inline">\(d_{Tx}(\mu,n)\)</span>是经过调制的用户数据符号。</p><p>为了使距离和多普勒影响的差异更清晰可见，上式可以重新写为： <span class="math display">\[\begin{aligned}y(t)&amp;=\displaystyle\sum_{\mu=0}^{N_{sym}-1}\text{exp}(j2\pif_Dt)\displaystyle\sum_{n=0}^{N_{c}-1}A(\mu,n)\\&amp;×[d_{Tx}(\muN_c+n)\text{exp}(-j2\pi f_n\frac{2R}{c})]\\&amp;×\text{exp}(j2\pif_nt)\text{rect}(\frac{t-\muT_{OFDM}-\frac{2R}{c}}{T_{OFDM}})\end{aligned}\qquad(3)\]</span>接收机通过仅在基本OFDM符号持续时间T观察接收信号来恢复与一个OFDM符号相关的各个调制符号。</p><p>在频域维度，对于固定的OFDM符号索引<span class="math inline">\(\mu\)</span>，在相同OFDM符号索引下，在每个时间采样点t时，多普勒频率在每个子载波上引起相同的相移<strong>。在时域维度，对于固定的子载波索引n，多普勒效应在该子载波上的连续调制符号之间引入线性相移，其对应于在总的OFDM符号持续时间期间多普勒频率的相位变化<span class="math inline">\(2\pif_DT_{OFDM}\)</span></strong>（两个相邻OFDM符号之间的线性相移）。</p><blockquote><p>可以看(3)式中多普勒频偏引起的相移式子中含有t，只在时域起作用。</p><p>同理，距离引起的相移式子中含有<span class="math inline">\(f_n\)</span>，只在频域起作用。下面会讲到。</p></blockquote><p>在时域维度，到反射物体的距离对相同子载波上的不同OFDM符号之间的相移是相同的。<strong>在频域维度，到反射物体的距离对相同OFDM符号上的连续子载波之间产生线性相移</strong>。</p><p>然而，最重要的观察是，反射物体引入的距离和多普勒对调制符号具有完全正交的影响（一个频域，一个时域）。虽然距离仅沿沿着频率轴引入线性相移，但多普勒也是如此，但仅沿沿着时间轴。只要观测持续时间足够短，反射物体保持在一个距离分辨率单元内，这种正交性就成立。</p><p>通过快速傅立叶变换操作从接收基带信号<span class="math inline">\(y(t)\)</span>恢复接收调制符号<span class="math inline">\(d_{Rx}(\mu,n)\)</span>。故接收调制符号<span class="math inline">\(d_{Rx}(\mu,n)\)</span>可以被量化为： <span class="math display">\[\begin{aligned}d_{Rx}(\mu N_c+n)&amp;=A(\mu,n)d_{Tx}(\muN_c+n)\text{exp}(-j2\pi n\Deltaf\frac{2R}{c})\\&amp;×\text{exp}(j2\pi\muT_{OFDM}\frac{2vf_c}{c})\end{aligned}\qquad(4)\]</span>为了得到更描述性的表示，调制符号帧现在被视为矩阵，其中每行表示一个OFDM符号，每列表示一个子载波，如下述式（5）所示。在（5）中，省略了下标。<span class="math display">\[\boldsymbol{D}=\begin{bmatrix}d(0) &amp; d(1) &amp; \cdots &amp; d(N_c-1)\\d(N_c) &amp; d(N_c+1) &amp; \cdots &amp; d(2N_c-1)\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\d((N_{sym}-1)N_c) &amp; d((N_{sym}-1)N_c+1) &amp; \cdots &amp;d(N_{sym}N_c-1)\end{bmatrix}\qquad(5)\]</span> 式(4)可以表示成如下形式 <span class="math display">\[(\boldsymbol{D_{Rx}})_{\mu,n}=A(\mu,n)(\boldsymbol{D_{Tx}})_{\mu,n}·[(\overrightarrow{k}_D)^T·\overrightarrow{k}_R]\qquad(6)\]</span> 其中 <span class="math display">\[\overrightarrow{k}_R=\Bigg(0,\text{exp}(-j2\pi \Deltaf\frac{2R}{c}),\cdots,\text{exp}(-j2\pi (N_c-1)\Deltaf\frac{2R}{c})\Bigg)\]</span></p><p><span class="math display">\[\overrightarrow{k}_D=\Bigg(0,\text{exp}(j2\piT_{OFDM}\frac{2vf_c}{c}),\cdots,\text{exp}(-j2\pi (N_{sym}-1)\Deltaf\frac{2R}{c})\Bigg)\]</span></p><blockquote><p>在我们的代码流程里直接在“PSK”和"IFFT"流程之间，加的目标物体的距离速度信息，将<span class="math inline">\(d_{Tx}(\mu,n)\)</span>变为<span class="math inline">\(d_{Rx}(\mu,n)\)</span>。再进行的IFFT、并串变换，加循环前缀、数模转换、模数转换、去除循环前缀、串并变换、FFT等一系列操作。</p></blockquote><h2 id="迭代2d-fft">4.迭代2D-FFT</h2><h3 id="基本原理-1">4.1 基本原理</h3><p>本部分提出了迭代2D FFT方法，减小了2DFFT方法带来的量化误差。算法如下图所示。信道信息矩阵通过发送符号矩阵与接收符号矩阵逐元素相除得到。然后，通过2DFFT得到第一个估计结果。如果感知精度不满足要求，则根据第一次估计结果对信道信息矩阵进行相位补偿。基于相位补偿后的信道信息矩阵得到第二次估计结果。上述过程迭代执行，直到感知精度满足要求。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20250209220423603.png" alt="迭代2D FFT方法" style="zoom: 67%;"></p><p>以距离估计为例。时延<span class="math inline">\(\tau\)</span>写为<span class="math inline">\(\tau=\displaystyle\sum_{ i = 1 }^{ X } \tau_{ i }\)</span>。其中<span class="math inline">\(\tau_i\)</span>为第i次迭代的估计时延，X为迭代次数。在初始时延估计的情况下，<span class="math inline">\(\tau_i\)</span>如下。 <span class="math display">\[\tau _ { i } =  \begin{cases} \frac { k _ { i } - 0 . 5 } { \Deltaf  N_c^i } , i &lt; X \\ \frac { k_i } { \Delta f  N _ c^i } , i = X\end{cases}\]</span> 其中，<span class="math inline">\(k_i\)</span>是在第i次迭代中得到的峰值索引。信道信息矩阵Y中的第m行写作式(1)。根据第一次迭代得到的<span class="math inline">\(\tau_1\)</span>，对Y中第m行向量的时延项进行相位补偿，得到<span class="math inline">\(k&#39;_{rm}\)</span>，如(2)式所示。对<span class="math inline">\(k&#39;_{rm}\)</span>的IDFT的峰值进行搜索，得到峰值指数来估计目标的距离。<span class="math display">\[k _ { r m } = \left[ 1 , e ^ { - j 2 \pi \Delta f \tau } , \ldots , e ^{ - j 2 \pi ( N _ { c } - 1 ) \Delta f \tau } \right] ^ { T } \qquad(1)\]</span></p><p><span class="math display">\[k _ { r m } ^ { \prime } = k _ { r m } \odot \left[ 1 , e ^ { j 2 \pi\Delta f \tau _ { 1 } } , \ldots , e ^ { j 2 \pi ( N _ { c } - 1 )\Delta f \tau _ { 1 } } \right] ^ { T }\qquad(2)\]</span></p><p><span class="math inline">\(k&#39;_{rm}\)</span>进行的IDFT，结果如下<span class="math display">\[\begin{aligned}r(k)&amp;=\frac{1}{N_c}\displaystyle\sum_{n=0}^{N_c-1}e^{-j2\pin\Delta f(\tau-\tau_1)}e^{j2\pin\frac{k}{N_c^2}}\\&amp;=\frac{1}{N_c}\displaystyle\sum_{n=0}^{N_c-1}e^{-j2\pin\Delta f\tau_2}e^{j2\pin\frac{k}{N_c^2}}\\&amp;=\frac{1}{N_c}\displaystyle\sum_{n=0}^{N_c-1}e^{j2\pin(\frac{k}{N_c^2}-\Delta f\tau_2)}\end{aligned}\qquad(3)\]</span> 其中<span class="math inline">\(k=0,1,...,N_c-1\)</span>，<span class="math inline">\(r(k)\)</span>为<span class="math inline">\(k&#39;_{rm}\)</span>的IDFT的第k个元素。当只有两次迭代时，我们有<span class="math inline">\(\tau-\tau_1=\tau_2\)</span>。当指数项相互抵消时出现峰值，峰值对应的索引为<span class="math inline">\(k_2\)</span>，得到<span class="math inline">\(\tau_2=\frac{k_2}{\Delta fN_c^2}\)</span>。经过两次迭代，得到目标的距离为： <span class="math display">\[R = \frac { c } { 2 } ( \tau _ { 1 } + \tau _ { 2 } ) = \frac { c } { 2\Delta f } \frac { k _ { 1 } - \frac { 1 } { 2 } + \frac { k _ { 2 } } {N _ { c } } } { N _ { c } }\qquad(4)\]</span> <img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20250210112134265.png" alt="距离估计的迭代"></p><p>通过X次迭代，提高了距离估计的精度。迭代过程如图3所示。与二维FFT方法的距离估计相比，X次迭代的距离估计精度为<span class="math display">\[\Delta R = \frac { c } { 2 \Delta f } \cdot \frac { 1 } {  N _ { c } ^ {X  } } \qquad(5)\]</span> 类似地，将上述迭代2DFFT方法应用于速度估计。经过两次迭代，多普勒频移为<span class="math inline">\(f_d = f_{d1} + f_{d2}\)</span>，其中<span class="math inline">\(f_{di}\)</span>为第i次迭代估计的多普勒频移。在第1次迭代估计速度时，将二维FFT方法得到的峰值指数记为<span class="math inline">\(l_1\)</span>，根据第1次迭代得到的峰值指数l1对信道信息矩阵Y的每个元素进行相位补偿。类似于(2 )，相位补偿后Y的第n列记为<span class="math inline">\(k&#39;_{vn}\)</span>。<span class="math inline">\(k&#39;_{vn}\)</span>的DFT计算如下。 <span class="math display">\[\begin{aligned}r(l)&amp;=\frac{1}{N_{sym}}\displaystyle\sum_{m=0}^{N_{sym}-1}e^{j2\pimT_{sym}(f_d-f_{d1})}e^{-j2\pim\frac{l}{N_{sym}^2}}\\&amp;=\frac{1}{N_{sym}}\displaystyle\sum_{m=0}^{N_{sym}-1}e^{j2\pim(T_{sym}f_{d2}-\frac{l}{N_{sym}^2})}\end{aligned}\qquad(6)\]</span> 其中<span class="math inline">\(l=0,1,...,N_{sym}-1\)</span>，<span class="math inline">\(r(l)\)</span>为<span class="math inline">\(k&#39;_{vn}\)</span>的DFT的第l个元素。搜索<span class="math inline">\(r(l)\)</span>的峰值，得到峰值索引<span class="math inline">\(l_2\)</span>。经过两次迭代得到的估计速度为 <span class="math display">\[V = \frac { c } { 2 f _ { c } T _ { s y m } } ( \frac { l _ { 1 } - 0 .5 + \frac { l _ { 2 } } { N_{sym} } } { N_{sym} } )\qquad(7)\]</span> 与二维FFT方法的速度估计相比，X迭代的速度估计精度得到了提高。<span class="math display">\[\Delta V = \frac { c } { 2 f _ { c } T _ { s y m } N_{sym}  ^ { X }}\qquad(8)\]</span></p><h3 id="单目标测试">4.2 单目标测试</h3><p>参数配置：</p><p>载频：4GHz</p><p>子载波间隔：30KHz</p><p>子载波数量：3276</p><p>OFDM符号数量：280</p><p>OFDM符号抽取间隔：7</p><p>T_OFDM：1/子载波间隔</p><p><strong>信噪比：-10dB</strong></p><p>待测目标速度：7 m/s</p><p>待测目标距离：20 m</p><h4 id="单组数据测试">4.2.1 单组数据测试</h4><p><strong>2D FFT测试结果</strong></p><p>速度分辨率：4.0179 m/s</p><p>距离分辨率：1.5263 m</p><p>测速结果：8.0357 m/s</p><p>测距结果：19.8413 m</p><p><strong>迭代2D FFT测试结果（2次迭代）</strong></p><p>速度分辨率：0.1004 m/s</p><p>距离分辨率：0.0005 m</p><p>测速结果：7.0312 m/s</p><p>测距结果：20.0034 m</p><p><strong>迭代2D FFT测试结果（3次迭代）</strong></p><blockquote><p>若距离维也进行第3次迭代，则数组会超过matlab预设的最大数组大小</p></blockquote><p>速度分辨率：0.0025 m/s</p><p>测速结果：7.0162 m/s</p><p>在高次迭代（三次及以上）时，信噪比对测速精度的影响：</p><p>低信噪比时，测速精度不如高信噪比</p><h4 id="用迭代2d-fft方法测试自己生成的100组数据">4.2.2 用迭代2DFFT方法测试自己生成的100组数据</h4><p><strong>2次迭代</strong></p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20250220110528424.png" alt="CDF图"><figcaption aria-hidden="true">CDF图</figcaption></figure><p><strong>3次迭代</strong></p><p>信噪比为-10dB</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20250220111703837.png"></p><h2 id="分数阶fft与cfar算法窗长选择的问题">5.分数阶FFT与CFAR算法窗长选择的问题</h2><h3 id="理论分析">5.1 理论分析</h3><p>根据上文，我们可以得到信道频域响应<span class="math inline">\(\bf{H}\)</span>的公式，其中<span class="math inline">\(L_p\)</span>为总的目标个数，<span class="math inline">\(p\)</span>为目标索引；<span class="math inline">\(n\)</span>为子载波索引，<span class="math inline">\(\Delta f_{scs}\)</span>为子载波间隔，<span class="math inline">\(\tau_p\)</span>为时延；<span class="math inline">\(f_{dp}\)</span>为多普勒频偏，<span class="math inline">\(m\)</span>为OFDM符号索引，<span class="math inline">\(T\)</span>为OFDM符号持续时间。 <span class="math display">\[\bf{H}=\displaystyle\sum_{p=1}^{L_p}e^{-j2\pi n\Deltaf_{scs}\tau_p}e^{j2\pi f_{dp}m T}\]</span> 对<span class="math inline">\(\bf{H}\)</span>在距离维进行IFFT，速度维进行FFT，结果如下。其中<span class="math inline">\(N\)</span>为子载波个数，<span class="math inline">\(M\)</span>为OFDM符号个数。<span class="math inline">\(q\)</span>和<span class="math inline">\(l\)</span>分别表示在RDM里速度和距离维度的索引值。<span class="math inline">\(T_s=1/(Nf_{scs})\)</span>表示采样时间间隔，<span class="math inline">\(F_s=1/(MT)\)</span>表示采样频率间隔。 <span class="math display">\[\begin{aligned}\mathbf{RDM}[q,l]&amp;=\text{FFT}(\text{IFFT}(\mathbf{H}))\\&amp;=\displaystyle\sum_{m=0}^{M-1}\frac{1}{N}\displaystyle\sum_{n=0}^{N-1}\displaystyle\sum_{p=1}^{L_p}e^{-j2\pin\Delta f_{scs}\tau_p}e^{j2\pi f_{dp}mT}e^{j\frac{2\pi}{N}nl}e^{-j\frac{2\pi}{M}mq}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}\displaystyle\sum_{n=0}^{N-1}e^{-j2\pin\Deltaf_{scs}\tau_p}e^{j\frac{2\pi}{N}nl}\displaystyle\sum_{m=0}^{M-1}e^{j2\pif_{dp}m T}e^{-j\frac{2\pi}{M}mq}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}\displaystyle\sum_{n=0}^{N-1}e^{-j2\pin(\Deltaf_{scs}\tau_p-\frac{l}{N})}\displaystyle\sum_{m=0}^{M-1}e^{j2\pim(f_{dp}T-\frac{q}{M})}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}\frac{1-e^{-j2\piN(\Delta f_{scs}\tau_p-\frac{l}{N})}}{1-e^{-j2\pi (\Deltaf_{scs}\tau_p-\frac{l}{N})}}\frac{1-e^{j2\piM(f_{dp}T-\frac{q}{M})}}{1-e^{j2\pi (f_{dp}T-\frac{q}{M})}}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}\frac{e^{-j\piN(f_{scs}\tau_p-\frac{l}{N})}(e^{j\pi N(\Deltaf_{scs}\tau_p-\frac{l}{N})}-e^{-j\pi N(\Deltaf_{scs}\tau_p-\frac{l}{N})})}{e^{-j\pi(f_{scs}\tau_p-\frac{l}{N})}(e^{j\pi (\Deltaf_{scs}\tau_p-\frac{l}{N})}-e^{-j\pi (\Deltaf_{scs}\tau_p-\frac{l}{N})})}\\&amp;×\frac{e^{j\pi M(f_{dp}T-\frac{q}{M})}(e^{-j\piM(f_{dp}T-\frac{q}{M})})-e^{j\pi M(f_{dp}T-\frac{q}{M})})}{e^{j\pi(f_{dp}T-\frac{q}{M})}(e^{-j\pi (f_{dp}T-\frac{q}{M})}-e^{j\pi(f_{dp}T-\frac{q}{M})})}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}e^{-j\pi (N\Deltaf_{scs}\tau_p-l)}e^{j\frac{\pi}{N}(N\Deltaf_{scs}\tau_p-l)}\frac{sin(\pi(N\Deltaf_{scs}\tau_p-l))}{sin(\frac{\pi}{N}(N\Delta f_{scs}\tau_p-l))}\\&amp;×e^{j\pi(Mf_{dp}T-q)}e^{-j\frac{\pi}{M}(Mf_{dp}T-q)}\frac{sin(\pi(Mf_{dp}T-q))}{sin(\frac{\pi}{M}(Mf_{dp}T-q))}\\&amp;=\frac{1}{N}\displaystyle\sum_{p=1}^{L_p}e^{-j\pi(\frac{\tau_p}{T_s}-l)}e^{j\frac{\pi}{N}(\frac{\tau_p}{T_s}-l)}\frac{sin(\pi(\frac{\tau_p}{T_s}-l))}{sin(\frac{\pi}{N}(\frac{\tau_p}{T_s}-l))}\\&amp;×e^{j\pi(Mf_{dp}T-q)}e^{-j\frac{\pi}{M}(\frac{f_{dp}}{F_s}-q)}\frac{sin(\pi(\frac{f_{dp}}{F_s}-q))}{sin(\frac{\pi}{M}(\frac{f_{dp}}{F_s}-q))}\end{aligned}\]</span></p><p>可以看到式中有两个类似sinc函数的式子，叫做Dirichlet核，其图像如下。所以当同时满足<span class="math inline">\(\frac{\tau_p}{T_s}-l=0,\frac{f_{dp}}{F_s}-q=0\)</span>时RDM会出现峰值。以第一个Dirichlet核为例，当<span class="math inline">\(\pi(\frac{\tau_p}{T_s}-l)\)</span>的值在0附近，也就是当<span class="math inline">\(\pi(\frac{\tau_p}{T_s}-l)\)</span>的值在0附近的一个周期内时，<span class="math inline">\(\frac{sin(\pi(\frac{\tau_p}{T_s}-l))}{sin(\frac{\pi}{N}(\frac{\tau_p}{T_s}-l))}\)</span>的值也很大，这会影响CFAR算法对目标的检测。好在变量<span class="math inline">\(l\)</span>为一个正整数，<span class="math inline">\(\pi(\frac{\tau_p}{T_s}-l)\)</span>的值不会落在0附近的一个周期之内，在峰值附近的两个点对应的Dirichlet核的值为<span class="math inline">\(\frac{sin(\pi)}{sin(\frac{\pi}{N})}=0\)</span>。但是进行分数阶FFT后情况会变得不一样。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293282668522.png" alt="狄利克雷核"><figcaption aria-hidden="true">狄利克雷核</figcaption></figure><p>若进行分数阶FFT，则是在算RDM谱时调高IFFT和FFT的点数，具体操作为<mark>通过用尾随零填充<span class="math inline">\(\mathbf{H}\)</span>以达到目标点数</mark>。我们设置距离维的分数阶系数为<span class="math inline">\(N_a\)</span>，对应到IFFT点数为<span class="math inline">\(N×N_a\)</span>；速度维的的分数阶系数为<span class="math inline">\(M_b\)</span>，对应到FFT点数为<span class="math inline">\(M×M_b\)</span>。具体计算如下： <span class="math display">\[\begin{aligned}\mathbf{RDM}[q,l]&amp;=\text{FFT}(\text{IFFT}(\mathbf{H}))\\&amp;=\displaystyle\sum_{m=0}^{M-1}\frac{1}{N×N_a}\displaystyle\sum_{n=0}^{N-1}\displaystyle\sum_{p=1}^{L_p}e^{-j2\pin\Delta f_{scs}\tau_p}e^{j2\pi f_{dp}mT}e^{j\frac{2\pi}{N×N_a}nl}e^{-j\frac{2\pi}{M×M_b}mq}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}\displaystyle\sum_{n=0}^{N-1}e^{-j2\pin\Deltaf_{scs}\tau_p}e^{j\frac{2\pi}{N×N_a}nl}\displaystyle\sum_{m=0}^{M-1}e^{j2\pif_{dp}m T}e^{-j\frac{2\pi}{M×M_b}mq}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}\displaystyle\sum_{n=0}^{N-1}e^{-j2\pin(\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})}\displaystyle\sum_{m=0}^{M-1}e^{j2\pim(f_{dp}T-\frac{q}{M×M_b})}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}\frac{1-e^{-j2\piN(\Delta f_{scs}\tau_p-\frac{l}{N×N_a})}}{1-e^{-j2\pi (\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})}}\frac{1-e^{j2\piM(f_{dp}T-\frac{q}{M×M_b})}}{1-e^{j2\pi (f_{dp}T-\frac{q}{M×M_b})}}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}\frac{e^{-j\piN(f_{scs}\tau_p-\frac{l}{N×N_a})}(e^{j\pi N(\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})}-e^{-j\pi N(\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})})}{e^{-j\pi(f_{scs}\tau_p-\frac{l}{N×N_a})}(e^{j\pi (\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})}-e^{-j\pi (\Deltaf_{scs}\tau_p-\frac{l}{N×N_a})})}\\&amp;×\frac{e^{j\pi M(f_{dp}T-\frac{q}{M×M_b})}(e^{-j\piM(f_{dp}T-\frac{q}{M×M_b})})-e^{j\piM(f_{dp}T-\frac{q}{M×M_b})})}{e^{j\pi(f_{dp}T-\frac{q}{M×M_b})}(e^{-j\pi (f_{dp}T-\frac{q}{M×M_b})}-e^{j\pi(f_{dp}T-\frac{q}{M×M_b})})}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}e^{-j\pi (N\Deltaf_{scs}\tau_p-\frac{l}{N_a})}e^{j\frac{\pi}{N}(N\Deltaf_{scs}\tau_p-\frac{l}{N_a})}\frac{sin(\pi(N\Deltaf_{scs}\tau_p-\frac{l}{N_a}))}{sin(\frac{\pi}{N}(N\Deltaf_{scs}\tau_p-\frac{l}{N_a}))}\\&amp;×e^{j\pi(Mf_{dp}T-\frac{q}{M_b})}e^{-j\frac{\pi}{M}(Mf_{dp}T-\frac{q}{M_b})}\frac{sin(\pi(Mf_{dp}T-\frac{q}{M_b}))}{sin(\frac{\pi}{M}(Mf_{dp}T-\frac{q}{M_b}))}\\&amp;=\frac{1}{N×N_a}\displaystyle\sum_{p=1}^{L_p}e^{-j\pi(\frac{\tau_p}{T_s}-\frac{l}{N_a})}e^{j\frac{\pi}{N}(\frac{\tau_p}{T_s}-\frac{l}{N_a})}\frac{sin(\pi(\frac{\tau_p}{T_s}-\frac{l}{N_a}))}{sin(\frac{\pi}{N}(\frac{\tau_p}{T_s}-\frac{l}{N_a}))}\\&amp;×e^{j\pi(Mf_{dp}T-\frac{q}{M_b})}e^{-j\frac{\pi}{M}(\frac{f_{dp}}{F_s}-\frac{q}{M_b})}\frac{sin(\pi(\frac{f_{dp}}{F_s}-\frac{q}{M_b}))}{sin(\frac{\pi}{M}(\frac{f_{dp}}{F_s}-\frac{q}{M_b}))}\end{aligned}\]</span></p><p>进行分数阶FFT后，Dirichlet核内的变量发生改变。以第一个Dirichlet核为例，设当<span class="math inline">\(q\)</span>取<span class="math inline">\(\hat{q}\)</span>时取到最大值，当<span class="math inline">\(q\)</span>的值在<span class="math inline">\((\hat{q}-M_b,\hat{q}+M_b)\)</span>内时，Dirichlet核的值也会很大，不可被忽略，这些点会影响CFAR算法对目标的检测。因为CFAR算法是对待测目标附近的参考单元进行计算来作为背景杂波估计（例如CA-CFAR是对参考单元取平均），当参考单元内的值很大以至于接近目标峰值时，就会导致最后计算出的门限值很高，导致目标检测无法被检测出来。所以对于进行分数阶FFT后的RDM，我们需要增加检测窗长和保护窗长，来减少和避免目标峰附近的点对目标检测造成的消极影响。（最极端的情况是将保护窗长设置为<span class="math inline">\(2M_b+1\)</span>）</p><h3 id="osca-cfar算法参数配置">5.2 OSCA-CFAR算法参数配置</h3><h4 id="n_am_b1">5.2.1 <span class="math inline">\(N_a=M_b=1\)</span></h4><p><strong>OSCA-CFAR参数配置：</strong></p><p>检测窗大小：13*13</p><p>保护窗大小：3*3</p><p>设置的虚警概率：1e-6</p><p>偏置设置：0.1* maxpeak</p><p>k：3/4</p><h4 id="n_a8m_b5124012.8">5.2.2 <span class="math inline">\(N_a=8,M_b=512/40=12.8\)</span></h4><p><strong>OSCA-CFAR参数配置：</strong></p><p>检测窗大小：33*33</p><p>保护窗大小：7*7</p><p>设置的虚警概率：1e-6</p><p>偏置设置：0.1* maxpeak</p><p>k：3/4</p><h1 id="五杂波环境中的综合传感与通信">五、杂波环境中的综合传感与通信</h1><p>本文提出了一种实用的综合传感与通信（ISAC）框架，用于从杂波环境中感知动态目标，同时确保用户的通信质量。为了同时实现通信功能和感知功能，我们设计了多个可与用户通信的通信波束和一个可旋转扫描整个空间的感知波束。为了最小化感知波束对现有通信系统的干扰，将服务区域划分为感知波束（S4S）扇区和通信波束（C4S）扇区，并针对每种扇区给出了波束赋形设计和功率分配优化策略，建立了一个同时包含静态环境和动态目标的混合感知信道模型，该方法首先滤除静态环境杂波的干扰，提取有效的动态目标回波，然后设计了一套完整实用的动态目标检测方案，用于检测动态目标的存在并利用角度多普勒谱估计（ADSE）和多个子载波联合检测（MSJD）实现了动态目标检测和角度估计，而距离和速度的估计则采用扩展子空间算法实现，仿真结果表明了该方法的有效性，并优于现有的忽略距离和速度估计的方法环境杂乱。</p><h2 id="引言">1.引言</h2><p>集成传感和通信（ISAC）最近在无线通信领域中吸引了显著的研究兴趣[1]-[3]。ISAC的概念是利用通信信号感知真实的物理世界中的各种信息，如建筑构成、人类活动等，同时保证用户的通信质量。由于ISAC允许感知系统和通信系统共享相同的硬件和频谱资源，并可以服务于各种智能应用，如车联网、数字孪生等，它被认为是第六代（6G）通信的关键技术之一[4]，[5]。</p><p>感知的最终功能是构建从真实的物理世界到数字孪生世界的映射关系，其中物理世界包括静态环境（如道路和建筑物）和动态目标（例如行人和车辆）。因此，ISAC系统的传感任务包括静态环境传感和动态目标传感如图1的左半部分所示。静态环境的变化通常是缓慢的，因此可以应用各种环境重建技术来感知静态环境[6]-[8]。然而，由于动态目标的变化是快速的，动态目标的检测和参数估计的实时更新是一个非常重要的问题，一般来说，动态目标检测问题可以分为两类：1）感知协作通信用户，如移动的手机;以及2）感测不与基站（BS）通信的非协作动态目标，例如移动物体或不处于通信状态的移动的用户。</p><p>此外，随着对传感需求的不断增长，研究人员致力于使ISAC系统具有超高的传感精度。令人鼓舞的是，由于其高方向性和高时间分辨率，具有大规模多输入多输出（MIMO）阵列的毫米波或太赫兹波段的传感可以实现更高的精度[9]，[10]。因此，基于大规模MIMO阵列的ISAC系统已经得到了广泛的研究。在协同用户感知方面，通过对通信信号进行处理，提取到达时间（TOA）、离开角（AOD）等信道参数，可以估计用户的位置[11]-[14]。另一方面，在ISAC框架下，对非合作目标的感知也进行了研究。例如，Z.Gao等人提出了一种依赖于MIMO阵列的ISAC系统，该系统应用压缩采样来促进目标感测和其他ISAC处理[15]。Z.Wang等人提出了一种同时发射和反射表面使能的ISAC框架，其中利用二维最大似然估计来估计目标角度[16]。Y.Li等人提出了一种两阶段算法，用于利用正交频分复用（OFDM）信号估计多个目标的位置和速度[17]。P.Kumari等人提出了一种用于车辆互联网的ISAC系统，该系统实现了车对车通信和全双工雷达感知[18]。X.Chen等人提出了一种基于多信号分类的ISAC系统，该系统可以获得动态目标感知的高估计精度[19]。然而，这些工作都忽略了静态环境杂波对动态目标感知的干扰，这与真实的场景不匹配，即目标总是被静态环境干扰淹没而难以与其分离，从而限制了真实的场景和实用ISAC系统的感知性能。</p><p>同时，对于基于MIMO阵列的ISAC系统，应该设计具有多个波束的波束成形以同时实现通信功能和感知功能[20]-[23]。阐述了多用户ISAC系统中的一个波束成形设计问题，旨在最大化感知方向上的功率，同时在通信方向上保持一定的功率[24]。H.Luo等人提出了一种将BS和可重构智能表面（RIS）相结合的ISAC系统，并联合优化波束形成矩阵，以最大化通信用户的可达和速率，同时满足感知波束约束[25].X.Wang等人研究了多用户ISAC系统的部分连接波束形成设计，旨在最小化DOA估计的Cramer-Rao界，同时确保通信性能[26]。然而，所有这些工作都需要复杂的优化过程，并且难以在实际系统中实现。</p><p>基于以上分析，现有的ISAC系统研究在波束形成设计上需要复杂的优化方案，在回波信号处理上忽略了环境杂波的严重干扰，难以在实际BS系统中部署和应用。本文提出了一种实用的ISAC框架，用于在保证用户通信质量的同时，从杂波环境中检测动态目标，论文总结如下：</p><ul><li>我们提出了一个实用的ISAC框架来同时实现通信和传感，其中我们设计了多个可以与用户通信的通信光束，同时分配一个可以旋转和扫描整个空间的传感光束。整个过程总结在图1的右半部分。</li><li>基站需要在每个时隙内优化发射波束赋形来传输信号，具体来说，为了最大限度地减少感知波束对现有通信系统的干扰，我们将基站的服务区域划分为用于感知的感知波束（S4S）扇区和用于感知的通信波束（C4S）扇区。为了避免实际系统中难以实现的复杂优化，我们将预编码优化问题转化为通信和传感波束的功率分配问题，并为每种类型的扇区提供有效的功率分配策略。</li><li>通过各种模拟，证明了所提方案的有效性，以及与忽略环境杂波的现有方法相比的优越性。</li></ul><p>本文的其余部分安排如下。在第二节中，我们提出了一个实用的 ISAC框架，可将传感功能有效集成到现有通信系统中。在第三节中，我们提供了一种低复杂度、实用的波束成形设计和功率分配策略。然后，我们在第四部分设计了一套完整实用的方案，用于从杂波环境中感知动态目标。第五节和第六节分别给出了仿真结果和结论。</p><h2 id="系统模型和isac框架">2.系统模型和ISAC框架</h2><p>在本节中，我们将提出一个实用的ISAC框架，有效地将传感功能集成到现有的通信系统中。</p><h3 id="基站模型">2.1 基站模型</h3><p>在图2中描绘了利用OFDM调制在毫米波或太赫兹频带中操作的基于大规模MIMO的ISAC系统，其采用同时用于无线通信和雷达感测的双功能基站。基站配置有两个平行且紧密放置的<span class="math inline">\(N_T\)</span>和<span class="math inline">\(N_R\)</span>个天线单元的均匀线性阵列（ULAs），分别作为发射阵列和接收阵列，其中天线间距为<span class="math inline">\(d\le\frac{\lambda}{2}\)</span>，<span class="math inline">\(\lambda\)</span>为波长。假设ULA平行于y轴，并且发射和接收ULA中的天线索引是<span class="math inline">\(0,\cdots,N_{T-1}\)</span>和<span class="math inline">\(0,\cdots,N_{R-1}\)</span>。假设通信系统使用总共M个子载波的窄带OFDM信号，并且最低频率和子载波间隔分别为<span class="math inline">\(f_0\)</span>和<span class="math inline">\(\Deltaf\)</span>。那么，传输带宽是<span class="math inline">\(W=(M-1)\Deltaf\)</span>，并且第m个子载波的频率是<span class="math inline">\(f_m=f_0+m\Delta f\)</span>，其中<span class="math inline">\(m=0,1,\cdots,M-1\)</span>。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240617172625168.png" alt="图2.系统模型"><figcaption aria-hidden="true">图2.系统模型</figcaption></figure><p>假设基站的服务区域为<span class="math inline">\(\{(r,\theta)|r_{min}\le r\ler_{max},\theta_{min}\le \theta\le \theta_{max}\}\)</span>，</p><h1 id="六单径测试加ici">六、单径测试加ICI</h1><p>当收发两端时钟不同步、且存在<strong>载波频率偏移（包括多普勒频移）</strong>时，接收信号的时域形式和频域形式将会产生较大的相位偏转，从而无法解调出正确的信号，严重时可能导致OFDM信号完全不可用。接收信号受到频偏和时偏的影响会产生相位偏转，还会产生一个冗余项，即频偏（目前我不太清楚时偏会不会产生ICI）造成的子载波间干扰（Inter-carrierInterference，ICI）。</p><p>我们这里不考虑时偏的影响，将时偏设置为0。总结上一段话可知，频偏对接受信号产生的影响=<strong>相位偏转</strong>+<strong>ICI</strong>。</p><p>频偏的产生方式目前我知道的有两种：①晶振频偏，这个值很小，通常取0.01；②由于速度产生的多普勒频偏。</p><p>在雷达测距中，距离会产生时延，从而导致相位偏转；速度会产生多普勒频偏，从而导致相位偏转。距离多普勒谱（Range-DopplerMap，RDM）就是据此画出来的。也就是说，RDM谱的绘制用到了多普勒频偏造成的相位偏转。</p><p>在通感测试代码中，我们利用了多普勒频偏产生的相位偏转，但是忽略了其产生的ICI。我们测试加入ICI对测试结果产生的影响，引入ICI这一项后，发现仅凭目标速度产生的多普勒频偏产生的ICI对RDM谱图造成的影响用肉眼难以观察到。如我们设置一个大一些的频偏，其不仅会导致ICI的出现，也会使接收信号产生相位偏转，从而必然使RDM谱图中的速度产生很大的偏移。</p><p>根据上述的内容，我目前有两个待尝试的方案：①加入一个归一化频偏，使它导致的相位偏转刚好让速度偏移一个分辨率格。这就要求我们根据速度分辨率算一下对应归一化频偏大小，但是那个频偏一定很小，其产生的ICI造成的影响（影响大概是令RDM谱图产生一些sinc杂峰）一定不太明显。</p><p>②增加最大无模糊速度，使速度等于最大无模糊速度时产生的ICI的效果足够明显。这要求我们在画RDM谱时，删除掉采样那一个步骤。</p><blockquote><p>根据文档《定位和通感相关的基础知识》有关OFDM信号加频偏的公式产生的思考：根据频域公式，加入频偏后，每个OFDM符号内的各个子载波上信号前是相同的<strong>幅度值</strong>(公式内没有子载波标号k)；而频偏其对OFDM符号间产生的线性相移我们已经利用（因为所加的频偏是速度产生的多普勒频偏），用来测试速度。故频偏产生的影响只有频域公式中的那个ICI，其对每个子载波产生的影响不一样，故会影响距离测试。经后面的仿真，发现一般速度产生的频偏所引起的ICI，对测试的影响都不明显。幅度值是一个小于1的数，只与归一化频偏有关，归一化频偏越大，该值越小，故可以观察到，增加归一化频偏，我们的RDM谱中的峰值都会统一降低。</p></blockquote><h2 id="方案一关于考虑频偏带来的相位偏转的影响">1.方案一：关于考虑频偏带来的相位偏转的影响</h2><h3 id="加入频偏考虑其产生的相位偏转">1.1加入频偏、考虑其产生的相位偏转</h3><p>速度分辨率：1.3120m/s</p><p>最大无模糊速度：52.4781m/s</p><p>归一化多普勒频偏计算公式： <span class="math display">\[f_d=\frac{2vf_c}{cf_{SCS}}\]</span> <span class="math inline">\(f_c\)</span>是信号中心频偏，<span class="math inline">\(f_{SCS}\)</span>是子载波间隔。</p><p>故将速度分辨率代入上式，就是我们将要增加的归一化频偏的大小。</p><p>我们的场景设置如下： <img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240908112719174.png"></p><p>作为对照的两组，一组是完全不考虑ICI影响的；一组是不仅考虑终端移动速度产生的多普勒频偏产生的ICI，还要另外添加一个归一化频偏，该频偏不仅也会产生ICI，还会导致接收信号产生一定的相位偏转，从而影响速度的测试结果。我们将另外添加的归一化频偏由一个速度分辨率大小折算出来，大小为0.0014。</p><p>RDM谱图结果对比如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240908121214713.png"></p><p>如图，频偏的添加导致测试速度都比真实速度偏了一个速度分辨率格的大小，但ICI造成的影响并不明显。此时，5个目标的归一化频偏从大到小依次为：0.0091、0.0069、0.0058、0.0047、0.0014。</p><p>为了更直观地看到ICI产生的影响，我们继续加大频偏。加入的归一化频偏由最大无模糊速度折算出来，大小为0.0571，其RDM谱如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E8%80%83%E8%99%91ICI%E5%B9%B6%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%9C%80%E5%A4%A7%E6%97%A0%E6%A8%A1%E7%B3%8A%E9%80%9F%E5%BA%A6%E7%9A%84%E9%A2%91%E5%81%8F_RDM-17257982097811.png"></p><p>当目标速度超过最大无模糊速度时，其峰值位置在RDM谱图上会开始循环，循环的周期为最大无模糊速度。加入的归一化频偏所导致的相位偏转相当于令目标速度偏了一个最大无模糊速度的大小。故上图与不另外加频偏得到RDM谱图的峰值位置是一样的。但ICI产生的影响依旧不明显。</p><p>于是我们考虑加入十倍最大无模糊速度折算出的归一化频偏，大小为0.5714，其RDM谱如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E8%80%83%E8%99%91ICI%E5%B9%B6%E5%8A%A0%E4%B8%80%E4%B8%AA10%E5%80%8D%E6%9C%80%E5%A4%A7%E6%97%A0%E6%A8%A1%E7%B3%8A%E9%80%9F%E5%BA%A6%E7%9A%84%E9%A2%91%E5%81%8F_RDM.png"></p><p>加入的归一化频偏所导致的相位偏转相当于令目标速度偏了十个最大无模糊速度的大小，故上述RDM谱图的峰值位置依然不变，由频偏所产生的ICI对RDM谱图产生了比较直观的影响，即导致RDM谱图产生一些sinc效应杂峰。</p><h3 id="逐渐加频偏不考虑引入的频偏造成的相位偏转">1.2逐渐加频偏、不考虑引入的频偏造成的相位偏转</h3><p>为了只关注ICI产生的影响，我们逐渐增加归一化频偏大小，不去考虑它产生的相位偏转，只考虑其产生的ICI影响，故测试到的速度不会有所变化。</p><p>产生ICI的归一化频偏分别设为0、0.2、0.4、0.6，得到它们的RDM谱图：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240909214610389.png"></p><p>当归一化频偏到达0.6时，由频偏所产生的ICI对RDM谱图产生了比较直观的影响，即导致RDM谱图产生一些sinc效应杂峰，但不会对检测结果产生影响。</p><p>我们继续增加归一化频偏大小，直到产生的ICI影响检测结果。发现当归一化频偏超过0.8时，其产生的ICI就会影响检测结果。我们给出当归一化频偏大小为0.85时的结果图：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240912105241610.png"></p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240912105309539.png"></p><p>可以看到，峰值搜索结果中发生了漏检，ICI造成的sinc效应杂峰太高已经影响到了检测结果。可以得出结论当归一化频偏超过0.8时，就无法忽略ICI的影响</p><h2 id="方案二设法增加最大无模糊速度">2.方案二：设法增加最大无模糊速度</h2><p>在我尝试删除采样这一步骤后，只是在数值上增加了最大无模糊速度，但实际的最大无模糊速度并未改变。</p><h1 id="七多目标近距离场景下不同检测算法的对比">七、多目标近距离场景下不同检测算法的对比</h1><p>在多目标近距离的场景下，性能：OSCA&gt;CA&gt;GO。</p><p>CA-CFAR算法将待检测单元周围的临近参考单元数据作平均处理，作为背景杂波功率估计以获得检测门限。CA-CFAR在目标数量较少时表现最佳。但在参考滑窗中还出现其它的目标时，CA-CFAR的检测阈值就会上升，CA-CFAR对主目标的检测性能会严重下降，这就是“目标遮蔽”效应。</p><p>GO-CFAR通过选择杂波功率较大的半窗参考单元取平均作为背景杂波估计。在近距离场景下，当多个目标彼此靠近时，GO-CFAR会倾向于选择靠近<strong>强目标</strong>一侧的半窗参考单元取平均作为背景杂波估计，这会导致<strong>门限过高</strong>，容易产生漏检，也更容易产生“目标遮蔽”效应。</p><p>OSCA-CFAR将参考单元内的数据排序处理，取排序后的第k个值作为背景杂波功率估计值来计算检测门限。这种方式使得OS-CFAR在多目标密集的环境中表现更佳，因为它可以避免多目标导致的检测阈值的上升，并可以有效忽略较强目标对杂波估计的干扰。</p><h2 id="同距近速">1.同距近速</h2><p>多目标同距近速场景设置如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914105818767.png"></p><p>速度分辨率：2.6239m/s</p><p>距离分辨率：1.2207m</p><p>其RDM谱平方律检波结果如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/RDM-17262831227411.png"></p><h3 id="go-cfar">1.1 GO-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914110814865.png"></p><p>可以看出结果不理想，原因分析：检测窗大小为9*9，此时RDM速度维分辨率为<span class="math inline">\(\Deltav=2.6239m/s\)</span>，60m同距的三个点，其速度差值均小于<span class="math inline">\(4\Deltav\)</span>，导致参考窗采样时会取到同距点的峰值区域，GO-CFAR取最大值的特性使得门限被抬高，使得同距的三个点都没被检测出来。</p><h3 id="ca-cfar">1.2 CA-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914112007039.png"></p><p>结合RDM图可以看出，在60m同距的三个点中，CA-CFAR检测出了峰值最高的那个点，性能要好于GO-CFAR。那是因为CA-CFAR取平均值的特性，相比于GO-CFAR取最大值，CA-CFAR的门限要低一些。但是多目标依然会抬高门限，导致60m另外两个点没有被检测到。</p><h3 id="osca-cfar">1.3 OSCA-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914112830776.png"></p><p>OSCA-CFAR将参考单元内的数据排序处理，取排序后的第k个值作为背景杂波功率估计值来计算检测门限。这种方式使得OS-CFAR在多目标密集的环境中表现更佳，因为它可以避免多目标导致的检测阈值的上升，并可以有效忽略较强目标对杂波估计的干扰。故5个目标均可被正确检出。</p><p>故可得出结论，在多目标同距近速的场景下，性能：OSCA&gt;CA&gt;GO。</p><h2 id="同速近距">2.同速近距</h2><p>多目标同速近距场景设置如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914142442058.png"></p><p>速度分辨率：2.6239m/s</p><p>距离分辨率：1.2207m</p><p>其RDM谱平方律检波结果如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E5%90%8C%E9%80%9F%E8%BF%91%E8%B7%9D_RDM.png"></p><h3 id="go-cfar-1">2.1 GO-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914143631431.png"></p><p>4m/s同速的三个点的距离差值均小于<span class="math inline">\(4\Deltad\)</span>，导致参考窗采样时会取到同速点的峰值区域，GO_CFAR取最大值的特性使得门限被抬高，使得同速的三个点都没被检测出来。</p><h3 id="ca-cfar-1">2.2 CA-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914143830369.png"></p><p>在CA-CFAR算法下，4m/s同速的三个点，其中在RDM谱中峰值最高的那个点被检出。</p><h3 id="osca-cfar-1">2.3 OSCA-CFAR</h3><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240914143953578.png"></p><p>可以看到，在多目标同速近距的场景下，性能：OSCA&gt;CA&gt;GO。</p><p>另外，我们又测试了多目标近距近速场景下不同检测方法的性能差异，结果与上述一致。故我们可得出结论，在多目标近距离场景下，不同检测方法的性能：OSCA&gt;CA&gt;GO。</p><h2 id="其它cfar检测算法">3.其它CFAR检测算法</h2><p>CA-CFAR检测在杂波边缘会引起虚警概率的上升，而在多目标环境中将导致检测概率下降。GO-CFAR和SO-CFAR是满足上述两种需求的修正方案。但是，它们各自只能解决其中的一个问题，并且带来了一定的检测损失。GO在杂波边缘环境中能较好的控制虚警概率，但会导致在多目标环境下检测性能下降；SO能在干扰目标位于前沿或后沿窗之一的多目标环境中分辨出主目标，但在杂波边缘和均匀杂波环境中检测性能差。OS算法在检测性能和算法运算量等方面介于上述三种检测方法之间，是一种折衷的选择。</p><p>WCA-CFAR不常用，其分别对前后窗按杂波强度加权得到杂波估计，需要干扰的先验信息。</p><h1 id="八基于lfmofdm的目标检测">八、基于LFM+OFDM的目标检测</h1><p>LFM与OFDM联合使用，采用TDM方式区分。前面1个符号承载LFM信号，后面1个符号承载OFDM信号，依次排列。</p><p>仿真在单径AWGN信道中进行，仿真参数如下：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240918211614585.png"></p><p>场景设置如下： <img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20240918213544107.png"></p><h2 id="ofdm目标检测部分">1.OFDM目标检测部分</h2><p>在频域添加时延和多普勒频偏，添加方式和之前在单径AWGN信道中基于OFDM的目标检测一样。</p><p>速度分辨率：3.2802m/s</p><p>距离分辨率：1.2207m</p><p>RDM谱：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/RDM-17266663807831.png"></p><p>CFAR门限图：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E9%97%A8%E9%99%90.png"></p><p>峰值搜索结果：</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E5%B3%B0%E5%80%BC%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C.png"></p><p>结论：OFDM目标检测部分正常。</p><h2 id="lfm目标检测部分">2.LFM目标检测部分</h2><h3 id="lfm信号测速测距原理实数信号表示形式">2.1LFM信号测速测距原理（实数信号表示形式）</h3><p>线性调频连续波（LFM），线性调频的含义即调制信号频率随时间线性变化。从时域上看，是一个频率随时间线性变化的波形；从频域上看，发射信号的频率与时间成正比，如下图所示，第一个图为时域，第二三个图为频域。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241009174529799.png" alt="LFM时域波形"><figcaption aria-hidden="true">LFM时域波形</figcaption></figure><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241009174420507.png" alt="LFM频域波形" style="zoom:50%;"></p><p>LFM时域信号（实数信号表示形式）如下 <span class="math display">\[s_t(t)=Acos[2\pi(f_0t+\mu t^2/2)+\phi_0],t\in[0,T]\]</span>其中，发射信号的扫频带宽为B，发射时宽为T。调频斜率为B/T，记为<span class="math inline">\(\mu\)</span>。脉冲重复周期为<span class="math inline">\(T_c\)</span>，即一个信号发射到下一个信号发射的时间差，是两个相邻信号的间隔时间。</p><blockquote><p>扫频带宽（Frequency SweepBandwidth）是指在频率扫描过程中，信号覆盖的频率范围。它通常表示从最低频率到最高频率的差值。</p><p>发射时宽（PulseWidth）指的是信号或脉冲在发射过程中持续时间的长度。</p></blockquote><p>假设，在电磁波的覆盖区域中，电磁波在空气中传输速度为c。某一目标在距离发射天线为R的位置，以径向v远离天线，以远离天线为正方向。则接受天线接受到的信号比发射的信号延迟<span class="math inline">\(\tau=\frac{2(R+vt)}{c}\)</span></p><p>则接收天线接收到目标的回波信号模型如下： <span class="math display">\[s_r(t)=Acos\{2\pi[f_0(t-\tau)+\mu (t-\tau)^2/2]+\phi_0\},t\in[0,T]\]</span> 将接收到回波信号<span class="math inline">\(s_r(t)\)</span>和发射信号<span class="math inline">\(s_t(t)\)</span>进行混频，并经过低通滤波器后就可以得到一个中频信号。用<span class="math inline">\(p(t)\)</span>来表示相位，则通过混频后得到中频信号的相位如下所示：</p><blockquote><p>混频器的主要作用是将接收信号（RX chirp）和发射信号（TXchirp）的频率和相位分别相减，产生中频信号（IFsignal）的频率和相位，从而得到中频信号。这个过程可以提取目标的距离和速度信息。</p></blockquote><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241006212007957.png"></p><p>对照LFM的时域公式，我们可以看出中频信号依然是一个线性调频信号，其调频斜率、载频、初相如下<span class="math display">\[\begin{array}{l}\mu_m=\frac{4\mu v}{c}-\frac{4\mu v^2}{c^2}\\f_m=\frac{2f_0v}{c}+\frac{2\mu R}{c}-\frac{4\muRv}{c^2}\\\phi_m=\frac{4\pi Rf_0}{c}-\frac{4\pi\mu R^2}{c^2}\end{array}\]</span> 因为光速c等于<span class="math inline">\(3×10^8m/s\)</span>，所以忽略c的平方项。<span class="math inline">\(\mu_m\)</span>也忽略。</p><blockquote><p><span class="math inline">\(\mu_m\)</span>忽略的原因：</p><p>中频信号的扫频带宽<span class="math inline">\(B_m=\mu_mT=\frac{4\muv}{c}T=\frac{4Bv}{c}\)</span></p><p>中频信号的时宽带宽积<span class="math inline">\(D_m=B_mT_c=\frac{4v}{c}D\)</span></p><p>其中B、D为发射信号的扫频带宽和时宽带宽积。</p><p>上述公式可以表明，即使目标在几百米每秒的高速运动情况下，中频信号的时宽带宽积仅有原来的<span class="math inline">\(10^{-6}\)</span>倍，在毫米波雷达发射极大的信号情况下(D的数量级为<span class="math inline">\(10^6\)</span>)，中频信号Dm的数量级也只有<span class="math inline">\(10^0\)</span>。</p></blockquote><p>因此可以认为中频信号为一单频信号（即只有载频和初相），故通过频谱分析（距离维FFT）即能得到其中心频率（即载频<span class="math inline">\(f_m\)</span>）的峰值和其对应的频点n。</p><blockquote><p>测距测速都是对中频信号进行操作。</p></blockquote><h4 id="测距">2.1.1 测距</h4><p>根据测得的中心信号的中心频率<span class="math inline">\(f_m\)</span>和频点n，我们便可以测距。忽略c的平方项后：<span class="math display">\[f_m=\frac{2f_0v}{c}+\frac{2\mu R}{c}\]</span> 忽略多普勒频偏对中频信号频率的影响，则 <span class="math display">\[\begin{array}{l}f_m=\frac{2\mu R}{c}=\frac{2BR}{cT}\\R=\frac{cTf_m}{2B}\end{array}\]</span> 假设单个扫描周期ADC采样点数为N，采样频率为Fs，式中n为FFT谱峰对应的频点，根据T、Fs、N之间的关系，距离与频率关系的公式可进一步化简为：</p><blockquote><p>ADC 是“模数转换器”（Analog-to-Digital Converter）的缩写。ADC负责将连续的模拟信号进行采样，以便进行后续的数字信号处理，包括进行距离维FFT和距离测量等。</p><p>采样周期<span class="math inline">\(T_s=\frac{T}{N},F_s=\frac{1}{T_s}\)</span>，<span class="math inline">\(f_m=\frac{F_s}{N}n\)</span></p></blockquote><p><span class="math display">\[R=\frac{cTf_m}{2B}=\frac{cT}{2B}\frac{F_s}{N}n=\frac{c}{2B}\frac{TF_s}{N}n=\DeltaR·1·n=\Delta R·n\]</span></p><blockquote><p>LFM进行目标检测的距离分辨率：<span class="math inline">\(\Deltad=\frac{c}{2B}\)</span>；速度分辨率：<span class="math inline">\(\Deltav=\frac{c}{2f_0T_cN}\)</span>。</p></blockquote><p>式中，c/2B为雷达的距离分辨率ΔR，可见中频信号的FFT谱峰对应的频点n，即目标距离门号，乘以距离分辨率就可得到目标的距离。在MATLAB中，对于距离维做FFT，目的就是找出中频频率峰值和频点，然后根据峰值所在的距离门号，解算出目标的距离。</p><blockquote><p>我们这里介绍测距的原理，就是为了找到距离分辨率的公式，因为我们已经知道进行matlab时距离分辨率乘以n就是目标距离。</p></blockquote><h4 id="测速">2.1.2 测速</h4><p>对于两个相邻周期的信号，由于周期间隔时间Tc较短，距离分辨率有限，两个周期内距离维FFT谱中的峰值位置几乎没有发生变化，但是由于相位比距离更加敏感，即周期间微小的距离变化会引起中频信号的初相的变化。</p><blockquote><p>不通过距离测速，而通过相位测速。</p></blockquote><p>忽略c的平方项后： <span class="math display">\[\phi_m=\frac{4\pi Rf_0}{c}\]</span> 计算相邻周期的相位差，即可得到目标的速度： <span class="math display">\[\begin{array}{l}\Delta\phi_m=\frac{4\pi f_0\Delta d}{c}=\frac{4\pi f_0vT_c}{c}\\v=\frac{c\Delta\phi_m}{4\pi f_0T_c}\end{array}\]</span>推广到多个脉冲，如128个，那么相位的变化是呈周期性的，速度维度做128点FFT后的峰值就是相位差，即获取速度对应的峰值和频点再通过解算便可获得目标的速度，这个过程就是速度维FFT。接下来进行速度解算。上述公式经过推导可以变为：<span class="math display">\[v=\frac{c\Delta\phi_m}{4\pi f_0T_c}=\frac{c}{4\pif_0T_c}\frac{2\pi}{N}n=\frac{c}{2f_0T_cN}n=\Delta v·n\]</span> 其中速度分辨率<span class="math inline">\(\Deltav=\frac{c}{2f_0T_cN}\)</span>。</p><h3 id="代码实现-1">2.2 代码实现</h3><p>这里用的LFM信号模型为复信号： <span class="math display">\[s_t(t)=Aexp[j2\pi(f_0t+\mu t^2/2)+\phi_0],t\in[0,T]\]</span></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%==========================================================================</span><br><span class="hljs-comment">%%   连续脉冲LFM雷达测距测速</span><br>clear;clc;close all;<br><span class="hljs-comment">%% LFM参数设置</span><br>fc = <span class="hljs-number">4e9</span>;               <span class="hljs-comment">%载波频率</span><br>PRF = <span class="hljs-number">2000</span>;               <span class="hljs-comment">%脉冲重复频率</span><br>Tr = <span class="hljs-number">1</span>/PRF;             <span class="hljs-comment">%脉冲重复周期</span><br>B = <span class="hljs-number">80e6</span>;               <span class="hljs-comment">%带宽</span><br>Fs = <span class="hljs-number">2.5</span>*B;             <span class="hljs-comment">%采样频率</span><br>Ts = <span class="hljs-number">1</span>/Fs;              <span class="hljs-comment">%采样时间</span><br>Tp = <span class="hljs-number">10e-6</span>;             <span class="hljs-comment">%脉宽(发射时宽）</span><br>c = <span class="hljs-number">3e8</span>;                <br>lamda = c/fc;           <span class="hljs-comment">%载波波长</span><br>Kr = B/Tp;               <span class="hljs-comment">%调频斜率</span><br>N_pulse = <span class="hljs-number">50</span>;           <span class="hljs-comment">%脉冲个数（个数不能太少）</span><br>t = <span class="hljs-number">0</span>:<span class="hljs-number">1</span>/Fs:Tp;        <span class="hljs-comment">%采样时间</span><br>N_samples = <span class="hljs-built_in">length</span>(t);   <span class="hljs-comment">%采样点个数</span><br>N_targets= <span class="hljs-number">5</span>;           <span class="hljs-comment">%目标物体个数</span><br>Rmax = c/<span class="hljs-number">2</span>*Tp;       <span class="hljs-comment">%最大检测距离（受到采样时间的限制，采样时间为16Tp）</span><br>Vmax = lamda*PRF/<span class="hljs-number">2</span>;     <span class="hljs-comment">%目标最大速度，最大测速范围满足在第一盲速之内</span><br>R_targets = [<span class="hljs-number">1000</span>,<span class="hljs-number">1200</span>,<span class="hljs-number">680</span>,<span class="hljs-number">860</span>,<span class="hljs-number">145</span>];<span class="hljs-comment">%物体的距离随机生成</span><br>RCS = <span class="hljs-number">10</span>*(<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span><span class="hljs-built_in">i</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,N_targets)));<span class="hljs-comment">%目标物体RCS，幅度为10，相位在（0,2pi）之间随机分布</span><br>V_targets = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">-6</span>,<span class="hljs-number">-22</span>,<span class="hljs-number">25</span>];<span class="hljs-comment">%目标物体速度</span><br><span class="hljs-comment">%% 接收矩阵sr计算</span><br>sr = <span class="hljs-built_in">zeros</span>(N_pulse,N_samples);<span class="hljs-comment">%sr的每一行表示一个回波信号所含的采样点，一共有50行不同回波信号构成</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:N_pulse<br>    delay = (<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*Tr;   <span class="hljs-comment">%发送第i个Chrip信号时相对初始时间的时延</span><br>    sr_row = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">% 内层for循环，一个目标一个目标来研究，对应每一个回波脉冲是由每一个目标回波之和组成</span><br>    <span class="hljs-keyword">for</span> k=<span class="hljs-number">1</span>:N_targets<br>        tao=<span class="hljs-number">2</span>*(R_targets(k)+V_targets(k).*(delay+t))/c;   <span class="hljs-comment">%在当前时刻，雷达信号往返的时间（目标物体在运动，距离在变化）</span><br>        sr_temp=RCS(k).*rectpuls(t-tao-Tp/<span class="hljs-number">2</span>,Tp).*<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span><span class="hljs-built_in">j</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*t<span class="hljs-number">-1</span><span class="hljs-built_in">j</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*tao+<span class="hljs-number">1</span><span class="hljs-built_in">j</span>*<span class="hljs-built_in">pi</span>*Kr.*(t-tao-Tp/<span class="hljs-number">2</span>).^<span class="hljs-number">2</span>);<br>        sr_row=sr_row+sr_temp;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 外层for循环，不同的脉冲，对应的delay是不同值，再代入来计算回波</span><br>    sr(<span class="hljs-built_in">i</span>,:)=sr_row;<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% R_range = c*t/2;    %在采样时间内，距离的范围</span><br>delta_d=c/<span class="hljs-number">2</span>/B;        <span class="hljs-comment">% 距离分辨率</span><br>Rmax/delta_d;<br>R_range = delta_d * ((<span class="hljs-number">1</span> : <span class="hljs-built_in">round</span>(Rmax/delta_d)) - <span class="hljs-number">1</span>);    <span class="hljs-comment">%距离轴</span><br><span class="hljs-comment">%% 脉冲压缩</span><br><span class="hljs-comment">% 参考信号st</span><br>st=rectpuls(t-Tp/<span class="hljs-number">2</span>,Tp).*<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span><span class="hljs-built_in">j</span>*<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>*fc*tao+<span class="hljs-number">1</span><span class="hljs-built_in">i</span>*<span class="hljs-built_in">pi</span>*Kr*(t-Tp/<span class="hljs-number">2</span>).^<span class="hljs-number">2</span>);<span class="hljs-comment">%时域参考信号（将原始信号右移Tp/2）</span><br><br><span class="hljs-comment">% stf=conj(fft(st));%匹配滤波器的频域特性</span><br><span class="hljs-comment">% for i=1:N_pulse</span><br><span class="hljs-comment">%     sr_mf(i,:)=ifft(fft(sr(i,:)).*stf);  %分别对每一行脉冲压缩 频域脉冲压缩(匹配滤波mf） ，混频     </span><br><span class="hljs-comment">% end</span><br><br><span class="hljs-comment">% 混频操作</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:N_pulse<br>    sr_mf(<span class="hljs-built_in">i</span>,:)=fft(st.*<span class="hljs-built_in">conj</span>(sr(<span class="hljs-built_in">i</span>,:)),N_samples,<span class="hljs-number">2</span>); <span class="hljs-comment">% 混频，之后进行距离维fft</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% 通过观察，得出经验性结论：只有时域混频接收信号作滤波器，然后分析频域是正确的</span><br><span class="hljs-comment">%% 图像输出</span><br><span class="hljs-comment">%----------------------------测距（Range FFT）------------------------------</span><br><span class="hljs-comment">% 第一个回波信号的距离幅度谱</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">2</span>);<br>sr_mf=sr_mf(<span class="hljs-number">1</span>:N_pulse,<span class="hljs-number">1</span>:<span class="hljs-built_in">round</span>(Rmax/delta_d));    <span class="hljs-comment">% 保留距离维的有用点</span><br><span class="hljs-built_in">plot</span>(R_range,<span class="hljs-built_in">abs</span>(sr_mf(<span class="hljs-number">1</span>,:)))                       <br>title(<span class="hljs-string">&#x27;第一个回波信号的距离幅度谱&#x27;</span>);<br><span class="hljs-comment">%----------------------------测速（Speed FFT）------------------------------</span><br>sr_speed=fft(sr_mf,N_pulse,<span class="hljs-number">1</span>);   <span class="hljs-comment">% 速度维fft</span><br>sr_speed=fftshift(sr_speed,<span class="hljs-number">1</span>);   <span class="hljs-comment">% 将频谱中心移到零，区分速度的正负</span><br>delta_v = lamda / (<span class="hljs-number">2</span> * Tr * N_pulse);<span class="hljs-comment">% 速度分辨率</span><br><span class="hljs-comment">% V=linspace(0,PRF,50)*lamda/2;     % 速度轴</span><br>V=delta_v * (-N_pulse / <span class="hljs-number">2</span>  : N_pulse / <span class="hljs-number">2</span><span class="hljs-number">-1</span>) ;<span class="hljs-comment">% 速度轴</span><br><br><span class="hljs-comment">% 尝试着画一下三维图</span><br><span class="hljs-built_in">figure</span>(<span class="hljs-number">4</span>)<br>mesh(R_range,V,<span class="hljs-built_in">abs</span>(sr_speed)/<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">abs</span>(sr_speed))));<br>xlabel(<span class="hljs-string">&#x27;距离/m&#x27;</span>); <br>ylabel(<span class="hljs-string">&#x27;速度/(m/s)&#x27;</span>);<br>zlabel(<span class="hljs-string">&#x27;幅度/db&#x27;</span>);<br>title(<span class="hljs-string">&#x27;目标距离速度信息一览&#x27;</span>);<br></code></pre></td></tr></table></figure><p>距离分辨率：1.8750m；速度分辨率：1.5000m/s</p><p>最大检测距离：1500m；最大检测速度：37.5m/s</p><p>待测目标距离和速度：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241009183843365.png" alt="待测目标距离速度信息"><figcaption aria-hidden="true">待测目标距离速度信息</figcaption></figure><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/untitled.png" alt="第一个回波信号的距离幅度谱"><figcaption aria-hidden="true">第一个回波信号的距离幅度谱</figcaption></figure><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/v.png" alt="速度距离fft结果"><figcaption aria-hidden="true">速度距离fft结果</figcaption></figure><h1 id="九自干扰信号的影响与消除">九、自干扰信号的影响与消除</h1><p>在实际通信场景的感知探测过程中，有两根天线分别作为收发端，<strong>由于收发端的相对距离较近</strong>，可能出现发射信号未经环境反射而直接泄露至接收端的现象。这一信号分量被称为自干扰（self-interference,SI）信号，而经过环境反射的信号则是有用信号。SI信号具有传输距离较短、功率较大的特点，会导致有用信号受到强烈干扰，从而影响ISAC 系统的整体感知性能。</p><p>传统 SIC 可划分为传播域消除、模拟域消除和数字域消除。传播域消除是通过环形器隔离、<strong>天线隔离</strong>等方法提高收发隔离度，使得SI信号在到达接收机时经历较大的衰减。模拟域方法则通过可调控的硬件电路在接收机射频前端重建模拟SI 信号的副本，并完成相应的消除过程。<strong>数字域方法</strong>则以发射机基带信号作为参考源，利用数字信号处理技术估计SI 信道参数，进而重建 SI 信号，然后通过从接收信号中减去估计的 SI信号，实现 SI 的消除。</p><p>然而，在传统通信系统中，由于器件性能和工程技术上的局限性，传播域消除和模拟域消除通常难以将SI 信号降至噪声水平。因此，还需要进一步对经过模数转换器后的SI信号进行数字域消除处理。数字域具有较强的信号处理能力，数字域 SI消除效果通常好于模拟域。因此，当前 ISAC研究亟需提出复杂度低、性能优良的<strong>数字域自干扰消除方案</strong>，以提升系统感知性能。</p><p>对于通信感知一体化系统中的自干扰，由于一体化接收机和一体化信号发射机之间的距离很近，为了简化分析，一体化系统的自干扰可以<strong>近似为静态零距离的强目标</strong>。</p><h2 id="自干扰信号的影响">1.自干扰信号的影响</h2><p>在感知接收端的接收目标回波可以表示为： <span class="math display">\[y_r(t)=\displaystyle\sum_{u=1}^{U}\eta_us_x(t-\tau_u)e^{j2\pif_ut}+\eta_0s_x(t)+w(t)\]</span> 其中<span class="math inline">\(s_x(t)\)</span>为发送信号；<span class="math inline">\(U\)</span>代表待测目标的个数，<span class="math inline">\(f_u\)</span>是第<span class="math inline">\(u\)</span>个目标的速度产生的多普勒频率，<span class="math inline">\(\tau_u\)</span>是第<span class="math inline">\(u\)</span>个目标的距离产生的时延；<span class="math inline">\(\eta_u\)</span>表示发射信号在检测第<span class="math inline">\(u\)</span>个目标时到达接收天线的路径损耗；<span class="math inline">\(\eta_0\)</span>表示发射天线到接收天线的路径损耗，也是自干扰信号的增益系数。</p><p>上式第一项为携带目标距离速度信息的反射信号，第二项为自干扰信号，第三项为噪声信号。</p><p>由于收发天线在信号传输过程中的位置固定，在进行仿真模拟的过程中<strong>可以将自干扰信号的复增益如式所示设为定值</strong>。根据天线方向图以及收发天线间距可以计算得到自干扰信号的增益取值。</p><blockquote><p>路径损耗计算公式： <span class="math display">\[PL(dB)=10\lg\frac{P_T}{P_R}=-10\lg[\frac{\lambda^2}{(4\pi)^2d^2}]\]</span> <span class="math inline">\(P_T\)</span>是发射信号功率，<span class="math inline">\(P_R\)</span>是接收信号功率。</p><p>算的是功率，要开方才是幅值的比例。</p></blockquote><p>基于LFM信号进行测试</p><p>待测目标信息：距离40m，速度20m/s</p><p>天线隔离度：70dB</p><p>收发天线间距：<span class="math inline">\(\frac{\lambda}{4}\)</span></p><p>根据待测目标的距离计算回波信号的路径损耗，记为PL1；根据收发天线的间距计算自干扰信号的路径损耗，记为PL2。通过计算相对路损得到增益系数的幅值为η=PL1/PL2。代入参数得到自干扰信号的增益系数的幅值为1.6528。</p><h3 id="增益系数的相位固定">1.1 增益系数的相位固定</h3><p>增益系数的相位取一个<strong>固定相位</strong>。在此情况下得到受到自干扰信号影响的RDM谱图：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0.png" alt="有自干扰信号的影响(固定相位)"><figcaption aria-hidden="true">有自干扰信号的影响(固定相位)</figcaption></figure><p>可以发现，在增益系数相位取固定相位时，在自干扰信号的影响下，RDM谱图中多出一个0速0距峰。</p><h3 id="增益系数的相位随机">1.2 增益系数的相位随机</h3><p><strong><u>增益系数的相位在不同时间采样点上随机</u></strong></p><blockquote><p>这种情况被认为不符合实际情况</p></blockquote><p>自干扰信号在<strong>不同时间采样点</strong>的增益系数的相位取[0,2π]内的随机值，在此情况下得到受到自干扰信号影响的RDM谱图：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E9%9A%8F%E6%9C%BA%E7%9B%B8%E4%BD%8D.png" alt="有自干扰信号的影响(随机相位)"><figcaption aria-hidden="true">有自干扰信号的影响(随机相位)</figcaption></figure><p>可以发现，当自干扰信号在不同时间采样点增益系数相位取随机值时，在零速上出现了许多不同距离值的杂峰，会被CFAR算法检测到。因为在不同时间采样点加入随机相位，相当于把自干扰信号的距离信息打乱。</p><p>进行自干扰消除后：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-172940836598313.png" alt="消除自干扰信号的影响(随机相位)"><figcaption aria-hidden="true">消除自干扰信号的影响(随机相位)</figcaption></figure><p>可见，该方法可以很好的消除自干扰信号的影响。</p><p><strong><u>增益系数的相位在不同符号上随机</u></strong></p><p>自干扰信号在<strong>不同符号</strong>的增益系数的相位取[0,2π]内的随机值，在此情况下得到受到自干扰信号影响的RDM谱图：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-172940739090311.png" alt="有自干扰信号的影响(随机相位)"><figcaption aria-hidden="true">有自干扰信号的影响(随机相位)</figcaption></figure><p>可以发现，当自干扰信号在不同符号增益系数相位取随机值时，在零距上出现了许多不同距离值的杂峰，会被CFAR算法检测到。因为在不同符号加入随机相位，相当于把自干扰信号的速度信息打乱。</p><p>进行自干扰消除后：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-172940775427312.png" alt="消除自干扰信号的影响(随机相位)"><figcaption aria-hidden="true">消除自干扰信号的影响(随机相位)</figcaption></figure><p>自干扰消除方案没能将零距上的杂峰消除掉，因为每个符号上对应的自干扰信号增益系数的相位不同，故其增益系数值不同。对所有符号取平均的平均信道响应并不能近似等于每个符号上自干扰信号的增益系数。</p><p><strong><u>增益系数的相位在不同时间采样点和不同符号上均随机</u></strong></p><p>自干扰信号在<strong>不同符号和不同时间采样点</strong>的增益系数的相位均取[0,2π]内的随机值，在此情况下得到受到自干扰信号影响的RDM谱图：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-172940848527214.png" alt="有自干扰信号的影响(随机相位)"><figcaption aria-hidden="true">有自干扰信号的影响(随机相位)</figcaption></figure><p>可以发现，图中观察不到自干扰信号。因为在不同符号和不同时间点均加入随机相位，相当于把自干扰信号的速度距离信息都打乱。</p><h2 id="消除自干扰信号">2.消除自干扰信号</h2><p>我们这里讨论的都是数字域自干扰消除方案。</p><h3 id="测试自干扰消除方法的可行性">2.1 测试自干扰消除方法的可行性</h3><p>简单理解如下：</p><p>将一体化感知接收端离散采样信号转换为频域信号可以表示为： <span class="math display">\[Y=H_0S_x+\sim\]</span> 其中<span class="math inline">\(H_0S_x\)</span>为自干扰的频域形式，<span class="math inline">\(H_0\)</span>为自干扰信号直接从发射端到接收端的信道频率响应，<span class="math inline">\(S_x\)</span>为发射信号的频域形式，“<span class="math inline">\(\sim\)</span>”表示携带目标距离速度信息的反射信号和噪声的频域形式。</p><p>我们令<span class="math inline">\(H=\frac{Y}{S_x}\)</span>，一共有N个发射信号，对这N个信号求出的<span class="math inline">\(H\)</span>取平均得到<span class="math inline">\(H&#39;\)</span>。N个<span class="math inline">\(H\)</span>中的目标反射信号和噪声取平均后近似为0，故<span class="math inline">\(H&#39;\)</span>便是<span class="math inline">\(H_0\)</span>的估计值，即自干扰信号前的增益系数。<span class="math display">\[Y&#39;=Y-H&#39;X\]</span> 所得<span class="math inline">\(Y&#39;\)</span>便是消除自干扰后的接收信号。</p><p>我们对上一节添加自干扰影响的信号进行自干扰消除：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E5%8E%BB%E9%99%A4%E8%87%AA%E5%B9%B2%E6%89%B0.png" alt="消除自干扰信号的影响"><figcaption aria-hidden="true">消除自干扰信号的影响</figcaption></figure><p>可见，该方法可以很好的消除自干扰信号的影响。</p><h3 id="测试在速度极小时自干扰消除方法的局限性">2.2测试在速度极小时自干扰消除方法的局限性</h3><p>详细理解如下：</p><p>接收信号的频域形式如下，我们的<strong>目标是求自干扰信号的增益系数<span class="math inline">\(H_p\)</span></strong> <span class="math display">\[Y_p=H_pS_p+S_p·k_r·k_d+W_p\qquad(1)\]</span> 其中<span class="math inline">\(p\)</span>代表第<span class="math inline">\(p\)</span>个符号，<span class="math inline">\(N_p\)</span>代表总符号数；<span class="math inline">\(S_p\)</span>为发射信号的频域形式；<span class="math inline">\(W_p\)</span>为噪声信号的频域形式；<span class="math inline">\(k_r\)</span>为待测目标的距离信息，<span class="math inline">\(k_d\)</span>为待测目标的速度信息。 <span class="math display">\[k_d=e^{j2\pi f_dpT},f_d=\frac{2vf_c}{c}\]</span> 其中<span class="math inline">\(T\)</span>为一个符号的时间，<span class="math inline">\(f_d\)</span>为多普勒频偏。</p><p>第<span class="math inline">\(p\)</span>个符号的传播信道的频率响应如下： <span class="math display">\[\tilde{H_p}=\frac{Y_p}{S_p}=H_p+k_r·e^{j2\pif_dpT}+\frac{W_p}{S_p}\qquad(2)\]</span> 对<span class="math inline">\(N_p\)</span>个符号的信道响应取平均，得到平均信道响应为：<span class="math display">\[\tilde{H}=\frac{1}{N_p}\displaystyle\sum_{p=0}^{N_p-1}(H_p+k_r·e^{j2\pif_dpT}+\frac{W_p}{S_p})\qquad(3)\]</span>其中由于噪声信号与发射信号互不相关的特性，使得噪声平均响应近似为零。</p><p>然后我们对目标反射信号的平均信道响应进一步变形：</p><p><span class="math display">\[\begin{aligned}\frac{1}{N_p}\displaystyle\sum_{p=0}^{N_p-1}k_r·e^{j2\pif_d pT}&amp;=\frac{1}{N_p}k_r\frac{1-e^{j2\pi f_dN_pT}}{1-e^{j2\pif_dT}}\\&amp;=k_r\frac{e^{j\pi f_dN_pT}(e^{-j\pi f_dN_pT}-e^{j\pif_dN_pT})}{N_pe^{j\pi f_dT}(e^{-j\pi f_dT}-e^{j\pif_dT})}\\&amp;=k_r·e^{j\pi f_d(N_p-1)T}·\frac{\sin\pif_dN_pT}{N_p\sin\pi f_dT}\end{aligned}\qquad(4)\]</span> 其中<span class="math inline">\(\frac{\sin\pif_dN_pT}{N_p\sin\pi f_dT}=\frac{\sin\pi N_pT·2vf_c/c}{N_p\sin\piT·2vf_c/c}\)</span>是狄利克雷核，其中的变量为<span class="math inline">\(f_d\)</span>中的速度<span class="math inline">\(v\)</span>。根据最大无模糊速度算出<span class="math inline">\(\frac{\piT·2vf_c}{c}\in[-\frac{\pi}{2},\frac{\pi}{2}]\)</span>，我们令其为<span class="math inline">\(x\)</span>。故我们可以将上式化为<span class="math inline">\(\frac{\sin nx}{n\sinx}\)</span>，我们画出该函数的图像如下，其中<span class="math inline">\(n=N_p=140\)</span>为总符号数。根据该函数的性质，随着<span class="math inline">\(v\)</span>增大，<span class="math inline">\(\frac{\sin\pi f_dN_pT}{\sin\pi f_dT}\approx0\)</span>。因此在取信道的平均响应时可以近似忽略目标反射信号的信道相应的影响，$H_p<span class="math inline">\(。此时：\)</span>$ Y_p-S_p= $$ <span class="math inline">\(\tilde{Y_p}\)</span>近似等于去除自干扰信号的频域响应。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293282668522.png" alt="狄利克雷核"><figcaption aria-hidden="true">狄利克雷核</figcaption></figure><p>但是，当待测目标的<span class="math inline">\(v\)</span>非常小接近0时，<span class="math inline">\(\frac{\sin\pi f_dN_pT}{\sin\pif_dT}\)</span>不可以近似等于零，目标反射信号的信道相应的影响便不可以被忽略，信道的平均响应<span class="math inline">\(\tilde{H}\)</span>就包含了目标反射信号的信道响应。此时$H_p≠<span class="math inline">\(，我们用\)</span><span class="math inline">\(消除自干扰信号，会将对速度极小的待测目标造成影响。此时\)</span>$Y_p-S_p=S_pk_r·(e<sup>{j2f_dpT}-e</sup>{jf_d(N_p-1)T}·)+ $$ 其中<span class="math inline">\(\frac{\sin\pi f_dN_pT}{\sin\pif_dT}\)</span>可以看作一个系数，速度越小，该系数越大，最大值为1。<span class="math inline">\(\tilde{W_p}\)</span>近似等于噪声信号的频域响应。上式括号中的两项的距离信息相同。上式括号中的第一项为待测目标峰，其速度位于<span class="math inline">\(v=0\)</span>与<span class="math inline">\(v=\Deltav\)</span>之间（<span class="math inline">\(\Deltav\)</span>是速度分辨率），由于速度很小接近0，故在RDM谱图中该峰位于<span class="math inline">\(v=0\)</span>处，但在<span class="math inline">\(\pm\Delta v\)</span>处的幅度不为0。</p><p>上式括号中的第二项中没有<span class="math inline">\(p\)</span>这个符号标号，相当于没有速度信息，也就是<span class="math inline">\(v=0\)</span>，故其产生的峰也在<span class="math inline">\(v=0\)</span>处，且在<span class="math inline">\(\pm\Deltav\)</span>处的幅度为0。两个峰位置相同，进行相减，<strong>便消除了v=0处的目标峰，留下了<span class="math inline">\(\pm\Deltav\)</span>处的两个残余峰</strong>。在多目标场景下，低速目标峰被消除，且在其它目标峰的对比之下，自干扰消除产生的<span class="math inline">\(\pm\Deltav\)</span>处的两个残余峰几乎看不见；在单目标场景下，低速目标峰被消除只剩下<span class="math inline">\(\pm\Deltav\)</span>处的两个残余峰。下面进行仿真验证。</p><h4 id="多目标场景">2.2.1 多目标场景</h4><p>基于LFM信号进行测试</p><p>待测目标信息：距离40m、20m；速度20m/s，0.1m/s</p><p>天线隔离度：70dB</p><p>收发天线间距：<span class="math inline">\(\frac{\lambda}{4}\)</span></p><p>增益系数的相位取固定相位</p><p>时域添加噪声：-10dB</p><p>加入自干扰影响：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/untitled-17292591612501.png" alt="受到自干扰影响的RDM谱"><figcaption aria-hidden="true">受到自干扰影响的RDM谱</figcaption></figure><p>注：受到速度分辨率的限制，在RDM谱图里，速度为0.1m/s的待测目标点所显示的速度为0。</p><p>用上述方法消除自干扰后的RDM谱：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/untitled-17292593353502.png" alt="消除自干扰后的RDM谱"><figcaption aria-hidden="true">消除自干扰后的RDM谱</figcaption></figure><p>可见，消除自干扰信号的同时，消掉了速度为0.1的目标峰。</p><blockquote><p>我们测试了不同速度下自干扰消除的情况，我们得出了自干扰消除不会消除目标峰的最小速度值，即<span class="math inline">\(v=1.5m/s\)</span>，当待测目标速度小于1.5m/s时，目标检测会发生错误</p></blockquote><h4 id="单目标测试-1">2.2.2 单目标测试</h4><p>基于LFM信号进行测试</p><p>待测目标信息：距离20m；速度0.1m/s</p><p>天线隔离度：70dB</p><p>收发天线间距：<span class="math inline">\(\frac{\lambda}{4}\)</span></p><p>增益系数的相位取固定相位</p><p>时域添加噪声：-10dB</p><p>加入自干扰影响：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293922875157.png" alt="受到自干扰影响的RDM谱"><figcaption aria-hidden="true">受到自干扰影响的RDM谱</figcaption></figure><p>消除自干扰后：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293924437418.png" alt="消除自干扰后的RDM谱"><figcaption aria-hidden="true">消除自干扰后的RDM谱</figcaption></figure><p>可见消除自干扰信号后，一同消去了低速目标峰，只留下了两个幅值非常低的残余峰。</p><p>随着<span class="math inline">\(v\)</span>在0到<span class="math inline">\(\Deltav\)</span>之间越来越大，两个残余峰的幅度都会变高，此时在多目标场景下，残余峰也可被检测出来。但比较两个峰的高低，上图左侧残余峰越来越高，右侧残余峰越来越低，<strong>在<span class="math inline">\(v&gt;1.5m/s\)</span>时右侧残余峰就足够低，以致可以被忽略</strong>。当<span class="math inline">\(0&lt;v&lt;\Deltav/2\)</span>时，目标峰应该位于<span class="math inline">\(v=0\)</span>处，当<span class="math inline">\(\Delta v/2&lt;v&lt;\Deltav\)</span>时，目标峰应位于<span class="math inline">\(v=\Deltav\)</span>处。故当<span class="math inline">\(v&gt;\Deltav\)</span>时，即可认为自干扰消除不会影响待测目标的检测结果。</p><p>若我们认为直到<span class="math inline">\(\frac{\sin\piN_pT·2vf_c/c}{N_p\sin\piT·2vf_c/c}\)</span>近似为零时，即信道的平均响应时可以近似忽略目标反射信号的信道相应的影响时，自干扰消除才不会影响待测目标的检测结果。那当<span class="math inline">\(v&gt;\Delta v\)</span>时，<span class="math inline">\(\frac{\sin\pi N_pT·2vf_c/c}{N_p\sin\piT·2vf_c/c}\)</span>便近似等于0，自干扰消除不会影响待测目标的检测结果。</p><p>当总符号数变化时，结论相同。故当总符号数减少时，速度分辨率升高，系统的最小可测速度下降。</p><h3 id="测试在符号数较少时自干扰消除方法的可行性">2.3测试在符号数较少时自干扰消除方法的可行性</h3><h4 id="改变总符号数">2.3.1 改变总符号数</h4><p>基于LFM信号进行测试</p><p>待测目标信息：距离20m；速度90m/s</p><p>天线隔离度：70dB</p><p>收发天线间距：<span class="math inline">\(\frac{\lambda}{4}\)</span></p><p>增益系数的相位取固定相位</p><p>时域添加噪声：-10dB</p><p>总符号数：<span class="math inline">\(N_p\)</span>=10</p><p>加入自干扰影响：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-172940518749810.png" alt="受到自干扰影响的RDM谱"><figcaption aria-hidden="true">受到自干扰影响的RDM谱</figcaption></figure><p>消除自干扰后：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17294050075009.png" alt="消除自干扰后的RDM谱"><figcaption aria-hidden="true">消除自干扰后的RDM谱</figcaption></figure><p>可见，即使在总符号数比较少的情况下，我们的自干扰消除方案依然能很好的起作用。</p><h4 id="仅改变取平均时的符号数">2.3.2 仅改变取平均时的符号数</h4><p>由于减小符号总数会导致速度分辨率的提升，当总符号数为10时，速度分辨率达到了91.8459m/s，无法对低速情况进行测试分析。于是我们的总符号数保持140不变，针对上一节的式（2），只对与当前符号相邻的10个符号取平均，3.2.2节中<span class="math inline">\(\frac{\sin nx}{n\sin x}\)</span>中的<span class="math inline">\(n\)</span>便取为10。我们画出<span class="math inline">\(n=10\)</span>时该函数的图像。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293292505953.png" alt="狄利克雷核(n=10)"><figcaption aria-hidden="true">狄利克雷核(n=10)</figcaption></figure><p>可以发现图像随着<span class="math inline">\(x\)</span>增大，函数值在0附近波动，当<span class="math inline">\(x\)</span>较小时，函数值会变大。对比n=140时的情况，可发现两个不同：</p><ol type="1"><li><strong>随着<span class="math inline">\(x\)</span>增大，函数值在0附近波动，但并不能近似为0</strong>。也就是说目标反射信号的信道相应不能被忽略，信道的平均响应<span class="math inline">\(\tilde{H}\)</span>就包含了目标反射信号的信道响应的一部分，在消除自干扰时会使待测目标峰变矮，但不会完全消除掉目标峰。也就是说，当速度较大时，消除自干扰后依然可以正确检测出目标。</li><li>根据3.2.2节所述，当<span class="math inline">\(v\)</span>较小接近于0时，函数值会变大，此时在消除自干扰时几乎会将待测目标峰完全消除。但<strong>n=10时主峰变宽</strong>，自干扰不会消除目标峰的最小速度变大了。也就是说，n=10时，引入消除自干扰步骤的LFM的可测速度范围变小了。</li></ol><p>基于LFM信号进行测试</p><p>待测目标信息：距离40m、20m；速度40m/s、1.5m/s;</p><p>天线隔离度：70dB</p><p>收发天线间距：<span class="math inline">\(\frac{\lambda}{4}\)</span></p><p>增益系数的相位取固定相位</p><p>加入自干扰影响：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293313863045.png" alt="受到自干扰影响的RDM谱"><figcaption aria-hidden="true">受到自干扰影响的RDM谱</figcaption></figure><p>消除自干扰后：</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B9%B2%E6%89%B0-17293314664296.png" alt="消除自干扰影响的RDM谱"><figcaption aria-hidden="true">消除自干扰影响的RDM谱</figcaption></figure><p>可见，消除自干扰信号的同时，消掉了速度为1.5的目标峰。</p><p>我们测试了不同速度下自干扰消除的情况，我们得出了自干扰消除不会消除目标峰的最小速度值，即<span class="math inline">\(v=2.2m/s\)</span>，当待测目标速度小于等于2.2m/s时，该待测目标峰会被自干扰消除步骤一并消掉。</p><h2 id="最小二乘法消除自干扰">3.最小二乘法消除自干扰</h2><p>自干扰信号的复幅度为<span class="math inline">\(\beta_0\)</span>；<span class="math inline">\(\text{z}\)</span>可以看作将接收信号的频域矩阵向量化后的结果；<span class="math inline">\(\text{a}_0\)</span>可以看作将发送信号的频域矩阵向量化后的结果。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241107111700835.png" style="zoom:150%;"></p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241107111737206.png" style="zoom:150%;"></p><blockquote><p>注：</p><ol type="1"><li><p>复值函数是指一个<strong>输出为复数的函数</strong>。它的输入可以是复数，也可以是实数或更高维的实数向量。上述<span class="math inline">\(J(\beta)\)</span>就是一复值函数。</p></li><li><p>如果<em>A</em>是一个 <em>m</em> x <em>n</em>的矩阵，而<em>B</em>是一个 <em>p</em> x <em>q</em>的矩阵，<strong>克罗内克积</strong>则是一个 <em>mp</em> x <em>nq</em>的矩阵</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/Center.jpeg" style="zoom: 50%;"></p></li><li><p>vec操作就是会将一个矩阵按照它的列进行向量化（因为习惯上使用列为主，而不是行为主）。</p></li></ol></blockquote><h1 id="十协作感知">十、协作感知</h1><p><a href="https://ieeexplore.ieee.org/document/10557715">CooperativeSensing for 6G Mobile Cellular Networks: Feasibility, Performance, andField Trial</a></p><h2 id="系统模型">1.系统模型</h2><p>协作感知系统，<span class="math inline">\(N_t\)</span>个基站作为发射机，<span class="math inline">\(N_r\)</span>个基站作为接收机，每个基站配备<span class="math inline">\(N\)</span>根天线。第<span class="math inline">\(n_t\)</span>个发射机的第<span class="math inline">\(n\)</span>个发射天线上的发射信号（时域）由下式给出<span class="math display">\[x_{n_t,n}(t)=s_{n_t,n}(n_c,n_s)e^{j2\pi f_\Deltan_ct}g(t-n_sT_s),n=1,2,\cdots,N,n_t=1,2,\cdots,N_t\qquad(1)\]</span> 其中<span class="math inline">\(s_{n_t,n}(n_c,n_s)\)</span>是第<span class="math inline">\(n_s\)</span>个OFDM符号（<span class="math inline">\(n_s=1,2,\cdots,N_s\)</span>）的第<span class="math inline">\(n_c\)</span>个子载波（<span class="math inline">\(n_c=1,2,\cdots,N_c\)</span>）上的数字调制符号（QAM符号），其中<span class="math inline">\(N_c\)</span>和<span class="math inline">\(N_s\)</span>分别是子载波和OFDM符号的总数。<span class="math inline">\(f_\Delta\)</span>和<span class="math inline">\(T_s\)</span>分别是子载波间隔和包括循环前缀的OFDM符号周期。<span class="math inline">\(g(t)\)</span>是脉冲整形函数。</p><p>在匹配滤波和快速傅里叶逆变换之后，在第<span class="math inline">\(n_r\)</span>个接收机（<span class="math inline">\(n_r=1,2,\cdots,N_r\)</span>）处接收的频域信号被写为<span class="math display">\[\textbf{y}_{n_r}(n_c,n_s)=\displaystyle\sum_{n_t=1}^{N_t}\textbf{H}_{n_r,n_t}(n_c,n_s)\textbf{s}_{n_t}(n_c,n_s)+\textbf{w}_{n_r}(n_c,n_s)+\textbf{i}_{n_r}(n_c,n_s)\qquad(2)\]</span> 其中<span class="math inline">\(\textbf{s}_{n_t}(n_c,n_s)=[s_{n_t,1}(n_c,n_s),\cdots,s_{n_t,N}(n_c,n_s)]^T\)</span>是第<span class="math inline">\(n_t\)</span>个发射机的频域符号矢量（也就是QAM符号），<span class="math inline">\(\textbf{y}_{n_r}(n_c,n_s)=[y_{n_r,1}(n_c,n_s),\cdots,y_{n_r,N}(n_c,n_s)]^T\)</span>是第<span class="math inline">\(n_r\)</span>个接收机的接收信号向量，<span class="math inline">\(y_{n_r,n}(n_c,n_s)\)</span>是第<span class="math inline">\(n\)</span>个接收天线处的第<span class="math inline">\(n_s\)</span>个OFDM符号的第<span class="math inline">\(n_c\)</span>个子载波上的接收信号。<span class="math inline">\(\textbf{w}_{n_r}\)</span>和<span class="math inline">\(\textbf{i}_{n_r}\)</span>分别是加性高斯白噪声和干扰信号。<span class="math inline">\(\textbf{H}_{n_r,n_t}(n_c,n_s)\)</span>（N×N矩阵）是第<span class="math inline">\(n_r\)</span>接收机和第<span class="math inline">\(n_t\)</span>个发射机相关联的频域信道，由下式给出<span class="math display">\[\textbf{H}_{n_r,n_t}(n_c,n_s)=\displaystyle\sum_{l=1}^{L_{n_t}}\beta_{n_r,n_t,l}e^{j2\piT_sf_{D,n_r,n_t,l}n_s}e^{-j2\pi\tau_{n_r,n_t,l}f_{\Delta}n_c}\textbf{a}_{n_r}(\Omega_{n_r,l})\textbf{a}^T_{n_t}(\Omega_{n_t,l})\qquad(3)\]</span> 其中<span class="math inline">\(L_{n_t}\)</span>是第<span class="math inline">\(n_t\)</span>个发射机覆盖的感知对象的数量。<span class="math inline">\(\tau_{n_r,n_t,l}=\frac{d_{n_r,n_t,l}}{c}\)</span>是时间延迟，其中<span class="math inline">\(d_{n_r,n_t,l}\)</span>和<span class="math inline">\(c\)</span>分别指信号传播距离和光速。具体地，信号传播距离<span class="math inline">\(d_{n_r,n_t,l}\)</span>被写为 <span class="math display">\[d_{n_r,n_t,l}=d_{n_t,l}+d_{n_r,l}\qquad(4)\]</span> 其中<span class="math inline">\(d_{n_t,l}\)</span>和<span class="math inline">\(d_{n_r,l}\)</span>分别是第<span class="math inline">\(n_t\)</span>个发射机到第<span class="math inline">\(l\)</span>个物体的信号传播距离和第<span class="math inline">\(l\)</span>个物体到第<span class="math inline">\(n_r\)</span>个接收机的信号传播距离。<span class="math inline">\(f_{D,n_r,n_t,l}=\frac{v_{||,n_r,n_t,l}f_c}{c}\)</span>是第<span class="math inline">\(l\)</span>个物体的多普勒频率，其中<span class="math inline">\(v_{||,n_r,n_t,l}\)</span>和<span class="math inline">\(f_c\)</span>分别表示投影速度和载波频率。投影速度由下式给出<span class="math display">\[v_{||,n_r,n_t,l}=\frac{\partial d_{n_r,n_t,l}}{\partialt}=v_{||,n_r,l}+v_{||,n_t,l}\qquad(5)\]</span> 其中<span class="math inline">\(v_{||,n_r,l}\)</span>和<span class="math inline">\(v_{||,n_t,l}\)</span>分别是第<span class="math inline">\(l\)</span>个物体相对于第<span class="math inline">\(n_r\)</span>个接收机和第<span class="math inline">\(n_t\)</span>个发射机的径向速度。<span class="math inline">\(\textbf{a}_{n_r}(\Omega_{n_r,l})\)</span>和<span class="math inline">\(\textbf{a}_{n_t}(\Omega_{n_t,l})\)</span>分别是第<span class="math inline">\(n_r\)</span>个接收机和第<span class="math inline">\(n_t\)</span>个发射机的转向矢量（N×1向量）。<span class="math inline">\(\Omega_{n_r,l}\)</span>和<span class="math inline">\(\Omega_{n_t,l}\)</span>分别是第<span class="math inline">\(l\)</span>条路径的AOA（到达角技术，标签到基站）和AOD（出发角技术，基站到标签）。<span class="math inline">\(\beta_{n_r,n_t,l}\)</span>是跨第<span class="math inline">\(l\)</span>个对象连接第<span class="math inline">\(n_r\)</span>个接收机和第<span class="math inline">\(n_t\)</span>个发射机的第<span class="math inline">\(l\)</span>条路径的信道增益，其可以被建模为 <span class="math display">\[\beta_{n_r,n_t,l}=\frac{\eta_{n_t,n_r}G_{T,n_t}G_{R,n_r}c^2}{(4\pi)^3d_{n_t,l}^2d_{n_r,l}^2f_c^2}\qquad(6)\]</span> 其中<span class="math inline">\(\eta_{n_t,n_r}\)</span>是感知目标的RCS，<span class="math inline">\(G_{T,n_t}\)</span>和<span class="math inline">\(G_{R,n_r}\)</span>分别是发射机和接收机的天线增益。可以观察到，双基地RCS<span class="math inline">\(\eta\)</span>是感知的关键，因为接收信号功率与<span class="math inline">\(\eta\)</span>成正比。因此在下一节中我们通过提供双基地RCS的仿真来证明合作传感系统的可行性。</p><h2 id="协作感知">2.协作感知</h2><p>在本节中，我们提出了一种有效的方法来估计协作传感系统中物体的位置和速度。</p><h3 id="信道参数估计">2.1 信道参数估计</h3><p>每个接收器获得的频域符号由来自多个发射器的符号组成。因此，我们首先通过区分不同发射机的发射符号来提取频域通道矩阵。将（2）重写为<span class="math display">\[y _ { n _ { r } } ( n _ { c } , n _ { s } ) = \textbf{H} _ { n _ { r } }\textbf{s} + \textbf{w} _ { n _ { r } } ( n _ { c } , n _ { s } ) +\textbf{i} _ { n _ { r } } ( n _ { c } , n _ { s } ) \qquad( 7 )\]</span> 其中<span class="math inline">\(\textbf{s} = [ \textbf{s} _ {1 } ^ { T } , \textbf{s} _ { 2 } ^ { T } , \cdots , \textbf{s} _ { N _ {t } } ^ { T } ] ^ { T } \in \mathbb{C} ^ { N N _ { t } \times 1}\)</span>并且<span class="math inline">\(\textbf{H} _ { n _ { r } } =\left[ \textbf{H} _ { n_r  , 1} , \textbf{H} _ { n_r , 2 } , \cdots ,\textbf{H} _ { n_r , N _ { t } } \right] \in \mathbb{C} ^ { N \times N N_ { t }}\)</span>。通过为不同的发射机设置相互正交的参考信号，并假设<span class="math inline">\(\textbf{H} _ { n _ { r } }\)</span>在<span class="math inline">\(N N _ { t}\)</span>个符号周期内保持不变，我们可以将系统模型以矩阵形式写为 <span class="math display">\[\textbf{Y} _ { n _ { r } } = \textbf{H} _ { n _ { r } } \textbf{S} +\textbf{W} _ { n _ { r } } + \textbf{I} _ { n _ { r } } \qquad( 8 )\]</span></p><h1 id="十一微多普勒">十一、微多普勒</h1><h2 id="旋翼无人机回波建模">1.旋翼无人机回波建模</h2><h3 id="单旋翼叶片单散射点回波模型">1.1 单旋翼叶片单散射点回波模型</h3><p>对于旋翼无人机，它的机械结构可简化成无人机主体和各个旋翼，每个旋翼由若干个旋翼叶片组成，旋翼叶片结构示意图如下图所示。</p><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241120204713741.png" alt="旋翼叶片示意图"><figcaption aria-hidden="true">旋翼叶片示意图</figcaption></figure><p>首先考虑旋翼上单个散射点的回波模型。当俯仰角为 0时,考虑叶片上的一个散射点 P，该点的坐标位置为<span class="math inline">\((x_0,y_0)\)</span>，散射点 P到固定在机体的坐标原点，距离为 <span class="math display">\[l _ { p } = \sqrt { x _ { 0 } ^ { 2 } + y _ { 0 } ^ { 2 } } \qquad(1)\]</span> 旋翼叶片转速为，则经过时间 t 后，散射点 P 的坐标位置为<span class="math inline">\((x_t,y_t)\)</span>。初始旋转角为<span class="math inline">\(\varphi_0\)</span>，时间 t 后， <span class="math display">\[\varphi _ { t } = \varphi _ { 0 } + \Omega t \qquad(2)\]</span> 若旋翼沿雷达径向的速度为 v，时间 t后，得到从雷达到该散射点的距离为 <span class="math display">\[R _ { p } ( t ) = \sqrt { R _ { 0 } ^ { 2 } + l _ { p } ^ { 2 } + ( v t) ^ { 2 } + 2 l _ { p } R _ { 0 } \cos ( \varphi _ { 0 } + \Omega t ) +2 R _ { 0 } v t + 2 v t l _ { p } \cos ( \varphi _ { 0 } + \Omega t )}\qquad(3)\]</span> 其中<span class="math inline">\(R_0\)</span>是雷达到旋翼中心<span class="math inline">\(O\)</span>的距离。假设在远场<span class="math inline">\(( \frac { l _ { p } } { R _ { 0 } } ) ^ { 2 }\rightarrow 0\)</span>，上式可写为 <span class="math display">\[R _ { p } ( t ) \cong R _ { 0 } + v t + l _ { p } \cos ( \varphi _ { 0 }+ \Omega t )\qquad(4)\]</span> 雷达从散射点 P 接收到的信号为 <span class="math display">\[s _ { R } ( t ) = \text{exp} \left\{ - j \left[ 2 \pi f _ { 0 } t +\frac { 2 \pi } { \lambda }× 2R _ { p } ( t ) \right] \right\}=\text{exp} \left\{ - j \left[ 2 \pi f _ { 0 } t + \Phi _ { p } ( t )\right] \right\}\qquad(5)\]</span> <strong>若仰角 β、转子叶片高度不为0</strong>，雷达无人机相对位置示意图如下图所示，假设无人机相对于雷达以径向速度v 飞行，则 t 时刻无人机旋翼中心与雷达中心的距离为<span class="math inline">\(R_t=R_0+vt\)</span>，散射点 P此时的旋转相位为<span class="math inline">\(\varphi_t=\Omega t + \varphi_ { 0 }\)</span>，则在全局雷达坐标系<span class="math inline">\((X,Y,Z)\)</span>中， t 时刻旋翼中心 o的坐标为<span class="math inline">\(( R _ { t } \cos \beta \cos \alpha,R _ { t } \cos \beta \sin \alpha,R _ { t }\sin\beta)\)</span>，在目标坐标系<span class="math inline">\((x,y,z)\)</span>中，散射点 P 的坐标为<span class="math inline">\((l \cos \varphi _ { t } ,l \sin \varphi _ { t},0)\)</span>。假设目标在远场因此，在t时刻，从雷达到散射点P的距离为<span class="math display">\[\begin{aligned}R _ { p } ( t ) &amp;= || \overrightarrow { O P } || \\&amp;= | | \overrightarrow { O o } + \overrightarrow { o P } | |\\&amp; = \sqrt { ( R _ { t } \cos \beta \cos \alpha + l_p \cos \varphi _{ t } ) ^ { 2 } + ( R _ { t } \cos \beta \sin \alpha + l_p  \sin \varphi_ { t } ) ^ { 2 } + ( R _ { t } \sin \beta ) ^ { 2 } }\\&amp; = \sqrt { R _ { t } ^ { 2 } + l_p  ^ { 2 } + 2 R _ { t } l_p  \cos\beta \cos ( \varphi _ { t } - \alpha ) }\\&amp;\cong R _ { t } + l_p  \cos \beta \cos ( \varphi _ { t } - \alpha)\\&amp; = R _ { 0 } + v t + l_p  \cos \beta \cos (\Omega t + \varphi _ { 0} - a )\end{aligned}\]</span> 相位函数为 <span class="math display">\[\Phi _ { p } ( t ) = \frac { 4 \pi } { \lambda } \left[ R _ { 0 } + v t+ \cos \beta  l _ { p }\cos ( \varphi _ { 0 } + \Omega t-\alpha )\right]\qquad(6)\]</span> <img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241127183956364.png" alt="雷达与单旋翼无人机的运动关系示意图"></p><p>则 <span class="math display">\[s _ { R } ( t ) = \text{exp} \left\{ - j \frac { 4 \pi } { \lambda }\left[ R _ { 0 } + v t  \right] \right\} \text{exp} \left\{ - j 2 \pi f_ { 0 } t - \frac { 4 \pi } { \lambda } l _ { p } \cos \beta \cos (\Omega t + \varphi _ { 0 } -\alpha) \right\}\qquad(7)\]</span> 对接收信号进行解调到基带，则散射体 P 返回的基带信号为 <span class="math display">\[s _ { B } ( t ) = \text{exp} \left\{ - j \frac { 4 \pi } { \lambda }\left[ R _ { 0 } + v t \right] \right\} \text{exp} \left\{ - j \frac { 4\pi } { \lambda } l _ { p } \cos \beta \cos ( \Omega t + \varphi _ { 0}-\alpha ) \right\}\qquad(8)\]</span></p><h3 id="单旋翼叶片整体模型">1.2 单旋翼叶片整体模型</h3><p>上节对旋翼的一个单散射点进行了回波建模，先对旋翼叶片整体进行建模。桨叶叶片的长度为<span class="math inline">\(L=L_2-L_1\)</span>，<span class="math inline">\(L_2\)</span>和<span class="math inline">\(L_1\)</span>分别为旋翼中心到桨叶叶尖与桨叶根部的距离。则通过式(8)对叶片长度<span class="math inline">\(l_p\)</span>积分，得到叶片整体总基带信号为 <span class="math display">\[\begin{aligned}s _ { L } ( t ) &amp;= \sigma \text{exp} \left\{ - j \frac { 4 \pi } {\lambda } \left[ R _ { 0 } + v t +  \right] \right\} \int _ { L_1 } ^ {L_2 } \text{exp} \left\{ - j \frac { 4 \pi } { \lambda } l _ { p}\cos\beta \cos ( \Omega t + \varphi _ { 0 }-\alpha ) \right\} d l _ { p}\\&amp; = \sigma (L_2-L_1) \text{exp} \left\{ - j \frac { 4 \pi } {\lambda } \left[ R _ { 0 } + v t  \right] \right\} \text{exp} \left\{ -j \frac { 4 \pi } { \lambda } \frac { L_2+L_1 } { 2 } \cos \beta \cos (\Omega t + \varphi _ { 0 }-\alpha ) \right\}\\&amp; \cdot \sin c \frac { 4 \pi } { \lambda } \frac { L_2-L_1} { 2 }\cos \beta \cos ( \Omega t + \varphi _ { 0 } -\alpha)\end{aligned}\qquad(9)\]</span> 其中<span class="math inline">\(\sigma\)</span>为叶片的RCS，<span class="math inline">\(L\)</span>是叶片的总长度。</p><p>对于有 N 个叶片的转子，N 个叶片有 N 个不同的初始转角 <span class="math display">\[\varphi _ { k } = \varphi _ { 0 } + k \frac { 2 \pi } { N } , k = 0 , 1, . . . , N - 1\qquad(10)\]</span> 结合式(9)可以得到<strong>单旋翼无人机的回波模型</strong>为：<span class="math display">\[\begin{aligned}s _ { N } ( t ) &amp;= \sigma (L _ { 2 } - L _ { 1 } ) \text{exp}\left\{ - j \frac { 4 \pi } { \lambda } [ R _ { 0 } + v t ] \right\}\times \\ &amp;\sum _ { n = 0 } ^ { N - 1 } \sin c \left\{ \left[ \frac{ 4 \pi }{\lambda}\frac{( L _ { 2 } - L _ { 1 } ) } { 2} \cos\beta  \cos ( \Omega t + \varphi _ { 0 } + \frac { 2 \pi n } { N } -\alpha ) \right] \right\} \text{exp} \{ - j \Phi _ { n } ( t ) \}\end{aligned}\qquad(11)\]</span></p><h3 id="多旋翼无人机回波模型">1.3 多旋翼无人机回波模型</h3><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241127183924982.png" alt="雷达与多旋翼无人机的运动关系示意图"><figcaption aria-hidden="true">雷达与多旋翼无人机的运动关系示意图</figcaption></figure><p>在此模型中假定无人机具有M个旋翼，每个旋翼具有N个叶片。一个旋翼的回波模型可以表示为每个叶片回波的线性叠加，多旋翼无人机回波模型可以表示为每个单旋翼回波的线性叠加：<span class="math display">\[\begin{aligned}s _ { \sum } ( t ) &amp;= \sum _ { m = 1 } ^ { M } \sigma(L_2-L_1)  \text{exp} \left\{ - j \frac { 4 \pi } { \lambda } \left[ R _{  m } +vt \right] \right\} \times\\&amp;\sum _ { n = 0 } ^ { N - 1 } \sin c \left\{ \left[ \frac { 4 \pi }{ \lambda } \frac { (L_2-L_1)  } { 2 } \cos \beta _ { m } \cos ( \Omega_ { m } t + \varphi _ { 0 , m } + \frac { 2 \pi n } { N }-\alpha )\right] \right\}\text{exp} \left\{ - j \Phi _ { m , n } ( t ) \right\}\end{aligned}\qquad(12)\]</span> 式中，相位函数<span class="math inline">\(\Phi _ { m , n } ( t)\)</span>为： <span class="math display">\[\Phi _ { m , n } ( t ) = \frac { 4 \pi } { \lambda } \frac { L_2+L_1  }{ 2 } \cos \beta _ { m } \cos ( \Omega _ { m } t + \varphi _ { 0 , m } +\frac { 2 \pi n } { N } -\alpha), ( m = 1 , 2 , \cdots , M ; n = 0 , 1 ,2 \cdots , N - 1 )\qquad(13)\]</span> 其中，<span class="math inline">\(R_{m}\)</span>为某时刻第 m个旋翼到雷达的距离，<span class="math inline">\(\beta_m\)</span>为雷达与第 m个旋翼之间的俯仰角，<span class="math inline">\(\Omega_m\)</span>为第 m个旋翼的旋转角频率，<span class="math inline">\(\varphi_{0,m}\)</span>为第 m个旋翼的某一叶片的初始旋转角。</p><p>一般地,对信号的相位函数求时间导数可以得到信号的瞬时频率。因此,对式(12)求时间导数可以得到第m 个旋翼第 n 个叶片的等效瞬时多普勒频率<span class="math inline">\(f_{m,n}\)</span>： <span class="math display">\[f _ { m , n } ( t ) = - \frac { 2 \Omega _ { m } } { \lambda}×\frac{L_2+L_1 }{2} \cos \beta _ { m } \sin ( \Omega _ { m } t +\varphi _ { 0 , m } + \frac { 2 \pi k } { N }-\alpha )\qquad(14)\]</span> 对于一个悬停的旋翼无人机，旋翼到雷达的距离<span class="math inline">\(R_{m}\)</span>与俯仰角<span class="math inline">\(\beta_m\)</span>基本相等。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241207171635445.png"></p><p>参考文献：</p><p>[1]徐泽颖.基于流形学习的多旋翼无人机目标识别方法研究[D].电子科技大学,2024.DOI:10.27005/d.cnki.gdzku.2024.003895.</p><p>[2]李思维.基于微多普勒特性的低慢小目标识别方法研究[D].电子科技大学,2024.DOI:10.27005/d.cnki.gdzku.2024.000875.</p><p>[3]李明哲,饶烜.一种基于转速补偿的悬停无人机时频域积累检测算法[J/OL].雷达科学与技术,1-18[2024-11-21].http://kns.cnki.net/kcms/detail/34.1264.tn.20241101.1518.002.html.</p><p>[4]何彬宇.基于深度学习的无人机目标微多普勒谱图识别研究[D].电子科技大学,2023.DOI:10.27005/d.cnki.gdzku.2023.002942.</p><p>[5]谷贺林.基于Wigner-Ville分布的无人机旋翼微多普勒特征提取方法的研究[D].石家庄铁道大学,2023.DOI:10.27334/d.cnki.gstdy.2023.000633.</p><h3 id="旋翼叶片的-rcs-模型">1.4 旋翼叶片的 RCS 模型</h3><figure><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241201201351335.png" alt="旋翼叶片和雷达的几何关系"><figcaption aria-hidden="true">旋翼叶片和雷达的几何关系</figcaption></figure><p>为了计算旋翼叶片的电磁散射，简单起见，叶片被简化为一个刚性的、均匀的、线性的矩形平板，它以恒定的转速绕固定轴旋转，并且不考虑前缘和后缘。在矩形平板上完全不考虑拍动、护板和加强筋。旋翼叶片和雷达的几何关系显示在上图中。在RCS 公式中，有两个项：峰值 RCS <span class="math inline">\(\sigma_{Peak}\)</span> 和方向因子<span class="math inline">\(\sigma_{Aspect}\)</span>： <span class="math display">\[\sigma = \sigma _ { P e a k } \sigma _ { A s pect  } = \frac { 4 \pi a ^{ 2 } b ^ { 2 } } { \lambda ^ { 2 } } ( \cos \theta \frac { \sin x _ { k} } { x _ { k } } \frac { \sin y _ { k } } { y _ { k } } ) ^ { 2 }\]</span> 其中<span class="math inline">\(\sigma _ { Peak } = 4 \pi a ^{ 2 } b ^ { 2 } / \lambda ^ { 2 }\)</span>，<span class="math inline">\(\sigma _ { A s p e c t } = ( \cos \theta ( \sin x_ { k } / x _ { k } ) ( \sin y _ { k } / y _ { k } ) ) ^ { 2}\)</span>，<span class="math inline">\(x_k=ka\sin\theta\sin\varphi\)</span>，<span class="math inline">\(y_k=kb\sin\theta\cos\varphi\)</span>，并且<span class="math inline">\(k=2\pi/\lambda\)</span>。上式与极化无关，且仅对<span class="math inline">\(\theta\le 20°\)</span>的小视角准确。</p><p>多旋翼可以由一组<span class="math inline">\(N_R\)</span>个旋翼建模，其中每个旋翼都有<span class="math inline">\(N_B\)</span>个叶片。为了计算<span class="math inline">\(N_R\)</span>× <span class="math inline">\(N_B\)</span>个旋转叶片的电磁散射，简单起见，可以将叶片建模为刚性的、均匀的、线性的矩形平板。对于完美导电的矩形平板，其RCS 的数学公式如上式所示。为简单起见，每个叶片的 RCS都可以分配到叶片的尖端。 <span class="math display">\[s _ { \sum } ( t ) = \sum _ { j = 1 } ^ { N_R } \sum _ { k = 0 } ^ {N_B-1 } \sigma _ { j , k } ( t ) \text{exp} \left\{ - j \frac { 4 \pi }{ \lambda } R _ { j } ( t ) \right\} e x p \left\{ - j \Phi _ { j,k } (t ) \right\}\]</span> 其中<span class="math inline">\(N_R\)</span>是是旋翼总数，<span class="math inline">\(N_B\)</span>是每个旋翼上的叶片总数，<span class="math inline">\(R_j(t)\)</span>是时间t从雷达到第j个旋翼中心的距离，<span class="math inline">\(\sigma_{j,k}(t)\)</span>是时间t第j个旋翼上第k个叶片的RCS。</p><h2 id="飞鸟目标的雷达回波建模">2.飞鸟目标的雷达回波建模</h2><p>当雷达照射到飞鸟目标时，飞鸟翅膀的上下周期性振动也将在雷达回波信号中产生微多普勒效应，因此以雷达中心O为原点建立全局坐标系(X,Y,Z)，以飞鸟两侧翅膀的重合点o为原点建立飞鸟坐标系(x,y,z)，则雷达与飞鸟翅膀的相对位置如下图所示。设飞鸟中心在o点，其到雷达的距离为<span class="math inline">\(R_t\)</span>，与雷达的方位角为<span class="math inline">\(\alpha\)</span>，俯仰角为<span class="math inline">\(\beta\)</span>，其相对雷达径向的飞行速度为v，飞鸟扑翼与xoy面的夹角为<span class="math inline">\(\phi_t\)</span>。为方便分析，将飞鸟的扑翼看做是一个不弯曲的线源，它的回波信号可以由多个单散射点叠加而成，则可按照上一节节的做法对飞鸟进行分析。即先对飞鸟翅膀上的单一散射点进行分析，然后对单散射点的回波信号进行积分即可得到飞鸟目标的雷达回波模型。</p><p><img src="/2024/06/02/%E9%80%9A%E4%BF%A1%E6%84%9F%E7%9F%A5%E4%B8%80%E4%BD%93%E5%8C%96/image-20241122195651488.png" alt="雷达与飞鸟扑翼的几何关系图" style="zoom:67%;"></p><p>取飞鸟翅膀上的一点P，设P点距飞鸟中心o的距离为<span class="math inline">\(l_p\)</span>。在t时刻，雷达O到飞鸟中心o的距离为<span class="math inline">\(R_t=R_0+vt\)</span>，飞鸟翅膀与xoy面的夹角<span class="math inline">\(\phi_t=\phi_{max}·sin\omega(t-\Deltat)\)</span>，其中<span class="math inline">\(\phi_{max}\)</span>是飞鸟翅膀与xoy面的最大夹角，<span class="math inline">\(\omega_b=2\pif_{bird}\)</span>是飞鸟翅膀震动的角频率，<span class="math inline">\(f_{bird}\)</span>为鸟类的扑翼频率，<span class="math inline">\(\Deltat\)</span>是用于表征飞鸟翅膀初始夹角的变量。</p><p>在全局雷达坐标系<span class="math inline">\((X,Y,Z)\)</span>中， t时刻飞鸟中心 o 的坐标为<span class="math inline">\(( R _ { t } \cos\beta \cos \alpha, R _ { t } \cos \beta \sin \alpha,R _ { t }\sin\beta)\)</span>，在目标坐标系<span class="math inline">\((x,y,z)\)</span>中，散射点 P 的坐标为<span class="math inline">\((l \cos \varphi _ { t } ,0，l \sin \varphi _ { t})\)</span>。则P到雷达中心o的距离为： <span class="math display">\[\begin{aligned}R _ { p } ( t ) &amp;= || \overrightarrow { O P } || \\&amp;= | | \overrightarrow { O o } + \overrightarrow { o P } | |\\&amp; = \sqrt { ( R _ { t } \cos \beta \cos \alpha + l_p \cos \phi _ { t} ) ^ { 2 } + ( R _ { t } \cos \beta \sin \alpha ) ^ { 2 } + ( R _ { t }\sin \beta+ l_p  \sin \phi _ { t }  ) ^ { 2 } }\\&amp; = \sqrt { R _ { t } ^ { 2 } + l_p  ^ { 2 } + 2 R _ { t } l_p(\cos\beta\cos\alpha\cos\phi_t+\sin\beta\sin\phi_t)  }\\&amp;\cong R _ { t } +l_p  (\cos\beta\cos\alpha\cos\phi_t+\sin\beta\sin\phi_t)\end{aligned}\]</span> 在t时刻但散射点P的回波模型为： <span class="math display">\[\begin{aligned}S _ { p } ( t ) &amp;= \sigma e ^ { - j \frac { 4 \pi } { \lambda } ( R_ { 0 } + v t +l_p  (\cos\beta\cos\alpha\cos\phi_t+\sin\beta\sin\phi_t))}\\&amp;  = \sigma e ^ { - j \frac { 4 \pi } { \lambda } ( R _ { 0 } +l_p  (\cos\beta\cos\alpha\cos\phi_t+\sin\beta\sin\phi_t) ) } * e ^ { - j2 \pi f _ { b a } t }\end{aligned}\]</span> 式中，<span class="math inline">\(f_{bd}=2v/\lambda\)</span>是飞鸟由于平动产生的多普勒频率，*前面部分则是由于飞鸟翅膀震动产生的微多普勒特性。</p><p>对单散射点 P在飞鸟翅膀的有效区间[L1,L2]上进行积分，则可得飞鸟单个翅膀的回波模型为 $$\begin{aligned} S _ { L } ( t ) &amp;= _ { L _ { 1 } } ^ { L _ { 2 } } S_ { P } ( t ) d l_p\ &amp; = ( L _ { 2 } - L _ { 1 } ) c ( { } ( L _ { 2} - L _ { 1 } ) (_t+_t)) \ &amp; e ^</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信感知一体化</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像与视频处理</title>
    <link href="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    <url>/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>2024/5/11 16:22 今天学习一下图像和视频处理的相关知识。</p><p>2024/5/16 11:17到今天，已经把前三个实验任务完成了，今天准备开始做第四个实验。</p><p>2024/5/18 16:21 项目结束。</p><h1 id="一pbm和pgm">一、PBM和PGM</h1><h2 id="pbm和pgm基本知识">1.PBM和PGM基本知识</h2><ul><li>PBM（Portable BitMap）支持单色图（1个像素位）。</li><li>PGM（PortableGreyMap）支持灰度图形，能够读PBM图形和PGM图形，输出PGM图形。</li><li>PPM（PortablePixMap）支持真彩色图形，可以读上面所有格式，输出PPM图形。</li></ul><p>这三种图像格式都通过头2个字节<strong>magic number</strong>（P1, P2,P3, P4, P5, P6）来表明图像的类型(PBM, PGM, PPM), 以及编码方式(ASCII 或Binary)。</p><table><thead><tr><th style="text-align: left;">Magic Number</th><th style="text-align: left;">图像类型</th><th style="text-align: left;">编码方式</th></tr></thead><tbody><tr><td style="text-align: left;">P1</td><td style="text-align: left;">Bitmap</td><td style="text-align: left;">ASCII</td></tr><tr><td style="text-align: left;">P2</td><td style="text-align: left;">Graymap</td><td style="text-align: left;">ASCII</td></tr><tr><td style="text-align: left;">P3</td><td style="text-align: left;">Pixmap</td><td style="text-align: left;">ASCII</td></tr><tr><td style="text-align: left;">P4</td><td style="text-align: left;">Bitmap</td><td style="text-align: left;">Binary</td></tr><tr><td style="text-align: left;">P5</td><td style="text-align: left;">Graymap</td><td style="text-align: left;">Binary</td></tr><tr><td style="text-align: left;">P6</td><td style="text-align: left;">Pixmap</td><td style="text-align: left;">Binary</td></tr></tbody></table><p>其实我们主要看的是图像文件的头信息, 且头信息都是ASCII格式的,数据部分才分ASCII编码方式和Binary编码方式。</p><p>下面着重讲解ppm格式：</p><p>PPM图像格式分为两部分，分别为<strong>头部分</strong>和<strong>图像数据</strong>部分。</p><p>头部分：由3部分组成，通过换行或空格进行分割，一般PPM的标准是空格。</p><ul><li>第1部分：P3或P6，指明PPM的编码格式，</li><li>第2部分：图像的宽度和高度，通过ASCII表示，</li><li>第3部分：最大像素值，0-255字节表示。</li></ul><p>图像数据部分：</p><ul><li>ASCII格式：按RGB的顺序排列，RGB中间用空格隔开，图片每一行用回车隔开。</li><li>Binary格式：PPM用24bits代表每一个像素，红绿蓝分别占用8bits。</li></ul><h2 id="读取写入pgmppm图像">2.读取/写入PGM/PPM图像</h2><p>读取PGM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PGM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[image_data, width, height, max_val,P]</span> = <span class="hljs-title">readPGM</span><span class="hljs-params">(filename, format)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;r&#x27;</span>);<br>    P=fgetl(fid); <span class="hljs-comment">% 读取并忽略P5</span><br>    fgetl(fid); <span class="hljs-comment">% 读取并忽略注释</span><br>    dimensions = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">2</span>);<br>    width = dimensions(<span class="hljs-number">1</span>);<br>    height = dimensions(<span class="hljs-number">2</span>);<br>    max_val = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        image_data = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, [width, height]);<br>        image_data = image_data&#x27;;<br>    <span class="hljs-keyword">else</span><br>        image_data = fread(fid, [width, height], <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>        image_data = image_data&#x27;;<br>    <span class="hljs-keyword">end</span><br>    image_data=uint8(image_data);<br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>写入PGM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 写入PGM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writePGM</span><span class="hljs-params">(filename, image_data, width, height, max_val, format,P)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;w&#x27;</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P2</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d\n&#x27;</span>, max_val);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>            fprintf(fid, <span class="hljs-string">&#x27;%d &#x27;</span>, image_data(<span class="hljs-built_in">i</span>, :));<br>            fprintf(fid, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P5</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, max_val);<br>        image_data = image_data&#x27;;<br>        fwrite(fid, image_data, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>读取PPM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PPM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[image_data, width, height, max_val,P]</span> = <span class="hljs-title">readPPM</span><span class="hljs-params">(filename, format)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;r&#x27;</span>);<br>    P=fgetl(fid);<span class="hljs-comment">% 读取并忽略P6</span><br>    fgetl(fid); <span class="hljs-comment">% 读取并忽略注释</span><br>    dimensions = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">2</span>);<br>    width = dimensions(<span class="hljs-number">1</span>);<br>    height = dimensions(<span class="hljs-number">2</span>);<br>    max_val = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        image_data = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, [<span class="hljs-number">3</span>, width * height]);<br>        image_data = <span class="hljs-built_in">reshape</span>(image_data, [<span class="hljs-number">3</span>,width, height]);<br>        <br>    <span class="hljs-keyword">else</span><br>            image_data = fread(fid, [<span class="hljs-number">3</span>,width*height], <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>            image_data=double(<span class="hljs-built_in">reshape</span>(image_data,[<span class="hljs-number">3</span>,width,height]));<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>写入PPM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 写入PPM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writePPM</span><span class="hljs-params">(filename, image_data, width, height, max_val, format,P)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;w&#x27;</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P3</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d\n&#x27;</span>, max_val);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>                fprintf(fid, <span class="hljs-string">&#x27;%d %d %d &#x27;</span>, image_data(:, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>));<br>            <span class="hljs-keyword">end</span><br>            fprintf(fid, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P6</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, max_val);<br>        fwrite(fid, image_data, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PPM图像并以其原始格式写入PPM图像</span><br><span class="hljs-comment">% input.ppm改成输入文件地址，output.ppm改成输出文件地址</span><br><span class="hljs-comment">% 注意在读取不同格式的图像数据时，要把函数后面的format换成相应的ASCII或Binary</span><br>[ppm_image_data, ppm_width, ppm_height, ppm_max_val] = readPPM(<span class="hljs-string">&#x27;input.ppm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>writePPM(<span class="hljs-string">&#x27;output.ppm&#x27;</span>, ppm_image_data, ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>, P);<br><br><br><br><span class="hljs-comment">% 读取PGM图像并以其原始格式写入PGM图像</span><br>[pgm_image_data, pgm_width, pgm_height, pgm_max_val] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, pgm_image_data, pgm_width, pgm_height, pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>, P);<br></code></pre></td></tr></table></figure><blockquote><p><code>fscanf</code>函数用于从文件中按照指定的格式读取数据，并返回读取到的数据。但如果指定格式是矩阵的话，其读取后的数据填充方式是先填充列。故若源文件中数据矩阵式m×n大小，那就需要用<code>A=fscanf(fid, '%d', [n,m])</code>，再将A转置才是源文件中的矩阵。</p><p><code>fscanf</code>用于读取格式化的<strong>文本数据</strong>，可以按照指定的格式读取不同类型的数据。</p><p><code>fread</code>则用于读取<strong>二进制数据</strong>，它不关心数据的具体格式，只是按照字节来读取数据。</p><p><code>fgetl</code>是MATLAB中用于从文本数据文件中读取一行文本的函数。</p><p>当你使用 <code>fopen</code>打开文件时，该函数会返回一个文件标识符。你可以将这个标识符保存在一个变量中，并在后续的文件操作中使用它。一般情况下，当你完成文件操作后，应该使用<code>fclose</code> 函数关闭文件，并释放该文件标识符。</p></blockquote><h1 id="二格式转换">二、格式转换</h1><h2 id="yuv图像格式">1.YUV图像格式</h2><p>YUV是一种图像颜色编码方式。相对于常见且直观的RGB颜色编码，YUV的产生自有其意义，它基于人眼对<strong>亮度</strong>比<strong>色彩</strong>的敏感度更高的特点，使用Y、U、V三个分量来表示颜色，并通过降低U、V分量的采样率，尽可能保证图像质量的情况下，做到如下3点：占用更低的存储空间、数据传输效率更高、兼容黑白与彩色显示。</p><h3 id="像素">1.1 像素</h3><p>想要深入了解YUV格式，必须得从Bit、Byte级别“看穿看透”它。</p><ul><li>Bit：位 —— 计算机硬件系统能识别的最基础单位。</li><li>Byte：字节 —— 计算机文件系统能识别的最基础单位。</li><li>像素：Pixel —— 显示图像的最基础单位。</li></ul><p>显示器上的一个像素点对应图像里的一个像素，不管哪种显示器，最终都是以像素为最小单位进行图像呈现。</p><p>不论技术怎么革新，有两点是始终不变的：</p><ul><li>显示的基础单元是<strong>像素</strong>。</li><li>每个像素的色彩由<strong>红、绿、蓝</strong>三原色混合实现。</li></ul><p>三原色是什么？显示器像素点的颜色数据是怎么排列存储的？带着问题先了解下RGB，为YUV的了解做个铺垫。</p><h3 id="rgb">1.2 RGB</h3><p>RGB：用R、G、B三个分量来表示像素点颜色，分别表示红、绿、蓝。这三种颜色就称为<strong>三原色</strong>，它们以不同比例混合能生成其他任意颜色。</p><p>RGB表示一帧图像：</p><ul><li>每个像素点背后都包含一组R、G、B分量，像素点的颜色就是它们的混合。</li><li>R、G、B每个分量分别占1个byte，也就是8个bit。</li></ul><p>例如，一张分辨率 1280 * 720 的RGB图片，占用 1280 * 720 * 3 / 1024 /1024 = 2.63MB 空间。</p><h3 id="yuv表示图像">1.3 YUV表示图像</h3><p>YUV：用Y、U、V三个分量来表示像素颜色。</p><ul><li>Y表示<strong>亮度</strong>（Luminance、缩写Luma），即为<strong>灰度值</strong>。</li><li>U 和 V表示<strong>色度</strong>（Chrominance、缩写Chroma），即为<strong>色调和饱和度</strong>。</li></ul><p>默认Y、U、V每个分量占用存储空间1个byte，和RGB一样。前文概述中提到过，YUV是通过降低U、V分量的采样率来实现它占用空间小和传输效率高的优势。也就是图像每个像素的Y分量都被完整采样全部保存，但是U、V分量只做部分采样，让多个像素按照一些规则共用U、V分量。</p><h2 id="ppm图像和pgm图像之间的转换">2.PPM图像和PGM图像之间的转换</h2><p>PPM就是RGB图像，PGM就是灰度图像，也就是YUV中Y通道的图像。</p><p>给出YUV转换公式：</p><p>Y = 0.257 * R + 0.504 * G + 0.098 * B + 16</p><p>U = -0.148 * R - 0.291 * G + 0.439 * B + 128</p><p>V = 0.439 * R - 0.368 * G - 0.071 * B + 128</p><p>PPM转换为PGM：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[gray_image,YUV_image]</span> = <span class="hljs-title">BUPT_format_converter</span><span class="hljs-params">(color_image)</span></span><br>    [~,width, height] = <span class="hljs-built_in">size</span>(color_image);<br>    gray_image = <span class="hljs-built_in">zeros</span>(height, width);<br>    YUV_image = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>,width,height);<br><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>            R = color_image(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            G = color_image(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            B = color_image(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            <br>            Y = <span class="hljs-number">0.257</span> * R + <span class="hljs-number">0.504</span> * G + <span class="hljs-number">0.098</span> * B + <span class="hljs-number">16</span>;<br>            U = <span class="hljs-number">-0.148</span> * R - <span class="hljs-number">0.291</span> * G + <span class="hljs-number">0.439</span> * B + <span class="hljs-number">128</span>;<br>            V = <span class="hljs-number">0.439</span> * R - <span class="hljs-number">0.368</span> * G - <span class="hljs-number">0.071</span> * B + <span class="hljs-number">128</span>;<br>            <span class="hljs-comment">% 更改Y/U/V，选择得到哪个通道的灰度图</span><br>            gray_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = <span class="hljs-built_in">round</span>(Y);<br>            YUV_image(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = Y;<br>            YUV_image(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = U;<br>            YUV_image(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = V;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>下面图(a)是PPM(RGB)图像，图(b)是PGM(灰度)图像，图(c)是U通道的图像，图(d)是V通道的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514095516604.png" alt="PPM转换为Y、U、V通道的图像"><figcaption aria-hidden="true">PPM转换为Y、U、V通道的图像</figcaption></figure><p>RGB和灰度色彩空间之间的转换并不是线性的。这是因为转换涉及使用非线性系数对RGB 分量进行加权平均，如YUV转换公式中所指定的那样。</p><p>U、V通道的图片产生了失真。这是因为YUV色彩空间将颜色信息（U和V通道）与亮度信息（Y通道）分开。当单独显示YUV通道作为灰度图像时，人眼可能会将颜色信息视为灰度变化，从而导致与原始RGB图像相比的失真外观。</p><p>换句话说，U和V通道代表色度信息，在单独显示为灰度图像时，并没有以原始的上下文展示。它们应该与亮度通道（Y）结合起来重建完整的彩色图像。因此，单独查看它们可能不能准确地呈现原始图像的颜色。</p><p>根据YUV转换公式我们倒推得到RGB的转换公式：</p><p><em>R</em>=<em>Y</em>+1.403⋅(<em>V</em>−128)</p><p><em>G</em>=<em>Y</em>−0.344⋅(<em>U</em>−128)−0.714⋅(<em>V</em>−128)</p><p><em>B</em>=<em>Y</em>+1.770⋅(<em>U</em>−128)</p><p>YUV图像数据向PPM（RGB）图像转换：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rgb_img</span> = <span class="hljs-title">yuv_to_rgb</span><span class="hljs-params">(YUV_img)</span></span><br>    <span class="hljs-comment">% 得到图片维度</span><br>    [~,width, height] = <span class="hljs-built_in">size</span>(YUV_img);<br>    <br>    <span class="hljs-comment">% 建立rgb图像数据</span><br>    rgb_img = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>,width,height);<br>    <br>    <span class="hljs-comment">% 转换YUV 为 RGB</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>            Y = YUV_img(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            U = YUV_img(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            V = YUV_img(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            <br>            R = Y + <span class="hljs-number">1.403</span> * (V - <span class="hljs-number">128</span>);<br>            G = Y - <span class="hljs-number">0.344</span> * (U - <span class="hljs-number">128</span>) - <span class="hljs-number">0.714</span> * (V - <span class="hljs-number">128</span>);<br>            B = Y + <span class="hljs-number">1.770</span> * (U - <span class="hljs-number">128</span>);<br>            <br><br>            rgb_img(:, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = [<span class="hljs-built_in">round</span>(R), <span class="hljs-built_in">round</span>(G), <span class="hljs-built_in">round</span>(B)];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[ppm_image_data, ppm_width, ppm_height, ppm_max_val,P] = readPPM(<span class="hljs-string">&#x27;input.ppm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>[pgm_image_data,YUV_image]=BUPT_format_converter(ppm_image_data);<br>ppm_image = yuv_to_rgb(YUV_image);<br><span class="hljs-comment">%将YUV数据重新复原为RGB图像</span><br>writePPM(<span class="hljs-string">&#x27;output_2.ppm&#x27;</span>, ppm_image , ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P3&#x27;</span>);<br><span class="hljs-comment">%得到Y、U、V的PGM图像</span><br>writePGM(<span class="hljs-string">&#x27;output_1.pgm&#x27;</span>, pgm_image_data, ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h1 id="三图像采样">三、图像采样</h1><h2 id="下采样sub-sampling的基本原理">1.下采样（Sub-sampling）的基本原理</h2><p>图像的下采样也就是缩小图像。下采样是一种信号处理技术，用于降低信号的采样率。在图像处理中，下采样指的是减少图像的像素数量，从而降低图像的分辨率。这通常通过在水平和垂直方向上以一定的间隔丢弃像素来实现。</p><p>下采样的原理是基于采样定理。根据奈奎斯特-香农采样定理，为了正确地表示一个信号（或图像），采样频率必须<strong>至少</strong>是信号最高频率的两倍。因此，如果降低采样率，即减少采样频率，就必须牺牲一些高频细节。下采样通过删除一些像素来实现这一点，从而降低了图像的分辨率，但同时也减少了文件大小和处理复杂度。</p><p>然而，需要注意的是，对图像进行下采样时，实际上是减少了从原始图像中取样的数量，降低了有效的采样频率，这意味着图像的空间频率内容相对于采样率变得更高。如果在下采样过程中不恰当地处理高频细节，可能会导致混叠问题，即产生意外的图案或失真。因此，在进行下采样时，通常会应用滤波器来平滑图像并移除高频信息，以减少混叠问题的发生。</p><p>当对图像进行下采样时，可能会产生混叠的明显例子是在图像中出现的摩尔纹（Moiré）图案。摩尔纹是一种常见的混叠现象，通常出现在对具有细微重复细节的图像进行采集时。这些细节可能包括纹理或图案。混叠是由于采样频率不足以准确捕捉场景中的高频细节而导致的，最终会在图像中产生不正确的表示和不需要的图案。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/512b616b27ca4d9c891cdf7b43e68b3c.jpeg" alt="混叠现象-摩尔纹"><figcaption aria-hidden="true">混叠现象-摩尔纹</figcaption></figure><h2 id="图像下采样">2.图像下采样</h2><p>实现一个函数，通过因子n对<strong>灰度图像</strong>进行下采样，其中n是2的倍数。该函数应该能够在水平和垂直方向上独立地进行下采样，或者同时在两个方向上进行下采样。</p><blockquote><p>因子n表示在n个像素点中取1个，若水平n=2，则表示图像的水平宽度要变为原来的1/2。</p></blockquote><p>对图像Lena进行下采样：2水平，2垂直，2垂直和8水平，4垂直和4水平。</p><p>下采样函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 子采样函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub_sampled_image</span> = <span class="hljs-title">subSample</span><span class="hljs-params">(image, n_horizontal, n_vertical)</span></span><br>    <span class="hljs-comment">% 获取原始图像的大小</span><br>    [height, width] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 计算子采样后的大小</span><br>    new_height = height / n_vertical;<br>    new_width = width / n_horizontal;<br>    <br>    <span class="hljs-comment">% 初始化子采样后的图像</span><br>    sub_sampled_image = <span class="hljs-built_in">zeros</span>(new_height, new_width);<br>    <br>    <span class="hljs-comment">% 子采样</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:new_height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:new_width<br>            sub_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = image((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*n_vertical + <span class="hljs-number">1</span>, (<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)*n_horizontal + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 水平方向子采样因子为2</span><br>sub_sampled_horizontal_2 = subSample(lena_image, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>writePGM(<span class="hljs-string">&#x27;output_1.ppm&#x27;</span>, sub_sampled_horizontal_2, <span class="hljs-built_in">size</span>(sub_sampled_horizontal_2, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_horizontal_2, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 垂直方向子采样因子为2</span><br>sub_sampled_vertical_2 = subSample(lena_image, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>writePGM(<span class="hljs-string">&#x27;output_2.pgm&#x27;</span>, sub_sampled_vertical_2, <span class="hljs-built_in">size</span>(sub_sampled_vertical_2, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_vertical_2, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><br><span class="hljs-comment">% 水平方向子采样因子为8，垂直方向子采样因子为2</span><br>sub_sampled_horizontal_8 = subSample(lena_image, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);<br>writePGM(<span class="hljs-string">&#x27;output_3.pgm&#x27;</span>, sub_sampled_horizontal_8, <span class="hljs-built_in">size</span>(sub_sampled_horizontal_8, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_horizontal_8, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><br><span class="hljs-comment">% 垂直方向子采样因子为4，水平方向子采样因子为4</span><br>sub_sampled_vertical_4 = subSample(lena_image, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br>writePGM(<span class="hljs-string">&#x27;output_4.pgm&#x27;</span>, sub_sampled_vertical_4, <span class="hljs-built_in">size</span>(sub_sampled_vertical_4, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_vertical_4, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><p>下面图(a)是在垂直方向因子为1水平方向因子为2的图像，图(b)是在垂直方向因子为2水平方向因子为1的图像，图(c)是在垂直方向因子为2水平方向因子为8的图像，图(d)是在垂直方向因子为4水平方向因子为4的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514100217700.png" alt="图像下采样后的图像"><figcaption aria-hidden="true">图像下采样后的图像</figcaption></figure><h2 id="上采样up-sampling的基本原理">3.上采样（Up-sampling）的基本原理</h2><p>图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。</p><p>最简单的方式是重采样和插值：将输入图片 input image 进行 rescale到一个想要的尺寸，而且计算每个点的像素点，使用如双线性插值(Bilinear-Interpolation)等插值方法对其余点进行插值。各种插值方法都有各自的优缺点。插值就是在不生成像素的情况下增加图像像素大小的一种方法，在周围像素色彩的基础上用数学公式计算丢失像素的色彩（也有的有些相机使用插值，人为地增加图像的分辨率）。所以在放大图像时，图像看上去会比较平滑、干净。但必须注意的是插值并不能增加图像信息。</p><h3 id="最邻近元法nearest-neighbour-interpolation">3.1最邻近元法（Nearest Neighbour Interpolation）</h3><p>最邻近元法是最简单的一种插值方法，不需要计算，在待求像素的四邻像素中，将距离待求像素最近的像素素灰度赋给待求像素。设i+u, j+v (i, j为正整数， u,v为大于零小于1的小数，下同)为待求像素坐标，则待求像素灰度的值 f(i+u,j+v)　如下图所示：</p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/1.png"></p><p>如果 (i+u, j+v) 落在A区，即 u&lt;0.5,v&lt;0.5，则将左上角像素的灰度值赋给待求像素，同理，落在B区则赋予右上角的像素灰度值，落在C区则赋予左下角像素的灰度值，落在D区则赋予右下角像素的灰度值。</p><p>最邻近元法计算量较小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能出现明显的锯齿状。当图片放大时，缺少的像素通过直接使用与之最接近的原有的像素的颜色生成，也就是说照搬旁边的像素，这样做的结果是产生了明显可见的<strong>锯齿</strong>。</p><h3 id="双线性内插法bilinear-interpolation">3.2 双线性内插法（BilinearInterpolation）</h3><p>双线性插值是通过周边的四个点，计算权值，然后决定插入后的图像的像素值。新生成的图像中每个点都会计算一遍，是利用待求象素四个邻象素的灰度在两个方向上作线性内插，如下图所示：</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>(i+u,j+v)是目标位置（0&lt;u,v&lt;1)，需要进行插值的像素坐标，f(i+u,j+v)是该坐标下的像素值；(i,j)，(i+1,j)，(i,j+1)，(i+1,j+1)是原始图像中与目标位置最近的四个像素的坐标，分别表示左上、左下、右上和右下四个像素的位置。</p><p>根据双线性插值的原理，插值的结果 <code>interpolated_value</code>是通过如下公式计算得到的： <span class="math display">\[interpolated\_value=\frac{f(i,j)·[(i+1)-(i+u)]·[(j+1)-(j+v)]+f(i+1,j)·(i+u-i)·[(j+1)-(j+v)]+f(i,j+1)·[(i+1)-(i+u)]·(j+v-j)+f(i+1,j+1)·(i+u-i)·(j+v-j)}{(i+1-i)(j+1-j)}\]</span>双线性内插法的计算比最邻近点法复杂，计算量较大，但没有灰度不连续的缺点，结果基本令人满意。双线性插值算法（BilinearInterpolation）输出的图像的每个像素都是原图中四个像素（2×2）运算的结果，这种算法极大地消除了锯齿现象。但它具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><h2 id="图像上采样">4.图像上采样</h2><p>最邻近元法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up_sampled_image</span> = <span class="hljs-title">BUPT_up</span><span class="hljs-params">(image, factor, method)</span></span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% factor: 放大倍数</span><br>    <span class="hljs-comment">% method: 插值方法，&#x27;nearest&#x27; 或 &#x27;bilinear&#x27;</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% up_sampled_image: 放大后的图像</span><br>    <br><br>    <span class="hljs-comment">% 获取原始图像尺寸</span><br>    [rows, cols] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 计算放大后的尺寸</span><br>    new_rows = <span class="hljs-built_in">round</span>(rows * <span class="hljs-built_in">factor</span>);<br>    new_cols = <span class="hljs-built_in">round</span>(cols * <span class="hljs-built_in">factor</span>);<br>    <br>    <span class="hljs-comment">% 初始化放大后的图像</span><br>    up_sampled_image = <span class="hljs-built_in">zeros</span>(new_rows, new_cols);<br>    <br>    <span class="hljs-comment">% 遍历放大后的图像的每个像素位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:new_rows<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:new_cols<br>            <span class="hljs-comment">% 计算对应原始图像的位置</span><br>            original_i = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">i</span> / <span class="hljs-built_in">factor</span>), rows));<br>            original_j = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">j</span> / <span class="hljs-built_in">factor</span>), cols));<br>            <br>            <span class="hljs-comment">% 根据插值方法填充像素值</span><br>            <span class="hljs-keyword">if</span> strcmp(method, <span class="hljs-string">&#x27;nearest&#x27;</span>)<br>                <span class="hljs-comment">% 最近邻插值</span><br>                up_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = image(original_i, original_j);<br>            <span class="hljs-keyword">elseif</span> strcmp(method, <span class="hljs-string">&#x27;bilinear&#x27;</span>)<br>                <span class="hljs-comment">% 双线性插值</span><br>                up_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = bilinear_interpolation(image, <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">i</span> / <span class="hljs-built_in">factor</span>, rows)), <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">j</span> / <span class="hljs-built_in">factor</span>, cols)));<br>            <span class="hljs-keyword">else</span><br>                error(<span class="hljs-string">&#x27;Unsupported interpolation method.&#x27;</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>双线性内插法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpolated_value</span> = <span class="hljs-title">bilinear_interpolation</span><span class="hljs-params">(image, x, y)</span></span><br>    <span class="hljs-comment">% 双线性插值</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% x, y: 插值位置</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% interpolated_value: 插值后的像素值</span><br><br>    <span class="hljs-comment">% 获取图像尺寸</span><br>    [rows, cols] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 四个最近的整数坐标</span><br>    x1 = <span class="hljs-built_in">floor</span>(x);<br>    x2 = x1 + <span class="hljs-number">1</span>;<br>    y1 = <span class="hljs-built_in">floor</span>(y);<br>    y2 = y1 + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">% 边界处理</span><br>    <span class="hljs-keyword">if</span> x2 &gt; rows<br>        x2 = rows;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> y2 &gt; cols<br>        y2 = cols;<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 获取四个最近像素的值</span><br>    Q11 = image(x1, y1);<br>    Q12 = image(x1, y2);<br>    Q21 = image(x2, y1);<br>    Q22 = image(x2, y2);<br>    <br>    <span class="hljs-comment">% 计算双线性插值</span><br>    interpolated_value = <span class="hljs-built_in">round</span>((Q11 * (x2 - x) * (y2 - y) + Q21 * (x - x1) * (y2 - y) + Q12 * (x2 - x) * (y - y1) + Q22 * (x - x1) * (y - y1)) / ((x2 - x1) * (y2 - y1)));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取 Lena 图像</span><br>[lena, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input_1.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 最近邻插值放大 Lena 图像</span><br><span class="hljs-built_in">factor</span> = <span class="hljs-number">4.5</span>;<br>up_sampled_nearest = BUPT_up(lena, <span class="hljs-built_in">factor</span>, <span class="hljs-string">&#x27;nearest&#x27;</span>);<br><br>writePGM(<span class="hljs-string">&#x27;output_1.pgm&#x27;</span>, up_sampled_nearest, <span class="hljs-built_in">size</span>(up_sampled_nearest, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(up_sampled_nearest, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 读取 Baboon 图像</span><br>[baboon, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input_2.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 双线性插值放大 Baboon 图像</span><br><span class="hljs-built_in">factor</span> = <span class="hljs-number">3.6</span>;<br>up_sampled_bilinear = BUPT_up(baboon, <span class="hljs-built_in">factor</span>, <span class="hljs-string">&#x27;bilinear&#x27;</span>);<br><br>writePGM(<span class="hljs-string">&#x27;output_2.pgm&#x27;</span>, up_sampled_bilinear, <span class="hljs-built_in">size</span>(up_sampled_bilinear, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(up_sampled_bilinear, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240516224506826.png" alt="最邻近元法得到的锯齿状边缘" style="zoom:50%;"></p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240516224717094.png" alt="双线性内插法得到的图片进行放大" style="zoom: 50%;"></p><p>将两种方法得到的上采样图像经过放大后观察细节，最邻近元法产生了明显的锯齿状边缘；而双线性内插法得到图像表现较好，没有灰度不连续的地方。</p><p>在速度方面，Nearest Neighbour 插值通常比 Bilinear 插值更快。这是因为Nearest Neighbour插值只需要在目标位置附近找到最近的一个像素值，并将其作为插值结果，而不需要进行复杂的计算。相比之下，Bilinear插值需要对目标位置周围的四个最近邻像素进行加权平均，计算量更大，因此更慢一些。</p><p>在准确性方面，Bilinear 插值通常比 Nearest Neighbour插值更准确。这是因为 Bilinear插值考虑了目标位置与最近邻像素之间的距离，以及像素值之间的线性关系，可以提供更加平滑和连续的插值结果。相比之下，NearestNeighbour插值仅仅是简单地将最近邻像素的值赋给目标位置，可能会导致插值结果的锯齿状边缘和块状伪影。</p><h1 id="四图像量化">四、图像量化</h1><h2 id="基本原理">1.基本原理</h2><p>图像通常是自然界景物的客观反映，并以照片形式或视频记录的介质连续保存，获取图像的目标是从感知的数据中产生数字图像，因此需要把连续的图像数据离散化，转换为数字化图像，其工作主要包括两方面——量化和采样。数字化幅度值称为量化，数字化坐标值称为采样。</p><p>所谓量化（Quantization），就是将图像像素点对应亮度的连续变化区间转换为单个特定值的过程，即将原始灰度图像的空间坐标幅度值离散化。量化等级越多，图像层次越丰富，灰度分辨率越高，图像的质量也越好；量化等级越少，图像层次欠丰富，灰度分辨率越低，会出现图像轮廓分层的现象，降低了图像的质量。下图是将图像的连续灰度值转换为0至255的灰度级的过程。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/v2-cf13cbb100995b17cb52c0e17eddf839_r.jpg" alt="图像量化"><figcaption aria-hidden="true">图像量化</figcaption></figure><p>如果量化等级为2，则将使用两种灰度级表示原始图片的像素（0-255），灰度值小于128的取0，大于等于128的取128；如果量化等级为4，则将使用四种灰度级表示原始图片的像素，新图像将分层为四种颜色，0-64区间取0，64-128区间取64，128-192区间取128，192-255区间取192；依次类推。</p><p>量化是一个不可逆过程。在量化过程中，连续值被近似为有限的一组离散值，这会导致信息丢失。这种损失称为量化误差。一旦细节被丢弃，就不能从量化值中完美恢复原始的细节。这个过程涉及数据精度的不可逆减少，因此不可能准确重建原始的连续值。</p><p>将量化后的图像文件大小将与原始图像文件进行比较。通常，量化后的文图像文件由于数据精度的降低会更小。量化通常应用于数据大小缩减非常关键的领域，如图像和视频压缩。它还用于数字信号处理，以简化信号的表示和传输。</p><h2 id="图像量化">2.图像量化</h2><p>实现一个函数来均匀量化灰度图像。该函数将允许通过给定的量化等级 n（2的幂）来减少灰度值的数量。</p><p>量化函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quantized_image</span> = <span class="hljs-title">uniformQuantize</span><span class="hljs-params">(image, n)</span></span><br>    <span class="hljs-comment">% 确保n是2的幂</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">mod</span>(<span class="hljs-built_in">log2</span>(n), <span class="hljs-number">1</span>) ~= <span class="hljs-number">0</span><br>        error(<span class="hljs-string">&#x27;n必须是2的幂&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 将图像值转换为0到1之间</span><br>    image = double(image) / <span class="hljs-number">255</span>;<br>    <br>    <span class="hljs-comment">% 计算每个量化级别的步长</span><br>    step_size = <span class="hljs-number">1</span> / n;<br>    <br>    <span class="hljs-comment">% 对图像进行量化</span><br>    quantized_image = <span class="hljs-built_in">floor</span>(image / step_size) * step_size;<br>    <br>    <span class="hljs-comment">% 将量化后的图像重新映射到0到255之间</span><br>    quantized_image = uint8(quantized_image * <span class="hljs-number">255</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>floor</code> 函数用于对每个元素执行向下取整操作。</p><p><code>uint8()</code> 是一个函数，用于将数据转换为无符号 8位整数类型。<code>uint8</code> 类型的值范围是 0 到255，这使得它特别适合用于存储图像数据，因为灰度图像的像素值通常也是在这个范围内。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 设置量化因子，例如4</span><br>n = <span class="hljs-number">128</span>;<br><br><span class="hljs-comment">% 对图像进行均匀量化</span><br>quantized_image = uniformQuantize(lena_image, n);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, quantized_image, <span class="hljs-built_in">size</span>(quantized_image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(quantized_image, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(quantized_image);<br>title([<span class="hljs-string">&#x27;量化后的图像，因子为&#x27;</span>, num2str(n)]);<br></code></pre></td></tr></table></figure><p>下面是对比不同量化等级的“Lena”图。图(a)是量化等级为2时的图像，图(b)是是量化等级为8时的图像，图(c)是是量化等级为32时的图像，图(d)是是量化等级为128时的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514104729354.png" alt="量化后的图像"><figcaption aria-hidden="true">量化后的图像</figcaption></figure><h1 id="五灰度图像的直方图">五、灰度图像的直方图</h1><h2 id="灰度直方图的基本原理">1.灰度直方图的基本原理</h2><h3 id="定义">1.1 定义</h3><p>灰度直方图是关于灰度级分布的函数，是对图像中灰度级分布的统计。灰度直方图是将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率。可表示为：<span class="math display">\[P(k)=\frac{n_k}{n},\quad k=0,1,\cdots,L-1\]</span> 且 <span class="math display">\[\displaystyle\sum_{k=0}^{L-1}P(k)=1\]</span> 式中，k为图像的第k级灰度值，<span class="math inline">\(n_k\)</span>则为图像中灰度值为k的像素个数，n为图像的总像素个数，L为灰度级数。不同的灰度分布对应着不同的图像质量。灰度直方图能反映图像的概貌和质量，也是图像增强处理的重要依据</p><h3 id="灰度直方图的性质">1.2 灰度直方图的性质</h3><ol type="1"><li>直方图的位置缺失性：灰度直方图仅仅反映了数字图像中各灰度级出现频数的分布，即取某灰度值的像素个数占图像总像素个数的比例，但对那些具有同一灰度值的像素在图像中的空间位置一无所知，即其具有位置缺失性。</li><li>直方图与图像的一对多特性：任一幅图像都能唯一地确定与其对应的一个直方图，但由于直方图的位置缺失性，对于不同的多幅图像来说，只要其灰度级出现频数的分布相同，则都具有相同的直方图，即直方图与图像是一对多的关系。</li><li>直方图的可叠加性：由于灰度直方图是各灰度级出现频数的统计值，若一图像分成几个子图，则该图像的直方图就等于各子图直方图的叠加。</li></ol><h2 id="获取灰度图像的直方图">2.获取灰度图像的直方图</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;D:\学习资料\大四下\思涵的实验\新建文件夹\6.img2024\Peppers512_ASCII2014.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>   <br><span class="hljs-comment">% 计算直方图</span><br>histogram_values = imhist(lena_image);<br><br><span class="hljs-comment">% 绘制直方图</span><br><span class="hljs-built_in">figure</span>;<br>bar(histogram_values);<br>title(<span class="hljs-string">&#x27;Peppers灰度图像直方图&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(histogram_values)]);<br></code></pre></td></tr></table></figure><blockquote><p><code>imhist</code> 是 MATLAB中用于计算图像直方图的函数。它接受一个灰度图像作为输入，并返回一个表示直方图的向量。即返回一个向量，里面包含不同灰度级出现的频率。</p><p><code>bar</code> 是 MATLAB中用于创建柱状图的函数。它可以用来可视化数据的分布或频率。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174050694.png" alt="Lena与它的灰度直方图"><figcaption aria-hidden="true">Lena与它的灰度直方图</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174125706.png" alt="Baboon与它的灰度直方图"><figcaption aria-hidden="true">Baboon与它的灰度直方图</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174208637.png" alt="Peppers与它的灰度直方图"><figcaption aria-hidden="true">Peppers与它的灰度直方图</figcaption></figure><h2 id="图像增强直方图均衡化">3.图像增强——直方图均衡化</h2><p>直方图均衡化是一种用于增强图像对比度的图像处理技术。它通过重新分配图像中的像素值，使得图像的像素值分布更加均匀，增强图像的对比度，从而改善图像的视觉效果。</p><p>直方图均衡化的过程如下：</p><ol type="1"><li><p>灰度转换：如果图像是彩色图像，则首先需要将其转换为灰度图像。这可以通过将彩色图像的RGB通道值平均或权重化来实现，得到一个表示亮度的灰度图像。</p></li><li><p>统计直方图：对于灰度图像，统计每个像素值的频数，生成原始图像的直方图。直方图表示了不同像素值的数量分布。</p></li><li><p>计算累积分布函数：通过计算原始图像的累积分布函数，可以得到每个像素值的累积概率分布，<strong>即小于等于该像素值的概率</strong>。可以通过对直方图进行归一化和累加操作得到。</p></li><li><p>映射像素值：根据每个像素值的累积概率分布映射出新的像素值，即将概率乘以255得到均衡化后的像素值。</p></li><li><p>像素重新映射：对于原始图像中的每个像素，根据映射将其像素值替换为均衡化后的像素值。</p></li><li><p>生成均衡化后的图像：根据重新映射的像素值，生成均衡化后的图像。均衡化后的图像在直方图上将有更平坦的分布，从而提高了图像的对比度。</p></li></ol><p>注意，经过直方图均衡化后，分布并不是完全均匀的。虽然直方图均衡化的目的是使像素强度的分布更加均匀，但结果的分布受到原始图像像素值及其在强度范围内的分布方式的影响。</p><p>经过直方图均衡化后，图像的直方图相比于原始图像会更加均匀地分布，但不会完全平坦。这是因为该过程是基于原始直方图的累积分布函数（CDF）重新分配像素值的，这意味着某些强度级别的像素数量仍然会因原始图像内容而有所不同。</p><p>例如，如果原始图像中有大量像素具有特定的强度值，那么在均衡化后，这些像素会分布到一系列的强度值中，但分布仍然可能显示出与原始强度值相对应的峰值和谷值。</p><h2 id="代码实现">4.代码实现</h2><p>直方图均衡化：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equalized_image</span> = <span class="hljs-title">histogramEqualization</span><span class="hljs-params">(image)</span></span><br>    <br>    <span class="hljs-comment">% 计算图像的直方图</span><br>    histogram_values = imhist(image);<br><br>    <span class="hljs-comment">% 计算累积分布函数（CDF）</span><br>    cdf = cumsum(histogram_values) / <span class="hljs-built_in">numel</span>(image);<br>    <br>    <span class="hljs-comment">% 创建一个查找表（Lookup Table），用于将原始灰度级映射到均衡化后的灰度级</span><br>    equalization_map = uint8(<span class="hljs-number">255</span> * cdf);<br><br>    <span class="hljs-comment">% 应用查找表，将原始图像转换为均衡化后的图像,将图像矩阵中的像素值作为查找表中的索引</span><br>    equalized_image = equalization_map(double(image) + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>cumsum</code>可以对向量、矩阵或多维数组的元素进行累加，返回同尺寸的数组，其中每个元素表示该位置及之前所有元素的和。注意是在一行进行累加。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 主函数示例，读取PGM图像并应用直方图均衡化</span><br><span class="hljs-comment">% 读取PGM图像</span><br>[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 调用直方图均衡化函数</span><br>equalized_image = histogramEqualization(lena_image);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, equalized_image, <span class="hljs-built_in">size</span>(equalized_image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(equalized_image, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 显示原始图像和均衡化后的图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(equalized_image);<br>title(<span class="hljs-string">&#x27;均衡化后的图像&#x27;</span>);<br><br><span class="hljs-comment">% 显示直方图</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>imhist(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像直方图&#x27;</span>);<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(equalized_image);<br>title(<span class="hljs-string">&#x27;均衡化后的图像直方图&#x27;</span>);<br><br><span class="hljs-comment">% 显示均衡化后的图像直方图</span><br><span class="hljs-built_in">figure</span>;<br>histogram_values=imhist(equalized_image);<br>bar(histogram_values);<br>title(<span class="hljs-string">&#x27;Peppers均衡化后的图像直方图&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(histogram_values)]);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%9D%87%E8%A1%A1%E5%8C%96%E5%AF%B9%E6%AF%94_Lena.jpeg" alt="Lena经过均衡化的图像"><figcaption aria-hidden="true">Lena经过均衡化的图像</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%9D%87%E8%A1%A1%E5%8C%96%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%AF%B9%E6%AF%94_Lena.jpeg" alt="Lena经过均衡化的直方图"><figcaption aria-hidden="true">Lena经过均衡化的直方图</figcaption></figure><h2 id="直方图建模">5.直方图建模</h2><p>直方图建模技术是修改图像的动态范围和对比度的有效工具。与对比度拉伸不同，直方图建模运算符可以使用非线性和非单调的传递函数来映射输入和输出图像中的像素强度值。</p><h3 id="lena作为输入直方图">5.1 Lena作为输入直方图</h3><p>使用图像A(Lena)的直方图作为输入直方图，并根据输入对另一个图像B(Peppers)的直方图建模。</p><p>步骤：</p><ol type="1"><li>读取图像A和图像B，并计算它们的直方图。</li><li>计算图像A和图像B的累积分布函数（CDF）。</li><li>创建一个映射表，将图像B的像素值映射到具有图像A的直方图分布的像素值。</li><li>应用映射表，生成输出图像。</li></ol><p>直方图建模：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputImage</span>  = <span class="hljs-title">Histogram_modelling</span><span class="hljs-params">(imageA,imageB)</span></span><br>    <br>    <span class="hljs-comment">% 计算图像A和图像B的直方图</span><br>    histA = imhist(imageA);<br>    histB = imhist(imageB);<br><br>    <span class="hljs-comment">% 计算累积分布函数（CDF）</span><br>    cdfA = cumsum(histA) / <span class="hljs-built_in">numel</span>(imageA);<br>    cdfB = cumsum(histB) / <span class="hljs-built_in">numel</span>(imageB);<br><br>    <span class="hljs-comment">% 根据图像B的CDF值找到最接近图像A的CDF值的索引，并构建映射表</span><br>    mapping = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br><br>    <span class="hljs-comment">% 生成映射表</span><br>    <span class="hljs-keyword">for</span> grayLevel = <span class="hljs-number">1</span>:<span class="hljs-number">256</span><br>        [~, idx] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(cdfB(grayLevel) - cdfA));<br>        mapping(grayLevel) = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">% MATLAB的索引从1开始，减去1得到灰度值</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">% 应用映射表到图像B</span><br>    outputImage = mapping(double(imageB) + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>min</code> 函数有两个输出：</p><ol type="1"><li><strong>最小值</strong>：在数组中找到的最小值。</li><li><strong>索引</strong>：最小值所在的位置（索引）。</li></ol><p>例如，<code>[minValue, idx] = min(A)</code>。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取灰度图像A和B</span><br>[imageA, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input_A.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>[imageB, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input_B.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br>outputImage = Histogram_modelling(imageA,imageB);<br><br><span class="hljs-comment">% 显示原始图像和结果图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(imageB);<br>title(<span class="hljs-string">&#x27;图像B&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>imhist(imageA);<br>title(<span class="hljs-string">&#x27;图像A的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(imageB);<br>title(<span class="hljs-string">&#x27;图像B的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>imhist(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B的直方图&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, outputImage, <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1%E5%89%8D%E5%90%8EB%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="建模前后图像B的对比" style="zoom:80%;"></p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1AB_%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="直方图对比" style="zoom:67%;"></p><h3 id="使用指数分布的近似值作为输入直方图">5.2使用指数分布的近似值作为输入直方图</h3><p>使用指数分布的近似值作为输入直方图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 生成指数分布直方图的近似</span><br>N = <span class="hljs-number">256</span>; <span class="hljs-comment">% 灰度级别数量</span><br>lambda = <span class="hljs-number">0.05</span>; <span class="hljs-comment">% 指数分布的参数</span><br><br><span class="hljs-comment">% 计算指数分布概率密度函数</span><br>x = <span class="hljs-number">0</span>:N<span class="hljs-number">-1</span>;<br>pdf_exp = lambda * <span class="hljs-built_in">exp</span>(-lambda * x);<br><br><span class="hljs-comment">% 标准化概率密度函数以得到直方图</span><br>pdf_exp = pdf_exp / sum(pdf_exp); <span class="hljs-comment">% 使概率密度函数的总和为1</span><br><br><span class="hljs-comment">% 使用指数分布近似作为输入直方图，模拟另一个图像的直方图</span><br>cdf_exp = cumsum(pdf_exp); <span class="hljs-comment">% 计算指数分布的累积分布函数</span><br><br><span class="hljs-comment">% 读取另一个图像，这里假设为灰度图像B</span><br>[imageB, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 计算图像B的直方图</span><br>histB = imhist(imageB) / <span class="hljs-built_in">numel</span>(imageB); <span class="hljs-comment">% 将直方图标准化为概率</span><br><br><span class="hljs-comment">% 计算图像B的累积分布函数（CDF）</span><br>cdfB = cumsum(histB); <br><br><span class="hljs-comment">% 创建映射表</span><br>mapping = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br><br><span class="hljs-comment">% 对于每个灰度级别，找到与指数分布CDF最接近的灰度级别</span><br><span class="hljs-keyword">for</span> grayLevel = <span class="hljs-number">1</span>:<span class="hljs-number">256</span><br>    [~, idx] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(cdfB(grayLevel) - cdf_exp));<br>    mapping(grayLevel) = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">% MATLAB的索引从1开始，减去1得到灰度值</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 应用映射表到图像B</span><br>outputImage = mapping(double(imageB) + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 显示原始图像和结果图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(imageB);<br>title(<span class="hljs-string">&#x27;图像B&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>bar(pdf_exp);<br>title(<span class="hljs-string">&#x27;指数分布直方图&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(pdf_exp)]);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(imageB);<br>title(<span class="hljs-string">&#x27;图像B的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>imhist(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B的直方图&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, outputImage, <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E5%BB%BA%E6%A8%A1%E5%89%8D%E5%90%8EB%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="建模前后图像B的对比"><figcaption aria-hidden="true">建模前后图像B的对比</figcaption></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83_%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="直方图对比" style="zoom: 67%;"></p><h1 id="六图像的基本操作">六、图像的基本操作</h1><h2 id="图像负片">1.图像负片</h2><p>图像的负片是指将图像的每个像素的灰度值取反，即将每个像素的灰度值从原来的值减去最大灰度级别，得到新的灰度值。这样做的结果是原来较亮的区域变得较暗，而原来较暗的区域变得较亮。因此，负片图像呈现出与原始图像完全相反的外观，亮度和对比度都会发生反转。</p><p>在实际应用中，图像的负片经常用于图像增强、特效处理和艺术创作等方面。负片可以改变图像的外观，使其更具有视觉冲击力和独特性。同时，负片还可以突出原始图像中的细节和特征，对图像进行突出和强调。因此，在数字图像处理中，生成图像的负片是一项常见且有用的操作。</p><p>得到图像负片：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">negativeImage</span> = <span class="hljs-title">generateNegative</span><span class="hljs-params">(image)</span></span><br>    <br>    <span class="hljs-comment">% 计算灰度级别的最大值</span><br>    maxIntensity = double(<span class="hljs-built_in">max</span>(image(:)));<br>    <br>    <span class="hljs-comment">% 生成负片</span><br>    negativeImage = maxIntensity - image;<br>    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取灰度图像</span><br>[image, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br>negativeImage = generateNegative(image);<br><br><span class="hljs-comment">% 显示原始图像和负片图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(negativeImage);<br>title(<span class="hljs-string">&#x27;负片图像&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, negativeImage, <span class="hljs-built_in">size</span>(negativeImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(negativeImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%8E%9F%E5%A7%8B%E5%9B%BE%E5%83%8F%E5%92%8C%E8%B4%9F%E7%89%87%E5%9B%BE%E5%83%8F_Lena.jpeg" alt="Lena及其负片图像"><figcaption aria-hidden="true">Lena及其负片图像</figcaption></figure><h2 id="图像的旋转和倾斜">2、图像的旋转和倾斜</h2><h3 id="基本原理-1">2.1 基本原理</h3><p>图像倾斜的矩阵形式：</p><p>假设我们有一个二维向量(x,y)表示图像中的一个像素点。图像倾斜操作可以表示为以下矩阵乘法：<span class="math display">\[\begin{bmatrix}x&#39; \\y&#39;\end{bmatrix}= \begin{bmatrix}1 &amp; tan(\theta) &amp; 0\\0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}\]</span> 在这里，θ是倾斜的角度，(x',y')是经过倾斜操作后的像素点坐标。</p><p>图像旋转的矩阵形式：</p><p>图像旋转操作可以表示为以下矩阵乘法： <span class="math display">\[\begin{bmatrix}x&#39; \\y&#39;\end{bmatrix}= \begin{bmatrix}cos(\theta) &amp; -sin(\theta) \\sin(\theta) &amp; cos(\theta)\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}\]</span>在这里，θ是旋转的角度，(x',y')是经过旋转操作后的像素点坐标。</p><h3 id="代码实现-1">2.2 代码实现</h3><p>创建并在下面粘贴一张 PGM 图像，其中包含用 Arial 字体、72点、大写字母书写的您的姓名。将创建的图像顺时针旋转 30 度、60 120 度和-50度。将同一图像倾斜 10 度、40 度和 60 度。</p><p>旋转和倾斜函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[I_rotated,I_skewed]</span>=<span class="hljs-title">BUPT_transform</span><span class="hljs-params">(I, theta1, theta2)</span></span><br>   <br>    <span class="hljs-comment">% 旋转图像</span><br>    I_rotated = imrotate(I, theta1);<br><br>    <span class="hljs-comment">% 倾斜图像</span><br>    tform = affine2d([<span class="hljs-number">1</span>, <span class="hljs-built_in">tand</span>(theta2), <span class="hljs-number">0</span>; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">% 创建仿射变换对象</span><br>    I_skewed = imwarp(I, tform);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imrotate(I, theta1)</code> 是 MATLAB中用于旋转图像的函数。它将图像 <code>I</code> 按照指定的角度<code>theta1</code> 进行逆时针旋转。</p><p><code>affine2d</code>是用于创建仿射变换对象的函数。仿射变换是一种线性变换，可以保持平行线的直线性质，但通常会改变对象的大小、形状和方向。</p><p><code>affine2d()</code>的参数是一个矩阵。它可以通过矩阵来描，这个矩阵通常是一个 3×33×3的矩阵，称为仿射变换矩阵。这个矩阵包含了对平移、旋转、缩放和剪切等操作的描述。</p><p>下面是这个仿射变换矩阵的一般形式： <span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; t_x\\a_{21} &amp; a_{22} &amp; t_y\\0 &amp; 0 &amp; 1\end{bmatrix}\]</span> 其中：</p><ul><li><span class="math inline">\(a_{11}\)</span>和<span class="math inline">\(a_{22}\)</span>控制着水平和垂直方向上的缩放；</li><li><span class="math inline">\(a_{12}\)</span>和<span class="math inline">\(a_{21}\)</span>控制着水平和垂直方向上的剪切；</li><li><span class="math inline">\(t_x\)</span>和<span class="math inline">\(t_y\)</span>控制着水平和垂直方向上的平移。</li></ul><p><code>imwarp()</code>用于对图像进行<strong>仿射变换</strong>或<strong>非线性变换</strong>。它可以将输入图像根据指定的变换应用到输出图像上。</p></blockquote><p>创建包含自己姓名的PGM 图像并实现上述操作：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义您的名字</span><br>name = <span class="hljs-string">&#x27;Your name&#x27;</span>;<br> <br><span class="hljs-comment">% 创建一个灰度图像，大小可以根据需要调整</span><br>image_size = [<span class="hljs-number">512</span>, <span class="hljs-number">512</span>];<br>image = uint8(<span class="hljs-built_in">zeros</span>(image_size) * <span class="hljs-number">255</span>); <span class="hljs-comment">% 初始化为全黑图像</span><br> <br><span class="hljs-comment">% 设置文本属性</span><br>text_position = [<span class="hljs-number">10</span>, <span class="hljs-number">25</span>]; <span class="hljs-comment">% 文本位置</span><br><br><span class="hljs-comment">% 在图像上绘制文本</span><br>image = insertText(image, text_position, name, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">72</span>, <span class="hljs-string">&#x27;Font&#x27;</span>, <span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-string">&#x27;TextColor&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-comment">% 保存图像为PGM格式</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, image, <span class="hljs-built_in">size</span>(image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(image, <span class="hljs-number">1</span>), <span class="hljs-number">255</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 读取并显示创建的图像</span><br>originalImage = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>imshow(originalImage);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>rotationAngles = [<span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">120</span>, <span class="hljs-number">-50</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(rotationAngles)<br>    [I_rotated,~]=BUPT_transform(originalImage, rotationAngles(<span class="hljs-built_in">i</span>), <span class="hljs-number">0</span>);<br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br>    imshow(I_rotated);<br>    title([<span class="hljs-string">&#x27;旋转 &#x27;</span>, num2str(rotationAngles(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27; 度&#x27;</span>]);<br><span class="hljs-keyword">end</span><br>skewAngles = [<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(skewAngles)<br>    [~,I_skewed]=BUPT_transform(originalImage, <span class="hljs-number">0</span>, skewAngles(<span class="hljs-built_in">i</span>));<br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">5</span>);<br>    imshow(I_skewed);<br>    title([<span class="hljs-string">&#x27;倾斜 &#x27;</span>, num2str(skewAngles(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27; 度&#x27;</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>insertText()</code>函数用于在图像上插入文本。它的基本用法：<code>insertText(I, position, text)</code></p><p>其中：</p><ul><li><code>I</code> 是输入图像。</li><li><code>position</code> 是文本的起始位置，可以是一个二元素的数组<code>[x, y]</code>，表示文本左下角的坐标。</li><li><code>text</code> 是要插入的文本字符串。</li></ul><p>此外，<code>insertText()</code>还支持很多参数来控制文本的样式和外观，比如字体大小、字体、颜色等。你可以通过提供参数值来设置这些选项。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC-17157800682331.jpeg" alt="经过旋转、倾斜后的图像"><figcaption aria-hidden="true">经过旋转、倾斜后的图像</figcaption></figure><p>将旋转与倾斜结合：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>;<br>[I_rotated,~]=BUPT_transform(originalImage, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>);<br>[~,I_skewed]=BUPT_transform(I_rotated, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(I_skewed);<br>title(<span class="hljs-string">&#x27;先旋转20°再倾斜50°&#x27;</span>);<br><br>[~,I_skewed]=BUPT_transform(originalImage, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);<br>[I_rotated,~]=BUPT_transform(I_skewed, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(I_rotated);<br>title(<span class="hljs-string">&#x27;先倾斜50°再旋转20°&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%97%8B%E8%BD%AC%E5%80%BE%E6%96%9C%E7%BB%93%E5%90%88.jpeg" style="zoom:67%;"></p><h1 id="七对图像噪声的处理">七、对图像噪声的处理</h1><h2 id="均方误差-mse-和峰值信噪比-psnr">1.均方误差 (MSE) 和峰值信噪比(PSNR)</h2><p>均方误差（MSE）是衡量原始图像与失真图像之间平均平方差的一种度量，量化了原始图像和失真图像之间对应像素差异的平方的平均值。其公式如下：<span class="math display">\[\text{MSE} = \frac{1}{m \cdot n} \sum_{i=1}^{m} \sum_{j=1}^{n} [I(i,j) -K(i,j)]^2\]</span> 其中： - <span class="math inline">\(I\)</span>是原始图像。 -<span class="math inline">\(K\)</span>是失真图像。 - <span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>是图像的维度（行数和列数）。 - <span class="math inline">\(I(i,j)\)</span>和<span class="math inline">\(K(i,j)\)</span>分别是原始图像和失真图像在位置<span class="math inline">\((i,j)\)</span>的像素值。</p><p>峰值信噪比是比较信号最大可能值与背景噪声水平的一种度量，通常以分贝(dB) 表示。其公式如下： <span class="math display">\[\text{PSNR} = 10 \cdot \log_{10} \left( \frac{\text{MAX}^2}{\text{MSE}}\right)\]</span> 其中： - <span class="math inline">\(MAX\)</span>是图像的最大可能像素值（对于8位图像，这个值是255）。- <span class="math inline">\(MSE\)</span>是原始图像和失真图像之间的均方误差。</p><p>PSNR 通常是一个正值，因为<span class="math inline">\(MAX^2\)</span>的比值对实用和有用的图像来说总是大于1。如果PSNR为负，表明图像噪声极高，几乎无法使用。这种情况在实际应用中极为罕见。</p><p>通过向测试图像添加不同量的随机噪声，可以观察到 MSE 和 PSNR的变化，这有助于理解图像质量随着噪声的恶化情况，以及这些度量如何量化这种恶化。</p><h2 id="获取加入噪声的图像">2.获取加入噪声的图像</h2><p>获取加入噪声的图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add_noise_and_evaluate</span><span class="hljs-params">(original_image)</span></span><br>    <br>    <span class="hljs-comment">% 添加盐和胡椒噪声,可以改变噪声的密度，表示图像中受噪声影响的像素比例。例如，0.05 表示5%的像素会被随机设为0或1（黑或白）</span><br>    sp_noisy_image = imnoise(original_image, <span class="hljs-string">&#x27;salt &amp; pepper&#x27;</span>, <span class="hljs-number">0.05</span>);<br>    <span class="hljs-comment">% 计算盐和胡椒噪声的MSE和PSNR</span><br>    [mse_sp, psnr_sp] = compute_mse_psnr(original_image, sp_noisy_image);<br>    <br>    <span class="hljs-comment">% 添加高斯噪声,在这里可以改变噪声的方差</span><br>    gauss_noisy_image_1 = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.0001</span>);<br>    <span class="hljs-comment">% 计算高斯噪声的MSE和PSNR</span><br>    [mse_gauss_1, psnr_gauss_1] = compute_mse_psnr(original_image, gauss_noisy_image_1);<br>    <br>    <span class="hljs-comment">% 添加高斯噪声,在这里可以改变噪声的方差</span><br>    gauss_noisy_image_2 = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.0025</span>);<br>    <span class="hljs-comment">% 计算高斯噪声的MSE和PSNR</span><br>    [mse_gauss_2, psnr_gauss_2] = compute_mse_psnr(original_image, gauss_noisy_image_2);<br>    <br>    <span class="hljs-comment">% 显示原始图像和添加噪声后的图像</span><br>    <span class="hljs-built_in">figure</span>;<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), imshow(original_image), title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), imshow(sp_noisy_image), title(<span class="hljs-string">&#x27;盐和胡椒噪声图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), imshow(gauss_noisy_image_1), title(<span class="hljs-string">&#x27;\delta=0.01时的高斯噪声图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>), imshow(gauss_noisy_image_2), title(<span class="hljs-string">&#x27;\delta=0.05高斯噪声图像&#x27;</span>);<br>    <br>    <span class="hljs-comment">% 显示计算结果</span><br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;盐和胡椒噪声 - MSE: &#x27;</span>, num2str(mse_sp), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_sp)]);<br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;标准差=0.01时的高斯噪声 - MSE: &#x27;</span>, num2str(mse_gauss_1), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_gauss_1)]);<br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;标准差=0.05时的高斯噪声 - MSE: &#x27;</span>, num2str(mse_gauss_2), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_gauss_2)]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imnoise</code> 函数是 MATLAB中用于向图像添加各种类型噪声的函数。</p></blockquote><p>计算MSE与PSNR：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[mse, psnr]</span> = <span class="hljs-title">compute_mse_psnr</span><span class="hljs-params">(original_image, noisy_image)</span></span><br>    <span class="hljs-comment">% 计算均方误差 (MSE)</span><br>    mse = immse(original_image, noisy_image);<br>    <br>    <span class="hljs-comment">% 计算峰值信噪比 (PSNR)</span><br>    max_pixel_value = <span class="hljs-number">255</span>; <span class="hljs-comment">% 对于8位图像</span><br>    psnr = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>(max_pixel_value^<span class="hljs-number">2</span> / mse);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br>add_noise_and_evaluate(original_image);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E5%8A%A0%E5%99%AA%E5%A3%B0-17159126666311.jpeg" alt="加入不同噪声后的Lena图"><figcaption aria-hidden="true">加入不同噪声后的Lena图</figcaption></figure><p>其中，盐和胡椒噪声的MSE: 935.1138, PSNR:18.4222；标准差=0.01时的高斯噪声的MSE: 6.6053, PSNR:39.9318；标准差=0.05时的高斯噪声的MSE: 162.7394, PSNR:26.0159。可以看到，MSE越小，误差越小；PSNR越大，误差越小。</p><h2 id="低通滤波高斯滤波">3.低通滤波——高斯滤波</h2><h3 id="基本原理-2">3.1 基本原理</h3><p>低通滤波：图像滤波通过对原始图像像素执行某些操作生成处理后的图像。输出图像中的每个像素是作为原始图像中一个或多个像素（通常位于输出像素附近）的函数计算的。该过程通常通过将具有所需属性的卷积核与输入图像的像素进行卷积来实现。如果卷积核是高斯核，则滤波器的行为取决于高斯的方差。</p><p>使用的高斯核的公式：<span class="math inline">\(G(x,y)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{x^2+y^2}{2\sigma^2})\)</span></p><p>2D高斯核可以分解为两个1D高斯核。用于行和列的单独方程是：</p><p>对于行：<span class="math inline">\(G_r(x)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{x^2}{2\sigma^2})\)</span></p><p>对于列：<span class="math inline">\(G_c(y)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{y^2}{2\sigma^2})\)</span></p><p>使用可分离滤波器的优点：</p><ul><li><strong>效率:</strong> 可分离滤波器将计算复杂度从<span class="math inline">\(O(n^2)\)</span>降低到<span class="math inline">\(O(n)\)</span>，其中n是核的大小。这意味着卷积操作变得更快。</li><li><strong>内存使用:</strong>它也减少了内存使用，因为使用两个较小的1D核代替一个大的2D核。</li></ul><p>σ与滤波器的截止频率之间的关系是截止频率与σ成反比。随着σ的增加，截止频率降低，导致图像更平滑和模糊。截止频率<span class="math inline">\(f_c\)</span>可以近似为：<span class="math inline">\(fc\approx\frac{1}{2\pi \sigma}\)</span></p><p>给定σ，选择卷积核大小的标准通常是确保卷积核捕获高斯函数的大部分显著值。一个常见的规则是使用大小为6σ或8σ的卷积核。这是因为高斯函数在离均值3σ或4σ以外的值非常接近零，可以忽略不计。使用此标准可以确保卷积核足够大以提供准确的滤波，同时不过分增大，避免不必要的计算成本。</p><h3 id="代码实现-2">3.2 代码实现</h3><p>将噪声功率为50 dBm的高斯噪声添加到图像Lena中，然后将噪声图像分别与σ =0.5，1，2，4，7，10的高斯核卷积。</p><p>高斯滤波：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BUPT_lowpass</span><span class="hljs-params">(original_image)</span></span><br>    <br>    <span class="hljs-comment">% 添加高斯噪声，噪声功率为50 dBm</span><br>    <span class="hljs-comment">% 噪声方差是噪声功率除以255的平方</span><br>    noise_power = <span class="hljs-number">50</span>;<br>    noisy_image = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, noise_power / <span class="hljs-number">255</span>^<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">% 定义不同sigma值的高斯核</span><br>    sigmas = [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>];<br>    filtered_images = cell(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>(sigmas));<br>    <br>    <span class="hljs-comment">% 对每个sigma值，进行高斯低通滤波</span><br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>        sigma = sigmas(k);<br>        <span class="hljs-comment">% 计算高斯核的尺寸。</span><br>        <span class="hljs-comment">% 这里我们使用了经验法则，即高斯核的大小一般取为6 * sigma左右，以确保包含足够的高斯分布信息</span><br>        <span class="hljs-comment">% 而且要是奇数，这样高斯核的中心元素可以对准图像的像素</span><br>        kernel_size = <span class="hljs-number">2</span> * <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3</span> * sigma) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">% 创建一个高斯核</span><br>        gaussian_kernel = fspecial(<span class="hljs-string">&#x27;gaussian&#x27;</span>, kernel_size, sigma);<br>        <span class="hljs-comment">% 对噪声图像进行高斯滤波</span><br>        filtered_images&#123;k&#125; = imfilter(noisy_image, gaussian_kernel, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 显示原始图像、噪声图像以及不同sigma值的滤波结果</span><br>    <br>    <span class="hljs-built_in">figure</span>;<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>    imshow(original_image);<br>    title(<span class="hljs-string">&#x27;Original Image&#x27;</span>);<br>    <br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>    imshow(noisy_image);<br>    title(<span class="hljs-string">&#x27;Noisy Image&#x27;</span>);<br>    <br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>        subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, k + <span class="hljs-number">2</span>);<br>        imshow(filtered_images&#123;k&#125;);<br>        title([<span class="hljs-string">&#x27;\sigma = &#x27;</span>, num2str(sigmas(k))]);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>fspecial</code>用于创建预定义的二维滤波器。它支持多种滤波器类型，例如高斯滤波器、均值滤波器、Laplacian滤波器等。</p><p><code>imfilter</code>用于图像滤波。它通过卷积操作将指定的滤波器核应用于输入图像。这个函数非常适用于实现各种图像处理操作，例如模糊、锐化、边缘检测等。</p><p><code>'same'</code> 是 <code>imfilter</code>函数的一个参数，用于指定输出图像的尺寸和位置与输入图像相同</p><p>卷积操作的几种不同模式：</p><ul><li><strong><code>'full'</code></strong>：输出图像包含卷积核在整个输入图像上的滑动结果，输出图像尺寸比输入图像大。</li><li><strong><code>'valid'</code></strong>：输出图像仅包含卷积核完全在输入图像内部滑动的结果，输出图像尺寸比输入图像小。</li><li><strong><code>'same'</code></strong>：输出图像尺寸与输入图像相同，卷积结果对齐到输入图像的中心位置。</li></ul></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br>BUPT_lowpass(original_image);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2.jpeg" alt="经过低通滤波的Lena图" style="zoom:150%;"></p><p>随着σ值的增加，滤波效果变得更加明显。具体来说：当σ较小，等于0.5时，图像保持了较多的细节，但噪声去除效果有限；当σ中等，等于1或2时，噪声被有效去除，图像变得更加平滑，但细节也开始丢失；当σ较大，等于4、7、10时，图像非常平滑，噪声几乎完全去除，但图像细节丢失严重，边缘变得模糊。</p><p>由此可以看出，选择适当的σ值是实现噪声去除与图像细节保留之间的平衡的关键。</p><h2 id="低通滤波矩形滤波">4.低通滤波——矩形滤波</h2><p>实现一个矩形滤波器。使用5 × 5和7 × 7内核对噪声图像Lena进行滤波。</p><p>矩形滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filtered_image</span> = <span class="hljs-title">BUPT_rect</span><span class="hljs-params">(image, kernel_size)</span></span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% kernel_size: 滤波器大小，为正奇数</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% filtered_image: 滤波后的图像</span><br><br>    <span class="hljs-comment">% 应用矩形滤波器</span><br>    kernel = <span class="hljs-built_in">ones</span>(kernel_size) / (kernel_size^<span class="hljs-number">2</span>);<br>    filtered_image = imfilter(image, kernel, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br><span class="hljs-comment">% 添加高斯噪声</span><br>noisy_lena = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>/<span class="hljs-number">255</span>^<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% 使用矩形滤波器进行滤波</span><br>filtered_lena_5x5 = BUPT_rect(noisy_lena, <span class="hljs-number">5</span>);<br>filtered_lena_7x7 = BUPT_rect(noisy_lena, <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">% 显示结果</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(original_image);<br>title(<span class="hljs-string">&#x27;原始 Lena 图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(noisy_lena);<br>title(<span class="hljs-string">&#x27;添加高斯噪声后的 Lena 图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>imshow(filtered_lena_5x5);<br>title(<span class="hljs-string">&#x27;5x5 矩形滤波器&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>imshow(filtered_lena_7x7);<br>title(<span class="hljs-string">&#x27;7x7 矩形滤波器&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E7%9F%A9%E5%BD%A2%E6%BB%A4%E6%B3%A2.jpeg" alt="经过矩形滤波的Lena图"><figcaption aria-hidden="true">经过矩形滤波的Lena图</figcaption></figure><p>由于所有邻域内像素的权重相等，矩形滤波器容易产生明显的模糊效果，特别是大尺寸核的情况下，图像细节损失严重，边缘变得不清晰。通过加权平均的方式，高斯滤波器在噪声去除的同时，保留了更多的图像细节和边缘信息。随着σ值的增加，图像逐渐变得更平滑，但高斯滤波器整体上在保留图像细节方面优于矩形滤波器。</p><p>矩形滤波器适用于一些对计算要求较低的场景，或对图像细节和边缘不太敏感的场景。高斯滤波器适用于需要平滑图像并保留细节的场景，更适合在图像处理、计算机视觉等领域使用。</p><p>通过上述比较可以看出，高斯滤波器在视觉效果和细节保留上均优于矩形滤波器，尽管计算复杂度略高，但在大多数应用中是更好的选择。</p><h1 id="八边缘检测">八、边缘检测</h1><h2 id="一阶微分算子">1.一阶微分算子</h2><p>边缘检测是图像处理与计算机视觉中的重要技术之一。其目的是检测识别出图像中亮度变化剧烈的像素点构成的集合。图像边缘的正确检测对于分析图像中的内容、实现图像中物体的分割、定位等具有重要的作用。边缘检测大大减少了源图像的数据量，剔除了与目标不相干的信息，保留了图像重要的结构属性。</p><p>图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。</p><p>一阶微分为基础的边缘检测，通过计算图像的梯度值来检测图像的边缘，如Roberts算子、Prewitt算子和Sobel算子等。</p><h3 id="roberts算子">1.1 Roberts算子</h3><p>Roberts算子是一种最简单的算子，它利用局部差分算子寻找边缘。采用对角线相邻两像素之差近似<strong>梯度幅值</strong>检测边缘，检测垂直边缘的效果比斜向边缘要好，定位精度高，但对噪声比较敏感，无法抑制噪声的影响。</p><p>Roberts算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差，如下的2个卷积核形成了Roberts算子，图像中的每一个点都用这2个核做卷积。其中，<code>Gx</code>用于计算水平方向（对角线方向）的梯度，<code>Gy</code>用于计算垂直方向（对角线方向）的梯度： <span class="math display">\[G_x=\begin{bmatrix}1 &amp; 0\\0 &amp; -1\end{bmatrix},G_y=\begin{bmatrix}0 &amp; -1\\1 &amp; 0\end{bmatrix}\]</span>对于每个像素，使用这两个卷积核分别计算其在两个对角方向上的梯度。假设图像的像素值矩阵为<code>I</code>，那么在位置 <code>(i, j)</code> 处的梯度计算如下： <span class="math display">\[gradient_x = I(i, j) * G_x(1, 1) + I(i, j+1) * G_x(1, 2) + I(i+1, j) *G_x(2, 1) + I(i+1, j+1) * G_x(2, 2)\]</span></p><p><span class="math display">\[gradient_y = I(i, j) * G_y(1, 1) + I(i, j+1) * G_y(1, 2) + I(i+1, j) *G_y(2, 1) + I(i+1, j+1) * G_y(2, 2)\]</span></p><p><span class="math display">\[(梯度幅值)magnitude = \sqrt{gradient_x^2 + gradient_y^2)}\]</span></p><p>若对于输入图像I(x,y),使用Roberts算子后输出图像为g(x,y),则 <span class="math display">\[g(x,y)=\sqrt{(I(x,y)-I(x+1,y+1))^2+(I(x+1,y)-I(x,y+1))^2}\]</span>在Matlab中，Roberts算子主要是通过imfilter()函数实现边缘提取。该函数主要是利用卷积核实现对图像的卷积运算。</p><h3 id="prewitt算子">1.2 Prewitt算子</h3><p>Prewitt是一种图像边缘检测的微分算子，其原理是利用特定区域内像素值产生的差分实现边缘检测。由于Prewitt算子采用3x3模板对区域内的像素值进行计算，而Roberts算子的模板为2x2，故Prewitt算子的边缘检测结果在水平和垂直方向均比Roberts算子更加明显。Prewitt算子适合用来识别噪声较多，灰度渐变的图像。Prewitt算子卷积核如下：</p><p><span class="math display">\[G_x=\begin{bmatrix}1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 0\\-1 &amp; -1 &amp; -1\end{bmatrix},G_y=\begin{bmatrix}-1 &amp; 0 &amp; 1\\-1 &amp; 0 &amp; 1\\-1 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><h3 id="sobel算子">1.3 Sobel算子</h3><p>在边缘检测中，常用的一种模板是Sobel算子。Sobel算子有两个卷积核，一个是检测水平边缘的；另一个是检测垂直边缘的。与Prewitt算子相比，Sobel算子对于像素的位置的影响做了加权，可以降低边缘模糊程度，因此效果更好。</p><p>Sobel算子卷积核如下： <span class="math display">\[G_x=\begin{bmatrix}-1 &amp; 0 &amp; 1\\-2 &amp; 0 &amp; 2\\-1 &amp; 0 &amp; 1\end{bmatrix},G_y=\begin{bmatrix}1 &amp; 2 &amp; 1\\0 &amp; 0 &amp; 0\\-1 &amp; -2 &amp; -1\end{bmatrix}\]</span></p><h2 id="代码实现-3">2.代码实现</h2><p>边缘检测函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge_image</span> = <span class="hljs-title">edge_detection</span><span class="hljs-params">(image, method)</span></span><br>    <span class="hljs-comment">% 初始化卷积核</span><br>    <span class="hljs-keyword">switch</span> method<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sobel&#x27;</span><br>            gx = [<span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-2</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br>            gy = gx&#x27;;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;roberts&#x27;</span><br>            gx = [<span class="hljs-number">1</span> <span class="hljs-number">0</span>; <span class="hljs-number">0</span> <span class="hljs-number">-1</span>];<br>            gy = [<span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prewitt&#x27;</span><br>            gx = [<span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br>            gy = gx&#x27;;<br>        <span class="hljs-keyword">otherwise</span><br>            error(<span class="hljs-string">&#x27;Unsupported edge detection method.&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 处理灰度图像</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">size</span>(image, <span class="hljs-number">3</span>) == <span class="hljs-number">1</span><br>        edge_image = apply_filter(image, gx, gy);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">% 处理RGB图像</span><br><br>        edge_image = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(image));<br>        <span class="hljs-keyword">for</span> c = <span class="hljs-number">1</span>:<span class="hljs-number">3</span><br>            edge_image(:,:,c) = apply_filter(image(:,:,c), gx, gy);<br>        <span class="hljs-keyword">end</span><br>        edge_image = uint8(edge_image);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gradient_magnitude</span> = <span class="hljs-title">apply_filter</span><span class="hljs-params">(image, gx, gy)</span></span><br>    <span class="hljs-comment">% 应用卷积</span><br>    <span class="hljs-comment">% 得到在x方向的梯度</span><br>    gradient_x = imfilter(double(image), gx, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br>    <span class="hljs-comment">% 得到在y方向的梯度</span><br>    gradient_y = imfilter(double(image), gy, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br>    <br>    <span class="hljs-comment">% 计算梯度的绝对值</span><br>    gradient_magnitude = <span class="hljs-built_in">sqrt</span>(gradient_x.^<span class="hljs-number">2</span> + gradient_y.^<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">% 正规化结果以便显示</span><br>    gradient_magnitude = uint8(<span class="hljs-number">255</span> * mat2gray(gradient_magnitude));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imfilter</code>函数用于对图像进行卷积操作，在这里用的是矩形滤波器。</p><p>使用 <code>'replicate'</code>选项处理图像边缘，使边界外的像素值等于边界上的像素值，从而避免边缘处出现人为的卷积结果。</p><p>在图像卷积过程中，需要处理卷积核超过图像边界的情况。<code>imfilter</code>提供了多种处理边界的方法，<code>replicate</code>是其中一种。以下是几种常见的边界处理方法：</p><ul><li><strong><code>replicate</code></strong>：边界外的像素值复制最近的边界内像素值。这种方法会使边缘部分的卷积结果较为平滑。</li><li><strong><code>circular</code></strong>：边界外的像素值从图像的另一侧循环复制。例如，左边界外的像素值将从右边界复制。</li><li><strong><code>symmetric</code></strong>：边界外的像素值对称于边界复制。例如，左边界外第一个像素值与左边界内第一个像素值对称。</li><li><strong><code>fill</code></strong>：边界外的像素值填充为指定的常数值，默认值为 0。</li></ul></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 加载灰度图像（PGM格式）</span><br>gray_image = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><span class="hljs-comment">% 加载RGB图像（PPM格式）</span><br>rgb_image = imread(<span class="hljs-string">&#x27;input.ppm&#x27;</span>);<br><br><span class="hljs-comment">% 对灰度图像进行边缘检测</span><br>gray_sobel = edge_detection(gray_image, <span class="hljs-string">&#x27;sobel&#x27;</span>);<br>gray_roberts = edge_detection(gray_image, <span class="hljs-string">&#x27;roberts&#x27;</span>);<br>gray_prewitt = edge_detection(gray_image, <span class="hljs-string">&#x27;prewitt&#x27;</span>);<br><br><span class="hljs-comment">% 对RGB图像进行边缘检测</span><br>rgb_sobel = edge_detection(rgb_image, <span class="hljs-string">&#x27;sobel&#x27;</span>);<br>rgb_roberts = edge_detection(rgb_image, <span class="hljs-string">&#x27;roberts&#x27;</span>);<br>rgb_prewitt = edge_detection(rgb_image, <span class="hljs-string">&#x27;prewitt&#x27;</span>);<br><br><span class="hljs-comment">% 显示结果</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); imshow(gray_sobel); title(<span class="hljs-string">&#x27;Gray Sobel&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); imshow(gray_roberts); title(<span class="hljs-string">&#x27;Gray Roberts&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); imshow(gray_prewitt); title(<span class="hljs-string">&#x27;Gray Prewitt&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); imshow(rgb_sobel); title(<span class="hljs-string">&#x27;RGB Sobel&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); imshow(rgb_roberts); title(<span class="hljs-string">&#x27;RGB Roberts&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); imshow(rgb_prewitt); title(<span class="hljs-string">&#x27;RGB Prewitt&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Peppers_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_grey-17160136154963.jpeg" alt="经过边缘检测后的Peppers灰度图像"><figcaption aria-hidden="true">经过边缘检测后的Peppers灰度图像</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Peppers_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_rgb.jpeg" alt="经过边缘检测后的Peppers的RGB图像"><figcaption aria-hidden="true">经过边缘检测后的Peppers的RGB图像</figcaption></figure><p>Roberts 算子边缘检测简单且计算效率高，但对噪声敏感。Sobel算子在存在噪声时性能较好，并且能够检测到更平滑的边缘，但计算稍复杂。Prewitt算子类似于 Sobel算子，但略简单，效果也稍差。在具体应用中可以根据需求选择合适的边缘检测算法。</p><h2 id="二阶微分算子laplacian算子">3.二阶微分算子——Laplacian算子</h2><h3 id="基本原理-3">3.1 基本原理</h3><p>二阶微分为基础的边缘检测，通过寻求二阶导数中的过零点来检测边缘，如Laplacian算子等。</p><p>Laplacian算子是n维欧几里德空间中的一个二阶微分算子，常用于图像增强和边缘提取。它通过灰度差分计算邻域内的像素，基本流程是：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作。在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。拉普拉斯滤波器是用于找到图像中的边缘的导数滤波器。由于导数滤波器对噪声非常敏感，因此在应用拉普拉斯之前通常会对图像进行平滑处理。例如，可以使用对图像进行平滑处理。将高斯低通滤波器和拉普拉斯滤波器组合的两步过程称为高斯拉普拉斯（LoG）算子。</p><h3 id="代码实现-4">3.2 代码实现</h3><p>LoG滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义LoG算子函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span> = <span class="hljs-title">LoG</span><span class="hljs-params">(image, sigma)</span></span><br>    <span class="hljs-comment">% 高斯滤波</span><br>    img_smoothed = BUPT_lowpass_1(image, sigma);<br>    <span class="hljs-comment">% 计算拉普拉斯算子</span><br>    laplacian_filter = fspecial(<span class="hljs-string">&#x27;laplacian&#x27;</span>);<br>    result = imfilter(img_smoothed, laplacian_filter,<span class="hljs-string">&#x27;conv&#x27;</span>, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>高斯滤波器(BUPT_lowpass_1)：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filtered_image</span> = <span class="hljs-title">BUPT_lowpass_1</span><span class="hljs-params">(image, sigma)</span></span><br>        kernel_size = <span class="hljs-number">2</span> * <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3</span> * sigma) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">% 创建一个高斯核</span><br>        gaussian_kernel = fspecial(<span class="hljs-string">&#x27;gaussian&#x27;</span>, kernel_size, sigma);<br>        <span class="hljs-comment">% 对噪声图像进行高斯滤波</span><br>        filtered_image = imfilter(image, gaussian_kernel,  <span class="hljs-string">&#x27;conv&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">img = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><span class="hljs-comment">% 定义不同方差值</span><br>sigmas = [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">% 显示原始图像</span><br><span class="hljs-built_in">figure</span>;<br><br><span class="hljs-comment">% 对不同的方差值进行LoG滤波并显示结果</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>    <span class="hljs-comment">% 计算LoG结果</span><br>    log_result = LoG(img, sigmas(<span class="hljs-built_in">i</span>));<br>    <br>    <span class="hljs-comment">% 显示LoG结果</span><br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">i</span>);<br>    imshow(log_result,[]);<br>    title([<span class="hljs-string">&#x27;LoG结果 (标准差=&#x27;</span>, num2str(sigmas(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;)&#x27;</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imshow(log_result, [])</code> 中的 <code>[]</code>参数是对图像进行缩放和映射的选项。当 <code>[]</code> 参数传递给<code>imshow</code> 函数时，MATLAB会自动选择适当的显示范围，使图像的最小值映射到0，最大值映射到255（对于uint8类型的图像）。这意味着函数会根据图像的最小值和最大值自动调整显示的亮度对比度，以使图像更清晰地显示在屏幕上。</p><p>如果不使用 <code>[]</code> 参数，<code>imshow(log_result)</code>将默认使用图像的原始数据范围进行显示，这可能导致图像在显示时看起来很暗或者很亮。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_Peppers.jpeg" alt="经过边缘检测的Peppers图像"><figcaption aria-hidden="true">经过边缘检测的Peppers图像</figcaption></figure><p>增加高斯滤波器的标准差的一般效果是，随着标准差的增加，高斯滤波器的模糊程度增加，导致图像变得更加模糊。这可能会导致一些细节丢失，但也会减少噪声的影响。</p><p>当LoG滤波器的掩模大小（kernelsize）对于所选择的高斯宽度（方差）来说太小时，输出的效果是LoG被截断，即只有部分边缘信息被检测到，而不是完整的边缘。这可能导致图像中的边缘检测不准确，因为边缘的某些部分被忽略了。为避免严重的截断，可以根据高斯的方差定义一个经验性规则来确定LoG掩模的大小。一般而言，LoG掩模的大小应至少为高斯滤波器的三倍，以确保边缘信息完整地包含在内。</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像与视频处理</tag>
      
      <tag>PPM</tag>
      
      <tag>PGM</tag>
      
      <tag>直方图</tag>
      
      <tag>量化</tag>
      
      <tag>采样</tag>
      
      <tag>滤波</tag>
      
      <tag>边缘检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协作非正交多址接入</title>
    <link href="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/"/>
    <url>/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一协作非正交多址接入方案">一、协作非正交多址接入方案</h1><h2 id="通过星座重排实现非正交多用户传输">1.通过星座重排实现非正交多用户传输</h2><p>本文提出了一种通过重新排列调制星座的新型非正交多址接入方案。每个用户的调制符号在叠加到不同的资源元素上之前，都要通过一个置换函数进行重映射。多用户系统的互信息被视为为每个用户找到最佳重映射的标准。采用模拟退火算法实现优化。根据误码率的数值结果，所提出的方案明显优于其他方案。</p><h3 id="引言">1.1引言</h3><p>非正交多址接入（NOMA）作为 5G无线通信的几项关键技术之一，能有效提高频谱利用率和系统容量。近年来，人们提出了多种NOMA 方案，包括功率域非正交多址接入（power domain non-orthogonalmultiple access）、稀疏码多址接入（sparse code multipleaccess，SCMA）、多用户共享接入（multi-user sharingaccess，MUSA）、模式划分多址接入（pattern division multipleaccess，PDMA）等。一般来说，这些非正交多用户接入方案都是通过发送器的符号叠加和接收器的高级多用户检测来实现非正交多用户传输的。</p><blockquote><p>Pattern Division Multiple Access (PDMA)是一种多址接入技术，旨在提高通信系统中多用户之间的频谱效率。它将时间-频率资源划分成一系列模式，每个模式用于单独的用户或用户组。通过精确的模式分配和调度，PDMA允许多个用户同时使用同一频谱资源，从而提高了系统的容量和效率。</p></blockquote><p>现有的 NOMA方案利用某些信号域的特性来区分用户，如发射功率、相位旋转、扩频序列等。目前的研究主要以系统容量或错误概率作为性能分析的标准。</p><p>大多数现有方案都利用了调制符号的振幅或者相位差。在传输过程中，振幅和相位不可避免地会受到信道衰落的影响。因此，尽管这些方案能够实现良好的性能，但它们在很大程度上依赖于信道状态信息（CSI）的正确性。一旦无法保证信道估计的准确性，性能下降就不可避免。因此，本文避免使用振幅和相位作为用户特征，而是提出了用于多用户叠加传输的星座重排（CoRe）。星座重排已在许多通信场景中实现，如中继信道、HARQ系统等。通过重新排列不同链路调制中的比特-符号映射，可以得到最小欧氏距离更大的联合星座。对于多用户传输系统，我们在将每个用户的调制符号叠加到资源元素上之前，会根据一个置换函数对其进行重新映射。从一个用户的角度来看，联合星座因与资源元素的多重连接而具有更好的距离特性。从系统的角度来看，联合星座充分利用了多维空间，并获得了更多的非重叠点。我们以可实现速率为标准，通过置换函数对系统进行优化。我们采用模拟退火算法，以可接受的复杂度搜索最佳值。数值结果表明，与其他方案相比，我们提出的方案在传输速率和误码率(BER) 方面都有显著提高。</p><p>本文的其余部分安排如下。第二节介绍了多用户叠加传输的系统模型和因子图表示法。第三节介绍了新提出的多用户传输星座重排方案，并介绍了优化准则和模拟退火算法。第四节提供了数值结果和性能讨论。第五节得出结论。</p><h3 id="多用户叠加传输的上行链路系统模型">1.2多用户叠加传输的上行链路系统模型</h3><p>在不失一般性的前提下，我们考虑一个多用户叠加传输的上行链路系统，如图1 所示，K 个用户将其数据映射到 N个资源元素上。资源要素（RE）可以是时间、频率和/或空间维度的，其中一个 RE与另一个 RE 正交。系统负载由<span class="math inline">\(\lambda=K/N\)</span>表示。如图 2所示，叠加可以用因子图来表示。</p><p>我们定义<span class="math inline">\(X=[X_1,X_2,\cdots,X_K]^T\)</span>为 K维用户符号向量，<span class="math inline">\(R=[R_1,R_2,\cdots,R_N]^T\)</span>为 N维叠加信号向量。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309103321318.png" alt="图1：多用户叠加传输的上行链路系统模型"><figcaption aria-hidden="true">图1：多用户叠加传输的上行链路系统模型</figcaption></figure><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309103405901.png" alt="图2：多用户叠加传输因子图"><figcaption aria-hidden="true">图2：多用户叠加传输因子图</figcaption></figure><p>因子图的边连接可用叠加矩阵 H 来描述。矩阵 H 的大小为 N ×K，元素为二进制。第 (n; k) 个元素用<span class="math inline">\(h_{nk}\)</span>表示。如果第 k 个用户的数据通过第 n个资源元素传输，则<span class="math inline">\(h_{nk}=1\)</span>；否则，<span class="math inline">\(h_{nk}=0\)</span>。一个 RE 上的信号叠加是来自不同UE 的调制符号的相加。那么我们有： <span class="math display">\[R=HX=\begin{bmatrix}\sum_{k=1}^Kh_{1k}X_k  \\\sum_{k=1}^Kh_{2k}X_k  \\\vdots \\\sum_{k=1}^Kh_{Nk}X_k    \end{bmatrix}\qquad (1)\]</span> 接收机接收到的信号为： <span class="math display">\[Y=R+Z\qquad (2)\]</span> 其中，<span class="math inline">\(Y=[Y_1,Y_2,\cdots,Y_N]^T\)</span>是 N维接收信号向量，<span class="math inline">\(Z=[Z_1,Z_2,\cdots,Z_N]^T\)</span>表示 N维噪声向量。</p><h3 id="星座重排的拟议方案">1.3 星座重排的拟议方案</h3><h4 id="拟议计划说明">1.3.1 拟议计划说明</h4><p>本文提出了多用户叠加传输的星座重排方法，如图3所示。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309105403057.png" alt="表I：4-PAM的π_nk(·)示例"><figcaption aria-hidden="true">表I：4-PAM的π_nk(·)示例</figcaption></figure><p>我们将用户传输的符号重新映射到每条边上，然后再叠加到 RE 上。第 k个用户设备和第 n 个资源元素之间的重映射函数用<span class="math inline">\(\pi_{nk}(·)\)</span>表示。它是M进制调制符号的排列，显然重映射符号的数量仍然是M。表Ⅰ显示了 4-PAM 的<span class="math inline">\(\pi_{nk}(·)\)</span>示例，其中 d为归一化常数。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309110021598.png" alt="图3：重新排列星座的因子图"><figcaption aria-hidden="true">图3：重新排列星座的因子图</figcaption></figure><p>图4展示了使用星座重排的优势。我们以第二个用户的 4-PAM 调制符号<span class="math inline">\(X_2\)</span>及其相连的RE（即<span class="math inline">\(R_1\)</span>和<span class="math inline">\(R_N\)</span>）为例，假设比特到符号的映射为格雷映射。如图4(b)所示，第二条边上的符号被重新映射，导致联合星座的布局发生变化。与图4(a)相比，星座的最小欧氏距离变大，因为重新映射使二维星座平面得到充分利用。</p><p>对于给定的叠加矩阵 H，系统相应的 N × K CoRe矩阵可表示为： <span class="math display">\[G = \begin{bmatrix}h_{11}\pi_{11}(·) &amp; h_{12}\pi_{12}(·) &amp; \cdots&amp;h_{1K}\pi_{1K}(·) \\h_{21}\pi_{21}(·) &amp; h_{22}\pi_{22}(·) &amp; \cdots &amp;h_{2K}\pi_{2K}(·) \\\vdots &amp; \vdots &amp;\ddots &amp; \vdots\\h_{N1}\pi_{N1}(·) &amp; h_{N2}\pi_{N2}(·) &amp; \cdots &amp;h_{NK}\pi_{NK}(·)  \end{bmatrix}\qquad (3)\]</span> 回顾公式(1)，带有 CoRe 的 RE 上的叠加信号 R 可重写为： <span class="math display">\[R=\begin{bmatrix}\sum_{k=1}^Kh_{1k}\pi_{1k}(X_k)  \\\sum_{k=1}^Kh_{2k}\pi_{2k}(X_k)  \\\vdots \\\sum_{k=1}^Kh_{Nk}\pi_{Nk}(X_k)  \end{bmatrix}\qquad (4)\]</span> <img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309112121965.png" alt="图4：不同重新映射下X2的联合星座"></p><p>举一个例子，<span class="math inline">\(K=3\)</span>，<span class="math inline">\(N=2\)</span>，并且 <span class="math display">\[H= \begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1\end{bmatrix}\qquad (5)\]</span> 则接收机接收到的信号为： <span class="math display">\[\begin{cases}Y_1=\pi_{11}(X_1)+\pi_{12}(X_2)+\pi_{13}(X_3)+Z_1\\Y_2=\pi_{21}(X_1)+\pi_{23}(X_3)+Z_2\\\end{cases}\qquad (6)\]</span>在这个例子中，我们通过图5中的星座重排来展示其优势。我们假设所有用户的传输符号都是BPSK 调制的。根据<span class="math inline">\(\pi^1(-1)=1\)</span>，<span class="math inline">\(\pi^1(1)=-1\)</span>对<span class="math inline">\(X_3\)</span>和<span class="math inline">\(R_1\)</span>之间边缘上的调制符号进行重新映射，联合星座的布局就会发生变化，如图5(b)所示。与图5(a)相比，星座的最小欧氏距离变大。更重要的是，图5(a)中重叠的星座点被分开了。图5(b)中区分的星座点数量达到了8个，这使得多用户系统的最大传输速率为1比特/用户。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240310012622259.png" alt="图5：不同重映射下K=3,N=2的联合星座"><figcaption aria-hidden="true">图5：不同重映射下K=3,N=2的联合星座</figcaption></figure><h4 id="使用-core-的可实现速率">1.3.2 使用 CoRe 的可实现速率</h4><p>可实现速率是多用户系统的一个重要性能指标，它由传输符号与接收信号之间的互信息来衡量。在CoRe设计中，通过选择适当的置换函数来最大化可实现率，从而实现系统优化。因此，在给定H 的基础上，目标是寻找一个能使系统互信息最大化的 G，即 <span class="math display">\[G^*=arg\ max(I(X;Y))\qquad (7)\]</span></p><blockquote><p>数学在argmaxg(t)中，表达的是定义域的一个子集，该子集中任一元素都可使函数g(t)取最大值。</p></blockquote><p>互信息的计算公式为： <span class="math display">\[I(X;Y)=h(Y)-h(Y|X)\qquad (8)\]</span> 假设每个用户的调制字母表都是有限的，并且服从均匀分布，则 h(Y)的值为： <span class="math display">\[h(Y)=-\intp(y)\log_2(p(y))dy~\\=-\int\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}p(y|x)\log_2(\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{\hatx}p(y|\hatx))dy~\\=\log_2(\displaystyle\prod_{k=1}^KN_k)-\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}\intp(y|x)\log_2(\displaystyle\sum_{\hat x}p(y|\hat x))dy\qquad (9)\]</span> 其中，<span class="math inline">\(N_k\)</span>是第 k个用户调制星座的基数。条件熵 h(Y|X) 可以表示为： <span class="math display">\[h(Y|X)=-\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}\intp(y|x)\log_2(p(y|x))dy\qquad (10)\]</span></p><blockquote><p><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/70.png" alt="条件熵的公式" style="zoom: 67%;"></p></blockquote><p>假设所有信道上的噪声都是高斯噪声，即<span class="math inline">\(Z_n\sim N(0,\sigma^2)\)</span>，我们有： <span class="math display">\[p(y|x)=\displaystyle\prod_{n=1}^N\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(Y_n-R_n)^2}{2\sigma^2})\qquad(11)\]</span> 不难发现，多维星座中点的布局和出现概率决定了p(y|x)。也就是说，可实现速率的优化就是找到最佳星座R。</p><h4 id="利用模拟退火算法进行优化">1.3.3 利用模拟退火算法进行优化</h4><p>我们假设每个用户使用 M 阶调制，系统需要重新映射 L 个边，即矩阵 G中非零元素的个数。由于<span class="math inline">\(\pi_{nk}(X_k)\)</span>是用户调制字母表的排列组合，因此将有<span class="math inline">\((M!)^L\)</span>种可能的解决方案。显然，用穷举搜索来找到最优解是不可能的。因此，利用模拟退火算法寻求最优G。模拟退火算法在解空间中进行随机搜索。如果新的解决方案更好，它就接受新方案；反之，它以一定概率接受新方案，而这种概率会随着温度的下降而降低。虽然它不能确保获得的解决方案是全局最优的，但它有机会通过设置几个不同的初始化来接近全局最优解决方案。</p><h3 id="数值结果及讨论">1.4 数值结果及讨论</h3><p>在本节中，我们将提供可实现速率和误码率方面的数值结果。我们首先展示了CoRe对星座布局和互信息的影响。然后介绍误码率性能，以验证互信息的比较。</p><h4 id="联合星座和互信息">1.4.1 联合星座和互信息</h4><p>为了更好地说明星座重排带来的改进，我们首先研究 K = 3 和 N = 2的小型结构。可能的边缘连接分别描述为<span class="math inline">\(H_1\)</span>、<span class="math inline">\(H_2\)</span>和<span class="math inline">\(H_3\)</span>，它们分别为： <span class="math display">\[H_1= \begin{bmatrix}1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1\end{bmatrix}\qquad (12)\]</span></p><p><span class="math display">\[H_2= \begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1  \end{bmatrix}\qquad (13)\]</span></p><p><span class="math display">\[H_3= \begin{bmatrix}1 &amp; 1 &amp; 1 \\1 &amp; 1 &amp; 1\end{bmatrix}\qquad (14)\]</span></p><p>相应的因子图如图6所示。由于我们在图5中已经表明，对于<span class="math inline">\(H_2\)</span>，使用BPSK调制可以实现1比特/用户的最大传输速率，因此现在我们将其扩展到4-PAM 调制的情况。</p><p>发射功率 p 被限制为1，即<span class="math inline">\(E(|X_k|^2)=1\)</span>，<span class="math inline">\(X_k\in [-3d,-d,d,3d]\)</span>，并且<span class="math inline">\(Z_n\sim N(0,\sigma^2)\)</span>。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311100527324.png" alt="图6：K = 3,N = 2的三个因子图"><figcaption aria-hidden="true">图6：K = 3,N = 2的三个因子图</figcaption></figure><p>图7显示了结构<span class="math inline">\(H_1\)</span>、<span class="math inline">\(H_2\)</span>和<span class="math inline">\(H_3\)</span>在最佳映射情况下每个用户的可实现速率。</p><p>我们可以看到，所有这些结构都明显得益于重映射。特别是结构<span class="math inline">\(H_3\)</span>，在没有重映射的情况下表现最差，但在进行了最佳重映射后表现最好。</p><p>现在我们研究结构<span class="math inline">\(H_3\)</span>，它是在不进行星座重排的情况下最差的结构。图8是通过模拟退火对G进行优化后得出的各用户平均互信息。我们可以发现，在不同的信噪比区域，最佳的G 矩阵是不同的。也就是说，<span class="math inline">\(G_1\)</span>是低信噪比区域的最佳选择，<span class="math inline">\(G_2\)</span> 是中等信噪比区域的最佳选择，而<span class="math inline">\(G_3\)</span>则是高信噪比区域的最佳选择。当信道条件较好时，结构<span class="math inline">\(G_3\)</span>的性能明显优于其他结构；而当信道条件较差时，结构<span class="math inline">\(G_3\)</span>的性能与其他结构相当。也就是说，<span class="math inline">\(G_3\)</span>结构适用于所有信噪比区域。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311101804437.png" alt="图7：不同映射下 H1、H2 和 H3 的可实现速率"><figcaption aria-hidden="true">图7：不同映射下 H1、H2 和 H3的可实现速率</figcaption></figure><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311101911374.png" alt="图8：采用不同重置方式 G1、G2 和 G3 时 H3的可实现速率"><figcaption aria-hidden="true">图8：采用不同重置方式 G1、G2 和 G3 时H3的可实现速率</figcaption></figure><p>根据图8中的观察结果，我们可以对重置后的星座布局进行研究。图9使用二维平面来表示与符号向量X 相关的所有可能的星座点。需要注意的是，用户符号叠加到 RE上后可能存在重叠的星座点，这些重叠点可以借助信道编码加以区分。图9(a)显示了两个RE在没有重映射的情况下的联合星座图，而图9(b,c,d)则显示了在不同信噪比下的联合星座图和相应的最佳重映射。与图9(c,d)相比，图9(b)中的星座点较少。这是因为在低信噪比情况下，为了对抗噪声，相邻星座点之间的欧氏距离应尽可能大。随着信噪比的增加，非重叠星座点的数量增加。根据熵最大化定理，当星座点具有均匀概率分布时，熵达到最大值<span class="math inline">\(K\log_2M\)</span>。由于在这种情况下噪声可以忽略不计，因此点数越多的星座可实现的速率越高。</p><p>下面，我们将参数增加到 K = 6 和 N = 4。负载系数 λ 仍为150%。我们将矩阵<span class="math inline">\(H_4\)</span>中的所有元素都设为 1，即所有用户和 RE都完全连接。矩阵<span class="math inline">\(H_5\)</span>为 PDMA系统优化的矩阵，矩阵<span class="math inline">\(H_6\)</span>取自其他方案。它们分别为： <span class="math display">\[H_5= \begin{bmatrix}1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0\end{bmatrix}\qquad (15)\]</span></p><p><span class="math display">\[H_6= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\qquad (15)\]</span></p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311111948260.png" alt="图10：采用不同映射的 H5 和 H6 的实现速率，BPSK"><figcaption aria-hidden="true">图10：采用不同映射的 H5 和 H6的实现速率，BPSK</figcaption></figure><p>首先，我们研究了文献中提出的 H5 和 H6 的可实现速率。采用 BPSK调制。从图10中可以看出，通过星座重排，互信息明显增加。如图所示，这两种结构都能达到BPSK 的最大传输速率。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311112631998.png" alt="图11：不同映射下 H4、H5 和 H6 的可实现速率，4PAM"><figcaption aria-hidden="true">图11：不同映射下 H4、H5 和 H6的可实现速率，4PAM</figcaption></figure><p>图 11 显示了采用 4PAM 调制和最佳映射的<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的可实现速率。从图11中可以看出，采用<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的系统在应用最佳重映射后都获得了显著提高。采用<span class="math inline">\(H_4\)</span>的结构改进最大，在其他结构中表现最好。同时，根据图7 和图 11 的观察结果，可实现速率从 K = 3 和 N = 2 时的 1.875比特/用户提高到 K = 6 和 N = 4 时的 1.966 比特/用户。通过增加参数 K 和N，同时保持 λ 不变，每个用户的可实现速率接近最大<span class="math inline">\(\log_2M\)</span>。</p><h4 id="误码率性能">1.4.2 误码率性能</h4><p>为了评估误码率性能，我们模拟了图 1中的结构。信道编码是速率为1/2的Turbo 码，调制为4-PAM。比特到符号的映射在调制中自然标出。经过星座重排后，符号在 AWGN信道中传输。接收机采用联合最大似然检测。由于信道编码有助于区分重叠的星座点，因此要进行迭代检测和解码。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311114246988.png" alt="图12：H4、H5 和 H6 在 AWGN 信道中不同映射的误码率性能"><figcaption aria-hidden="true">图12：H4、H5 和 H6 在 AWGN信道中不同映射的误码率性能</figcaption></figure><p>图 12 显示了 AWGN 信道中不同映射结构<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的平均误码率。在不进行星座重排的情况下，<span class="math inline">\(H_4\)</span>和<span class="math inline">\(H_5\)</span>结构不起作用，只有<span class="math inline">\(H_6\)</span>有机会恢复用户信息。在应用星座重排时，所有结构都通过使用最优重映射获得了显著改善。采用最佳映射的结构<span class="math inline">\(H_4\)</span>在误码率方面表现最佳，明显优于文献中优化的结构。图12 中的误码率性能比较与图 11 中的互信息比较一致。</p><h3 id="结论">1.5 结论</h3><p>本文提出通过星座重排实现多用户叠加传输系统。我们基于互信息对多用户系统进行了优化，并使用模拟退火算法为每个用户找到了最佳重映射。数值结果表明，与文献中的方案相比，我们提出的方案在传输速率和误码率方面都有显著提高。</p><h2 id="通过双层因子图实现协同-noma">2.通过双层因子图实现协同 NOMA</h2><p>本文通过构建双层因子图提出了协作非正交多址接入。源端用户通过叠加一些资源元素来传输他们的符号。如果目的地的非正交多址传输不成功，中继器将协助解码和转发。两条链路上的叠加结构构建了一个双层因子图。来自中继站的信息有助于区分星座重叠并改善距离特性。利用遗传算法进行优化，以最大限度地提高传输总和速率。提供了传输速率和符号错误率方面的数值结果，说明了双层因子图在合作NOMA 系统中的优越性。</p><h3 id="引言-1">2.1引言</h3><p>非正交多址接入（NOMA）被认为是一种有望提高 5G无线通信频谱效率的技术。非正交多址方案的关键概念是将不同用户的符号叠加到同一资源要素（RE）上，RE可以是时隙、频率信道、扩频码等。利用 NOMA的协同传输，即使每个节点只配备一个天线，也能获得空间自由度。</p><p>用于 5G 无线通信的合作 NOMA 近来备受关注。在协作 NOMA中，全双工和半双工模式都考虑了译码-前向（DF）中继和放大-前向（AF）中继。</p><p>关于协作 NOMA的现有研究大多基于高斯源假设，并在功率域中实现。对于离散调制的情况，相关文献十分有限。同时，中继信道的拓扑结构与因子图自然相连。然而，基于因子图扩展的协作NOMA 研究仍是空白。因此，本文提出了基于双层因子图的合作 NOMA方案。从信源到目的地的 NOMA传输被视为因子图的第一层。从中继站到目的地的传输构建了第二层，有助于区分星座重叠并改善距离特性。</p><p>有双层因子图在中继信道分布式信道编码中的应用，他采用了扩展和加长的因子图来实现编码合作。本文将双层因子图引入协作NOMA 系统。源节点的用户在多个资源元素上进行非正交传输。如果目的地的 NOMA传输不成功，中继器会对信息进行解码和转发，以协助传输。从目的地的角度来看，两条链路上的叠加结构构建了一个双层因子图。来自中继站的信息有助于区分源信息叠加中出现的星座重叠。此外，"-1"元素也包含在二进制叠加矩阵中。因此，重叠的概率降低了，联合星座的距离特性也得到了改善。为了最大限度地提高传输总和率，我们使用遗传算法进行了优化。提供了总和速率和符号错误率（SER）方面的数值结果，说明了双层因子图在合作NOMA 系统中的优越性。</p><p>本文的其余部分安排如下。首先，在第二节中使用因子图对一般的三节点中继信道进行建模。第三节提出了合作NOMA的双层因子图。第四节介绍了如何优化系统以实现最大传输速率。系统和速率和SER 性能见第五节。最后，第六部分是本文的结论。</p><h3 id="系统模型">2.2 系统模型</h3><p>本文考虑的是一般的三节点中继信道。与经典的中继模式不同，源节点（S）由多个用户设备（UE）组成。UE以非正交方式向共同接收器（即目的地(D)）传输信息。中继节点（R）协助从源节点到目的地的传输。我们假设系统以半双工模式运行：在第一阶段，源端UE向中继站和目的地广播；在第二阶段，中继站将源端的信息转发给目的地，而源端保持沉默。源端UE发出的信息叠加到多个资源元素（RE）上。同样，中继器将叠加的符号传送到目的地。最后，目的地结合信源和中继的信道观测结果来恢复信息。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311162147994.png" alt="图1. 中继信道"><figcaption aria-hidden="true">图1. 中继信道</figcaption></figure><p>中继信道模型如图 1所示。在不失一般性的前提下，我们假设有一个中继节点。扩展到多个中继节点的情况也很简单。在解码-转发协议中，中继节点对信息进行解码后再转发。我们假设源端有K 个 UE，它们彼此独立。K 个 UE 的调制符号向量为<span class="math inline">\(x_S=[x_1,x_2,\cdots,x_K]^T\)</span>。这些符号根据叠加矩阵<span class="math inline">\(H_S\)</span>映射到传输中的<span class="math inline">\(N_S\)</span>个资源元素上。目的地相应的接收信号矢量为<span class="math inline">\(y_{SD}=[y_1,y_2,\cdots,y_{N_S}]^T\)</span>。在中继节点，解码信息为<span class="math inline">\(x_R=[x_1&#39;,x_2&#39;,\cdots,x_K&#39;]^T\)</span>。中继根据叠加矩阵<span class="math inline">\(H_R\)</span>使用<span class="math inline">\(N_R\)</span>个RE 转发<span class="math inline">\(x_R\)</span>。目的地接收到的相应信号向量为<span class="math inline">\(y_{RD}=[y_{N_S+1},y_{N_S+2},\cdots,y_{N_S+N_R}]^T\)</span>。目的站根据<span class="math inline">\(y=[y_{SD}^T,y_{RD}^T]^T\)</span>进行多用户联合检测，以恢复源符号向量<span class="math inline">\(x_S\)</span>。我们假设所有资源元素的发射功率为p，所有信道的噪声均为高斯噪声。那么，系统模型可以写成： <span class="math display">\[y_{SD}=H_Sx_S+z_S\qquad\quad~\\y_{RD}=H_Rx_R+z_R\qquad (1)\]</span> 噪声矢量<span class="math inline">\(z_S=[z_1,z_2,\cdots,z_{N_S}]^T\)</span>和<span class="math inline">\(z_R=[z_{N_S+1},z_{N_S+2},\cdots,z_{N_S+N_R}]^T\)</span>，其中<span class="math inline">\(s\in[1,N_S]\)</span>时，<span class="math inline">\(z_s\sim N(0,\sigma_S^2)\)</span>；<span class="math inline">\(r\in[N_S+1,N_S+N_R]\)</span>时，<span class="math inline">\(z_r\sim N(0,\sigma_R^2)\)</span>；我们定义<span class="math inline">\(N=N_S+N_R\)</span></p><p>叠加矩阵<span class="math inline">\(H_S\)</span>和<span class="math inline">\(H_R\)</span>描述了传输符号向量与资源元素之间的联系。矩阵<span class="math inline">\(H_S\)</span>有<span class="math inline">\(N_S\)</span>行和 K 列，矩阵 <span class="math inline">\(H_R\)</span>的大小为<span class="math inline">\(N_R×K\)</span>。以<span class="math inline">\(H_S\)</span>为例，元素<span class="math inline">\(h_{nk}\)</span>代表第 n 行和第 k列的值。如果来自第 k 个 UE 的符号通过第 n 个 RE 传输，则<span class="math inline">\(h_{nk}≠0\)</span>否则<span class="math inline">\(h_{nk}=0\)</span>。每个叠加矩阵与因子图相关联。例如，图2 表示有 5 个 UE 和 3 个 RE 的叠加传输。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311172428326.png" alt="图2. 5个 UE 和3个 RE 的叠加传输"><figcaption aria-hidden="true">图2. 5个 UE 和3个 RE的叠加传输</figcaption></figure><h3 id="拟议计划">2.3 拟议计划</h3><h3 id="动机">2.3.1 动机</h3><p>我们首先来看看第一阶段的传输情况，在这一阶段中，源端 UE致力于将其信息传送到目的地。假设我们使用的是二进制叠加矩阵，即<span class="math inline">\(h_{nk}\)</span>等于 0 或 1。我们以图 2中的传输为例，其中： <span class="math display">\[H_S^{(3,5)}= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0  \\1 &amp; 1 &amp; 0 &amp; 0 &amp; 1  \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0   \end{bmatrix}\qquad (2)\]</span> 遗憾的是，这种叠加矩阵无法区分所有可能的传输符号向量。在 RE上存在重叠的叠加符号。也就是说，不同的源符号向量可能会产生相同的叠加向量。如果目的地接收到这样的叠加向量，就无法分辨出传输的是哪个源符号向量。图2 中的重叠叠加向量和相应的源符号向量列于表Ⅰ。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311173034851.png" alt="表Ⅰ.重叠的叠加向量"><figcaption aria-hidden="true">表Ⅰ.重叠的叠加向量</figcaption></figure><p>为了区分重叠的向量，目的地需要中继站提供额外的信息。通过观察表1，我们可以发现关于<span class="math inline">\(x_4\)</span>或<span class="math inline">\(x_5\)</span>的知识可以简单地消除所有重叠。因此，在第二阶段，中继会向目的地转发一个符号。</p><p>上例说明了协作 NOMA 的动机和设计原理。信源和中继的两个传输阶段为协作NOMA 构建了一个双层因子图。下面，我们将介绍拟议方案的细节。</p><h4 id="协作式-noma-的双层因子图">2.3.2 协作式 NOMA 的双层因子图</h4><p>考虑到一般系统模型，整个叠加矩阵可写成： <span class="math display">\[H= \begin{bmatrix}H_S  \\H_R   \end{bmatrix}\qquad (3)\]</span> 信源-目的地链路的因子图与叠加矩阵<span class="math inline">\(H_S\)</span>相关联，中继-目的地链路的因子图与<span class="math inline">\(H_R\)</span>相关联。整个双层因子图对应于 N 行 K列的矩阵 H。<span class="math inline">\(H_S\)</span>的设计目的是尽可能提高源-目的链路的传输速率，而<span class="math inline">\(H_R\)</span>所描述的传输有助于区分所有源符号向量。</p><p>事实上，并非所有二进制<span class="math inline">\(H_R\)</span>都能区分重叠的叠加向量。下面以 K = 6和<span class="math inline">\(N_S=3\)</span>为例进行说明。叠加矩阵<span class="math inline">\(H_S\)</span>为： <span class="math display">\[H_S^{(3,6)}= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp;0 \\1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp;0 \\0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\qquad (4)\]</span> 共有 14 个重叠叠加向量。表 II列出了最高概率—1/16的叠加矢量及其对应的源符号矢量。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311174840989.png" alt="表Ⅱ.重叠的叠加向量"><figcaption aria-hidden="true">表Ⅱ.重叠的叠加向量</figcaption></figure><p>在这个例子中，二进制<span class="math inline">\(H_R\)</span>只能减少重叠的可能性，但不能完全消除所有重叠。关键问题在于，当两个UE 的符号之和为 "0 "时，不可能对 "+1 "和"-1 "做出判断。这可以通过在两个UE 的其中一个连接中加入"-1 "来解决。因此，我们将<span class="math inline">\(H_R\)</span>中的值扩展为{-1,0,1}。如果来自第 k 个UE 的符号通过第 n 个 RE 传输，则<span class="math inline">\(h_{nk}=1\)</span>；如果符号被翻转后再传输，则<span class="math inline">\(h_{nk}=-1\)</span>；否则，<span class="math inline">\(h_{nk}=0\)</span>。K = 6、<span class="math inline">\(N_S=3\)</span>和<span class="math inline">\(N_R=2\)</span>的映射示例由图 3中的因子图表示。相应的叠加矩阵写为： <span class="math display">\[H_S^{(5,6)}= \begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp;1 \\1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp;0 \\1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp;1 \\\hline0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 &amp;0 \\0 &amp; 1 &amp; -1 &amp; 0 &amp; 0 &amp;1\end{bmatrix}\qquad (5)\]</span> 其中，上部与第一层相对应，下部与第二层相关。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311204849947.png" alt="图3. 双层因子图示例"><figcaption aria-hidden="true">图3. 双层因子图示例</figcaption></figure><h4 id="目的地联合解码">2.3.3 目的地联合解码</h4><p>目的地根据信源和中继的信道观测结果进行联合解码。在双层因子图上实现联合最大似然（ML）解码。解码向量的计算公式为：<span class="math display">\[\hat{x}= \arg \mathop{\min}\limits_{x\in X}p(y_{SD}y_{RD}|x)\qquad (6)\]</span> 由于信源—中继链路存在噪声，可能会出现<span class="math inline">\(x_S≠x_R\)</span>的情况。第 k 个用户<span class="math inline">\(x_k\)</span>的信息位和它在中继站的估计<span class="math inline">\(x_k&#39;\)</span>的信息位不同的概率为<span class="math inline">\(p(x_k≠x_k&#39;)=\varepsilon_k\)</span>。那么 (6)可以写成： <span class="math display">\[\hat{x}= \arg \mathop{\min}\limits_{x\inX}p(y_{SD}|x)p(y_{RD}|x)~\\=\arg \mathop{\min}\limits_{x\inX}p(y_{SD}|x)\displaystyle\sum_{x&#39;}p(y_{RD}|x&#39;)p(x&#39;|x)\qquad(7)\]</span> 其中<span class="math inline">\(p(x&#39;|x)=\prod_{k=1}^{K}p(x_k&#39;|x_k)\)</span>。</p><blockquote><ul><li>定义：（完备事件组/样本空间的划分）</li></ul><p>设B1，B2，…Bn是一组事件,若</p><ol type="1"><li><span class="math inline">\(\forall i≠j\in\{1,2,\cdots,n\},B_i\capB_j=\varnothing\)</span></li><li>B1∪B2∪…∪Bn=Ω</li></ol><p>则称B1，B2，…Bn样本空间Ω的一个划分，或称为样本空间Ω的一个完备事件组。</p><ul><li>定理（全概率公式）：</li></ul><p>设事件组<span class="math inline">\(\{B_i\}\)</span>是样本空间 Ω的一个划分，且P(Bi)&gt;0(i=1，2，…n)</p><p>则对任一事件A，有：</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/b7e4dcaa31a2dec0a3701849ded5b1be.svg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>定理（贝叶斯公式）：</li></ul><p>设B1，B2，…Bn…是一完备事件组，则对任一事件A，P（A）&gt;0，有</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/75e7f28a355ad71a021979ac4e46f161.svg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></blockquote><p>在联合 ML 检测中，可以通过成对差错概率（PEP）计算出 SER的上界。假设<span class="math inline">\(x_a,x_b\in\{x\}\)</span>，且第 k个 UE 中<span class="math inline">\(x_b\)</span>与<span class="math inline">\(x_a\)</span>不同，则第 k 个 UE 的平均 SER 上界为：<span class="math display">\[p_k(e)\le\frac{1}{M^K}\displaystyle\sum_{x_a}(\displaystyle\sum_{x_b,x_b^k≠x_a^k}p\{x_a\tox_b\})\qquad(8)\]</span> 其中<span class="math inline">\(p\{x_a\to x_b\}\)</span>是 K个 UE 的联合 PEP， <span class="math display">\[p\{x_a\to x_b\}=Q(\sqrt\frac{||Hx_a-Hx_b||^2}{4\sigma^2})\qquad(9)\]</span> 取所有 UE 的平均值即可得到 SER 的上限。</p><h3 id="系统优化">2.4 系统优化</h3><h4 id="和速率">2.4.1 和速率</h4><p>协作多用户传输的和速率被用作优化目标。对于一维调制，我们假设<span class="math inline">\(A_k\)</span>是星座字母表，星座大小为<span class="math inline">\(M_k\)</span>，<span class="math inline">\(k\in[1,K]\)</span>。我们将 J 定义为 K 个 UE的所有码字数，则<span class="math inline">\(J=\prod_{k=1}^{K}M_k\)</span>。传输符号向量集和为<span class="math inline">\(x_j\)</span>，j = 1, 2,...,J。集合<span class="math inline">\(y=[y_1,y_2,\cdots,y_{N_S+N_R}]^T\)</span>是包含通过AWGN 信道带有噪声矢量<span class="math inline">\(z=[z_1,z_2,\cdots,z_{N_S+N_R}]^T\)</span>的接收矢量。定义<span class="math inline">\(N=N_S+N_R\)</span>，我们计算和速率 I(X;Y)： <span class="math display">\[I(X;Y)=\displaystyle\sum_{j=1}^Jp(x_j)\int p(y|x_j)\log\frac{p(y|x_j)}{p(y)}dy\qquad(10)\]</span> 由于调制星座的等价性和独立性，我们可以得出： <span class="math display">\[I(X;Y)=\logJ-\frac{1}{J}\displaystyle\sum_{j=1}^J\int\displaystyle\prod_{n=1}^Np(y_n|x_j)\log\displaystyle\sum_{i=1}^J\frac{\displaystyle\prod_{n=1}^Np(y_n|x_i)}{\displaystyle\prod_{n=1}^Np(y_n|x_j)}dy\qquad(11)\]</span> 考虑噪声源中继链路，对于<span class="math inline">\(n\in[N_S+1,N_S+N_R]\)</span>，<span class="math inline">\(p(y_n|x_i)=\sum_{x&#39;}p(y_n|x&#39;)p(x&#39;|x_i)\)</span>。<span class="math inline">\(p(x&#39;|x_i)\)</span>的计算已在第三节第三部分中描述，过渡概率为：<span class="math display">\[p(y_n|x&#39;)=\frac{1}{\sqrt{2\pi}\sigma_R}exp[-\frac{(y_n-h_nx&#39;)^2}{2\sigma_R^2}]\qquad(12)\]</span> 其中，<span class="math inline">\(h_n\)</span>是叠加矩阵 H的第 n 行。</p><h4 id="两步优化">2.4.2 两步优化</h4><p>协作传输分两个阶段进行。相应地，优化也可分两步进行。第一步，优化从信源到目的地的传输，目的是尽可能提高该链路的传输速率。第二步，在第一阶段优化的结构基础上，最大限度地提高整体传输速率。</p><p>从因子图的角度来看，优化的第一步是为 S-D 链路选择最佳<span class="math inline">\(H_S\)</span>。在确定<span class="math inline">\(H_S\)</span>的基础上，第二步优化找出最佳<span class="math inline">\(H_R\)</span>。通过<span class="math inline">\(H_R\)</span>传输可区分重叠的星座并改善距离特性，从而有助于提高传输速率。</p><p>应用遗传算法（GA）可以实现优化。叠加矩阵被视为种群中的个体，相应的互信息就是个体的适应度。矩阵中的元素是基因，基因的排列构成染色体。通过个体选择、基因交叉和基因突变可以获得最优解。</p><p>对于 K = 5、<span class="math inline">\(N_S=3\)</span>和<span class="math inline">\(N_R=1\)</span>的系统，在高信噪比区域，GA得到的最佳<span class="math inline">\(H_S\)</span>为（2）。如第三节第一部分所述，<span class="math inline">\(H_{R_1}^{(1,5)}=\begin{bmatrix} 0 &amp;0&amp;0&amp;1&amp;0 \end{bmatrix}\)</span>或<span class="math inline">\(H_{R_1}^{(1,5)}=\begin{bmatrix} 0 &amp;0&amp;0&amp;0&amp;1 \end{bmatrix}\)</span>能够消除重叠。然而，GA得出的最佳<span class="math inline">\(H_R\)</span>是<span class="math inline">\(H_{R_2}^{(1,5)}=\begin{bmatrix} 0 &amp;1&amp;0&amp;1&amp;1 \end{bmatrix}\)</span>，它提供了更好的距离特性。</p><h4 id="联合优化">2.4.3 联合优化</h4><p>上述两步优化涉及 S-D链路和整个系统。第一阶段优化的目标是提高仅使用直接链路成功传输的概率。然而，由于第一次优化后结构已固定，第二次优化的搜索自由度受到限制。</p><p>在下面的联合优化中，我们直接优化双层叠加矩阵 H。矩阵<span class="math inline">\(H_S\)</span>取 H 的上<span class="math inline">\(N_S\)</span>行，<span class="math inline">\(H_R\)</span>等于 H 的下<span class="math inline">\(N_R\)</span>行。</p><p>下面以 K = 6 和 N = 4 为例进行说明。如果元素<span class="math inline">\(h_{nk}\)</span>从<span class="math inline">\(\{-1,0,1\}\)</span>中选择，则最优<span class="math inline">\(H^{(4,6)}\)</span>为： <span class="math display">\[H^{(4,6)}= \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 1 &amp; -1 &amp;1 \\1 &amp; 1 &amp; 1 &amp; -1 &amp; 0 &amp;1 \\0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp;1 \\\hline0 &amp; -1 &amp; 1 &amp; 1 &amp; 0 &amp;-1  \end{bmatrix}\qquad (13)\]</span>就整体传输速率而言，由于搜索空间更大，联合优化优于两步优化。但是，如果我们只关注第一阶段，取H 的上 <span class="math inline">\(N_S\)</span> 行的 S-D链路传输速率可能会低于优化 <span class="math inline">\(H_S\)</span>的传输速率。</p><h3 id="数值结果与讨论">2.5 数值结果与讨论</h3><h4 id="和速率-1">2.5.1 和速率</h4><p>在本节中，我们假定每个 UE 的信息都是 BPSK 调制的，S-D 和 R-D链路的噪声都服从<span class="math inline">\(z \simN(0,\sigma^2)\)</span>。对于两步优化，当中继节点的<span class="math inline">\(\varepsilon\)</span>不同时，我们比较了其传输速率。在所有用户的错误概率<span class="math inline">\(\varepsilon\)</span>相同的情况下，K = 6、 <span class="math inline">\(N_S\)</span> = 3 和 <span class="math inline">\(N_R\)</span> = 1 的传输速率如图 4 所示。最佳<span class="math inline">\(H_s^{(3,6)}\)</span>在第一步中获得，第三节第2部分对此进行了描述。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312162445084.png" alt="图4. 不同错误概率时的传输速率比较"><figcaption aria-hidden="true">图4.不同错误概率时的传输速率比较</figcaption></figure><p>可以看出，在<span class="math inline">\(\varepsilon\)</span> = 0时，使用 GA 搜索到的最优<span class="math inline">\(H_R^{(1,6)}=\begin{bmatrix} -1 &amp;0&amp;1&amp;0&amp;0&amp;-1\end{bmatrix}\)</span>可以使系统达到最大传输速率。即使<span class="math inline">\(\varepsilon\)</span>相对较大，传输速率仍比无中继时高得多。</p><p>下面我们将比较两种优化机制的传输速率。假设中继是无噪声的，K =5、<span class="math inline">\(N_S\)</span> = 3 和 <span class="math inline">\(N_R\)</span> = 1 时的传输速率如图 5 所示。叠加矩阵H 中的元素从<span class="math inline">\(\{-1,0,1\}\)</span>中选择。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312162940007.png" alt="图5. 不同优化机制的传输速率比较"><figcaption aria-hidden="true">图5.不同优化机制的传输速率比较</figcaption></figure><p>我们可以看到，由于使用了中继，系统的可实现传输速率得到了显著提高。比较两条实心曲线，我们可以看到联合优化比两步优化实现了更高的整体传输速率。在高信噪比区域，合作NOMA在两种优化机制下都实现了系统的最大传输速率。另一方面，如果比较两条虚线，两步优化可确保S-D链路获得更好的性能。正如第四节所述，两步优化的目标是第一阶段尽可能高的速率，而联合优化的目标是整体传输。</p><h4 id="错误性能">2.5.2 错误性能</h4><p>在本节中，我们将评估协作式 NOMA 系统的误码性能。BPSK调制符号从信源和中继站发射。在目的地，采用联合 ML 检测，并对 SER进行数值模拟。</p><p>当中继无噪声时，图 6 显示了 (2) 中<span class="math inline">\(H_S^{(3,5)}\)</span>的系统平均 SER，但<span class="math inline">\(H_R^{(1,5)}\)</span>的实现方式不同。很明显，来自中继的传输一般有助于区分重叠并改善SER 性能。<span class="math inline">\(H_R\)</span>的设计对 SER性能有重要影响。如四节第二部分所述，由于<span class="math inline">\(H_{R_2}^{(1,5)}\)</span>具有更好的距离特性，因此其性能优于<span class="math inline">\(H_{R_1}^{(1,5)}\)</span>。矩阵<span class="math inline">\(H_{R_3}^{(1,5)}=\begin{bmatrix} 0 &amp;1&amp;-1&amp;1&amp;1\end{bmatrix}\)</span>的性能最好，因为它为优化提供了更大的自由度。为了验证模拟结果，我们还加入了PEP 的上限。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312171713248.png" alt="图6. 针对 (2) 不同 HR 下的 HS 的 SER 比较"><figcaption aria-hidden="true">图6. 针对 (2) 不同 HR 下的 HS 的 SER比较</figcaption></figure><p>将"-1 "引入叠加矩阵 H 的影响如图 7 所示。在 N 和 K的每种设置下，与矩阵中没有"-1 "元素的系统相比，矩阵元素为<span class="math inline">\(\{-1,0,1\}\)</span>的系统获得了显著的增益。因子图的尺寸越大，增益就越高。这是因为因子图越大，可以探索的自由度就越高。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312172224867.png" alt="图7. 叠加矩阵中有&quot;-1 &quot;和没有&quot;-1 &quot;的 SER 比较"><figcaption aria-hidden="true">图7. 叠加矩阵中有"-1 "和没有"-1 "的 SER比较</figcaption></figure><p>图 8 显示了<span class="math inline">\(H^{(4,6)}\)</span>不同<span class="math inline">\(\varepsilon\)</span>的 SER 比较，其和速率性能如图4 所示。<span class="math inline">\(H^{(4,6)}_R\)</span>中的元素从<span class="math inline">\(\{-1,0,1\}\)</span>中选择，可以有效区分重叠，提高SER 性能。中继站的误差在一定程度上是可以容忍的，但当<span class="math inline">\(\varepsilon\)</span>较大时，误差下限是不可避免的。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312172636255.png" alt="图 8. 不同错误率时的 SER 比较"><figcaption aria-hidden="true">图 8. 不同错误率时的 SER比较</figcaption></figure><h3 id="结论-1">2.6 结论</h3><p>本文通过构建双层因子图，提出了合作式非正交多址接入。如果非正交多址传输在第一阶段没有成功，中继器会在第二阶段解码并转发信息。来自中继的信息有助于更好地区分叠加星座，并相应地提高整体传输速率。应用遗传算法进行了两种优化。提供了传输率和符号错误率方面的数值结果，验证了使用双层因子图的优势。</p><h1 id="二毕设协作非正交多址接入的研究与实现">二、毕设—协作非正交多址接入的研究与实现</h1><h2 id="对和速率公式用代码实现">1.对和速率公式用代码实现</h2><p>对和速率进行理论曲线的仿真，即用代码表示下面这个式子： <span class="math display">\[I(X;Y)=\logJ-\frac{1}{J}\displaystyle\sum_{j=1}^J\int\displaystyle\prod_{n=1}^Np(y_n|x_j)\log\displaystyle\sum_{i=1}^J\frac{\displaystyle\prod_{n=1}^Np(y_n|x_i)}{\displaystyle\prod_{n=1}^Np(y_n|x_j)}dy\]</span> 我们假定每个 UE 的信息都是 BPSK 调制的，S-D 和 R-D链路的噪声都服从<span class="math inline">\(z \simN(0,\sigma^2)\)</span>。</p><p>下面将公式以代码形式表示：</p><h3 id="计算py_nx_i">1.1 计算<span class="math inline">\(p(y_n|x_i)\)</span></h3><p><span class="math display">\[p(y_n|x_i)=\frac{1}{\sqrt{2\pi}\sigma}exp[-\frac{(y_n-H_nx)^2}{2\sigma^2}]\]</span></p><p>其中<span class="math inline">\(H_n\)</span>代表叠加矩阵的第n行。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">p</span> = <span class="hljs-title">generate_p</span><span class="hljs-params">(sigma_R, y, H ,x)</span></span><br>    p=<span class="hljs-number">1.</span>/(<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">2</span>*<span class="hljs-built_in">pi</span>)*sigma_R).*<span class="hljs-built_in">exp</span>(-(y-H*<span class="hljs-built_in">reshape</span>(x,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>)).^<span class="hljs-number">2.</span>/(<span class="hljs-number">2</span>*sigma_R^<span class="hljs-number">2</span>));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="计算displaystyleprod_n1npy_nx_i">1.2 计算<span class="math inline">\(\displaystyle\prod_{n=1}^Np(y_n|x_i)\)</span></h3><p>把<span class="math inline">\(p(y_1|x_i)\)</span>中的每个元素与<span class="math inline">\(p(y_2|x_i)\)</span>中的每个元素相乘，再与<span class="math inline">\(p(y_3|x_i)\)</span>中的每个元素相乘。最终得到的矩阵元素个数为<span class="math inline">\(length(y_1)*length(y_2)*length(y_3)\)</span>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pmul</span> = <span class="hljs-title">generate_pmul</span><span class="hljs-params">(sigma, H, y1, y2, y3, xj ,length1, length2, length3)</span></span><br><span class="hljs-comment">%             pmul=zeros(1,length1^3);</span><br><span class="hljs-comment">%             r=0;</span><br><br>           <br>            p1=generate_p(sigma, y1, H(<span class="hljs-number">1</span>,:) ,xj);<br>            p2=generate_p(sigma, y2, H(<span class="hljs-number">2</span>,:) ,xj);<br>            p3=generate_p(sigma, y3, H(<span class="hljs-number">3</span>,:) ,xj);<br>            pmul0=<span class="hljs-built_in">reshape</span>(p1.&#x27;*p2,length1^<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)*p3;<br>            pmul=<span class="hljs-built_in">reshape</span>(pmul0,<span class="hljs-number">1</span>,length1^<span class="hljs-number">3</span>);<br>            <br><span class="hljs-comment">%             %增加资源节点个数，即增加y4  </span><br><span class="hljs-comment">%             p1=generate_p(sigma, y1, H(1,:) ,xj);</span><br><span class="hljs-comment">%             p2=generate_p(sigma, y2, H(2,:) ,xj);</span><br><span class="hljs-comment">%             p3=generate_p(sigma, y3, H(3,:) ,xj);</span><br><span class="hljs-comment">%             p4=generate_p(sigma, y4, H(4,:) ,xj);</span><br><span class="hljs-comment">%             pmul0=reshape(p1.&#x27;*p2,length1^2,1)*p3;</span><br><span class="hljs-comment">%             pmul1=reshape(pmul0,length1^3,1)*p4;</span><br><span class="hljs-comment">%             pmul=reshape(pmul1,1,length1^4);</span><br><br><span class="hljs-comment">%             %优化算法：用矩阵运算代替for循环运算，提高代码运行速度         </span><br><span class="hljs-comment">%             for k=1:length1   </span><br><span class="hljs-comment">%                 p1=generate_p(sigma, y1(k), H(1,:) ,xj);</span><br><span class="hljs-comment">%                 for m=1:length2</span><br><span class="hljs-comment">%                     p2=generate_p(sigma, y2(m), H(2,:) ,xj);</span><br><span class="hljs-comment">%                     for n=1:length3</span><br><span class="hljs-comment">%                         r=r+1;</span><br><span class="hljs-comment">%                         p3=generate_p(sigma, y3(n), H(3,:) ,xj);</span><br><span class="hljs-comment">%                         pmul(r)=p1*p2*p3;</span><br><span class="hljs-comment">%                     end</span><br><span class="hljs-comment">%                 end      </span><br><span class="hljs-comment">%             end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="计算ixy">1.3 计算<span class="math inline">\(I(X;Y)\)</span></h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> sigma=<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigma_R)<br>        sumend_1=<span class="hljs-number">0</span>;  <br><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>=<span class="hljs-number">1</span>:J<br>            sum_1=<span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">length</span>(y1)^<span class="hljs-number">3</span>);<br><br>            p1=generate_pmul(sigma_R(sigma), H1, y1, y2, y3, xj&#123;<span class="hljs-built_in">j</span>&#125; ,<span class="hljs-built_in">length</span>(y1), <span class="hljs-built_in">length</span>(y2), <span class="hljs-built_in">length</span>(y3));<br><br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>= <span class="hljs-number">1</span>:J<br>                q1=generate_pmul(sigma_R(sigma), H1, y1, y2, y3, xj&#123;<span class="hljs-built_in">i</span>&#125; ,<span class="hljs-built_in">length</span>(y1), <span class="hljs-built_in">length</span>(y2), <span class="hljs-built_in">length</span>(y3));<br>                <br>                ratio1=q1./p1;<br>                sum_1=sum_1+ratio1;<br>            <span class="hljs-keyword">end</span><br>            sum_1(<span class="hljs-built_in">find</span>(<span class="hljs-built_in">isnan</span>(sum_1)==<span class="hljs-number">1</span>)) = <span class="hljs-number">1</span>;<br>            sum_1(<span class="hljs-built_in">find</span>(<span class="hljs-built_in">isinf</span>(sum_1)==<span class="hljs-number">1</span>)) = <span class="hljs-number">1</span>;<br>            integral_1=sum(p1.*<span class="hljs-built_in">log2</span>(sum_1)*(dy^<span class="hljs-number">3</span>));<br>            sumend_1=sumend_1+integral_1;<br>        <span class="hljs-keyword">end</span><br>        I1(sigma)=<span class="hljs-built_in">log2</span>(J)<span class="hljs-number">-1</span>/J*sumend_1;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="生成所有可能的发送符号向量集合">2.生成所有可能的发送符号向量集合</h2><p>每个 UE 的信息都是 BPSK调制的，则到达叠加矩阵的信号的星座字母表为[-1,1]。每个用户的发送符号为1或-1，6个用户所有可能的发送符号向量为<span class="math inline">\(2^6\)</span>个。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs matlab">A = [<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>];<br>X=&#123;A, A, A, A, A, A&#125;;<br><span class="hljs-comment">% 生成所有可能的传输符号向量集合</span><br>xj=generate_xj(X, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">xj</span> = <span class="hljs-title">generate_xj</span><span class="hljs-params">(arrays, idx)</span></span><br>    <span class="hljs-keyword">if</span> idx &gt; <span class="hljs-built_in">numel</span>(arrays)<br>        xj = &#123;[]&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 递归地生成当前数组后面的所有组合</span><br>    next_xj = generate_xj(arrays, idx + <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-comment">% 初始化当前数组的组合</span><br>    current_array = arrays&#123;idx&#125;;<br>    xj = cell(<span class="hljs-number">1</span>, <span class="hljs-built_in">numel</span>(current_array) * <span class="hljs-built_in">numel</span>(next_xj));<br>    <br>    <span class="hljs-comment">% 遍历当前数组的元素</span><br>    count = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(current_array)<br>        <span class="hljs-comment">% 在当前元素与后面的组合中进行组合</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(next_xj)<br>            xj&#123;count&#125; = [current_array(<span class="hljs-built_in">i</span>), next_xj&#123;<span class="hljs-built_in">j</span>&#125;];<br>            count = count + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协作非正交多址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复试常见题汇总</title>
    <link href="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>2024/3/30 11:18今天上午面试终于结束了，我感觉说的过去，不知道最后结果咋样。</p><h1 id="一通信原理">一、通信原理</h1><h2 id="高斯白噪声">1.高斯白噪声</h2><ul><li><u><strong>什么是白噪声，为什么叫白噪声？</strong></u></li></ul><p>噪声是一个随机过程，而随机过程有其功率谱密度函数，功率谱密度函数的形状则决定了噪声的“颜色”。</p><p>颜色为“白色”的噪声，即“白噪声”，其功率谱密度函数在整个实数范围内为常数。</p><p>有色噪声的功率谱密度函数则不为常数。</p><ul><li><strong><u>什么是白噪声，其功率谱和自相关函数有哪些特点？</u></strong></li></ul><p>白噪声是功率谱密度在整个频域范围为常数的噪声，其功率谱密度呈均匀分布，自相关函数是关于时间间隔<span class="math inline">\(\tau\)</span>的冲激函数。</p><ul><li><strong><u>高斯白噪声是什么，是功率信号还是能量信号？</u></strong></li></ul><p>白噪声是一种具有无限带宽的随机理想信号，功率谱为常数，功率分布与白光相似。高斯白噪声就是服从高斯分布的白噪声。</p><p>是功率信号。</p><h2 id="通信系统指标有效性可靠性">2.通信系统指标：有效性&amp;可靠性</h2><ul><li><u><strong>通信系统的指标是什么？</strong></u></li></ul><p>通信系统的主要性能指标是传输信息的有效性和可靠性。有效性是指在传输一定的信息量所消耗的信道资源的多少，信道资源包括信道的带宽和时间；而可靠性是指传输信息的准确程度。有效性和可靠性始终是相互矛盾的。在一定可靠性指标下，尽量提高信息的传输速率；或在一定有效性条件下，是消息的传输质量尽可能提高。根据香农公式，在信道容量一定时，可靠性和有效性之间可以彼此互换。</p><ul><li><u><strong>通信系统的指标是什么，怎么<mark>评价</mark>通信系统？</strong></u></li></ul><ol type="1"><li>有效性：传输频带（模拟通信系统），传输速率（又分波特率，比特率）（数字通信系统）；</li><li>可靠性：信噪比（模拟通信系统），差错概率（又分为误码率、误信率）（数字通信系统）；</li><li>标准性，经济性，可维护性。</li></ol><p>评价一个通信系统要从系统性能的可靠性和有效性同时考虑。可靠性的衡量指标包括误码率和各种增益等，有效性的衡量指标包括吞吐量，容量，传输速率，传输带宽等等。</p><ul><li><u><strong>模拟系统和数字系统的有效性和可靠性的衡量指标是什么？</strong></u></li></ul><p>模拟系统的有效性是通过有效带宽来衡量的，可靠性是信噪比来衡量的。</p><p>数字系统的有效性是通过频带利用率来衡量的，可靠性是误码率或者误信率。</p><p>其中有效带宽是指能够有效通过该信道信号的最大频带宽度；信噪比是信号功率和噪声功率的比值；频带利用率是单位频带内码元的传输速率；误码率是指码元在传输系统中被传错的概率，即错误码元数目在总传输码元中的比例。</p><p>补充：模拟系统的抗噪声指标为输出信噪比和制度增益。</p><ul><li><strong><u>通信系统两大关键指标及其关系？</u></strong></li></ul><p>有效性：在给定信道内，能传输多少信息。有效性一定要在相同的信道和信道带宽下衡量。</p><p>可靠性：接收信息的准确程度。</p><p><mark>度量</mark>：</p><p>模拟通信系统：</p><p>有效性：有效传输带宽越小，有效性越好。因为带宽资源是有限的。</p><p>可靠性：输出信噪比越大，可靠性越好。</p><p>数字通信系统：</p><p>有效性：频带利用率，即单位带宽所能实现的码速率或信息速率。越大越好。</p><p>可靠性：误码率。</p><p><mark>关系</mark>：</p><ol type="1"><li><p>相互矛盾。</p><p>以差错控制码为例，我们要引入冗余，对传输信息进行约束；通过在接收端检验这些约束，判断甚至更正发生的错误。显然，引入冗余就会减少有效信息的传输速率。</p><p>奈奎斯特第一准则也可以说明。如果码率增加，码元间隔减小，那么频域上的零点带宽就会增加，频带利用率下降。</p></li><li><p>通常可互换。</p><p>以调频通信系统为例，这是实现互换的最简单、最典型的系统。在大信噪比情况下，其信噪比增益与调频指数的三次方成正比。但是，由卡松公式，调频指数越高，其所占频带越宽，因此有效性越差。</p></li></ol><h2 id="数字模拟通信">3.数字/模拟通信</h2><ul><li><strong><u>简述数字通信与模拟通信的优缺点？</u></strong></li></ul><p>模拟通信优点：通过信道的信号频谱比较窄，因此信道的利用率高。</p><p>模拟通信缺点：（1）传输的信号是连续的，混入噪声干扰后不易清除，即抗干扰能力差。（2）不易保密。（3）设备不易大规模集成化。</p><p>数字通信优点：</p><p>（1）抗干扰能力强。</p><p>（2）可靠性高。</p><p>（3）由于数字信号传输采用二进制码，所以可以使用计算机对数字信号进行处理。</p><p>（4）数字通信系统可以传送各种信息，使通信系统灵活、通用，因而可以构成信号处理传送交换的现代数字通信网。</p><p>（5）数字信号易于加密处理，所以数字通信保密性强。</p><p>数字通信缺点：数字通信比模拟通信占用频带更宽。</p><ul><li><strong><u>什么是数字通信？描述数字通信系统的主要优缺点？</u></strong></li></ul><p>数字通信就是用数字信号传输信息的通信系统。数字通信系统的优点有差错可控，抗干扰能力强，易于存储，处理和交换，易于集成和加密，设备便于集成化和微机化，便于构成数字网。缺点是频带利用率不高，系统设备较为复杂。</p><ul><li><strong><u>什么是数字<mark>调制</mark>？它与模拟调制有哪些异同点？</u></strong></li></ul><p>由于数字基带信号的取值是有限的离散状态，数字调制是用载波信号的某些离散状态来表征传送的信息，在接收端对载波信号的离散调制参量估值。数字调制也有三种基本形式—调幅、调频、调相。数字调制的优点有：</p><ol type="1"><li>数字调制可以采用门限值检测；</li><li>数字脉冲在中继器中很容易再生；</li><li>通过压缩技术可以降低数字传输中所需要的带宽；</li><li>数字信号的信号质量通常优于模拟系统。</li></ol><ul><li><strong><u>数字通信的主要特点是什么？</u></strong></li></ul><ol type="1"><li>抗干扰能力强；</li><li>差错可控；</li><li>易于与各种数字终端接口，用现代计算机技术对信号进行处理、加工、变换、存储，从而形成智能网；</li><li>易于集成化，从而使通信设备微型化；</li><li>易于加密处理，且保密程度高。</li></ol><p>缺点：占用频带宽、系统设备复杂对同步要求高。</p><h2 id="调制">4.调制</h2><ul><li><strong><u>调制的目的、作用/意义？</u></strong></li></ul><p>调制的目的：是把要传输的模拟信号或数字信号变换成适合信道传输的信号，这就意味着把基带信号（信源）转变为一个相对基带频率而言频率非常高的带通信号，该信号称为已调信号，而基带信号称为调制信号。调制可以通过使高频载波随信号幅度的变化而改变载波的幅度、相位或者频率来实现。</p><p>调制的作用：</p><ol type="1"><li>调制搬移了基带信号的频谱，使已调波的频谱特性适宜信道的频谱特性。</li><li>调制将低频信号搬移到高频处，将调制信号转换成适合于信道传输的已调信号。</li><li>调制将多路基带信号搬移到不同的载波上，完成信号的频率分配，使多路信号互不干扰地在同一个信道上传输，从而实现频分复用，提高频率资源的利用率。</li><li>调制可以扩展信号带宽，提高系统抗干扰、抗衰路的能力。</li></ol><ul><li><strong><u>为什么要进行调制，即调制的目的和意义是什么？</u></strong></li></ul><ol type="1"><li>把调制信号转换成适合在信道中传输的已调信号；</li><li>实现信道的多路复用，提高信道利用率；</li><li>改善系统抗噪声性能。</li></ol><ul><li><strong><u>什么是线性调制？什么是非线性调制？</u></strong></li></ul><p>线性调制是频谱上的线性搬移。常见的线性调制有调幅，双边带调制，单边带调制和残留边带调制。非线性调制则不再是原调制信号的线性搬移，而是频谱的非线性变换，常见的有调频和调相。</p><p>线性调制是幅度调制，在波形上，幅度已调信号的幅度随基带信号的规律而成正比地变换；在频谱结构上，它的频谱完全是基带信号频谱在频域内的简单搬移，且这种搬移是线性的。但注意，“线性”并不意味着已调信号与调制信号之间符合线性变换关系。事实上，任何调制过程都是一种非线性的变换过程。</p><p>非线性调制是角度调制，已调信号频谱不再是原调制信号频谱的线性搬移，而是频谱的非线性变换，会产生与频谱搬移不同的新的频率成分，与线性调制相比，其优势是具有较高的抗噪声性能，缺点是占用更宽的带宽。</p><h2 id="基带频带传输">5.基带/频带传输</h2><ul><li><strong><u>什么是基带传输？什么是频带传输？</u></strong></li></ul><p>基带传输是按照数字信号以脉冲形式在信道上直接传输。此时的信道要有较宽的通频带。适用于小范围数据传输。</p><p>频带传输是通过对信号进行调制，使其成为具有一定频带的模拟信号。以适应在相应的信道中传输。</p><ul><li><strong><u>解释基带传输<mark>系统</mark>和频带传输系统？</u></strong></li></ul><p>基带传输系统：在某些具有低通特性的有线信道中，特别是在传输距离不太远的情况下，基带信号可以不经过载波调制而直接进行传输，这样的传输系统，成为数字基带传输系统。</p><p>频带传输系统：是用基带数字信号控制高频载波，把基带数字信号变换为频带数字信号的过程称为数字调制，已调信号通过信道传输到接收端，在接收端通过解调器把频带数字信号还原成基带数字信号，这种数字信号的反变换称为数字解调，把包含调制和解调过程的传输系统叫做数字信号的频带传输系统。</p><h2 id="模拟调制">6.模拟调制</h2><ul><li><strong><u>卡松公式是什么，它的意义是什么？</u></strong></li></ul><p>卡松公式指调频信号的带宽等于两倍的最大频偏加上调制信号的频率；说明了调频信号的带宽取决于最大频偏和调制信号的频率。</p><ul><li><strong><u>什么是过调幅失真？过调幅失真对调幅调制有哪些影响？</u></strong></li></ul><p>对于调幅信号<span class="math inline">\(s(t)=[A+m(t)]cosw_ct\)</span>，若<span class="math inline">\(A+m(t)\)</span>不能保证始终为正，则称为过调幅失真。过调幅失真将导致包络检波不能进行正确解调，此时只能使用相干解调的方式进行解调。</p><ul><li><strong><u>简述DSB与FM的优缺点？</u></strong></li></ul><p>DSB：</p><ol type="1"><li>频谱的上下边带含有相同的信息，与SSB相比有效性较差；</li><li><span class="math inline">\(\pmf_c\)</span>处没有载波分量，相干解调时需要提取载波；</li><li>信号带宽为基带带宽的两倍，与FM相比有效性较高；</li><li>FM牺牲了有效性换取了可靠性的提高，因此与FM相比可靠性较低。</li></ol><p>FM：</p><ol type="1"><li>频谱结构发生了很大变化（频率或相位随基带信号变化）；</li><li>属于非线性调制，分析较困难，只能进行近似分析；</li><li>占有较宽的信道带宽（已调信号带宽为调制信号带宽的许多倍）；</li><li>抗噪能力强，可靠性好（以牺牲带宽来换取高的抗噪能力）。</li></ol><h2 id="门限效应">7.门限效应</h2><ul><li><u><strong>什么是门限效应，什么是门限值，为什么相干解调不会出现门限效应，什么是最佳判决门限电平？</strong></u></li></ul><p>门限效应本质上是由包络检波器的非线性引起的，是当有用信号被噪声淹没，输入信噪比减小到一定程度导致输出信噪比急剧恶化的情况。开始出现门限效应的输入信噪比为门限值。使误码率最小的判决电平就是最佳门限电平。</p><p>由于相干解调信号和噪声可以分开解调，解调器的输出总是存在有效信号。</p><ul><li><strong><u>什么是门限效应，如何避免？</u></strong></li></ul><p>门限效应是由包络检波器的非线性解调导致的。相干解调中不存在门限效应，因为信号和噪声会分别进行解调。而非线性解调时，在小信噪比条件下，调制信号和噪声无法分开；并且随着输入信噪比的下降，包络检波器的输出信噪比会逐渐下降；在小于特定值（门限值）后，输出信噪比呈断崖式下降。</p><p>由于窄带调频信号可以使用相干解调，因此在功率较小的调频信号通信中，常用窄带调频，避免出现门限效应。</p><ul><li><strong><u>什么是门限效应，AM包络检波法为什么会产生门限效应，说明理由？</u></strong></li></ul><p>门限效应：输出信噪比不是按比例随着输入信噪比下降，而是急剧恶化，通常把这种现象称为解调器的门限效应。而开始出现门限效应的输入信噪比称为门限值。在大信噪比情况下，AM信号包络检波器的性能几乎与相干解调法相同。但当输入信噪比低于门限值时，将会出现门限效应，这时解调器的输出信噪比将急剧恶化，系统无法正常工作。</p><ul><li><strong><u>门限效应及其解决方法？</u></strong></li></ul><p>它是由包络检波器的非线性解调作用引起的。表现为当输入信噪比降到一定程度时，系统性能会急剧恶化。</p><p>用PLL（锁相环）进行解调，减小系统的等效带宽，从而降低输入噪声的功率，提高了输入信噪比。</p><h2 id="码间串扰">8.码间串扰</h2><ul><li><strong><u>匹配滤波器是什么，有什么作用？</u></strong></li></ul><p>匹配滤波器的频率响应是输入信号频率响应的共轭。在时域上是输入信号的反转平移。</p><p>匹配滤波器让信号尽可能大的通过，噪声尽可能小的通过，提高输出信噪比。</p><ul><li><u><strong>简述码间串扰和奈奎斯特准则？</strong></u></li></ul><p>码间串扰是前后码元对当前码元的接收产生的影响。</p><p>奈奎斯特准则是无码间串扰传输要满足的条件。</p><ul><li><strong><u>什么是码间串扰，它对通信质量有什么影响？</u></strong></li></ul><p>码间干扰是数字信号接收时，在抽样时刻接收信号中除当前码元以外的其他码元的取样值所产生的干扰。码间干扰是由于传输系统特性不理想而产生的，若系统特性不满足无码间干扰的条件，则会产生码间干扰。码间干扰会影响取样值的概率分布，使得误码率增大。</p><ul><li><u><strong>什么是码间串扰，怎样产生的，对通信质量有什么影响？</strong></u></li></ul><p>码间串扰是由于系统传输总特性不理想，导致前后码元的波形畸变、展宽，并使前面波形出现很长的拖尾，蔓延到当前码元的抽样时刻上，从而对当前码元的判决造成干扰。码间串扰严重时，会造成错误判决。</p><ul><li><u><strong>简述信道均衡？</strong></u></li></ul><p>频域均衡：从校正系统的频率特性出发，使得包括均衡器在内的基带系统的总的频率特性满足奈奎斯特准则。</p><p>时域均衡：利用均衡器产生的时间波形去直接校正发生了畸变的波形，使整个系统的冲激响应满足无码间串扰条件。</p><p>借助横向滤波器实现均衡是可能的，并且只要用无限长的横向滤波器，就能做到消除码间串扰的影响。横向滤波器可以将输入端在抽样时刻上有码间串扰的波形变换成在抽样时刻上没有码间串扰的波形，所以能实现时域均衡。</p><ul><li><strong><u>什么是时域均衡，什么是频域均衡？</u></strong></li></ul><p>时域均衡是利用均衡器产生的时间波形去直接校正已畸变的波形，使得包括均衡器在内的整个系统的冲击响应满足无码间串扰的条件。时域均衡能够根据信道特性的变化进行调整，有效地减少码间串扰。</p><p>频域均衡是指利用可调滤波器的频率特性来补偿基带系统的频率特性，使得包括均衡器在内的基带系统的总特性满足无失真传输的条件。</p><ul><li><u><strong>什么是时域均衡，为什么要时域均衡？</strong></u></li></ul><p>时域均衡是为了消除数据在传输过程中由于符号间干扰产生的影响。</p><p>时域均衡可以根据信道特性的变化进行调整，能够有效的减小码间串扰。</p><p>时域均衡是建立在消除取样点的码间干扰的基础上，并不要求传输波形的所有细节都与奈奎斯特准则所要求的理想波形一样，利用接受波形本身来进行补偿，消除取样点的码间干扰，提高判决的可靠性。</p><h2 id="数字调制">9.数字调制</h2><ul><li><strong><u>什么是多进制数字调制，有哪些优点？</u></strong></li></ul><p>采用多种基带波形的数字调制称为多进制数字调制。与二进制数字调制相比，<strong>多进制数字调制有以下几个特点</strong>：</p><ol type="1"><li>在码元速率（传码率）相同条件下，可以提高信息速率（传信率），使系统频带利用率增大。</li><li>在信息速率相同的条件下，可以降低码元速率，以提高传输的可靠性。</li></ol><blockquote><p>降低码元速率，会增加每个符号或码元的持续时间，从而减少传输过程中的信道噪声对每个符号的影响；可以增加每个符号之间的间隔，使得接收端更容易将信号与噪声分离开来。</p></blockquote><ul><li><strong><u>什么是正交幅度调制QAM？</u></strong></li></ul><p>正交幅度调制（QAM）是一种在两个正交载波上进行幅度调制的调制方式。这两个载波通常是相位差为90度的正弦波，因此被称作正交载波，QAM是一种振幅和相位联合键控，特别适用于频带资源有限的场合，QAM通过载波的某些参数的变化来传输信息，在QAM中，数据信号由相互正交的两个载波的幅度变化表示。</p><ul><li><strong><u>DPSK是如何消除相位模糊的？</u></strong></li></ul><p>DPSK—差分移相键控，用相邻码元的相位差表示基带信号，利用调制信号前后码元之间载波相对相位的变化来传递信息。</p><ul><li><u><strong>什么是GMSK？有什么优缺点？</strong></u></li></ul><p>GMSK的中文是高斯最小频移键控，是基带信号经过高斯低通滤波器的MSK。MSK的相位路径是不同斜率的直线组合成的折线，GMSK在其基础上，通过高斯滤波器使得相位路径变成了更光滑的曲线。优点：相对于MSK，具有更加集中的功率谱密度，对邻道干扰更小。缺点是有码间串扰。</p><ul><li><strong><u>OQPSK是如何减少信号包络起伏的？</u></strong></li></ul><p>OQPSK在QPSK的一个支路中加入一个延迟单元<span class="math inline">\(T_b\)</span>，使两个支路的基带的变换相差一个比特间隔，即每隔一个比特间隔只有一个支路发生相位变化，原来QPSK会出现<span class="math inline">\(\pi\)</span>相突变，OQPSK则为最大<span class="math inline">\(\frac{\pi}{2}\)</span>相突变。</p><ul><li><strong><u>什么是匹配滤波器，匹配滤波器的冲击响应是怎样的？</u></strong></li></ul><p>使滤波器的输出信噪比在某一特定时刻达到最大的滤波器就是匹配滤波器。匹配滤波器的单位冲击响应是输入信号的镜像函数。匹配滤波器的误码率仅和两种码元的波形之差的能量有关，而与波形本身无关。差别越大，误码率越小。</p><ul><li><strong><u>与单极性波相比，AMI码有什么优点？</u></strong></li></ul><ol type="1"><li>在“1”，“0”不等概率情况下，也无直流成分，并且在零附近频率的低频分量小，因此，对具有变压或其它交流耦合的传输信道来说，不受影响。</li><li>若码元极性与发端相反，收端也能正确接收。</li><li>编译码电路简单。</li></ol><ul><li><u><strong>什么是部分响应波形？什么是部分响应系统？</strong></u></li></ul><p>部分响应波形是指人为的有规律的在抽样时刻引入码间串扰，并在接收判决前再以约定的方式加以消除码间干扰，从而可以达到改善频谱的特性，压缩传输频带，还可以加速传输波形尾巴的衰落，使频带利用率提高到理论上的最大值。利用部分响应波形传输的基带系统就叫部分响应系统。由于升余弦滚降系统虽然有拖尾衰减快的优点，但是频带利用率不高，所以来设计一种部分响应系统同时满足两个优点。由于要恢复的信息码元只是接受信号中的一部分，所以叫做部分响应系统。部分响应系统是既能使频带利用率达到理论上的最大值又具有拖尾收敛快的优点的系统。</p><ul><li><strong><u>在基带传输部分响应系统中，采用预编码的意义何在？</u></strong></li></ul><p>部分响应系统的预编码是为了解决相关编码所引起的误码扩散的问题，经过预编码后，每一个输出值只跟当前输入值有关，不会出现误码扩散的现象。</p><ul><li><u><strong>数字基带传输系统的基本结构和各部分功能？</strong></u></li></ul><p>数字基带传输系统是由发送滤波器，信道，接收滤波器，抽样判决器及定时和同步系统构成。</p><p>信道信号发生器，用于把原始的基带信号转换成适合基带传输的信号；信道的作用是传输基带信号；接收滤波器的作用是接收信号并尽可能地滤除带外噪声和干扰，对信道均衡，形成有利于抽样判决的信号；抽样判决器是对接收滤波器的输出波形进行判决，恢复出基带信号；定时和同步系统的作用是为抽样判决器提供准确的抽样时钟。</p><ul><li><strong><u>数字通信系统的一般模型，并简述各个方框的功能？</u></strong></li></ul><p>信源——信源编码——加密——信道编码——调制——信道——解调——信道译码——解密——信源译码——信宿</p><p>信道编码和译码是为了压缩数据，减少冗余，提高传输的有效性。同时完成模数变换。</p><p>信道编码和译码是增加冗余，提高传输的可靠性，信道解码可以发现传输中的错误。</p><p>加密是为了保证信息的安全，人为地将传输的数字序列扰乱，只有能够对数据正确解密的人才能获取信息。</p><p>调制的目的是形成适合在信道上传输的信号，提高抗干扰能力，还可以用于实现多路复用，实现带宽和信噪比之间的转换。</p><h2 id="香农公式">10.香农公式</h2><ul><li><strong><u>香农公式是什么，怎么理解？</u></strong></li></ul><p>香农公式：<span class="math inline">\(C=B\log_2(1+S/N)\)</span>，其中C为信道容量，B为信道带宽。香农公式给出了理想情况下，<strong>理论上通信系统所能达到的极限信息传输速率</strong>。也就是说只要传输速率小于等于信道容量，则总可以找到一种信道编码技术，实现无差错传输信息。</p><p>香农定理的理解：三种增加信道容量的思路：①提高信号发射功率。②减少噪声功率。③增大信道带宽，但是用<strong>信道带宽来增加信道容量不是无限制的增大，因为信道带宽无限大时，噪声功率也无穷大</strong>。可以用带宽换取信噪比，<strong>如果给定信道容量C，则可以增大带宽来降低对信噪比要求；或者可以提高信噪比来换取较窄的频带，节约频谱资源</strong>。</p><ul><li><strong><u>香农公式有何意义？</u></strong></li></ul><p>给出了信息传输速率的上限和信道信噪比及带宽的关系。提高信噪比就能增加信道容量。当噪声功率为0的时候，信道容量无限大。增加带宽，并不能无限增加信道容量，有一个上限。</p><p>香农公式是一个被广泛公认的通信理论的基础和研究依据，也是近代信息论的基础，香农公式表明了系统的通信能力和抗干扰能力与传输信息所用带宽以及信噪比之间的关系。</p><ul><li><u><strong>香农三大定理？</strong></u></li></ul><p>香农第一定理是信源编码定理，通过信源编码，使码字尽量服从等概分布，每个码符号携带的信息量最大，可以使用尽量少的码符号传输信息。</p><p>香农第二定理是信道编码定理，指出了信息传输速率不能超出信道容量，信道容量<span class="math inline">\(C=B\log_2(1+S/N)\)</span>，如果超过信道容量，信息就不能可靠的传输。</p><p>香农第三定理是失真信源编码定理，指出了可以找到一种信源编码，编码后的传输速率略大于率失真函数，同时码字的平均失真度不大于给定的失真度。</p><blockquote><p>信息率失真函数：函数给出在满足一定失真情况下的最小信息传输速率。</p></blockquote><ul><li><strong><u>信道容量概念描述，它与什么有关？</u></strong></li></ul><ol type="1"><li>信道容量：信道中信息能够无差错传输的最大平均信息速率。</li><li>当<span class="math inline">\(S/n_0\)</span>一定时，无限增大带宽B，发现信道的容量并不会增大，此时的信道容量约为1.44<span class="math inline">\(S/n_0\)</span>。当想要以信道容量或接近信道容量的速率传递信息时，会发现为保障无差错传输的最低信噪比<span class="math inline">\(Eb/n_0\)</span>,，约为-1.6dB。</li></ol><ul><li><strong><u>什么是信道容量？</u></strong></li></ul><p>信道容量是信道的一个参数，反映了信道所能传输的最大信息量，其大小与信源无关。对不同的输入概率分布，互信息一定存在最大值。我们将这个最大值定义为信道容量，以不大于这个信道容量的速率进行传输，就能实现可靠传输。</p><h2 id="奈奎斯特采样定理">11.奈奎斯特采样定理</h2><ul><li><strong><u>描述采样定理/奈奎斯特采样定理？</u></strong></li></ul><p>采样定理最早是由奈奎斯特推导出来的，后来被香农明确说明并引用。这个定理表明如果信号的最高频率是<span class="math inline">\(f_m\)</span>，要想无失真地恢复出原信号需要的最低采样频率是2<span class="math inline">\(f_m\)</span>。因为在时域进行采样，等价于在频域进行频谱的周期搬移，搬移的周期只有大于2倍的信号最高频率才能避免频谱混叠，然后再加一个滤波器得到原始信号的频谱，再根据傅里叶变换的唯一性就可以无失真恢复出原信号。与之相关的还有频域采样定理，对序列进行N点DTFT变换，如果满足N≥M，可以无失真的恢复出原序列，如果不满足N≥M，会造成时域混叠现象。</p><blockquote><p>DTFT：离散时间傅里叶变换</p></blockquote><ul><li><u><strong>码间串扰？</strong></u></li></ul><p>由于实际信道都是有带宽的，因此在频域上与带通滤波器相乘，在时域上就是与无穷尽的Sa函数卷积，会导致时域信号无穷宽。因此在每一个码元间隔内，波形都被干扰了。</p><p>解决办法：让串扰只发生在采样点上。</p><p>我们把整个系统看作是LTI的，就得到了对级联信道的要求。这就是奈奎斯特第一准则。</p><ul><li><strong><u>奈奎斯特定律是什么？</u></strong></li></ul><p>奈奎斯特定律是一种信息速率，根据奈奎斯特定律，信道的极限速率（码元速率）等于信道带宽（低通信道）的两倍。</p><ul><li><u><strong>奈奎斯特第一准则？</strong></u></li></ul><p>只有当码速率不大于2倍信道带宽时，才有可能抽样值无失真。</p><ul><li><u><strong>什么是奈奎斯特速率和奈奎斯特<mark>间隔</mark>？</strong></u></li></ul><p>对于无失真恢复低通信号即不发生频谱混叠的所要求的最低采样速率为奈奎斯特速率。与此相对应的最小抽样间隔也即最低抽样速率的倒数为奈奎斯特间隔。</p><ul><li><strong><u>什么是奈奎斯特速率和奈奎斯特<mark>带宽</mark>，此时频带利用率有多大？</u></strong></li></ul><p>无码间串扰的情况下，系统能实现的最高传输速率就叫奈奎斯特速率，大小为<span class="math inline">\(1/T_s\)</span>；无码间串扰下，系统实现最高传输速率所需的最小传输带宽，大小为<span class="math inline">\(1/2T_s\)</span>；此时能提供的最高频带利用率为2Baud/Hz。</p><ul><li><strong><u>什么是码间干扰、产生原因、怎么解决？</u></strong></li></ul><p>什么是码间干扰（ISI）：由于信号的频带是有限的，这就造成时域是无限的，比如sinc函数，这就造成了采样时刻的抽样值可能会受到其他时刻的干扰。在一个抽样时刻，由于邻近码元的波形在该点的幅度值不为0，导致对当前码元抽样的干扰。也就是说，在抽样点得到的抽样值，不仅包含了当前码元的幅度值，还包含了临近码元的幅度值，这就是码间干扰。</p><p>产生原因：</p><ol type="1"><li>频带受限：这是在抽样判决之前，通过信道传输过来的信号需要经过一个滤波器，那么输入抽样判决器的信号，其频带宽度相比滤波之前的信号，频带受到了限制。</li><li>多径效应：同一码元波形的各个分量可能通过不同的路径传播，那么不同多径分量到达接收端的时间就不同，第一个多径分量到达的时刻和最后一个多径分量到达的时刻，这之间存在一个时间差，当这个时间差超过了一个码元的宽度之后，就意味着，上一个码元的一部分多径分量，在这个码元本应该传输完毕的时候，还没有到达接收点，而是混在了下一个码元的多径分量中到达的接收点，从而对下一个码元产生了干扰。</li></ol><p>解决办法：码间干扰的解决办法是采用均衡技术。关于码间干扰的准则有奈奎斯特准则。奈奎斯特第一准则表明信号的带宽是W，则最大无码间干扰的码元速率是2W。奈奎斯特第二准则表明，引入人为的码间干扰会提高频谱利用率，比如说部分响应系统就是引入人为的码间干扰，得到了最大的频带利用率2Baud/Hz。奈奎斯特第三准则表明如果抽样时刻的码元面积正比于脉冲的幅度，其他码元在该时刻面积为零，那么就没有码间干扰。</p><ul><li><strong><u>码间串扰，无码间串扰条件？</u></strong></li></ul><p>码间串扰是由于系统传输总特性（包括收、发滤波器和信道的特性）不理想，导致前后码元的波形畸变、展宽，并使前面波形出现很长的拖尾，蔓延到当前码元的抽样时刻上，从而对当前码元的判决造成干扰。码间串扰严重时会造成错误判决。</p><p>无码间干扰的时域条件：<span class="math inline">\(h(kT_b)=\begin{cases} 1 &amp;k=0\\ 0 &amp;k\text{为其他整数}\\\end{cases}\)</span></p><p>无码间干扰的频域条件：<span class="math inline">\(\displaystyle\sum_{k=1}^{\infty}H(f+\frac{k}{T_s})=T_s\)</span></p><p>若对h(t)在时刻<span class="math inline">\(t=KT_s\)</span>抽样，h(t)的抽样值除了在t=0时不为零外，在其他所有抽样点上均为零，就不存在码间串扰。一个系统的频谱特性若能等效成一个理想（矩形）低通滤波器，则可以实现无码间串扰。</p><blockquote><p>注意区分码间干扰和码间串扰。</p></blockquote><h2 id="眼图">12.眼图</h2><ul><li><strong><u>眼图的获取方法？</u></strong></li></ul><p>眼图的获取方法是调整示波器的扫描周期为信息码元周期的整数倍，由于示波器的“余晖效应”，示波器将显示多个周期的接受波叠加的结果。</p><ul><li><strong><u>什么是眼图，眼图由什么作用？</u></strong></li></ul><p>眼图是指接收滤波器输出信号，示波器将多个周期的接收信号叠加起来的结果，用于观察码间串扰和噪声的影响，从而估计系统的性能。另外也可以用眼图对接收滤波器的特性加以调整，以减少码间串扰和改善系统的传输性能。</p><ul><li><strong><u>简单叙述眼图和系统性能之间的关系？</u></strong></li></ul><p>最佳抽样时刻对应眼睛张开最大时刻；对定时误差的灵敏度由眼图斜边的斜率决定；图的阴影区的垂直高度，表示信号幅度畸变范围；图中央横轴位置对应判决门限电平；抽样时刻上下阴影区的间隔距离之半为噪声容限。</p><h2 id="均衡技术">13.均衡技术</h2><ul><li><strong><u>均衡技术的作用？</u></strong></li></ul><p>均衡技术是一种起校正和补偿作用的可调滤波器，使用均衡技术可以减少码间干扰，主要实现的方式是<strong>通过训练一组序列调整滤波器的权值</strong>，保证尽可能地减少码间干扰。</p><ul><li><strong><u>简述时域均衡的目的及实现方法？</u></strong></li></ul><p>时域均衡的目的是消除残留的码间干扰，减少传输失真，降低接收端的误码率。时域均衡的方法是采用横向抽头滤波器，通过设计2N+1个抽头的抽头系数，可以实现前后N个抽样值无码间干扰。</p><ul><li><u><strong>什么是升余弦滚降传输特性，为什么要设计升余弦滚降？</strong></u></li></ul><p>由于理想低通系统在实际应用中难以实现，并且理想低通滤波器的冲击响应的拖尾很长，当定时存在误差时，可能出现很严重的码间串扰。故需要设计升余弦滚降系统，它的传输特性为具有关于奈奎斯特带宽呈奇对称的振幅特性。可以利用半周期的余弦信号作为低通滤波器的下降沿。升余弦滚降系统的优点是拖尾衰减快，定时抖动不敏感；缺点是频带利用率低。</p><h2 id="多径效应">14.多径效应</h2><ul><li><strong><u>描述多径效应？</u></strong></li></ul><p>多径效应是指信号经过不同的路径到达接收端，产生的时延不同，按各自相位的叠加产生了干扰。由于多径传播的影响，会使信号的包络产生起伏，即衰落；会使信号由单频率变成窄带信号，即频率弥散现象；还会使信号的某些频率成分消失，即频率选择性衰落。解决办法主要是通过减少码元速率，比如说OFDM将串行数据转换为并行数据。一般来说，多径效应会使通信质量下降。但是，MIMO系统专门利用不同的天线发送信号，接收端再将不同码片组合起来，可以改善通信质量。</p><ul><li><strong><u>多径传播会导致什么现象？</u></strong></li></ul><p>瑞利型衰落，频率弥散和频率选择性衰落；瑞利型衰落是多径传播使单一频率的正弦信号变成了包络和相位受调制的窄带信号；从频谱上看就是频率弥散，多径传播使得单一谱线变成了窄带谱线；频率选择性衰落表示对信号不同的频率成分，信道有着不同的衰减，当失真随时间随机变化时就形成频率选择性衰落。具体的判断方法是信号的频谱比相关带宽宽时，则将产生严重的频率选择性衰落。在传输数字信号时，频率选择性衰落还会引起严重的码间干扰。</p><ul><li><strong><u>什么是相干时间、相干带宽、频率选择性衰落？</u></strong></li></ul><p>相干时间：相干时间就是信道保持恒定的最大时间差范围，发射端的同一信号在相干时间之内到达接收端，信号的衰落特性完全相似，接收端认为是一个信号。如果该信号的自相关性不好，还可能引入干扰，类似照相照出重影让人眼花缭乱。</p><p>相干带宽：它表示为信道传输特性函数相邻两个零点之间的频率间隔。如果信号的频谱比相关带宽要宽的话，则将产生严重的频率选择性衰落。</p><p>频率选择性衰落：指在不同频段上衰落特性不一样。当信号频率超过相干带宽时发生频率选择性衰落。</p><h2 id="信源编码和信道编码">15.信源编码和信道编码</h2><ul><li><strong><u>信源编码和信道编码，它们各自的作用、区别、关系？</u></strong></li></ul><p>信源编码：主要是利用信源的统计特性，解决信源的相关性，去掉信源冗余信息，从而达到压缩信源输出的信息率，提高系统有效性的目的。第三代移动通信中的信源编码包括语音压缩编码、各类图像压缩编码及多媒体数据压缩编码。</p><p>信道编码：为了保证通信系统的传输可靠性，克服信道中的噪声和干扰。它根据一定的（监督）规律在待发送的信息码元中（人为的）加入一些必要的（监督）码元，在接收端利用这些监督码元与信息码元之间的监督规律，发现和纠正差错，以提高信息码元传输的可靠性。信道编码的目的是试图以最少的监督码元为代价，以换取最大程度的可靠性的提高。</p><p>联系与区别：信源编码经过信号调制之后转变为信道编码。信源编码的作用一是将模拟信号转化为数字信号，二是对数据进行压缩；信道编码则是通过添加一定的校验位，来提高码自身的纠错能力的手段。</p><p>概括来记：</p><ol type="1"><li>信源编码：提高信息的有效性，压缩信源中的信息冗余度。对于模拟信源，还要先进行模数转换。常见的信源编码：PCM，霍夫曼编码等。</li><li>信道编码：提高信息的可靠性，发端按照一定的规则加入保护码元，收端进行相应的译码，以纠正信息传输过程中的错误。常见信道编码：循环码，卷积码。</li></ol><ul><li><strong><u>说明线性分组码的最小码距与其检错和纠错能力之间的关系。</u></strong></li></ul><p>若要检出e位错，则要求d<sub>0</sub>≥e+1。若要纠正t位错，则要求d<sub>0</sub>≥2t+1，若要纠正t位错，同时检出e位错，则要求d<sub>0</sub>≥e+t+1，其中e&gt;t。</p><h2 id="差错控制">16.差错控制</h2><ul><li><strong><u>常见的差错控制方式有哪些？有什么优缺点？</u></strong></li></ul><p>有前向纠错，检错重发，混合纠错。</p><p>前向纠错不需要反馈信道，不需要重发导致的延误，但误码率相对较高；检错重发需要反馈信道，且传输实时性较差，但误码率较低，更加可靠；混合纠错结合了前两者的优点，当错码较少时自行纠正，但是错码较多时自动重发。</p><ul><li><strong><u>请简述差错控制的基本原理及其目的？</u></strong></li></ul><p>为了能判断发送的信息是否有误，可以在发送时增加必要的附加数据，又为了能纠正一定程度的错误，就需要增加更多的附加数据，这些附加数据在不发送误码的情况下，是完全多余的，但若发生误码，便可利用信息数据与附加数据之间特定的关系实现误码检知和误码纠正，这就是差错控制编码的基本原理。</p><h2 id="衰落">17.衰落</h2><ul><li><strong><u>什么是多普勒效应？</u></strong></li></ul><p>随着移动物体与基站距离的变化，接收频率会发生变化。由远到近时，频率变大。由近到远时，频率变小。相对移动速度越大，频偏越严重。</p><ul><li><strong><u>什么是大尺度衰落和小尺度衰落？对信号的影响？</u></strong></li></ul><p>信号从发射端经过无线信道到达接收端，功率会发生衰减，主要表现为：平均路径损耗、大尺度衰落、小尺度衰落。</p><p>什么是大尺度衰落：大尺度衰落是由移动通信信道路径上的固定障碍物（建筑物、山丘、树林等）的阴影一起的，衰减特性一般服从d''律，平均信号衰落和关于平均衰落的变化具有对数正态分布的特征。利用不同测试环境下的移动通信信道的衰落中值计算公式，可以计算移动通信系统的业务覆盖范围区域。从无线系统工程的角度看，传播的衰落主要影响到无线区的覆盖。</p><p>什么是小尺度衰落：小尺度衰落是指短期内的衰落，具体指当移动台移动一个较小距离时，接收信号在短期内的快速波动。小尺度衰落由诸多因素共同决定：多径传播，移动台速度，周围物体的速度，信号传输带宽。</p><p>大尺度衰落对信号的影响：大尺度衰落可忽略不计，而且平均路径损耗和阴影衰落主要影响到无线区域的覆盖，通过合理的设计可消除这种不利影响。</p><p>小尺度衰落对信号的影响：小尺度衰落导致信号的幅度快速衰落，以致大尺度衰落可忽略不计，而且平均路径损耗和阴影衰落主要影响到无线区域的覆盖，通过合理的设计可消除这种不利影响；而多径衰落严重影响信号传输质量，并且是不可避免的，只能采用抗衰落技术来减少其影响。</p><h2 id="交织"><strong>18.交织</strong></h2><ul><li><u><strong>交织？</strong></u></li></ul><p>在通信系统中，某些错误的出现是突发的，不可预见性的。这些错误对整个系统的影响有时候会特别严重，为了最大化的减少错误对通信带来的影响，我们使用交织技术，将突发错误分散开来，利用信道编码在矫正单个错误和不太长错误时有效的特点，将信道中的突发错误转变为随机错误，两者结合来形成抗突发错误的有效形式。</p><p>通俗的讲，一个问题，在你最漫不经心的时候出现，通常会带给你一些小小的震惊，你可能需要一些时间来缓一下，然后才会得到解决问题的方法。交织就是为了让你在遇到这些问题的时候，提前做好心理建设，有备无患。当然，交织技术并不完全是一个预防，它很大程度上是一个根上的防治。在陆地移动通信信道上，比特差错通常是成串发生的，而信道编码无法解决这么长串发生的错误，所以交织技术本质上是将信号不再采用成串传输，而是将其分成多个较短的小串，小串不再采用同一个信道方向传输，用两个信号相互交织的形式，例如正弦波和余弦波相互缠绕的方式，将突发差错离散成随机差错，再利用处理随机差错的编码（Fec）等信道编码技术消除差错。</p><ul><li><u><strong>交织码和Turbo码的区别？</strong></u></li></ul><p>交织码可以把传输中的突发错误分散开来，减少不可纠的概率；Turbo码是把两个同类编码器并联在一起。</p><h2 id="复用技术">19.复用技术</h2><ul><li><strong><u>什么是频分复用、时分复用？</u></strong></li></ul><p>频分复用：就是以频段分割的方法在一个信道内实现多路通信的传输体制；</p><p>时分复用：把传输信道按时间进行分割成不同的时间段，每部分时间段称为时隙，主要用于数字信号的传输和接入。</p><ul><li><u><strong>什么是频分复用？</strong></u></li></ul><p>频分复用是一种按频率来划分信道的复用方式。在FDM中信道的带宽被分成多个互不重叠的频段（子通道），每路信号占据其中一个子通道，并且各路之间必须留有未被分配的频带（防护频带）进行分割，以防止信号重叠。在接收端采用适当的带通滤波器将多路信号分开，从而恢复所需要的信号。</p><ul><li><strong><u>CDMA技术？</u></strong></li></ul><p>CDMA是码分多址的英文缩写（Code Division MultipleAccess），它是在数字技术的分支——扩频通信技术上发展起来的一种崭新而成熟的无线通信技术。CDMA技术的原理是基于扩频技术，即将需传送的具有一定信号带宽的信息数据，用一个带宽远大于信号带宽的高速伪随机码进行调制，使原数据信号的带宽被扩展，再经载波调制并发送出去。接收端使用完全相同的伪随机码，与接收的带宽信号作相关处理，把宽带信号换成原信息数据的窄带信号即解扩，以实现信息通信。</p><ul><li><strong><u>简述OFDM调制的原理和特点？</u></strong></li></ul><p>OFDM技术：是一种多载波调制技术，具有较强的抗多径传播和抗频率选择性衰落的能力以及较高的频谱利用率。</p><p>基本思想：将宽带信道分解成许多并行的窄子信道，使每个子信道的带宽小于信道的相干带宽Bc，从而每个子信道所经历的衰落近似是平坦性衰落。</p><p>OFDM技术的特点：</p><ol type="1"><li>为了提高频带利用率和增大传输速率，各路子载波的已调信号频谱有部分重叠；</li><li>各路已调信号是严格正交的，以便接收端能完全地分离各路信号；</li><li>每路子载波的调制是多进制调制；</li><li>每路子载波的调制制度可以不同，根据各个子载波处信道特性的优劣不同采用不同的体质。</li></ol><p>采用OFDM的作用：传输更高比特速率，抗（多径）频率选择性衰落，降低由于信道不理想导致的码间串扰问题带来的信号影响。</p><h1 id="二信号与系统">二、信号与系统</h1><h2 id="信号性质">1.信号性质</h2><ul><li><strong><u>两个连续的周期信号之和什么情况下是周期信号？</u></strong></li></ul><p>两个周期信号相加后的周期都是两个信号周期的最小公倍数，若两个信号周期之比不是有理数，则相加后的信号不是周期信号。</p><ul><li><strong><u>请问信号经过希尔伯特变换后有什么变化，实现希尔伯特变换器的变换器又称为什么？</u></strong></li></ul><p>信号经希尔伯特变换后各频率分量的幅度不变，但相位将出现90°的相移，这就是说，将一个信号中原有的频率分量相移90°后，所得的时间函数就称为原信号的希尔伯特变换。因此把实现希尔伯特变换的变换器又称为90°移相器。</p><h2 id="系统">2.系统</h2><ul><li><strong><u>什么是线性系统？</u></strong></li></ul><p>线性系统是指同时满足叠加性与齐次性的系统。所谓叠加性是指当几个输入信号共同作用于系统时，总的输出等于每个输入单独作用时产生的输出之和；齐次性是指当输入信号增大若干倍时，输出也相应增大同样的倍数。</p><p>状态变量和输出变量对于所有可能的输入变量和初始状态都满足叠加原理的系统。一个由线性元部件所组成的系统必是线性系统。但是，相反的命题在某些情况下可能不成立。线性系统的状态变量与输入变量之间的因果关系可用一组线性微分方程或差分方程来描述，这种方程称为系统的数学模型。</p><ul><li><strong><u>什么是因果系统？</u></strong></li></ul><p>激励引起的响应不会出现在激励之前的系统，称为因果系统；也就是说，如果响应不依赖于将来的激励，那么系统就是因果的。</p><p>因果系统就是物理可实现系统。</p><ul><li><strong><u>什么是稳定系统？</u></strong></li></ul><p>一个系统，若对有界的激励所产生的响应也是有界的，则称该系统为有界输入有界输出稳定，简称稳定。该系统为稳定系统。</p><p>一个实际的系统一定是稳定系统，即有界的输入产生有界的输出。</p><p>对于频域来说，稳定系统是系统函数的收敛域要包含单位圆或者虚轴。</p><ul><li><strong><u>什么是时不变系统？</u></strong></li></ul><p>如果系统的参数不随时间而变化，则称此系统为时不变系统。即不管输入信号作用的时间先后，输出信号响应的形状均相同的系统。</p><p>时不变系统是满足时不变性质的系统，时不变性质：若系统满足输入延迟多少时间，其激励引起的响应也延迟多少时间。</p><ul><li><strong><u>请问系统无失真传输的条件是什么？</u></strong></li></ul><ol type="1"><li>系统的幅频特性是一个与频率无关的常数，对输入信号所有频率分量一视同仁，具有恒定的放大或缩小的功能。</li><li>系统的相频特性与频率成正比，对输入信号频率中的不同频率分量具有相同的延迟时间。</li></ol><ul><li><u><strong>振荡电路是否是稳定的，为什么？</strong></u></li></ul><p>不是稳定的，因为它的系统函数的极点不是全在左侧，而稳定的条件是系统函数的收敛域包括虚轴。</p><h2 id="卷积">3.卷积</h2><ul><li><strong><u>什么是卷积？</u></strong></li></ul><p>卷积的本质就是加权求和，它可以联系时域和频域。</p><p><strong>卷积的原理</strong>：任何一个信号都可以看成是一个个冲激信号的叠加，由于系统的线性时不变性，输出也可以看做是一个个冲激响应的叠加。将它们叠加起来就是卷积。</p><p><strong>卷积的物理意义</strong>：卷积是信号与系统中论述系统对输入信号的响应而提出的，卷积还可以作用于图像上对图像进行消除噪声、平滑滤波的作用。还有就是卷积定理，在时域上相乘就是在频域上卷积，时域卷积就是在频域上相乘。</p><p><strong>卷积的应用</strong>：(1)应用于图像处理；(2)卷积定理可以简化运算，比如FFT的使用。</p><p><strong>线性卷积</strong>：线性卷积是与循环卷积相区别的。线性卷积是两个非周期信号直接相卷积，而循环卷积则是两个非周期信号作周期延拓再取主值区间然后相卷积。</p><p>卷积的意义：当输入信号经过系统，其零状态响应可以等效为输入信号卷积系统的冲激函数。</p><h2 id="响应">4.响应</h2><ul><li><strong><u>什么是全响应？</u></strong></li></ul><p>全响应=齐次解（自由响应）+特解（强迫响应）。</p><p>齐次解：写出特征方程，求出特征根（自然频率或固有频率）；根据特征根的特点，齐次解有不同的形式；</p><p>特解：根据输入信号的形式有对应特解的形式，用待定系数法确定；在输入信号为直流和正弦信号时，特解就是稳态解。</p><p>用初始值确定积分常数，一般情况下，n阶方程有n个常数，可用n个初始值确定。</p><ul><li><strong><u>0-状态和0+状态是什么？</u></strong></li></ul><p>0-状态称为零输入时的初始状态，即初始值是由系统的储能产生的；0+状态称为加入输入后的初始状态，即初始值不仅有系统的储能，还受激励的影响。</p><p>从0-状态到0+状态的跃变：当系统已经用微分方程表示时，系统的初始值从0-状态到0+状态有没有跳变取决于微分方程右端自由项是否包含<span class="math inline">\(\delta(t)\)</span>及其各阶导数；如果包含有<span class="math inline">\(\delta(t)\)</span>及其各阶导数，说明响应的0-状态到0+状态发生了跳变。</p><p>0+状态的确定：已知0-状态求0+状态的值，可用冲激函数匹配法；求0+状态的值还可以用拉普拉斯变换中的初值定理求出。</p><ul><li><strong><u>怎么理解冲激响应？</u></strong></li></ul><p>冲激响应是系统在单位冲激信号的作用下而引起的零状态响应。一个信号可以分解为不同时延的冲激信号的叠加，这样，一个信号在经过一个系统处理之后就可以看做是很多不同时延的冲激信号经过了这个系统，这样可以大大简化我们对系统响应的计算。</p><ul><li><strong><u>什么是冲激响应和阶跃响应，它们的关系？</u></strong></li></ul><p>冲激响应：系统在单位冲激信号<span class="math inline">\(\delta(t)\)</span>作用下产生的零状态响应，称为单位冲激响应，简称冲激响应，一般用h(t)表示。</p><p>阶跃响应：系统在单位阶跃信号<span class="math inline">\(u(t)\)</span>作用下的零状态响应，称为单位阶跃响应，简称阶跃响应，一般用g(t)表示。</p><p>阶跃响应与冲激响应的关系：阶跃响应是冲激响应的积分。</p><ul><li><strong><u>冲激函数的特点？</u></strong></li></ul><p>高度无穷大，宽度无穷小，面积为1的对称窄脉冲。</p><h2 id="三大变换">5.三大变换</h2><ul><li><strong><u>傅里叶变换、拉普拉斯变换、Z变换的关系和区别？</u></strong></li></ul><p>傅里叶变换是最基本的变换，由傅里叶级数推导出。傅里叶级数只适用于周期信号，把非周期信号看成周期T趋于无穷的周期信号，就推导出傅里叶变换，能很好的处理非周期信号的频谱。但是傅里叶变换的弱点是原信号必须绝对可积，因此适用范围不广。</p><p>拉普拉斯变换是傅里叶变换的推广，傅里叶变换不适用于指数级增长的函数，而拉氏变换相当于是带有一个指数收敛因子的傅里叶变换，把频域推广到复频域，能分析的信号更广。然而缺点是从拉普拉斯变换的式子中，只能看到变量s，没有频率f的概念，要看幅频响应和相频响应，还得令<span class="math inline">\(s=j2\pi f\)</span>。</p><p>Z变换的本质是离散时间傅里叶变换（DTFT），<strong>如果说拉普拉斯变换专门分析模拟信号，那Z变换就是专门分析数字信号，Z变换可以把离散卷积变成多项式乘法，对离散数字系统能发挥很好的作用</strong>。Z变换看系统频率响应，就是令Z在复频域的单位圆上跑一圈，即<span class="math inline">\(Z=e^{j2\pif}\)</span>，即可得到频率响应。由于傅里叶变换的特性“时域离散，则频域周期”，因此离散信号的频谱必定是周期的，就是以这个单位圆为周期，Z在单位圆上不停地绕圈，就是周期重复。单位圆0°位置是实际频率0HZ，单位圆180°的实际频率就是采样频率的一半，fs/2。</p><p>总结一下：拉普拉斯变换是傅里叶变换的扩展，傅里叶变换是拉普拉斯变换的特例，z变换是离散的傅里叶变换在复平面上的扩展。</p><h1 id="三计算机网络">三、计算机网络</h1><h2 id="三次握手">1.三次握手</h2><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70.png" alt="三次握手" style="zoom: 50%;"></p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p><strong>第一次握手</strong>：客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；</p><p><strong>第二次握手</strong>：服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；</p><p><strong>第三次握手</strong>：客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手（SYN=1，ACK=y+1，seq=x+1）。</p><p>完成三次握手，客户端与服务器开始传送数据。</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70-17108316236944.png" alt="三次握手" style="zoom:50%;"></p><h2 id="四次挥手">2.四次挥手</h2><p>断开一个TCP连接需要“四次握手”。</p><p><strong>第一次挥手</strong>：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（当然，在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据），但是，此时主动关闭方还可以接受数据。</p><p><strong>第二次挥手</strong>：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p><strong>第三次挥手</strong>：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p><strong>第四次挥手</strong>：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70-17108315949982.png" alt="四次挥手" style="zoom:50%;"></p><h2 id="数据交换方式">3.数据交换方式</h2><ul><li><strong><u>数据交换方式都有哪些？</u></strong></li></ul><p>电路交换：经过建立连接、通信、释放连接三个步骤，整个报文直接从源点到目标点。</p><p>报文交换：通常我们把表示<strong>消息的整块数据</strong>成为一个<strong>报文</strong>。整个报文先传到附近的结点，全部储存下来再转发到下一个结点。</p><p>分组交换：在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。报文的一部分先传到附近的结点，再传到下一结点。</p><p>性能比较：</p><ol type="1"><li>若要传送大量数据，传送时间远大于连接建立时间，则电路交换的传送速度较快。</li><li>报文交换和分组交换不需要预先分配传送带宽，在传送突发数据时可提高整个网络的信道利用率。</li><li>分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ol><ul><li><strong><u>三种交换方式优缺点比较？</u></strong></li></ul><p>电路交换：</p><ul><li>优点：<ol type="1"><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实用性强</li><li>控制简单</li></ol></li><li>缺点：<ol type="1"><li>建立连接时间长</li><li>线路独占使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ul><p>报文交换：</p><ul><li>优点：<ol type="1"><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路的利用率</li><li>提供多目标服务</li></ol></li><li>缺点：<ol type="1"><li>引起了转发时延</li><li>需要较大的存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ul><p>分组交换：</p><ul><li><p>优点：</p><ol type="1"><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少出错率和重发数据量</li></ol></li><li><p>缺点：</p><ol type="1"><li>引起了转发时延</li><li>需要传输额外的信息量</li><li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组</li></ol></li></ul><h2 id="计算机网络体系结构分层">4.计算机网络体系结构分层</h2><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113588706576.webp" alt="OSI模型"><figcaption aria-hidden="true">OSI模型</figcaption></figure><p>TCP/IP分层：网络接口层、网际层、运输层、应用层。</p><p>五层协议：物理层、数据链路层、网络层、运输层、应用层。</p><p>物理层：负责<strong>将计算机连起来</strong>，在之间传送0和1这样的比特流。</p><p>数据链路层：工作在物理层之上，<strong>负责将数据包封装成帧</strong>，还要实现透明传输和差错检测。差错控制、流量控制、链路控制、mac寻址、区分数据和控制信息。</p><p>网络层：实现<strong>主机间</strong>的通信。选择合适的网间路由和交换结点。确保数据及时传送。</p><p>运输层：为应用层服务，实现<strong>进程间</strong>的通信。完成复用和分用的功能，实现差错控制和流量控制。</p><p>会话层：解决进程之间进行会话问题。</p><p>表示层：解决通信双方交换信息的表示问题。</p><p>应用层：通过应用进程之间的交互来实现特定网络应用。</p><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113588369094.webp" alt="协议数据单元"><figcaption aria-hidden="true">协议数据单元</figcaption></figure><h2 id="tcp和udp协议">5.TCP和UDP协议</h2><ul><li><strong><u>UDP协议的特点有哪些？</u></strong></li></ul><p>UDP协议全称是用户数据报协议，是一种无连接的协议。在OSI模型中，它在第四层-传输层，处于IP协议的上一层。</p><p>它有以下几个特点：</p><ol type="1"><li><p><strong>面向无连接</strong>：首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p></li><li><p><strong>有单播，多播，广播的功能</strong>：UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。</p></li><li><p><strong>UDP是面向报文的</strong>：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p></li><li><p><strong>不可靠性</strong>：首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包。</p></li></ol><ul><li><strong><u>TCP协议的特点有哪些？</u></strong></li></ul><p>TCP协议全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>它有以下几个特点：</p><ol type="1"><li>面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</li><li>仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li><li>面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li><li>可靠传输：对于可靠传输，判断丢包、误码，靠的是TCP的段编号以及确认号。</li><li>提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网格注入数据的速率和数量，缓解拥塞。</li><li>TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段。</li></ol><ul><li><strong><u>TCP与UDP传输协议有哪些区别？</u></strong></li></ul><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113433199182.webp" alt="UDP和TCP的对比"><figcaption aria-hidden="true">UDP和TCP的对比</figcaption></figure><ol type="1"><li>TCP基于连接，而UDP基于无连接的；</li><li>对系统资源的要求：TCP较多（TCP首部最小20字节），UDP少（UDP首部仅8字节）；</li><li>UDP程序结构较简单；</li><li>TCP是字节流模式，而UDP是数据报文模式；</li><li>TCP保证数据正确性，安全可靠，并且保证数据顺序，而UDP可能丢包，而且UDP不保证数据顺序。</li></ol><ul><li><strong><u>为什么说TCP协议传输是可靠的？</u></strong></li></ul><p>TCP的可靠性表现在：它向应用层提供的数据是无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一摸一样的</p><p>TCP采用了流量控制、拥塞控制、连续ARQ等技术来保证它的可靠性。</p><h2 id="拥塞控制和流量控制">6.拥塞控制和流量控制</h2><p>流量控制：是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。</p><p>概念：流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。</p><p>拥塞控制：是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</p><p>概念：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现锁死现象。拥塞控制是处理网络拥塞现象的一种机制。</p><ol type="1"><li>TCP发送方首先发送一个数据报，然后等待对方的回应；</li><li>得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报；</li><li>直到出现超时错误，这样，发送端就了解到了通信双方的线路承载能力，也就确定了拥塞窗口的大小。</li></ol><h2 id="网络层">7.网络层</h2><ul><li><strong><u>IP是指什么？</u></strong></li></ul><p>网络之间互连的协议（IP）是 Internet Protocol的外语缩写，在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。</p><ul><li><strong><u>MAC地址和IP的区别？</u></strong></li></ul><p>计算机网络分为七层，分别是物理层、数据链路层、网络层、运输层、会话层、表示层、应用层，MAC地址是硬件地址，用于物理层和数据链路层，IP地址是逻辑地址，用于网络层之上。交换机寻址用的是MAC地址，路由器寻找最佳路径用的是IP地址。</p><ul><li><strong><u>虚电路和数据报服务？</u></strong></li></ul><p>虚电路是发送方和接收方建立的一条逻辑电路，数据可以由发送方直接到达接收方，报文不需要带目的地址和序号，适合长时间通信的双方。数据报是通过不同的传输路径到达接收方，报文需要带目的地址和序号。但是可能会出现乱序重复丢失的现象。</p><p>虚电路和数据报都是分组交换技术，区别如下：</p><ol type="1"><li>数据报是无连接的数据交换，而虚电路是面向连接的数据交换；</li><li>数据报的分组都是通过独立的路由选择和转发，而同属于一条虚电路的分组按照同一路由转发；</li><li>数据报不保证数据的可靠交付，虚电路可靠性由网络保证；</li><li>数据报不保证分组的有序到达，虚电路保证分组的有序到达。</li></ol><h2 id="数据链路层">8.数据链路层</h2><ul><li><strong><u>交换机的概念？</u></strong></li></ul><p>交换机内部维护一张交换表（ARP表），它知道每个端口对应的MAC地址，下次传送帧的时候可以根据MAC地址直接发给对应的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p><ul><li><strong><u>简述交换机和路由器的作用？</u></strong></li></ul><p>交换机的作用可以简单的理解为将一些机器连接起来组成一个局域网。而路由器的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。</p><ul><li><strong><u>网桥的作用？</u></strong></li></ul><p>网桥是一个局域网与另一个局域网之间建立连接的桥梁。</p><p>优点：扩大物理范围、可以使用不同的物理层、互联不同的局域网、隔离碰撞域。</p><p>缺点：不能隔离广播域、没有流量控制。</p><h2 id="其他">9.其他</h2><ul><li><strong><u>计算机网络的传输媒质？</u></strong></li></ul><p>同轴电缆、双绞线、光纤。</p><ul><li><strong><u>计算机网络按照网络的拓扑结构分类？</u></strong></li></ul><p>总线型、星型、环型、树型、分布式网络。</p><ul><li><strong><u>HTTP与HTTPS有什么区别？</u></strong></li></ul><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。</p><p>两者区别：</p><ol type="1"><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者80，后者是443。</li><li>http的连接很简单，是无状态的；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><ul><li><strong><u>CSMA/CD和CSMA/CA的基本思想以及主要区别？</u></strong></li></ul><p>CSMA/CA：发送数据时先广播告知其他节点，让其他节点在某段时间内不要发送数据，以免出现碰撞。</p><p>CSMA/CD：发送前侦听，边发送边侦听，一旦出现碰撞停止发送。</p><ul><li><strong><u>两台笔记本电脑连起来后ping不同，你觉得可能存在哪些问题？</u></strong></li></ul><ol type="1"><li>首先考虑是否是网络的问题。</li><li>局域网设置问题，电脑互联是要设置的。看是否安装了必要的网络协议，最重要的是IP地址是否设置正确。</li><li>网卡驱动未安装正确。</li><li>防火墙设置有问题。</li><li>是否有什么软件阻止了ping包。</li></ol><h1 id="四移动通信">四、移动通信</h1><h2 id="多址方式">1.多址方式</h2><ul><li><strong><u>请问频分多址具体是怎样划分信道的？为了保证信道不产生明显的干扰，采用什么措施？FDMA有何特点？</u></strong></li></ul><p>FDMA对给定的频率资源规划出多个载波，通常是等间隔划分频段方式实现，一个载频对应一个物理通道；为了保证相邻信道之间不产生明显干扰，在用户信道之间，一般要设保护频带以确保频道之间相互正交；FDMA技术特点如下：每个频道只传送一路电话，一旦给移动台分配了频道，移动台和基站同时连续不断发射；信道带宽较窄，即FDMA通常使用窄带系统；系统简单，但需要双工器，同时需要精确的射频带通滤波器来消除邻道干扰和基站的杂散辐射。</p><ul><li><strong><u>请问时分多址具体是怎样划分信道的？为了保证TDMA系统正常工作，有什么要求？TDMA有何特点？</u></strong></li></ul><p>在一个带宽的无线载波上，把时间分成周期性的帧，每一帧再分割为若干时隙，每一时隙就是一个信道，分配给一个用户；同步和定时是TDMA系统正常工作的前提，具体就是要求：位同步、时隙同步、帧同步、网同步；TDMA的技术特点如下：（1）多用户共享一个载波频率，数据分组发送，不连续发送，需开关；（2）由于速率较高，往往需要采用均衡器。</p><ul><li><strong><u>请问码分多址是怎样划分信道的？如何解调？</u></strong></li></ul><p>通过不同的码序列来划分物理信道，信道在时间和频率上重合，在码字上分离；在CDMA系统中，码不但可以区分信道，还可以区分基站或用户，区分基站或用户的码统称为扰码；CDMA系统为每个用户分配了各自特定的地址码，无论从频域还是时域来看，各用户的信号都是混杂在一起的，因为这些地址码具有准正交性，接收端唯有使用完全一致的本地地址码才能解调信号。</p><h1 id="五英语">五、英语</h1><h2 id="自我介绍">1.自我介绍</h2><p>Good morning, dear teachers! I am glad to be here for this interview.My name is QinMian. I like this name because it stands for diligence. Iam from Beijing University of Posts and Telecommunications, and my majoris Information Engineering.</p><p>I would like to choose the word diligence to describe myself. I spentmore than eight hours on learning almost every day during my preparationof this exam, and that's why I am here. I don't believe luck, I don'tbelieve talent, but I do believe diligence can take me there.</p><p>During my college years, I always take study seriously and did wellin most of my specialized courses, and I got some precious learningexperience. Accordingly, I was awarded the scholarship for three times.In my junior year, I successfully passed CET-6, and working hard onEnglish equipped me with basic reading and writing abilities.</p><p>When I was a junior, I made the decision to take the postgraduateentrance examination because I hope I can get in-depth study in mymajor. In addition, I think to be a postgraduate can make myself morecompetitive in society. During the preparation for the preliminary exam,I collected a lot of major-related materials and had a betterunderstanding of my major. It made me more convinced that I wasinterested in Communications Engineering, and it also strengthened mybelief in attending graduate school.</p><p>Finally, I love our university. You know, it is selective and famous,especially in my field. What's more, our university is beautiful andfamous for its academic atmosphere. If I won the chance to study here, Iwould try my best to be a good student and a pride of our university inthe future.</p><p>Thank you for listening. This opportunity is so important to me thatI hope you can give me a high score. Thank you!</p><h2 id="常见问题">2.常见问题</h2><p>听到问题先说，Thank you for your question.</p><p>Can you talk about your plans in the postgraduate period?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326202216213.png"></p><p>Can you tell me something about your family?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326202953128.png"></p><p>How do you usually deal with your pressure?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326205706105.png"></p><p>《Green Book》: Whatever you do, do it a hundred percent, when youwork, work, when you laugh, laugh, when you eat, eat like it is yourlast meal.</p><p>I'm so sorry, teacher! I didn't hear the question clearly. Could youplease repeat it？</p><ul><li><strong><u>What research direction you are interestedin?</u></strong></li></ul><p>I want to research in the field of six generation mobile networks.Because it can bring faster transmission rates and lower latency. In thefuture, it will be applied in all aspects of our life. If I am admitted,I will continue to be strict with myself and work hard in my researchdirection.</p><ul><li><strong><u>Introduce your favorite course during your undergraduatestudies.</u></strong></li></ul><p>My favourite course is Principles of Communication. It is the mostimportant course in my major. I took the course seriously in my juniorand did well in it, and I got some precious major-related knowledge.What's more, because I like this course, in the preliminary exam, I gota high score in the course. I will continue to be strict with myself andapply the knowledge of this course to future research.</p><h1 id="六项目提问">六、项目提问</h1><ul><li><strong><u>蒙特卡洛拒绝采样？</u></strong></li></ul><p>蒙特卡洛思想是指通过随机采样和统计模拟的方式来解决问题。它的基本思想是利用随机数生成器生成符合一定概率分布的随机数，并通过大量的重复实验来估计问题的解。其目标是根据给定的概率密度函数f(x),产生服从目标分布的样本X。</p><ul><li><strong><u>毕设？</u></strong></li></ul><p>我的毕设题目是协作非正交多址接入的研究与实现，在一个三节点中继信道上，源端由多个用户设备组成，还有目的地和中继节点。源端的多个用户以非正交的方式向目的地传输信息。如果目的地的NOMA传输不成功，中继节点会对信息进行解码和转发，以协助传输。假设系统以半双工模式运行：在第一阶段，源端向中继节点和目的地传输信息；第二阶段，中继站将源端的信息转发给目的地，而源端保持沉默。最后，目的地结合信源和中继的信道观测结果来恢复信息。</p><p>源端多个用户发出的信息通过一个叠加矩阵叠加到多个资源元素上再传到目的地，同样中继节点将来自源端的信息通过另一个叠加矩阵叠加到多个资源元素上再传到目的地。两个叠加矩阵就构成了双层因子图。</p><p>我用matlab对加入中继节点和不加入中继节点时的传输速率进行了仿真，发现加入中继节点后系统的传输速率得到了提高。</p><p>另外，中继点在对来自源端的信息进行解码时可能会产生错误，这个错误率会影响传输速率，我也对这种情况进行了仿真，发现即使存在一定的错误率，有中继节点时的传输速率，依然要大于无中继节点时的传输速率。</p><p>应用遗传算法（GA）可以实现优化。</p><p>遗传算法（GeneticAlgorithm，GA）是模拟生物在自然环境中的遗传和进化的过程而形成的自适应全局优化搜索算法。</p><p>遗传算法借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种并行、高效、全局搜索的方法，它能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最优解。</p><p>叠加矩阵被视为种群中的个体，相应的互信息就是个体的适应度。矩阵中的元素是基因，基因的排列构成染色体。通过个体选择、基因交叉和基因突变可以获得最优解。</p><ul><li><strong><u>基于文本和图像的多媒体检索系统？</u></strong></li></ul><p>使用jieba分词对每首歌进行分词并统计所有词。</p><p>关键词的提取使用TF-IDF算法<strong>（term frequency–inverse documentfrequency，词频-逆文档频率）</strong>。TF是词频，表示词在文本中出现的频率；IDF是逆文档频率，表示词的常见程度。将两者相乘得到TF-IDF值，其大小表示了词对文本的重要程度，因此可以选取TF-IDF值大的作为文本的关键词。</p><p>VSM模型即向量空间模型，把提取文本内容中的关键词作为向量空间中的向量，并将向量间的相似度作为衡量文本相似度的标准。所以便可以通过求余弦相似度，来表征文本相似度。</p><p>Bag-of-words基础流程：</p><p>特征提取：使图像形成不同的图像块，并获得各图像块处的特征。</p><p>用K-means聚类算法将提取的SIFT特征聚类生成视觉词典。</p><p>K-means算法是度量样本间相似性的一种方法，该算法设置参数为K，把N个对象分成K个簇，簇内之间的相似度较高，而簇间的相似度较低。聚类中心有K个，视觉词典为K。</p><p>针对输入特征集，根据视觉词典进行量化。</p><p>把输入图像转化成视觉单词（visual words）的频率直方图。</p><p>构造特征到图像的倒排表，通过倒排表快速索引相关图像。</p><p>根据索引结果进行直方图匹配。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240328175547649.png" alt="话术" style="zoom: 67%;"></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>考研</tag>
      
      <tag>计算机网络</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动通信</title>
    <link href="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>视频教程<a href="https://www.icourse163.org/learn/HDU-1464128174?tid=1471185461#/learn/content?type=detail&amp;id=1256070370&amp;cid=1288761743">杭州电子科技大学移动通信公开课</a></li></ul><h1 id="一移动通信基础知识">一、移动通信基础知识</h1><h2 id="多址方式">1.多址方式</h2><p>多址方式就是用户间的资源分配。信号传输需要占用的资源包括频率、时间、空间、功率。</p><p>根据分配资源的不同，多址方式包含频分多址(FDMA)、时分多址(TDMA)、码分多址(CDMA)、空分多址(SDMA)、正交频分多址(OFDMA)、非正交多址(NOMA)这几类。</p><blockquote><p>NOMA在5G中采用</p></blockquote><p>FDMA的定义：在频域中一个相对窄带信道里，信号功率被集中起来传输，<strong>不同信号被分配到不同频率的信道</strong>，发往和来自邻近信道的干扰用带通滤波器限制，这样在规定的窄带里只能通过有用信号的能量，而任何其他频率的信号被排斥在外。</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218155752231.png"></p><ul><li>TDMA的定义：指一个信道由一连串周期性的时隙构成，<strong>不同信号被分配到不同的时隙里</strong>，利用定时选通来限制邻近信道的干扰，从而在规定时隙中只让有用的信号通过。</li></ul><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218160118592.png" alt="FDMA和TDMA相结合的多址方式"><figcaption aria-hidden="true">FDMA和TDMA相结合的多址方式</figcaption></figure><p>CDMA的定义：每一个信号被分配一个伪随机二进制序列进行扩频，<strong>不同信号的能量被分配到不同的伪随机序列里</strong>。</p><blockquote><p>不同用户所使用的码字是不同的，且是正交的。</p></blockquote><p>SDMA的定义：<strong>使得不同的用户信号占用不同的空间位置</strong>。不同用户信号的波束方向不同，避免了相互间的干扰。核心技术是智能天线，要求天线给每个用户分配一个点波束。</p><blockquote><p>处于不同位置的用户可以在同一时间使用同一频率和同一码型，而不会相互干扰。</p></blockquote><p>OFDMA的定义：</p><ul><li><p>是LTE系统中应用的多址方式，LTE是4G中采用的标准。</p></li><li><p>OFDM技术将带宽划分为多个重叠但正交的子载波。</p></li><li><p>而OFDMA将OFDM技术扩展到多用户，将不同的子载波分配给不同的用户。</p><blockquote><p>OFDMA是OFDM技术的演进，可以针对<strong>多个信号</strong>，通过将传输带宽划分成正交的不重叠的一系列子载波集，将不同的<strong>子载波集</strong>分配给不同的用户实现多址。</p><p>OFDM是一种调制技术，是针对<strong>一个信号</strong>，将高速数据信号转换成并行的低速子数据流，调制到若干个子信道上进行传输。</p></blockquote></li><li><p>实际上，LTE中采用的是OFDMA与TDMA结合的多址方式。</p></li></ul><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218161407617.png"></p><p>NOMA的定义：是5G中提出的一种多址方式，该方式最大的特点是为<strong>不同信号分配的功率不同</strong>，通常要结合接收端信号处理技术来消除干扰。</p><p>为什么要引入NOMA？</p><ul><li>非正交多址技术（NOMA）的<strong>基本思想</strong>是在发送端采用非正交发送，主动引入干扰信息，在接收端通过串行干扰删除（SIC）接收机实现正确解调。虽然，采用SIC技术的接收机复杂度有一定的提高，但是可以<strong>很好地提高频谱效率</strong>。</li><li><strong>用提高接收机的复杂度来换取频谱效率，这就是NOMA技术的本质</strong>。</li><li>非正交多址接入(Non-Orthogonal Multiple Access, NOMA)技术以<strong>不同功率</strong>将多个信息流在时域/频域/码域重叠的信道上传输，在相同无线资源上为多个用户同时提供无线业务。</li><li>在正交多址技术（OMA）中，只能为一个用户分配单一的无线资源，例如按频率分割或按时间分割，而NOMA方式可将一个资源分配给多个用户。在某些场景中，比如远近效应场景和广覆盖多节点接入的场景，特别是上行密集场景，采用功率复用的非正交接入多址方式较传统的正交接入有明显的性能优势，更适合未来系统的部署。目前已经有研究验证了在城市地区采用NOMA的效果，并已证实，采用该方法可使无线接入宏蜂窝的总吞吐量提高50%左右。非正交多址复用通过结合串行干扰消除或类最大似然解调才能取得容量极限，因此技术实现的难点在于是否能设计出低复杂度且有效的接收机算法。</li></ul><p><strong><mark>注意NOMA指的是非正交多址，而不是非正交频分，即NOMA的子信道传输依然采用正交频分复用（OFDM）技术，子信道之间是正交的</mark>，互不干扰，但是一个子信道上不再只分配给一个用户，而是多个用户共享，同一子信道上不同用户之间是非正交传输<mark>（即非正交多址）</mark>，这样就会产生用户间干扰问题，这也就是在接收端要采用SIC技术进行多用户检测的目的。在发送端，对同一子信道上的不同用户采用功率复用技术进行发送，不同的用户的信号功率按照相关的算法进行分配，这样到达接收端每个用户的信号功率都不一样。SIC接收机再根据不同户用信号功率大小按照一定的顺序进行干扰消除，实现正确解调，同时也达到了区分用户的目的。</strong></p><blockquote><p>总之，记住一句话，NOMA就是多个用户共享一份资源，目的便是<strong>提升频谱效率</strong>。</p></blockquote><h3 id="协作非正交多址接入co-noma">1.1协作非正交多址接入（Co-NOMA）</h3><p>协作非正交多址接入（Cooperative Non-Orthogonal MultipleAccess，简称Co-NOMA）是一种新型的多用户接入技术，它结合了NOMA和协作通信的思想。在 Co-NOMA中，多个用户之间可以通过相互协作来提高系统性能和频谱效率。</p><p>Co-NOMA的基本原理是，当一个用户的信号在到达接收器之前受到严重干扰时，其他用户可以通过协作来帮助该用户，以提高其信号的可靠性和质量。这种协作可以通过不同用户之间的合作传输、信号处理或者干扰抑制等方式实现。</p><p>Co-NOMA技术可以应用于不同的通信场景，包括蜂窝通信系统、物联网（IoT）、车联网（V2X）等。通过协作，Co-NOMA可以提高系统容量、覆盖范围和用户体验，同时有效地利用有限的频谱资源。</p><p>总的来说，Co-NOMA 是一种结合了 NOMA和协作通信思想的新型多用户接入技术，可以提高系统性能和频谱效率，并在未来的通信系统中具有广泛的应用前景。</p><h2 id="分集技术及复用技术">2.分集技术及复用技术</h2><p>分集技术利用多条独立的通道传输相同的数据，而复用技术利用多条独立的通道传输不同的数据。</p><h3 id="分集技术">2.1 分集技术</h3><p>分集技术是一种<strong>补偿信道衰落的技术</strong>，用于改善无线通信链路的质量，而且不用改变通用空中接口或者增加发射功率或者带宽。</p><p>分集是指分散传输和集中接收。所谓分散传输是使接收端能获得多个统计独立的、携带<strong>同一信息</strong>的衰落信号。集中接收是接收机把收到的多个统计独立的衰落信号进行合并(选择与组合)以降低衰落的影响。</p><blockquote><p>核心思想即寻找无线传播环境中的独立（或高度不相关）路径，传输同一信号。</p></blockquote><p>常用分集：时间分集、频率分集、空间分集、极化分集</p><p>时间分集：以超过信道相干时间的时间间隔重复发送信号，以便让再次收到的信号具有独立的衰落环境，从而产生分集效果。重发的时间间隔要满足：<span class="math display">\[\Delta T \gg \frac{1}{2f_m}=\frac{1}{2(v/\lambda)}\]</span>频率分集：在<strong>多于一个的载频</strong>上传送信号，其工作原理为，<strong>相隔超过信道相干带宽的两个信号是不相关的，并且不会出现相同的衰落</strong>。理论上，如果信道是不相关的，那么同时衰减的概率将是单独衰减概率的乘积。相干带宽的公式为：<span class="math display">\[B_c=\frac{1}{2\pi\Delta}(其中\Delta为时延扩展:最大传输时延和最小传输时延的差值)\]</span>空间分集：从不同的天线上获得非相关的接收信号，要求天线间的间隔距离等于或大于半个波长。</p><blockquote><p>在市区，<span class="math inline">\(d\)</span>通常取0.5<span class="math inline">\(\lambda\)</span>，而在郊区，<span class="math inline">\(d\)</span>通常取0.8<span class="math inline">\(\lambda\)</span>。</p></blockquote><p>极化分集：利用了空中的水平极化和垂直极化路径不相关的特性。由于在传输中进行了多次反射，使得信号在不同的极化方向上是不相关的。将极化天线用于多径环境中，当传输路径中有障碍物时，极化分集可以极大地减少多径时延扩展，而不会明显地降低功率。</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240219103011167.png"></p><p>接收端分集合并：选择性合并、最大比值合并、等增益合并。</p><h4 id="最大比传输mrt">2.1.1 最大比传输（MRT）</h4><p>MRT可以被视为一种空间分集技术，是一种用于多天线系统（MIMO）中的传输技术。它的原理基于<strong>最大化接收信号功率</strong>，从而提高信号质量和系统性能。</p><p>MRT通常应用于具有多个发射天线和多个接收天线的系统中。这种系统称为多输入多输出（MIMO）系统。在MRT中，发送端利用多个天线发送相同的信号，但在每个天线上<strong>加权不同的系数</strong>。这些系数通常是为了最大化接收端的信号功率而计算得到的。MRT的主要目标是通过合理的<strong>天线加权</strong>，使得接收端接收到的信号功率最大化。这意味着在接收端的每个天线上收到的信号尽可能强，并且在信号与噪声的混合中，信号所占的比例最大。</p><p>在MRT中，除了<strong>幅度加权</strong>外，也需要对发送信号的<strong>相位</strong>进行调整，以确保在接收端接收到的信号相位最大程度地匹配，从而实现信号的合理叠加。在接收端，通过一定的信号处理技术（如最大比合并），将从各个天线接收到的信号合并起来，以最大程度地提高接收信号的质量。</p><p>总的来说，MRT的原理是通过合理的天线加权和相位调整，在传输端尽可能地增强信号功率，从而在接收端获得更高的信噪比，提高通信系统的性能和可靠性。</p><h3 id="复用技术">2.2 复用技术</h3><p>复用技术是对信道进行划分，一个信道划分为多个独立通道，传输多路<strong>不同信号</strong>。包括时分复用(TDM)、频分复用(FDM)、码分复用(CDM)、波分复用(WDM)。</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240219103435103.png" alt="几种资源分配技术的比较"><figcaption aria-hidden="true">几种资源分配技术的比较</figcaption></figure><h2 id="性能指标定义">3.性能指标定义</h2><h3 id="中继事件中继概率与分集增益">3.1中继事件、中继概率与分集增益</h3><p>在通信系统中，中断事件、中断概率和分集增益是评估通信系统在衰落信道条件下稳定性和传输可靠性的重要指标。</p><p><strong>中断事件</strong>：在给定的通信方案下，由于信道衰落等因素导致无法达到所需的目标速率而发生的事件。</p><p><strong>中断概率</strong>：在通信过程中，中断事件发生的概率。对于固定的通信实现方案，该通信方案的可达容量为随机信道<span class="math inline">\(h\)</span>的函数<span class="math inline">\(I(h)\)</span>。如果<span class="math inline">\(I(h)&lt;R\)</span>，其中<span class="math inline">\(R\)</span>是目标速率，则发生中断事件。中断概率可以表示为<span class="math inline">\(Pr(I(h)&lt;R)\)</span>。</p><p><strong>分集增益</strong>：分集增益表示通过分集技术在高信噪比下提高信号质量的能力。在高信噪比条件下，分集系统可以通过收集多个独立接收的信号并将它们合并来提高信号质量。分集增益通常用<span class="math inline">\(G\)</span>表示，可以通过中断概率<span class="math inline">\(d\)</span>在高信噪比下的渐进行为来给出。 <span class="math display">\[d=Pr(I_h&lt;R_t)\infty \frac{1}{SNR},SNR\to+\infty\]</span>方程式表明，在高信噪比条件下，中断事件发生的概率趋近于零，即随着信噪比的增加，中断事件的概率几乎为零。这是因为在高信噪比条件下，信号相对于噪声更容易被正确地接收，从而降低了中断事件的发生概率，提高了通信系统的可靠性。</p><h3 id="遍历速率复用增益">3.2 遍历速率、复用增益</h3><p>与中断性能代表的可靠性不同，遍历和速率、复用增益两项指标通常用来衡量通信系统最大可达速率。</p><p><strong>遍历速率<span class="math inline">\(R_E\)</span></strong>：遍历速率表示系统在所有可能的随机状态下的平均速率。具体地，如果即时可达速率<span class="math inline">\(R(h)\)</span>是随机信道<span class="math inline">\(h\)</span>的函数，则遍历速率<span class="math inline">\(R_E\)</span>可以表示为<span class="math inline">\(R_E=E[R(h)]\)</span>,其中<span class="math inline">\(E\)</span>表示期望运算。这意味着遍历速率是所有可能的随机状态下的即时可达速率的期望值。</p><p><strong>复用增益<span class="math inline">\(m\)</span></strong>：复用增益表示系统可以无干扰传输的独立信息流的数量。在高信噪比条件下，复用增益可以通过<span class="math inline">\(E\)</span>在高信噪比下的渐进行为来给出。具体地，复用增益<span class="math inline">\(m\)</span>可以表示为： <span class="math display">\[m=\lim\limits_{SNR \to \infty}\frac{R_E}{log_2(SNR)}\]</span></p><h2 id="多天线技术mimo">4. 多天线技术（MIMO）</h2><h3 id="基本概念">4.1 基本概念</h3><p><strong>MIMO技术</strong>属于多天线技术，利用<strong>空间分集/复用</strong>来提高吞吐量，多个<strong>独立的</strong>的数据流<strong>同时传输</strong>。</p><p>MIMO分为<strong>point-to-pointMIMO</strong>和<strong>MU-MIMO</strong>两类，其中<strong>point-to-pointMIMO</strong>即属于<strong>利用空间分集来提高吞吐量</strong>，虽然在point-to-pointMIMO中，接收机和发射机都配备有多个天线，但是在每个时刻，只有一个用户可以被服务；<strong>MU-MIMO</strong>属于<strong>利用空间复用来提高吞吐量</strong>。</p><p><mark><strong>下面只关注使用空间复用的MIMO。</strong></mark></p><p>与<strong>SISO</strong>相比，<strong>MIMO</strong>：</p><ul><li>获得了吞吐量的增益</li><li>没有可靠性的增益</li></ul><h3 id="mimo的数学模型以22的mimo下行链路为例">4.2MIMO的数学模型（以2×2的MIMO下行链路为例）</h3><p><strong>2个用户的MIMO下行场景</strong>：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-7eaddb44830608b37cb87b80274c6d2b_720w.webp" alt="2x2的MIMO的模型"><figcaption aria-hidden="true">2x2的MIMO的模型</figcaption></figure><p>其中，<span class="math inline">\(h_{11},h_{12},h_{21},h_{22}\)</span>为四条可能的传输路径，是<strong>系数</strong>，其大小表示<strong>从该路径传输的数据量的大小</strong>，数值越大，表示从该条路径传输的数据量越多。</p><blockquote><p><span class="math inline">\(h_{ij}\)</span>中的<span class="math inline">\(i\)</span>表示的是第<span class="math inline">\(i\)</span>个接收天线(<span class="math inline">\(R_x\)</span>)，<span class="math inline">\(j\)</span>表示第<span class="math inline">\(j\)</span>个发射天线(<span class="math inline">\(T_x\)</span>)。</p></blockquote><p>四个系数构成一个<strong>信道矩阵</strong>：<span class="math inline">\(H=\begin{bmatrix} h_{11} &amp; h_{12}\\ h_{21}&amp; h_{22} \end{bmatrix}\)</span>。</p><p>用矩阵表示MIMO的过程：<span class="math inline">\(y=Hx\)</span>。其中，<span class="math inline">\(y\)</span>为<strong>接收机接收到的数据构成的矩阵</strong>，维度为<span class="math inline">\(N_{R_x}×1\)</span>，<span class="math inline">\(y=\begin{bmatrix} y_1\\ y_2\end{bmatrix}\)</span>；<span class="math inline">\(x\)</span>为<strong>发射机发送的数据构成的矩阵</strong>，维度为<span class="math inline">\(N_{T_x}×1\)</span>，<span class="math inline">\(x=\begin{bmatrix} x_1\\ x_2\end{bmatrix}\)</span>。接收数据表示为发送数据经过<strong>信道矩阵</strong>变换后得到。</p><p><strong>传播矩阵</strong><span class="math inline">\(H\)</span>的维度是<span class="math inline">\(N_{R_x}×N_{T_x}\)</span>。</p><blockquote><p>信道矩阵的行数 = 接收天线的个数；信道矩阵的列数 =发射天线的个数。</p></blockquote><p><strong>接收机的目的</strong>：从接收到的数据<span class="math inline">\(y\)</span>中提取得到原始数据<span class="math inline">\(x\)</span>。</p><p><strong>如何实现接收机的目的？</strong></p><p>概念上，可以直接通过对<strong>传播矩阵</strong>求逆得到，即<span class="math inline">\(\begin{bmatrix} x_1\\ x_2\end{bmatrix}=\begin{bmatrix} h_{11} &amp; h_{12}\\ h_{21} &amp; h_{22}\end{bmatrix}^{-1}\begin{bmatrix} y_1\\ y_2 \end{bmatrix}\)</span>。</p><p>然而，<strong>存在如下的问题</strong>：</p><ol type="1"><li><strong>传播矩阵的逆不一定存在</strong>，只有在<strong>富杂散</strong>，即传播路径各不相干，各自独立，的环境中，<span class="math inline">\(H^{-1}\)</span>才存在；</li><li>即使<span class="math inline">\(H^{-1}\)</span>存在，求解矩阵的逆也是一个很复杂的事，是否存在一种方式可以<strong>预处理</strong>数据，使得<strong>UE</strong>（统一编码）可以在不对传播矩阵进行求逆的情况下，对数据进行译码。</li></ol><p><strong>解决方法</strong> --使用<strong>SVD，将对信道矩阵求逆化简为对对角矩阵求逆，引入Precoding（预编码）。</strong></p><blockquote><p>因此，引入预编码的目的视为让矩阵求逆变得简单。</p></blockquote><h4 id="用svd分析mimo">4.2.1 用SVD分析MIMO</h4><p>对<strong>信道矩阵</strong>进行SVD，即<span class="math inline">\(H=U\varSigma V^H\)</span>。</p><blockquote><p><span class="math inline">\(V^H\)</span>表示矩阵<span class="math inline">\(V\)</span>的共轭转置，实数域中共轭转置就等于转置，V和H都是正交矩阵。</p></blockquote><p>预编码矩阵<span class="math inline">\(V\)</span>的维度是<span class="math inline">\(N_{T_x}×N_{T_x}\)</span>。</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-66028592dd8732d512b75e78c1e901d9_r.jpg" alt="MIMO_SVD"><figcaption aria-hidden="true">MIMO_SVD</figcaption></figure><blockquote><p>在发射端和接收端分别加上<strong>预编码矩阵</strong><span class="math inline">\(V\)</span>和<strong>合并矩阵</strong><span class="math inline">\(U^H\)</span>，<strong>这两个都是信道矩阵分解后得到的酉矩阵</strong>，因此最后剩下的新的信道矩阵是一个对角矩阵。</p></blockquote><p>在这种情况下，<span class="math inline">\(y=U^H(U\varSigmaV^H)Vx=\varSigma x\)</span>。</p><p>通过SVD，将<strong>信道矩阵</strong>可以简单表达为一个<strong>对角矩阵</strong>，<span class="math inline">\(\varSigma=\begin{bmatrix} \sigma_1 &amp; 0\\ 0&amp; \sigma_2 \end{bmatrix}\)</span>，其中<span class="math inline">\(\sigma_i\)</span>为信道矩阵<span class="math inline">\(H\)</span>的<strong>奇异值</strong>，<span class="math inline">\(\sigma_i^2\)</span>为<span class="math inline">\(H^*H\)</span>的<strong>特征值</strong>。</p><p>此时，2×2的MIMO图示可以简化为：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-0295e95d931f1a1090c2ccb3108b37f1_720w.webp" alt="简化的MIMO"><figcaption aria-hidden="true">简化的MIMO</figcaption></figure><h3 id="发射机如何得到预编码矩阵v">4.3 发射机如何得到预编码矩阵<span class="math inline">\(V\)</span></h3><p><strong>思考过程：</strong>接收机(UE)可以基于发射机(eNB)发送的特定的参考信号进行<strong>信道估计</strong>，得到<strong>信道矩阵</strong>。然而，预编码矩阵是在发射机(eNB侧)被需要，那么，<strong>发射机如何知道预编码矩阵V呢</strong>？概念上，<strong>接收机(UE侧)告知发射机(eNB侧)预编码矩阵</strong>。但是，<strong>上述方法不可行</strong>，因为，<strong>将整个预编码矩阵发送给eNB是一个巨大的开销</strong>。</p><p>3GPP，对此给出的做法如下：在标准化过程中，对无线电信道进行了广泛的调查，预先定义了一组矩阵，UE侧和eNB侧均已知这组矩阵。之后，UE基于信道估计选择一个最合适的预编码矩阵，然后通知eNB所选的预编码矩阵在CodeBook中的下标。</p><p>上述的描述，即为TM4，即带有反馈的MIMO：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-308da06fad3f4952b9b8df042112e95b_720w.webp" alt="带有反馈的MIMO"><figcaption aria-hidden="true">带有反馈的MIMO</figcaption></figure><p>UE侧在具体的时刻选择最适合信道的CodeBook的步骤：</p><ol type="1"><li>计算CodeBook中每个元素的<span class="math inline">\(\Omega=W(H^HH)W^H\)</span>，其中，<span class="math inline">\(W\)</span>为CodeBook中的每个元素(预编码矩阵)，<span class="math inline">\(H\)</span>为传播矩阵；</li><li>选择<span class="math inline">\(\Omega_{min}\)</span>对应的<span class="math inline">\(W\)</span>作为预编码矩阵</li><li>将选择的<span class="math inline">\(W\)</span>在CodeBook中的下标(PMI)告知发射机</li></ol><h3 id="rank-indicator">4.4 Rank Indicator</h3><p>Rank Indicator是UE侧一种特殊的测量，得到的是Rank Index。</p><p>从实际的角度来看，RankIndicator表明了MIMO的工作质量，如：对于一个2×2的MIMO，如果<span class="math inline">\(RI=2\)</span>，表示数据块有2个传输通道，即表明它以真正的MIMO方式运行，但是，如果<span class="math inline">\(RI=1\)</span>，表明数据块只有1个传输通道，即表示它实际只是在单天线通信，即2×2MIMO没有发挥出最佳效率。</p><p>从<strong>奇异值矩阵</strong>Σ中，我们可以得到RI。以2×2MIMO为例：<span class="math inline">\(\varSigma=\begin{bmatrix} \sigma_1 &amp; 0\\ 0&amp; \sigma_2 \end{bmatrix}\)</span>，<span class="math inline">\(RI\)</span>等于<span class="math inline">\(\varSigma\)</span>中对角元素非0的个数。</p><p><strong>RI的物理意义</strong>：表示独立通信的信道数目。</p><p>如果<span class="math inline">\(RI=2\)</span>，表示<span class="math inline">\(\sigma_1≠0\)</span>且<span class="math inline">\(\sigma_2≠0\)</span>，即有2条独立的信道；</p><p>如果<span class="math inline">\(RI=1\)</span>，表示<span class="math inline">\(\sigma_1=0\)</span><span class="math inline">\(或\sigma_2=0\)</span>，即虽然有2根天线，但只有一个数据流在工作，意味着其中一根天线的信号完全丢失或被埋在噪声中，无法decode。</p><h3 id="条件数----正确估计mimo信道的真实性能">4.5 条件数 --正确估计MIMO信道的真实性能</h3><p>RankIndicator只关注了奇异值矩阵中的<strong>非零元素的数目</strong>，但其中<strong>非零元素的数值大小</strong>也同样重要。</p><p>如，<span class="math inline">\(\varSigma_1=\begin{bmatrix} 2 &amp;0\\ 0 &amp; 1 \end{bmatrix}\)</span>，<span class="math inline">\(\varSigma_1=\begin{bmatrix} 2 &amp; 0\\ 0 &amp;0.1\end{bmatrix}\)</span>，虽然两个奇异值矩阵的RI是一样的，但是他们对应的MIMO的性能是完全不同的，用<strong>条件数</strong>来衡量。</p><p><strong>条件数的定义</strong>：<span class="math inline">\(K(H)=\frac{\lambda_{max}}{\lambda_{min}}\begin{cases}当K(H)\approx 1时为空间复用的最佳方法\\当K(H)\gg1时不是空间复用的最佳方法 \\ \end{cases}\)</span></p><h1 id="二noma和ofdma的性能对比">二、NOMA和OFDMA的性能对比</h1><h2 id="noma采用的关键技术">1.NOMA采用的关键技术</h2><h3 id="串行干扰删除sic">1.1 串行干扰删除（SIC）</h3><p>在发送端，类似于CDMA系统，引入干扰信息可以获得更高的频谱效率，但是同样也会遇到多址干扰（MAI）的问题。关于消除多址干扰的问题，在研究第三代移动通信系统的过程中已经取得很多成果，串行干扰删除（SIC）也是其中之一。NOMA在接收端采用SIC接收机来消除干扰，可以很好地提高接收机的性能。</p><p><strong>串行干扰消除技术的基本思想是采用逐级消除干扰策略，在接收信号中对用户逐个进行判决，进行幅度恢复后，将该用户信号产生的多址干扰从接收信号中减去，并对剩下的用户再次进行判决，如此循环操作，直至消除所有的多址干扰。</strong></p><p>例如：在一个由3个用户共享的子信道上，<strong>叠加后的信号为</strong><span class="math inline">\(x=x_1+x_2+x_3\)</span>。其中，<span class="math inline">\(x_i(i=1,2,3)\)</span>分别代表3个用户信号，其中，信号功率<span class="math inline">\(x_1&lt;x_2&lt;x_3\)</span>，为了简单起见。<strong>在接收端，接收信号<span class="math inline">\(y_i=h_i·x+w_i\)</span></strong>。</p><p>其中，<span class="math inline">\(h_i\)</span>是信道系数，<span class="math inline">\(w_i\)</span>是信道高斯白噪声和小区干扰。则SIC接收机解调3个用户过程为：</p><ul><li>在第一级检测之前，<strong>先要将接收信号按照信号功率大小进行排序</strong>，这里由于<span class="math inline">\(x_3\)</span>信号功率最强，先要对<span class="math inline">\(x_3\)</span>进行判决，输出<span class="math inline">\(x_3\)</span>。然后恢复出对<span class="math inline">\(x_3\)</span>的信号估计值，从接收信号中减去<span class="math inline">\(x_3\)</span>的估计值，得到<span class="math inline">\(x_1+x_2\)</span>，然后将<span class="math inline">\(y_2=h_2·(x_1+x_2)+w_2\)</span>作为下一级输入。按照功率顺序依次执行相同的操作，最后先后输出<span class="math inline">\(x_2\)</span>和<span class="math inline">\(x_1\)</span>，完成对所有的用户信号检测。</li><li><strong>在SIC信号检测过程中，很重要的一点是用户检测的顺序。这里进行排序是根据用户的信号功率来进行的。在NOMA中，发送端会采用功率复用技术对不同的用户进行功率分配</strong>。通常，信道增益高的用户会少分配一些功率资源，而信道增益低的用户会多分配一些功率资源。到达接收端后，每个用户的信号功率会不一样，SIC接收机根据用户的信号功率进行排序，依次对不同的进行解调，同时达到区分用户的目的。</li><li>虽然，SIC技术有很好的信号检测性能，但要在NOMA中采用，有3个问题。首先，相对于传统的SIC接收机，NOMA中采用的SIC接收机要更复杂，要求具备更强的信号处理能力；其次，从上述过程可知，根据信号功率排的用户顺序决定了最佳的接收效果，而在实际过程中，用户的功率是不断变化的，这就要求SIC接收机不断地对用户功率进行排序；再次，从SIC结构图中可以看出，每一级处理都会产生一定的时延，在现实多级处理过程中，产生的时延很大。前一个问题的解决有赖于未来芯片处理能力的提升，而后两个问题则需要对相关的处理算法进行进一步的研究。</li></ul><h3 id="功率复用">1.2 功率复用</h3><p>SIC在接收端消除多址干扰（MAI），需要在接收信号中对用户进行判决来排出消除干扰的用户的先后顺序，<strong>而判决的依据就是用户信号功率大小。基站在发送端会对不同的用户分配不同的信号功率，来获取系统<mark>最大的性能增益</mark>，同时达到<mark>区分用户</mark>的目的，这就是功率复用技术</strong>。功率复用技术在其他几种传统的多址方案没有被充分利用，其不同于简单的功率控制，而是由基站遵循相关的算法来进行功率分配。</p><h3 id="不依赖用户反馈csi">1.3 不依赖用户反馈CSI</h3><p>在现实的蜂窝网中，因为流动性、反馈处理延迟等一些原因，通常用户并不能根据网络环境的变化反馈出实时有效的网络状态信息。虽然在目前，有很多技术已经不再那么依赖用户反馈信息就可以获得稳定的性能增益，但是采用了SIC技术的NOMA方案可以更好地适应这种情况，从而NOMA技术可以在高速移动场景下获得更好的性能，并能组建更好的移动节点回程链路。</p><h2 id="与cdma3g和ofdma4g相比noma性能的优势">2.与CDMA（3G）和OFDMA（4G）相比，NOMA性能的优势</h2><p>从上面的描述中我们也可以看出，NOMA虽然是一种新的技术，但是也融合了一些3G和4G的技术和思想。例如，OFDM是在4G中用到的，而SIC最初是在3G中用到的。</p><p>3G的多址技术采用的是直序扩频码分多址（CDMA）技术，采用非正交发送，所有用户共享一个信道，在接收端采用RAKE接收机。<strong>非正交传输有一个很严重的问题，就是远近效应</strong>，在3G中，人们采用<strong>功率控制技术</strong>在发送端对距离小区中心比较近的用户进行功率限制，<strong>保证在到达接收端每个用户的功率相当。</strong></p><p><strong>4G的多址技术采用的是基于OFDM的正交频分多址（OFDMA）技术，不同用户之间采用正交传输，所以远近效应不是那么明显，功率控制也不再是必需的了</strong>。在链路自适应技术上，4G采用了自适应编码（AMC）技术，可以根据链路状态信息自动调整调制编码方式，从而给用户提供最佳的传输速度，但是在一定程度上要依赖用户反馈的链路状态信息。</p><p>跟CDMA和OFDMA相比，<strong>NOMA子信道之间采用正交传输</strong>，不会存在跟3G一样明显的远近效应问题，多址干扰（MAI）问题也没那么严重；由于可以不依赖用户反馈的CSI信息，在采用AMC和功率复用技术后，应对各种多变的链路状态更加自如，即使在高速移动的环境下，依然可以提供很好地速率表现；<strong>同一子信道上可以由多个用户共享</strong>，跟4G相比，在保证传输速度的同时，可以提高频谱效率，这也是最重要的一点。</p><h2 id="相关代码">3.相关代码</h2><h3 id="主函数">3.1 主函数</h3><h4 id="参数">3.1.1 参数</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 参数</span><br>order_psk = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">64</span>];      <span class="hljs-comment">% PSK符号阶数，2表示BPSK，4表示4PSK，以此类推</span><br><span class="hljs-keyword">for</span> order = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(order_psk)<br>    sym_total = <span class="hljs-number">2.048e4</span>*<span class="hljs-number">52</span>; <span class="hljs-comment">% 总符号数</span><br>    len_turbo = <span class="hljs-number">1280</span>;   <span class="hljs-comment">% Turbo码长</span><br>    bit_total = sym_total * <span class="hljs-built_in">log2</span>(order_psk(order));<br>    N_ofdma_u1 = <span class="hljs-number">26</span>;    <span class="hljs-comment">% OFDMA用户1的子载波数</span><br>    N_ofdma_u2 = <span class="hljs-number">26</span>;    <span class="hljs-comment">% OFDMA用户2的子载波数</span><br>    p1 = <span class="hljs-number">0.1</span>;           <span class="hljs-comment">% NOMA用户1的功率</span><br>    p2 = <span class="hljs-number">0.9</span>;           <span class="hljs-comment">% NOMA用户2的功率</span><br><br>    N_ofdm = <span class="hljs-number">64</span>;        <span class="hljs-comment">% OFDM子载波数</span><br>    N_data = <span class="hljs-number">52</span>;        <span class="hljs-comment">% 数据载波数</span><br>    <span class="hljs-comment">% N_data 表示的是实际用于数据传输的子载波数量，而 N_ofdm 表示的是整个 OFDM 符号中的所有子载波的总数量。</span><br>    <span class="hljs-comment">% 通常情况下，N_data 是 N_ofdm 的一个子集。</span><br>    N_GB = [<span class="hljs-number">4</span>; <span class="hljs-number">3</span>];      <span class="hljs-comment">% 载波间隔参数</span><br>    N_P = [<span class="hljs-number">12</span>; <span class="hljs-number">26</span>; <span class="hljs-number">40</span>; <span class="hljs-number">54</span>]; <span class="hljs-comment">% 导频参数</span><br>    CP = <span class="hljs-number">1</span>/<span class="hljs-number">4</span>;           <span class="hljs-comment">% CP占比</span><br><br>    Ts = <span class="hljs-number">1</span>/<span class="hljs-number">10000</span>;<br>    FD = <span class="hljs-number">500</span>;           <span class="hljs-comment">% 瑞利信道参数</span><br>    SNR = <span class="hljs-number">25</span>:<span class="hljs-number">1</span>:<span class="hljs-number">60</span>;           <span class="hljs-comment">% 信噪比 </span><br></code></pre></td></tr></table></figure><h4 id="参数合理性判断">3.1.2 参数合理性判断</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 参数合理性判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mod</span>(bit_total, len_turbo)~=<span class="hljs-number">0</span>)<br>    error(<span class="hljs-string">&#x27;总比特数必须是Turbo编码长度的整数倍&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mod</span>((<span class="hljs-number">3</span>*len_turbo+<span class="hljs-number">12</span>)*bit_total/len_turbo, N_data)~=<span class="hljs-number">0</span>)<br>    error(<span class="hljs-string">&#x27;总比特数必须保证OFDM符号完整&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (N_ofdma_u1+N_ofdma_u2~=N_data)<br>    error(<span class="hljs-string">&#x27;OFDMA中两用户的子载波数目之和必须等于数据载波总数&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (p1+p2~=<span class="hljs-number">1</span>)<br>    error(<span class="hljs-string">&#x27;功率系数p1与p2之和必须等于1&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="生成两个用户的发射符号序列加入turbo编码">3.1.3生成两个用户的发射符号序列，加入Turbo编码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 生成两个用户的发射符号序列，加入Turbo编码</span><br>[sym_seq_u1, bit_seq_u1] = data_gen(bit_total, len_turbo, order_psk(order));<br>[sym_seq_u2, bit_seq_u2] = data_gen(bit_total, len_turbo, order_psk(order));<br></code></pre></td></tr></table></figure><h4 id="noma编码和ofdma编码">3.1.4 NOMA编码和OFDMA编码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% NOMA和OFDMA</span><br>sym_seq_noma = noma_enc(sym_seq_u1, sym_seq_u2, p1, p2);<br><span class="hljs-comment">% 对两用户数据进行NOMA编码</span><br>sym_seq_ofdma = ofdma_enc(sym_seq_u1, sym_seq_u2, N_ofdma_u1, N_ofdma_u2);<br><span class="hljs-comment">% 对两用户数据进行OFDMA编码</span><br></code></pre></td></tr></table></figure><h4 id="ofdm调制">3.1.5 OFDM调制</h4><p>创建OFDM调制器：</p><p><code>comm.OFDMModulator</code> 是 MATLAB 中用于创建<strong>OFDM（正交频分多址）调制器</strong>对象的通信工具箱中的一个类。OFDM调制器通常包括以下功能和属性（以第一个NOMA调制器为例）：</p><ul><li><code>'FFTLength',N_ofdm</code>：设置了FFT（快速傅里叶变换）的长度为 <code>N_ofdm</code>。FFT长度决定了每个OFDM 符号中使用的子载波数量。</li><li><code>'NumGuardBandCarriers',N_GB</code>：设置了保护带宽子载波数量为<code>N_GB</code>。保护带宽是指在每个 OFDM符号的两端分配的用于保护子载波的数量，通常用于减小符号之间的干扰。</li><li><code>'PilotInputPort',true</code>：启用了插入导频的功能。</li><li><code>'PilotCarrierIndices',N_P</code>：设置了导频（Pilot）子载波的索引。导频子载波用于信道估计和补偿，在信道估计过程中，将发送导频信号并通过接收到的信号与其进行比较以估计信道特性。</li><li><code>'NumSymbols',num_ofdmsym_noma</code>：设置了要生成的 OFDM符号的数量，这里使用了之前计算得到的<code>num_ofdmsym_noma</code>。</li><li><code>'CyclicPrefixLength',N_ofdm*CP</code>：设置了循环前缀（CyclicPrefix）的长度为 <code>N_ofdm*CP</code>。循环前缀是在每个 OFDM符号的头部插入的一段重复的信号，用于抵消多径传播引起的符号间的码间干扰。</li><li><code>'InsertDCNull',true</code>：启用了插入直流（DC）空子载波的功能。直流空子载波用于消除直流偏移，以提高系统的性能。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab">num_ofdmsym_noma = <span class="hljs-built_in">length</span>(sym_seq_noma)/N_data;<br>mod_ofdm_noma = comm.OFDMModulator(...<br><span class="hljs-string">&#x27;FFTLength&#x27;</span>,N_ofdm,...<br><span class="hljs-string">&#x27;NumGuardBandCarriers&#x27;</span>,N_GB,...<br><span class="hljs-string">&#x27;PilotInputPort&#x27;</span>,<span class="hljs-built_in">true</span>,...<br><span class="hljs-string">&#x27;PilotCarrierIndices&#x27;</span>,N_P,...<br><span class="hljs-string">&#x27;NumSymbols&#x27;</span>,num_ofdmsym_noma,...<br><span class="hljs-string">&#x27;CyclicPrefixLength&#x27;</span>,N_ofdm*CP,...<br><span class="hljs-string">&#x27;InsertDCNull&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 构造NOMA的OFDM调制器</span><br>num_ofdmsym_ofdma = <span class="hljs-built_in">length</span>(sym_seq_ofdma)/N_data;<br>mod_ofdm_ofdma = comm.OFDMModulator(...<br><span class="hljs-string">&#x27;FFTLength&#x27;</span>,N_ofdm,...<br><span class="hljs-string">&#x27;NumGuardBandCarriers&#x27;</span>,N_GB,...<br><span class="hljs-string">&#x27;PilotInputPort&#x27;</span>,<span class="hljs-built_in">true</span>,...<br><span class="hljs-string">&#x27;PilotCarrierIndices&#x27;</span>,N_P,...<br><span class="hljs-string">&#x27;NumSymbols&#x27;</span>,num_ofdmsym_ofdma,...<br><span class="hljs-string">&#x27;CyclicPrefixLength&#x27;</span>,N_ofdm*CP,...<br><span class="hljs-string">&#x27;InsertDCNull&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 构造OFDMA的OFDM调制器</span><br></code></pre></td></tr></table></figure><p>OFDM调制：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">tx_noma = ofdm_tx(sym_seq_noma, mod_ofdm_noma);<br>tx_ofdma = ofdm_tx(sym_seq_ofdma, mod_ofdm_ofdma);<br><span class="hljs-comment">% OFDM调制</span><br></code></pre></td></tr></table></figure><h4 id="高斯白噪声信道">3.1.6 高斯白噪声信道</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> snr = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(SNR)<br>    <span class="hljs-comment">%% 高斯白噪声信道</span><br>    cawgn = comm.AWGNChannel(<span class="hljs-string">&#x27;NoiseMethod&#x27;</span>, <span class="hljs-string">&#x27;Signal to noise ratio (SNR)&#x27;</span>);<br>    <span class="hljs-comment">% 创建了一个 AWGN（加性高斯白噪声）信道对象 cawgn，并将噪声的添加方式设置为基于信噪比（SNR）的方法。</span><br>    cawgn.SNR = SNR(snr);<br>    rx_noma = step(cawgn, tx_noma);<span class="hljs-comment">% 使用了 step 方法来模拟信道传输过程，其中 step 方法的参数是信道对象和发送信号，返回值是接收到的带有噪声的信号。</span><br>    rx_ofdma = step(cawgn, tx_ofdma);<br>    <span class="hljs-comment">% 接收信号经过加性高斯白噪声信道加入高斯噪声</span><br></code></pre></td></tr></table></figure><h4 id="ofdm解调">3.1.7 OFDM解调</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% OFDM解调</span><br>sym_seq_noma_mat = ofdm_rx(rx_noma, mod_ofdm_noma);<br>sym_seq_noma = <span class="hljs-built_in">reshape</span>(sym_seq_noma_mat, <span class="hljs-built_in">numel</span>(sym_seq_noma_mat), <span class="hljs-number">1</span>);<br><span class="hljs-comment">% 将解调后的数据符号序列矩阵重塑成列向量，以便后续的处理</span><br>sym_seq_ofdma_mat = ofdm_rx(rx_ofdma, mod_ofdm_ofdma);<br>sym_seq_ofdma = <span class="hljs-built_in">reshape</span>(sym_seq_ofdma_mat, <span class="hljs-built_in">numel</span>(sym_seq_ofdma_mat), <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="noma和ofdma解码及绘图">3.1.8 NOMA和OFDMA解码及绘图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">        <span class="hljs-comment">%% NOMA和OFDMA解码</span><br>        <span class="hljs-keyword">if</span> (p1&gt;p2)<br>            [bit_u1, bit_u2] = noma_dec(sym_seq_noma, len_turbo, order_psk(order), p1, p2);<br>        <span class="hljs-keyword">else</span><br>            [bit_u2, bit_u1] = noma_dec(sym_seq_noma, len_turbo, order_psk(order), p2, p1);<br>        <span class="hljs-keyword">end</span><br><br>        [n1,r1(order, snr)] = biterr(bit_u1,bit_seq_u1);<br>        <span class="hljs-comment">% 解构赋值语法，将biterr函数的第一个返回值赋给变量n1，而将第二个返回值赋给矩阵r1中的特定位置，n1变量将包含比特误码数，而r1(order, snr)将包含比特误码率。</span><br>        [n2,r2(order, snr)] = biterr(bit_u2,bit_seq_u2);<br>        <span class="hljs-comment">% 按照功率顺序解码用户1和用户2的符号序列</span><br>        <br>        [bit_u11, bit_u22] = ofdma_dec(sym_seq_ofdma, len_turbo, order_psk(order), N_ofdma_u1, N_ofdma_u2);<br><br>        [n11,r11(order,snr)] = biterr(bit_u11,bit_seq_u1(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(bit_u11)));<br>        [n22,r22(order,snr)] = biterr(bit_u22,bit_seq_u2(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(bit_u22)));<br>        [r1(order,snr), r2(order,snr), r11(order,snr), r22(order,snr)]<br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% </span><br>save(<span class="hljs-string">&#x27;ber.mat&#x27;</span>,<span class="hljs-string">&#x27;r1&#x27;</span>,<span class="hljs-string">&#x27;r2&#x27;</span>,<span class="hljs-string">&#x27;r11&#x27;</span>,<span class="hljs-string">&#x27;r22&#x27;</span>);<br>plot_ber(order_psk, SNR, N_data, p1, p2, N_ofdma_u1, N_ofdma_u2);<br></code></pre></td></tr></table></figure><h3 id="生成两个用户的发射符号序列加入turbo编码-1">3.2生成两个用户的发射符号序列，加入Turbo编码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ symbol_seq, bit_seq ]</span> = <span class="hljs-title">data_gen</span><span class="hljs-params">( bit_num, len_turbo, M )</span></span><br><span class="hljs-comment">% 输入总比特数、Turbo码长和PSK阶数，生成符号序列，同时返回原始比特序列。</span><br><span class="hljs-comment">% 输出一个包含两个元素的元组，其中第一个元素是经过 PSK 调制后的符号序列，第二个元素是原始的随机生成的二进制比特序列。</span><br>bit_seq = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">rand</span>(bit_num, <span class="hljs-number">1</span>));<br><span class="hljs-comment">% 生成大小为 bit_num 的随机比特序列</span><br><br>[turbo_seq] = turbo_enc(bit_seq, len_turbo);<br><span class="hljs-comment">% Turbo编码，编码后长度为3*len+12</span><br><br>hModulator = comm.PSKModulator(M,<span class="hljs-string">&#x27;BitInput&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 创建了一个 PSK 调制器对象，用于将输入的二进制序列转换为 PSK 调制信号。</span><br><span class="hljs-comment">% PSK 调制器在数字通信中经常用于将数字数据转换为调制信号，用于传输到通信信道中。</span><br>hModulator.PhaseOffset = <span class="hljs-built_in">pi</span>/M;<br><span class="hljs-comment">% 将 PSK 调制器对象的相位偏移属性设置为 π/M，以确保调制信号的相位偏移符合预期，并与接收端的解调器相匹配。</span><br>symbol_seq = step(hModulator, turbo_seq);<br><span class="hljs-comment">% 进行PSK调制</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Turbo编码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ turbo_seq ]</span> = <span class="hljs-title">turbo_enc</span><span class="hljs-params">( bit_seq, len )</span></span><br><span class="hljs-comment">% 对输入比特序列进行Turbo编码</span><br><br>bit_mat = <span class="hljs-built_in">reshape</span>(bit_seq, len, <span class="hljs-built_in">numel</span>(bit_seq)/len);<br><span class="hljs-comment">% 将二进制序列bit_seq重新塑造</span><br>turbo_seq = [];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(bit_seq)/len<br>    turbo_seq0 = lteTurboEncode(bit_mat(:,<span class="hljs-built_in">i</span>));<br>    <span class="hljs-comment">% 对 bit_mat 中的第 i 列数据进行 Turbo 编码</span><br>    turbo_seq = [turbo_seq; turbo_seq0];<br>    <span class="hljs-comment">% 经过每次循环迭代将一个长度为 len 的子序列经过 Turbo 编码后的结果存储到 turbo_seq 中</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="noma编码">3.3 NOMA编码</h3><p>用户1的信号 <code>seq_u1</code> 被放大到功率水平<code>p1</code>，用户2的信号 <code>seq_u2</code> 被放大到功率水平<code>p2</code>，然后这两个信号相加得到 <code>seq_noma</code>，以便在NOMA 系统中进行传输。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ seq_noma ]</span> = <span class="hljs-title">noma_enc</span><span class="hljs-params">( seq_u1, seq_u2, p1, p2 )</span></span><br><span class="hljs-comment">% 将用户1和用户2的数据序列按照p1和p2的功率分配合成NOMA序列</span><br><br>seq_noma = <span class="hljs-built_in">sqrt</span>(p1) * seq_u1 + <span class="hljs-built_in">sqrt</span>(p2) * seq_u2;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdma编码">3.4 OFDMA编码</h3><p>根据给定的子载波分配，将多个用户的数据合成为一个 OFDMA 序列，以便在OFDMA 系统中进行传输。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ seq_ofdma ]</span> = <span class="hljs-title">ofdma_enc</span><span class="hljs-params">( seq_u1, seq_u2, N_u1, N_u2 )</span></span><br><span class="hljs-comment">% 将用户1和用户2的数据分别按照N_u1和N_u2的子载波数合成OFDMA序列，只保留部分序列。</span><br><br>sym_total = <span class="hljs-built_in">length</span>(seq_u1);<br>sym_u1 = sym_total * (N_u1/(N_u1+N_u2));<br>sym_u2 = sym_total * (N_u2/(N_u1+N_u2));<br>seq_u1_r = seq_u1(<span class="hljs-number">1</span>:sym_u1);<br>seq_u2_r = seq_u2(<span class="hljs-number">1</span>:sym_u2);<br><span class="hljs-comment">% 截取用户1和用户2的部分序列，保证序列总长度和NOMA的一致</span><br><br>mat_u1_r = <span class="hljs-built_in">reshape</span>(seq_u1_r, N_u1, <span class="hljs-built_in">numel</span>(seq_u1_r)/N_u1);<br>mat_u2_r = <span class="hljs-built_in">reshape</span>(seq_u2_r, N_u2, <span class="hljs-built_in">numel</span>(seq_u1_r)/N_u2);<br><br>mat_ofdma = [mat_u1_r; mat_u2_r];<br>seq_ofdma = <span class="hljs-built_in">reshape</span>(mat_ofdma, <span class="hljs-built_in">numel</span>(mat_ofdma), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdm调制-1">3.5 OFDM调制</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ tx_data ]</span> = <span class="hljs-title">ofdm_tx</span><span class="hljs-params">( sym_seq, mod_ofdm )</span></span><br><br><span class="hljs-comment">% OFDM调制，mod为调制器</span><br><br>N_data = mod_ofdm.FFTLength - sum(mod_ofdm.NumGuardBandCarriers) - <span class="hljs-number">1</span> - <span class="hljs-built_in">length</span>(mod_ofdm.PilotCarrierIndices);<br><span class="hljs-comment">% 计算 OFDM 符号中用于传输数据的子载波数量</span><br>N_P = <span class="hljs-built_in">length</span>(mod_ofdm.PilotCarrierIndices);<br>num_ofdmsym = mod_ofdm.NumSymbols;<br><br>pilot_seq = <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">rand</span>(N_P, num_ofdmsym),<span class="hljs-built_in">rand</span>(N_P, num_ofdmsym));<br><span class="hljs-comment">% 生成导频序列，每一列代表一个 OFDM 符号中的导频序列。</span><br>sym_mat = <span class="hljs-built_in">reshape</span>(sym_seq, N_data, num_ofdmsym);<br><span class="hljs-comment">% 重塑数据符号序列，每一列代表一个 OFDM 符号中的数据符号序列。</span><br><br>tx_data = step(mod_ofdm,sym_mat,pilot_seq);<br><span class="hljs-comment">% 调用了 mod_ofdm 对象的 step 方法。在调用过程中，OFDM 调制器将对每一列的数据符号序列和导频序列进行处理，并将它们合并成最终的 OFDM 符号序列 tx_data。</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdm解调-1">3.6 OFDM解调</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ sym_seq ]</span> = <span class="hljs-title">ofdm_rx</span><span class="hljs-params">( rx_data, mod)</span></span><br><span class="hljs-comment">% OFDM解调，mod为调制器</span><br><br>demod = comm.OFDMDemodulator(<span class="hljs-built_in">mod</span>);<br><span class="hljs-comment">% 创建了一个 OFDM 解调器对象 demod</span><br>[sym_seq, ~] = step(demod,rx_data);<br><span class="hljs-comment">% 解构赋值语法，[sym_seq, ~] 表示将 step 方法返回的第一个值赋给变量 sym_seq，而第二个值则被忽略（用 ~ 表示）</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="noma解码">3.7 NOMA解码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ bit_u1, bit_u2 ]</span> = <span class="hljs-title">noma_dec</span><span class="hljs-params">( sym_seq_noma, len, M, p1, p2 )</span></span><br><span class="hljs-comment">% 按信噪比依次解码用户1序列和用户2序列</span><br><br>sym_seq_u1 = sym_seq_noma/<span class="hljs-built_in">sqrt</span>(p1);<br><span class="hljs-comment">% 首先，将接收到的 NOMA 符号序列除以用户1的功率的平方根，以进行功率归一化</span><br>hDemod = comm.PSKDemodulator(M, <span class="hljs-string">&#x27;BitOutput&#x27;</span>, <span class="hljs-built_in">true</span>, <span class="hljs-string">&#x27;PhaseOffset&#x27;</span>,<span class="hljs-built_in">pi</span>/M);<br><span class="hljs-comment">% 创建了一个 PSK 解调器对象，用于将接收到的归一化后的符号序列解调为比特序列</span><br>pskdemod_u1 = step(hDemod, sym_seq_u1);<br><span class="hljs-comment">% 使用 PSK 解调器对归一化后的符号序列进行解调，得到用户1的比特序列</span><br><span class="hljs-comment">% 用户1PSK解调</span><br><br>bit_u1 = turbo_dec(pskdemod_u1, len);<br><span class="hljs-comment">% 用户1Turbo解码</span><br><br>turbo_seq_u1r = turbo_enc(bit_u1, len);<br>hMod_u1 = comm.PSKModulator(M,<span class="hljs-string">&#x27;BitInput&#x27;</span>,<span class="hljs-built_in">true</span>);<br>hMod_u1.PhaseOffset = <span class="hljs-built_in">pi</span>/M;<br>sym_seq_u1r = step(hMod_u1, turbo_seq_u1r);<br><span class="hljs-comment">% 用户1信号重构</span><br><br><br>sym_seq_u2 = (sym_seq_noma - sym_seq_u1r * <span class="hljs-built_in">sqrt</span>(p1))/<span class="hljs-built_in">sqrt</span>(p2);<br><span class="hljs-comment">% 用户2信号</span><br>pskdemod_u2 = step(hDemod, sym_seq_u2);<br><span class="hljs-comment">% 用户2PSK解调</span><br>bit_u2 = turbo_dec(pskdemod_u2, len);<br><span class="hljs-comment">% 用户2Turbo解码</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Turbo解码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ data_seq ]</span> = <span class="hljs-title">turbo_dec</span><span class="hljs-params">( turbo_seq, len )</span></span><br><span class="hljs-comment">% Turbo解码</span><br><br>len_p = <span class="hljs-number">3</span>*len+<span class="hljs-number">12</span>;<br>turbo_mat = <span class="hljs-built_in">reshape</span>(turbo_seq, len_p, <span class="hljs-built_in">numel</span>(turbo_seq)/len_p);<br>data_seq = [];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(turbo_seq)/len_p<br>    data_seq0 = lteTurboDecode(turbo_mat(:,<span class="hljs-built_in">i</span>));<br>    data_seq = [data_seq; data_seq0];<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdma解码">3.8 OFDMA解码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ bit_u1, bit_u2 ]</span> = <span class="hljs-title">ofdma_dec</span><span class="hljs-params">( sym_seq, len, M, N1, N2 )</span></span><br><span class="hljs-comment">% 根据用户1和用户2的子载波数进行OFDMA解码</span><br><br>sym_mat = <span class="hljs-built_in">reshape</span>(sym_seq, N1+N2, <span class="hljs-built_in">numel</span>(sym_seq)/(N1+N2));<br><span class="hljs-comment">% 首先，将接收到的OFDMA符号序列 sym_seq 重塑为一个矩阵 sym_mat,这个矩阵表示了每个OFDMA符号中的用户1和用户2的符号序列</span><br>sym_mat1 = sym_mat(<span class="hljs-number">1</span>:N1,:);<br><span class="hljs-comment">% 从重塑后的矩阵中提取出用户1的符号序列</span><br>sym_mat2 = sym_mat(N1+<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span>,:);<br><br>sym_seq1 = <span class="hljs-built_in">reshape</span>(sym_mat1, <span class="hljs-built_in">numel</span>(sym_mat1), <span class="hljs-number">1</span>);<br><span class="hljs-comment">% 将用户1的符号序列重新展开为列向量</span><br>sym_seq2 = <span class="hljs-built_in">reshape</span>(sym_mat2, <span class="hljs-built_in">numel</span>(sym_mat2), <span class="hljs-number">1</span>);<br><br>hDemod = comm.PSKDemodulator(M, <span class="hljs-string">&#x27;BitOutput&#x27;</span>, <span class="hljs-built_in">true</span>, <span class="hljs-string">&#x27;PhaseOffset&#x27;</span>,<span class="hljs-built_in">pi</span>/M);<br>pskdemod_u1 = step(hDemod, sym_seq1);<br><span class="hljs-comment">% 使用PSK解调器对用户1的符号序列进行解调，得到用户1的比特序列</span><br>bit_u1 = turbo_dec(pskdemod_u1, len);<br><span class="hljs-comment">% 将用户1的比特序列输入到Turbo解码器中进行解码，得到最终的用户1比特序列</span><br>pskdemod_u2 = step(hDemod, sym_seq2);<br>bit_u2 = turbo_dec(pskdemod_u2, len);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="绘图">3.9 绘图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ flag ]</span> = <span class="hljs-title">plot_ber</span><span class="hljs-params">( M, SNR, N_data, p1,p2,N1,N2 )</span></span><br><span class="hljs-comment">% 画BER的图</span><br><br>load(<span class="hljs-string">&#x27;ber.mat&#x27;</span>);<br>SNR_ad = SNR - <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(<span class="hljs-built_in">sqrt</span>(N_data));<br><span class="hljs-comment">% 计算了一个调整后的信噪比，这种调整通常用于匹配预先计算的数据与实际情况的场景</span><br><span class="hljs-comment">%% NOMA bpsk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">1</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">1</span>)));<br><span class="hljs-comment">% 分别计算 NOMA 系统中用户 1 和用户 2 的信噪比。这里使用了之前计算得到的调整后的 SNR（SNR_ad），并根据各自的功率分配（p1 和 p2）以及调制方案的比特数 M(1) 来计算</span><br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br><span class="hljs-comment">% 类似地，计算了 OFDMA 系统中用户 1 和用户 2 的信噪比，但使用的调制方案为 M(2)</span><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">1</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">1</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">2</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">2</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br><span class="hljs-comment">% semilogy 函数用于绘制双对数坐标系下的曲线。</span><br><span class="hljs-comment">% 它的前两个参数分别是 x 轴和 y 轴的值，即信噪比和比特误码率。</span><br><span class="hljs-comment">% -ob、-vb、-or 和 -vr 是曲线的样式，分别表示蓝色圆点、绿色圆点、红色圆点和紫色圆点。</span><br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-BPSK&#x27;</span>);<br>xlim([<span class="hljs-number">10</span> <span class="hljs-number">25</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-comment">%% NOMA-4psk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">4</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">4</span>)));<br><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">2</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">2</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">4</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">4</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-4PSK&#x27;</span>);<br>xlim([<span class="hljs-number">10</span> <span class="hljs-number">32</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-comment">%% NOMA 8psk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">3</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">3</span>)));<br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">5</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">5</span>)));<br><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">3</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">3</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">5</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">5</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-8PSK&#x27;</span>);<br>xlim([<span class="hljs-number">15</span> <span class="hljs-number">45</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="仿真结果">4.仿真结果</h2><p>BPSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-BPSK.jpeg" alt="BPSK时NOMA与OFDMA的误比特率对比" style="zoom: 80%;"></p><p>4PSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-4PSK.jpeg" alt="4PSK时NOMA与OFDMA的误比特率对比" style="zoom:80%;"></p><p>8PSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-8PSK.png" alt="8PSK时NOMA与OFDMA的误比特率对比" style="zoom: 80%;"></p>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动通信</tag>
      
      <tag>非正交多址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研数学</title>
    <link href="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>2024/1/12 13:40这些知识点是真题中的易错点，是在我做完1998到2023年的数一真题，总结出我在真题中做错的题目所涉及的知识点，大多数是因为相应知识点记不熟或者理解不到位，如果能将下面的知识点记牢，对提升数学成绩有很大帮助。</p><p>2024/1/18 10:24我的建议是在完成数学前两轮复习后，准备开始做真题前再开始看这份知识点整理。</p><h1 id="一高等数学">一、高等数学</h1><h2 id="数列极限">1.数列极限</h2><h3 id="数学归纳法">1.1 数学归纳法</h3><p>法一</p><ol type="1"><li>验证<span class="math inline">\(n=1\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>假设<span class="math inline">\(n=k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>证明<span class="math inline">\(n=k+1\)</span>时，命题<span class="math inline">\(f_n\)</span>正确。</li></ol><p>故命题正确</p><p>法二</p><ol type="1"><li>验证<span class="math inline">\(n=1\)</span>和<span class="math inline">\(n=2\)</span>时，命题<span class="math inline">\(f_n\)</span>都正确；</li><li>假设<span class="math inline">\(n&lt;k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>证明<span class="math inline">\(n=k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确。</li></ol><p>故命题正确</p><h3 id="结论">1.2 结论</h3><p>单调不一定连续；收敛不一定单调。</p><h3 id="一些比较">1.3 一些比较</h3><p><span class="math inline">\((\ln n)^n\)</span>比<span class="math inline">\(n\)</span>要大；</p><p><span class="math inline">\((\ln n)^\alpha\)</span>比<span class="math inline">\(n\)</span>要小。</p><h2 id="一元函数微分学">2.一元函数微分学</h2><h3 id="极值点与拐点的重要结论">2.1 极值点与拐点的重要结论</h3><p>曲线的可导点不同时为极值点和拐点，不可导点可同时为极值点和拐点。</p><p>设<span class="math inline">\(f(x)=(x-a)^ng(x)(n&gt;1)\)</span>，且<span class="math inline">\(g(a)≠0\)</span>，当<span class="math inline">\(n\)</span>为偶数时，<span class="math inline">\(x=a\)</span>是<span class="math inline">\(f(x)\)</span>的极值点；当<span class="math inline">\(n\)</span>为奇数时，<span class="math inline">\((a,0)\)</span>是<span class="math inline">\(f(x)\)</span>的拐点。</p><p>设<span class="math inline">\(f(x)=(x-a_1)^{n_1}(x-a_2)^{n_2}\cdots(x-a_k)^{n_k}\)</span>，其中<span class="math inline">\(n_i\)</span>是正整数，<span class="math inline">\(a_i\)</span>是实数且<span class="math inline">\(a_i\)</span>两两不等。记<span class="math inline">\(k_1\)</span>为<span class="math inline">\(n_i=1\)</span>的个数，<span class="math inline">\(k_2\)</span>为<span class="math inline">\(n_i&gt;1\)</span>且<span class="math inline">\(n_i\)</span>为偶数的个数，<span class="math inline">\(k_3\)</span>为<span class="math inline">\(n_i&gt;1\)</span>且<span class="math inline">\(n_i\)</span>为奇数的个数。则<span class="math inline">\(f(x)\)</span>的极值点个数为<span class="math inline">\(k_1+2k_2+k_3-1\)</span>，拐点个数为<span class="math inline">\(k_1+2k_2+3k_3-2\)</span>。</p><h3 id="结论-1">2.2 结论</h3><p>不能以函数在一点的导数符号来确定函数在一个区间上的单调性。</p><h3 id="微分">2.3 微分</h3><p><span class="math inline">\(\Delta y=A\Delta x+o(\Deltax)\)</span>，其中<span class="math inline">\(A\)</span>与<span class="math inline">\(\Delta x\)</span>无关，则称<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x\)</span>处可微。</p><p><span class="math inline">\(A\Delta x\)</span>称为<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x\)</span>处相应于<span class="math inline">\(\Delta x\)</span>的微分，记作<span class="math inline">\(dy\)</span>或<span class="math inline">\(d[f(x)]\)</span>，<span class="math inline">\(dy=A\Delta x=Adx\)</span>。 <span class="math display">\[A\Delta x=\begin{cases}dy \\d[f(x)]\\微分(\Deltax的微分)\\线性主部(\Delta y的线性主部)\end{cases}\]</span></p><h3 id="反函数的微分特点">2.4 反函数的微分特点</h3><p><span class="math inline">\(x_y&#39;=\frac{1}{y_x&#39;}\)</span></p><p><span class="math inline">\(y_x&#39;=\frac{dy}{dx}=\frac{1}{\frac{dx}{dy}}=\frac{1}{x_y&#39;}\)</span></p><p><span class="math inline">\(y_{xx}&#39;&#39;=\frac{d^2y}{dx^2}=\frac{d(\frac{dy}{dx})}{dx}=\frac{d(\frac{1}{x_y&#39;})}{dx}=\frac{d(\frac{1}{x_y&#39;})}{dy}·\frac{dy}{dx}=[-\frac{x_{yy}&#39;&#39;}{(x_y&#39;)^2}]·\frac{1}{x_y&#39;}=-\frac{x_{yy}&#39;&#39;}{(x_y&#39;)^3}\)</span></p><blockquote><p>不用背，可以自己推</p></blockquote><h2 id="一元函数积分学">3.一元函数积分学</h2><h3 id="一些常用不定积分">3.1 一些常用不定积分</h3><p><span class="math inline">\(\int\frac{dx}{cosx}=\intsecxdx=ln|secx+tanx|+C\)</span></p><p><span class="math inline">\(\int\frac{dx}{sinx}=\intcscxdx=ln|cscx-cotx|+C\)</span></p><p><span class="math inline">\(\int\frac{1}{\sqrt{x^2+a^2}}dx=ln(x+\sqrt{x^2+a^2})+C\)</span></p><p><span class="math inline">\(\int\frac{1}{\sqrt{x^2-a^2}}dx=ln|x+\sqrt{x^2-a^2}|+C\)</span></p><h3 id="弧长公式">3.2 弧长公式</h3><p>直角坐标方程：<span class="math inline">\(S=\int_{a}^{b}\sqrt{1+[y&#39;(x)]^2}dx\)</span></p><p>参数方程：<span class="math inline">\(S=\int_{\alpha}^{\beta}\sqrt{[x&#39;(t)]^2+[y&#39;(t)]^2}dt\)</span></p><p>极坐标方程：<span class="math inline">\(S=\int_{\alpha}^{\beta}\sqrt{[r(\theta)]^2+[r&#39;(\theta)]^2}d\theta\)</span></p><h3 id="一个定积分">3.3 一个定积分</h3><p><span class="math inline">\(\int_{0}^{+\infty}x^2e^{-x^2}dx=\frac{\sqrt{\pi}}{4}\)</span></p><p><span class="math inline">\(\int x^2e^{-x^2}dx=\intx·x·e^{-x^2}dx=\int-\frac{x}{2}d(e^{-x^2})=e^{-x^2}·(-\frac{x}{2})+\frac{1}{2}\inte^{-x^2}dx\)</span></p><p><span class="math inline">\(\int_{0}^{+\infty}x^2e^{-x^2}dx=e^{-x^2}·(-\frac{x}{2})|_0^{+\infty}+\frac{1}{2}\int_{0}^{+\infty}e^{-x^2}dx=\frac{\sqrt{\pi}}{4}\)</span></p><h3 id="结论-2">3.4 结论</h3><p><span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上可积，则<span class="math inline">\(F(x)=\int_{a}^{x}f(t)dt\)</span>在<span class="math inline">\([a,b]\)</span>上连续；</p><p><span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上连续，则<span class="math inline">\(F(x)=\int_{a}^{x}f(t)dt\)</span>在<span class="math inline">\([a,b]\)</span>上可导。</p><h3 id="换元法">3.5 换元法</h3><p>令<span class="math inline">\(k=\begin{cases}x=rcos\theta\\y=rsin\theta\end{cases}\)</span></p><p>则<span class="math inline">\(\iint_{DXY}f(x,y)dxdy=\iint_{Dr\theta}f(rcos\theta,rsin\theta)\begin{Vmatrix}\frac{\partial x}{\partial r} &amp; \frac{\partial x}{\partial \theta}\\\frac{\partial y}{\partial r} &amp; \frac{\partial y}{\partial \theta}\end{Vmatrix}drd\theta\)</span></p><blockquote><p>两条竖线分别是行列式和绝对值的意思</p></blockquote><h2 id="多元函数微分学">4.多元函数微分学</h2><h3 id="隐函数求导法">4.1 隐函数求导法</h3><p>设<span class="math inline">\(F(x,y,z)=0\)</span>，<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>满足<span class="math inline">\(F(P_0)=0\)</span>，<mark><span class="math inline">\(F&#39;_z(P_0)≠0\)</span></mark>，则在点<span class="math inline">\(P_0\)</span>的某邻域内可确定<span class="math inline">\(z=z(x,y)\)</span>，且有<span class="math inline">\(\frac{\partial z}{\partialx}=-\frac{F_x&#39;}{F_z&#39;}\)</span>，<span class="math inline">\(\frac{\partial z}{\partialy}=-\frac{F_y&#39;}{F_z&#39;}\)</span></p><h3 id="可微条件">4.2 可微条件</h3><p>若<span class="math inline">\(\lim\limits_{x \to 0,y \to0}\frac{f(x,y)-f(0,0)-f_x&#39;(0,0)·x-f_y&#39;(0,0)·y}{\sqrt{x^2+y^2}}=0\)</span>，则<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\((0,0)\)</span>可微；</p><p>令<span class="math inline">\(f_x&#39;(x_0,y_0)=A,f_y&#39;(x_0,y_0)=B\)</span>，若<span class="math inline">\(\lim\limits_{\varDelta x \to 0,\varDelta y \to0}\frac{f(x_0+\varDelta x,y_0+\varDelta y)-f(x_0,y_0)-A\varDeltax-B\varDelta y}{\sqrt{\varDelta x ^2+\varDelta y^2}}=0\)</span>，则<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\((x_0,y_0)\)</span>可微</p><h3 id="可微可导与连续的关系">4.3 可微、可导与连续的关系</h3><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117110110925.png"></p><h3 id="结论-3">4.4 结论</h3><p>二阶偏导数连续<span class="math inline">\(\to \frac{\partial^2f}{\partial u\partial v}=\frac{\partial^2 f}{\partial v\partialu}\)</span></p><h2 id="微分方程">5.微分方程</h2><h3 id="伯努利方程">5.1 伯努利方程</h3><p>能写成<span class="math inline">\(y&#39;+p(x)y=q(x)y^n(n≠0，1)\)</span>：</p><ul><li>先变形为<span class="math inline">\(y^{-n}·y&#39;+p(x)y^{1-n}=q(x)\)</span>；</li><li>令<span class="math inline">\(z=y^{-n}\)</span>，得<span class="math inline">\(\frac{dz}{dx}=(1-n)y^{-n}\frac{dy}{dx}\)</span>，则<span class="math inline">\(\frac{1}{1-n}\frac{dz}{dx}+p(x)z=q(x)\)</span>；</li><li>解此一阶线性微分方程即可。</li></ul><h3 id="欧拉方程">5.2 欧拉方程</h3><p>能写成<span class="math inline">\(x^2y&#39;&#39;+pxy&#39;+qy=f(x)\)</span>：</p><ol type="1"><li><p>当<span class="math inline">\(x&gt;0\)</span>时，令<span class="math inline">\(x=e^t\)</span>，则<span class="math inline">\(t=lnx\)</span>，<span class="math inline">\(\frac{dt}{dx}=\frac{1}{x}\)</span>。</p><p>于是<span class="math inline">\(\frac{dy}{dx}=\frac{dy}{dt}·\frac{dt}{dx}=\frac{1}{x}·\frac{dy}{dt}\)</span>；</p><p><span class="math inline">\(\frac{d^2y}{dx^2}=\frac{d}{dx}·(\frac{1}{x}\frac{dy}{dt})=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x}·\frac{d}{dx}(\frac{dy}{dt})=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x}·\frac{d}{dt}(\frac{dy}{dt})·\frac{dt}{dx}=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x^2}·\frac{d^2y}{dt^2}\)</span></p><p>方程化为<span class="math inline">\(\frac{d^2y}{dt^2}+(p-1)\frac{dy}{dt}+qy=f(e^t)\)</span>，即可求解。</p><blockquote><p>最后结果别忘了用<span class="math inline">\(t=lnx\)</span>回代成<span class="math inline">\(x\)</span>的函数</p></blockquote></li><li><p>当<span class="math inline">\(x&lt;0\)</span>时。令<span class="math inline">\(x=e^{-t}\)</span>，同理可得。</p></li></ol><h3 id="高阶常系数微分方程的通解与特解">5.3高阶常系数微分方程的通解与特解</h3><p>通解：</p><ol type="1"><li><p><span class="math inline">\(\lambda_1≠\lambda_2\)</span>： <span class="math display">\[y=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}\]</span></p></li><li><p><span class="math inline">\(\lambda_1=\lambda_2=\lambda\)</span>： <span class="math display">\[y=(C_1+C_2x)e^{\lambda x}\]</span></p></li><li><p><span class="math inline">\(\lambda=\alpha\pm i\beta\)</span>：<span class="math display">\[y=e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)\]</span></p></li></ol><p>特解：</p><ol type="1"><li><p>当自由项<span class="math inline">\(f(x)=P_n(x)e^{\alphax}\)</span>时，特解要设为<span class="math inline">\(y^*=e^{\alphax}Q_n(x)x^k\)</span>，其中： <span class="math display">\[\begin{cases}e^{\alpha x}照抄，\\ Q_n(x)为x的n次一般多项式，\\ k=\begin{cases}0，\alpha ≠\lambda_1, \alpha ≠\lambda_2\\ 1，\alpha =\lambda_1或\alpha=\lambda_2,\lambda_1≠\lambda_2\\2，\alpha =\lambda_1=\lambda_2\end{cases}  \end{cases}\]</span></p></li><li><p>当自由项<span class="math inline">\(f(x)=e^{\alphax}[P_m(x)cos\beta x+P_n(x)sin\beta x]\)</span>时，特解要设为<span class="math inline">\(y^*=e^{\alpha x}[Q_l^{(1)}(x)cos\betax+Q_l^{(2)}(x)sin\beta x]x^k\)</span>，其中： <span class="math display">\[\begin{cases}e^{\alpha x}照抄，\\l=max\{m,n\},Q_l^{(1)}(x),Q_l^{(2)}(x)分别为x两个不同的l次一般多项式，\\ k=\begin{cases}0，\alpha \pm i\beta 不是特征根\\ 1，\alpha \pm i\beta 是特征根\end{cases}  \end{cases}\]</span></p></li></ol><h3 id="高阶微分方程的解">5.4 高阶微分方程的解</h3><p>若<span class="math inline">\(\lambda\)</span>为单实根，写<span class="math inline">\(Ce^{\lambda x}\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(k\)</span>重实根，写<span class="math inline">\((C_1+C_2x+C_3x^2+\cdots +C_kx^{k-1})e^{\lambdax}\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为单复根<span class="math inline">\(\alpha\pm i\beta\)</span>，写<span class="math inline">\(e^{\alpha x}(C_1cos\beta x+C_2sin\betax)\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为二重复根<span class="math inline">\(\alpha\pm i\beta\)</span>，写<span class="math inline">\(e^{\alpha x}(C_1cos\beta x+C_2sin\betax+C_3xcos\beta x+C_4xsin\beta x)\)</span></p><h2 id="无穷级数">6无穷级数</h2><h3 id="广义p级数">6.1 广义<span class="math inline">\(p\)</span>级数</h3><p><span class="math inline">\(\displaystyle\sum_{n=2}^\infty\frac{1}{n(\lnn)^p}\begin{cases}收敛，p&gt;1\\ 发散，p≤1\end{cases}\)</span></p><h3 id="一些简单数项级数的和">6.2 一些简单数项级数的和</h3><p><span class="math inline">\(e^x=\displaystyle\sum_{n=0}^\infty\frac{x^n}{n!}\)</span></p><p><span class="math inline">\(\frac{e^x+e^{-x}}{2}=\displaystyle\sum_{n=0}^\infty\frac{x^{2n}}{(2n)!}\)</span></p><p><span class="math inline">\(cosx=\displaystyle\sum_{n=0}^\infty(-1)^n\frac{x^{2n}}{(2n)!}\)</span></p><p><span class="math inline">\(\frac{e^x-e^{-x}}{2}=\displaystyle\sum_{n=0}^\infty\frac{x^{2n+1}}{(2n+1)!}\)</span></p><p><span class="math inline">\(sinx=\displaystyle\sum_{n=0}^\infty(-1)^n\frac{x^{2n+1}}{(2n+1)!}\)</span></p><h3 id="傅里叶级数">6.3 傅里叶级数</h3><p>设函数<span class="math inline">\(f(x)\)</span>是周期为<span class="math inline">\(2l\)</span>的周期函数，且在<span class="math inline">\([-l,l]\)</span>上可积，则有 <span class="math display">\[a_n=\frac{1}{l}\int_{-l}^{l}f(x)cos\frac{n\pi}{l}xdx(n=0,1,2,\cdots)\]</span></p><p><span class="math display">\[b_n=\frac{1}{l}\int_{-l}^{l}f(x)sin\frac{n\pi}{l}xdx(n=1,2,3,\cdots)\]</span></p><p><span class="math display">\[f(x)\sim\frac{a_0}{2}+\displaystyle\sum_{n=1}^\infty(a_ncos\frac{n\pi}{l}x+b_nsin\frac{n\pi}{l}x)\]</span></p><h3 id="收敛区间和收敛域">6.4 收敛区间和收敛域</h3><p>收敛区间：不包含端点，是一个开区间；</p><p>收敛域：包含端点。</p><h2 id="多元函数积分学预备知识">7.多元函数积分学预备知识</h2><h3 id="曲线">7.1 曲线</h3><p>切向量：<span class="math inline">\(\tau=(A,B,C)\)</span></p><ul><li>已知<span class="math inline">\(\begin{cases} F(x,y,z)=0\\G(x,y,z)=0 \end{cases}\)</span>，则<span class="math inline">\(\overrightarrow{\tau}=\begin{vmatrix}\overrightarrow{i} &amp; \overrightarrow{j} &amp; \overrightarrow{k}\\\frac{\partial F}{\partial x} &amp; \frac{\partial F}{\partial y} &amp;\frac{\partial F}{\partial z}\\\frac{\partial G}{\partial x} &amp; \frac{\partial G}{\partial y} &amp;\frac{\partial G}{\partial z}\end{vmatrix}\)</span></li></ul><p>切线：<span class="math inline">\(\frac{x-x_0}{A}=\frac{y-y_0}{B}=\frac{z-z_0}{C}\)</span></p><p>法平面：<span class="math inline">\(A(x-x_0)+B(y-y_0)+C(z-z_0)=0\)</span></p><h3 id="曲面">7.2 曲面</h3><p>法向量：<span class="math inline">\(n=(A,B,C)\)</span></p><p>法线：<span class="math inline">\(\frac{x-x_0}{A}=\frac{y-y_0}{B}=\frac{z-z_0}{C}\)</span></p><p>切平面：<span class="math inline">\(A(x-x_0)+B(y-y_0)+C(z-z_0)=0\)</span></p><h3 id="两点式求直线">7.3 两点式求直线</h3><p>直线过不同的两点：<span class="math inline">\((x_1,y_1,z_1),(x_2,y_2,z_2)\)</span>，则直线方程为<span class="math inline">\(\frac{x-x_1}{x_2-x_1}=\frac{y-y_1}{y_2-y_1}=\frac{z-z_1}{z_2-z_1}\)</span></p><h3 id="曲线绕一条定直线旋转一周所形成的曲面">7.4曲线绕一条定直线旋转一周所形成的曲面</h3><p>曲线<span class="math inline">\(\begin{cases}F(x,y,z)=0\\G(x,y,z)=0\end{cases}\)</span>绕直线<span class="math inline">\(L\)</span>，首先在直线<span class="math inline">\(L\)</span>上找一点<span class="math inline">\(M_0(x_0,y_0,z_0)\)</span>，方向向量为<span class="math inline">\(\overrightarrow{s}\)</span>，在曲线上任取一点<span class="math inline">\(M_1(x_1,y_1,z_1)\)</span>，过<span class="math inline">\(M_1\)</span>的纬圆上任取一点<span class="math inline">\(P(x,y,z)\)</span>，则可以得到： <span class="math display">\[\begin{cases}|\overrightarrow{M_0M_1}|=|\overrightarrow{M_0P}|\\ \overrightarrow{s}\bot\overrightarrow{M_1P}\\F(x_1,y_1,z_1)=0\\ G(x_1,y_1,z_1)=0\end{cases}\]</span></p><blockquote><p>四个方程三个未知数</p></blockquote><h3 id="点到面的距离">7.5 点到面的距离</h3><p><span class="math display">\[d=\frac{Ax_0+By_0+Cz_0+D}{\sqrt{A^2+B^2+C^2}}\]</span></p><h3 id="平面束方程">7.6 平面束方程</h3><p>过<span class="math inline">\(L:\begin{cases}A_1x+B_1y+C_1z+D_1=0\\  A_2x+B_2y+C_2z+D_2=0  \end{cases}\)</span>的平面束方程为<span class="math inline">\(A_1x+B_1y+C_1z+D_1+\lambda(A_2x+B_2y+C_2z+D_2)=0\)</span></p><h3 id="方向导数和梯度">7.7 方向导数和梯度</h3><p>求<span class="math inline">\(u=u(x,y,z)\)</span>在<span class="math inline">\(P_0\)</span>点沿<span class="math inline">\(l\)</span>方向的方向导数</p><p>定义法：<span class="math inline">\(\frac{\partial u}{\partiall}|_{P_0}=\lim\limits_{t \to 0^+}\frac{u(P)-u(P_0)}{t}=\lim\limits_{t\to0^+}\frac{u(x_0+tcos\alpha,y_0+tcos\beta,z_0+tcos\gamma)-u(x_0,y_0,z_0)}{t}\)</span></p><blockquote><p>若三元函数<span class="math inline">\(u=u(x,y,z)\)</span>在点<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>处可微分，则可用公式法</p></blockquote><p>公式法：<span class="math inline">\(\frac{\partial u}{\partiall}|_{P_0}=u&#39;_x(P_0)cos\alpha+u&#39;_y(P_0)cos\beta+u&#39;_z(P_0)cos\gamma\)</span></p><p>求<span class="math inline">\(u=u(x,y,z)\)</span>在<span class="math inline">\(P_0\)</span>处的梯度：<span class="math inline">\(grad\thinspace u\thinspace|_{P_0}=(u&#39;_x(P_0),u&#39;_y(P_0),u&#39;_z(P_0))\)</span></p><blockquote><p>函数在某点处的梯度是一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。</p></blockquote><h3 id="散度和旋度">7.8 散度和旋度</h3><p>散度：<span class="math inline">\(div\thinspace A=\frac{\partialP}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partialz}\)</span></p><p>旋度：<span class="math inline">\(rot\thinspace A=\begin{vmatrix} i&amp; j &amp; k\\ \frac{\partial }{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial }{\partial z}\\ P &amp; Q &amp; R\end{vmatrix}\)</span></p><h2 id="多元函数积分学">8.多元函数积分学</h2><h3 id="球面坐标系">8.1 球面坐标系</h3><p><span class="math inline">\(\phi\)</span>的范围是从<span class="math inline">\(z\)</span>轴正向到负向<span class="math inline">\(0\to \pi\)</span>的</p><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117114157948.png" style="zoom: 20%;"></p><p><span class="math inline">\(\theta\)</span>的范围是<span class="math inline">\([0,2\pi]\)</span>，从<span class="math inline">\(x\)</span>轴正向开始逆时针转的</p><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117114800996.png" style="zoom: 20%;"></p><h3 id="斯托克斯公式">8.2 斯托克斯公式</h3><p><span class="math display">\[\oint Pdx+Qdy+Rdz=\iint_{\varSigma}\begin{vmatrix}cos\alpha &amp; cos\beta &amp;cos\gamma\\\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp;\frac{\partial}{\partial z}\\P &amp; Q &amp; R\end{vmatrix}dS\]</span></p><blockquote><p>二型线积分化为一型面积分</p></blockquote><h3 id="转换投影法">8.3 转换投影法</h3><p>对于二型面积分，若<span class="math inline">\(\varSigma\)</span>投影到<span class="math inline">\(xoy\)</span>平面上不是一条线，并且<span class="math inline">\(\varSigma\)</span>上任意两点到<span class="math inline">\(xoy\)</span>平面上的投影点不重合，则可将<span class="math inline">\(\varSigma\)</span>投影到<span class="math inline">\(xoy\)</span>平面。 <span class="math display">\[\iintP(x,y,z)dydz+Q(x,y,z)dzdx+R(x,y,z)dxdy=\pm\iint_{DXY}\{P[x,y,z(x,y)](-\frac{\partialz}{\partial x})+Q[x,y,z(x,y)](-\frac{\partial z}{\partialy})+R[x,y,z(x,y)]\}dxdy\]</span></p><blockquote><p>当<span class="math inline">\(\varSigma\)</span>为上侧时，取“+”；当<span class="math inline">\(\varSigma\)</span>为下侧时，取“-”</p></blockquote><h3 id="面线积分才能考虑代换">8.4 面线积分才能考虑代换</h3><p>例如<span class="math inline">\(\varSigma\)</span>是曲面<span class="math inline">\(x=\sqrt{1-3y^2-3z^2}\)</span>的前侧，<span class="math inline">\(\Omega\)</span>是<span class="math inline">\(\varSigma\)</span>围成的空间。三重积分是在一个空间内，<span class="math inline">\(x,y,z\)</span>不一直满足<span class="math inline">\(x=\sqrt{1-3y^2-3z^2}\)</span>的关系，无法代换，面线积分才能考虑代换。</p><h3 id="积分与路径无关">8.5 积分与路径无关</h3><h4 id="注意条件">8.5.1 注意条件</h4><p>积分与路径无关的条件是沿<span class="math inline">\(D\)</span>内任意光滑闭曲线都有<span class="math inline">\(\oint_LPdx+Qdy=0\)</span>；而<span class="math inline">\(\oint_LPdx+Qdy=A\)</span>不能推出积分与路径无关。</p><h4 id="积分与路径无关的6个等价条件">8.5.2积分与路径无关的6个等价条件</h4><ol type="1"><li><p><span class="math inline">\(\int_{LAB}P(x,y)dx+Q(x,y)dy\)</span>与路径无关</p></li><li><p>沿<span class="math inline">\(D\)</span>内任意分段光滑闭曲线都有<span class="math inline">\(\oint_LPdx+Qdy=0\)</span></p></li><li><p><span class="math inline">\(Pdx+Qdy\)</span>为某二元函数<span class="math inline">\(u(x,y)\)</span>的全微分：</p><p>由1推3，<span class="math inline">\(\int_{LAB}Pdx+Qdy=\int_{LAB}du(x,y)=u(x,y)|^B_A\)</span>，故<span class="math inline">\(du(x,y)=\frac{\partial u}{\partialx}dx+\frac{\partial u}{\partial y}dy=Pdx+Qdy\)</span></p></li><li><p><span class="math inline">\(Pdx+Qdy=0\)</span>是全微分方程：</p><p>意思是上式可以被视为全微分方程，因为3说了<span class="math inline">\(Pdx+Qdy\)</span>为二元函数<span class="math inline">\(u(x,y)\)</span>的全微分；因为<span class="math inline">\(du=0\)</span>，故通解为<span class="math inline">\(u(x,y)=C\)</span></p><blockquote><p><span class="math inline">\(\frac{\partial P}{\partialy}\equiv\frac{\partial Q}{\partialx}\)</span>是判断是不是全微分方程的标准，理由在第六条给出</p></blockquote><p>例：求解<span class="math inline">\((x^4+3xy^2-y^3)dx+(3x^2y-3xy^2+y^2)dy=0\)</span></p><p>解：<span class="math inline">\(\because \frac{\partial P}{\partialy}\equiv\frac{\partial Q}{\partial x}=6xy-3y^2\)</span></p><p>​ <span class="math inline">\(\therefore\)</span>所求式为全微分方程</p><p>​ <span class="math inline">\(\therefore\)</span> 取路径<span class="math inline">\((0,0)\to (x,0)\to(x,y)\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(\int_{0}^{x}5x^4dx+\int_{0}^{y}(3x^2y-3xy^2+y^2)dy=C\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(x^5+\frac{3}{2}x^2y^2-xy^3+\frac{y^3}{3}=C\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> 也可得<span class="math inline">\(u(x,y)=x^5+\frac{3}{2}x^2y^2-xy^3+\frac{y^3}{3}+C\)</span></p></li><li><p><span class="math inline">\(Pi+Qj\)</span>为某二元函数<span class="math inline">\(u(x,y)\)</span>的梯度</p></li><li><p><span class="math inline">\(\frac{\partial P}{\partialy}\equiv\frac{\partial Q}{\partial x}\)</span>在<span class="math inline">\(D\)</span>内处处成立：</p><p>由4推6，<span class="math inline">\(\becauseu&#39;&#39;_{xy}=u&#39;&#39;_{yx}\)</span>又<span class="math inline">\(\because \frac{\partial P}{\partialy}=u&#39;&#39;_{xy},\frac{\partial Q}{\partialx}=u&#39;&#39;_{yx}\)</span></p><p>​ <span class="math inline">\(\therefore \frac{\partial P}{\partialy}\equiv\frac{\partial Q}{\partial x}\)</span></p></li></ol><h1 id="二线性代数">二、线性代数</h1><h2 id="行列式">1.行列式</h2><h3 id="拉普拉斯展开式">1.1 拉普拉斯展开式</h3><p><span class="math display">\[\begin{vmatrix}A &amp; *\\O &amp; B\end{vmatrix}=\begin{vmatrix}A &amp; O\\* &amp; B\end{vmatrix}=|A|·|B|\]</span></p><p><span class="math display">\[\begin{vmatrix}O &amp; A\\B &amp; *\end{vmatrix}=\begin{vmatrix}* &amp; A\\B &amp; O\end{vmatrix}=(-1)^{mn}|A|·|B|\]</span></p><h3 id="克拉默法则">1.2 克拉默法则</h3><p>若<span class="math inline">\(n\)</span>个方程<span class="math inline">\(n\)</span>个未知数的线性方程组<span class="math inline">\(\begin{cases}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2\\\cdots\\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n\end{cases}\)</span></p><p>的系数行列式<span class="math inline">\(D=\begin{vmatrix} a_{11}&amp; a_{12} &amp; \cdots &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp;\cdots &amp; a_{2n} \\ \vdots &amp; \vdots &amp;\ddots &amp; \vdots\\a_{n1} &amp; a_{n2} &amp; \cdots &amp;a_{nn}\end{vmatrix}≠0\)</span>，</p><p>则方程组有唯一解：<span class="math inline">\(x_1=\frac{D_1}{D},x_2=\frac{D_2}{D},\cdots,x_n=\frac{D_n}{D}\)</span></p><p>其中<span class="math inline">\(D_j=\begin{vmatrix} a_{11}&amp;\cdots &amp; a_{1,j-1}&amp; b_1 &amp; a_{1,j+1}&amp; \cdots &amp;a_{1n}\\ a_{21} &amp;\cdots &amp; a_{2,j-1}&amp; b_2 &amp;a_{2,j+1}&amp; \cdots &amp; a_{2n} \\ \vdots &amp; &amp; \vdots &amp;\vdots &amp;  \vdots &amp; &amp;\vdots\\ a_{n1} &amp;\cdots &amp;a_{n,j-1}&amp; b_n &amp; a_{n,j+1}&amp; \cdots &amp;a_{nn}\end{vmatrix}\)</span></p><h3 id="代数余子式">1.3 代数余子式</h3><p><span class="math display">\[A_{ij}=(-1)^{i+j}M_{ij}\]</span></p><blockquote><p><span class="math inline">\(A_{ij}\)</span>是代数余子式，<span class="math inline">\(M_{ij}\)</span>是余子式</p></blockquote><h2 id="矩阵">2.矩阵</h2><h3 id="分块矩阵的初等行列变换">2.1 分块矩阵的初等行（列）变换</h3><p>交换分块矩阵中的某两个块行（列）；</p><p>用某个<mark><span class="math inline">\(可逆矩阵\)</span></mark>左（右）乘分块矩阵的某块行（列）；</p><p>用一个矩阵<mark><span class="math inline">\(左\)</span></mark>（右）乘某个块<mark><span class="math inline">\(行\)</span></mark>（列）之后加到另一个块<mark><span class="math inline">\(行\)</span></mark>（列）。</p><h3 id="伴随矩阵的秩">2.2 伴随矩阵的秩</h3><p><span class="math display">\[r(A^*)=\begin{cases}n, &amp;r(A)=n\\1, &amp;r(A)=n-1\\0, &amp;r(A)&lt;n-1\\\end{cases}\]</span></p><h3 id="初等矩阵的逆变换">2.3 初等矩阵的逆变换</h3><p><span class="math display">\[E_i^{-1}(k)=E_i(\frac{1}{k}),例:D = \begin{bmatrix}1 &amp; &amp;\\&amp; 1&amp;\\&amp;&amp;2\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp; &amp;\\&amp; 1&amp;\\&amp;&amp;\frac{1}{2}\end{bmatrix}\]</span></p><p><span class="math display">\[E_{ij}^{-1}(k)=E_{ij}(-k),例:D = \begin{bmatrix}1 &amp;0 &amp;0\\2 &amp; 1&amp;0\\0&amp;0&amp;1\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp;0 &amp;0\\-2 &amp; 1&amp;0\\0&amp;0&amp;1\end{bmatrix}\]</span></p><p><span class="math display">\[E_{ij}^{-1}=E_{ij},例:D = \begin{bmatrix}1 &amp;0 &amp;0\\0 &amp; 0&amp;1\\0&amp;1&amp;0\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp;0 &amp;0\\0 &amp; 0&amp;1\\0&amp;1&amp;0\end{bmatrix}\]</span></p><h3 id="矩阵的秩">2.4 矩阵的秩</h3><ol type="1"><li><span class="math inline">\(r(A)=r(A^T)\)</span>，<span class="math inline">\(r(A^TA)=r(A)\)</span></li><li><span class="math inline">\(r(A+B)\le r(A)+r(B)\)</span></li><li><span class="math inline">\(r(AB)\lemin\{r(A),r(B)\}\)</span>，若<span class="math inline">\(A\)</span>可逆，则<span class="math inline">\(r(AB)=r(B)\)</span>，<span class="math inline">\(r(BA)=r(B)\)</span></li><li>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵，<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times\)</span> s矩阵，<span class="math inline">\(AB=O\)</span>，则<span class="math inline">\(r(A)+r(B)\le n\)</span></li></ol><h2 id="n维向量">3.<span class="math inline">\(n\)</span>维向量</h2><h3 id="向量空间">3.1 向量空间</h3><h4 id="过渡矩阵">3.1.1 过渡矩阵</h4><p><span class="math display">\[\begin{bmatrix}\beta_1 &amp; \beta_2 &amp;\beta_3\end{bmatrix}=\begin{bmatrix}\alpha_1 &amp; \alpha_2 &amp;\alpha_3\end{bmatrix}C\]</span></p><p>称矩阵<span class="math inline">\(C\)</span>为由基<span class="math inline">\(\alpha_1\alpha_2\alpha_3\)</span>到<span class="math inline">\(\beta_1\beta_2\beta_3\)</span>的过渡矩阵。</p><h4 id="坐标变换公式">3.1.2 坐标变换公式</h4><p><span class="math display">\[\begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix}=C\begin{bmatrix}y_1 \\ y_2\\ y_3\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(x\)</span>是<span class="math inline">\(\gamma\)</span>在基<span class="math inline">\(\alpha\)</span>的坐标，其中<span class="math inline">\(y\)</span>是<span class="math inline">\(\gamma\)</span>在基<span class="math inline">\(\beta\)</span>的坐标。</p><h2 id="特征值与特征向量">4.特征值与特征向量</h2><h3 id="注意">4.1 注意</h3><p>求特征向量时，结果前要乘k，表示全部的特征向量。</p><h3 id="注意-1">4.2 注意</h3><p>证明<span class="math inline">\(A,B\)</span>相似，首先要证明<span class="math inline">\(A,B\)</span>可相似对角化。</p><h3 id="特征值与特征向量的变化规律">4.3 特征值与特征向量的变化规律</h3><table><thead><tr><th style="text-align: center;"><span class="math inline">\(A\)</span></th><th style="text-align: center;"><span class="math inline">\(kA+E\)</span></th><th style="text-align: center;"><span class="math inline">\(A+kE\)</span></th><th style="text-align: center;"><span class="math inline">\(A^{-1}\)</span></th><th style="text-align: center;"><span class="math inline">\(A^*\)</span></th><th style="text-align: center;"><span class="math inline">\(A^n\)</span></th><th style="text-align: center;"><span class="math inline">\(P^{-1}AP\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(k\lambda+1\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda+k\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{|A|}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(P^{-1}\alpha\)</span></td></tr></tbody></table><blockquote><p><span class="math inline">\(\lambda\)</span>变<span class="math inline">\(\alpha 不变\)</span>，<span class="math inline">\(\lambda\)</span>不变<span class="math inline">\(\alpha 变\)</span>。</p></blockquote><h3 id="特征多项式是lambda-e-a">4.4 特征多项式是<span class="math inline">\(|\lambda E-A|\)</span></h3><p>例：<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是同阶方阵，如果<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>相似，试证<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>的特征多项式相等。</p><p>证：<span class="math inline">\(\because A,B\)</span>相似</p><p>​ <span class="math inline">\(\therefore P^{-1}AP=B\)</span></p><p>​ <span class="math inline">\(\therefore |\lambda E-B|=|\lambdaE-P^{-1}AP|=|P^{-1}\lambda EP-P^{-1}AP|=|P^{-1}(\lambda E-A)P|=|\lambdaE-A|\)</span></p><h2 id="二次型">5.二次型</h2><h3 id="二次型的矩阵表示">5.1 二次型的矩阵表示</h3><p><span class="math inline">\(f(x_1,x_2,\cdots,x_n)=\cdots\)</span>称为<span class="math inline">\(n\)</span>元二次型；二次型有矩阵表示： <span class="math display">\[f(x_1,x_2,\cdots,x_n)=x^TAx\]</span> 其中<span class="math inline">\(x\)</span>是<span class="math inline">\(n\)</span>维列向量，<span class="math inline">\(A\)</span>是实对称矩阵，称<span class="math inline">\(A\)</span>为二次型的矩阵，秩<span class="math inline">\(r(A)\)</span>称为二次型的秩。</p><h3 id="一些曲面">5.2 一些曲面</h3><p>单叶双曲面：<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1\)</span></p><p>双叶双曲面：<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1\)</span></p><h3 id="施密特正交化">5.3 施密特正交化</h3><p><span class="math inline">\(\beta_1=\alpha_1\)</span></p><p><span class="math inline">\(\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}·\beta_1\)</span></p><p><span class="math inline">\(\beta_3=\alpha_3-\frac{(\alpha_3,\beta_1)}{(\beta_1,\beta_1)}·\beta_1-\frac{(\alpha_3,\beta_2)}{(\beta_2,\beta_2)}·\beta_2\)</span></p><h3 id="合同变换和正定矩阵">5.4 合同变换和正定矩阵</h3><p>两个<span class="math inline">\(n\)</span>阶矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，如果存在可逆矩阵<span class="math inline">\(C\)</span>，使得<span class="math inline">\(C^TAC=B\)</span>，就称矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>合同，记作<span class="math inline">\(A\simeq B\)</span>，称<span class="math inline">\(C\)</span>为合同变换的矩阵。</p><p>对二次型<span class="math inline">\(x^TAx\)</span>，如果对任何<span class="math inline">\(x≠0\)</span>，恒有<span class="math inline">\(x^TAx&gt;0\)</span>，则称二次型<span class="math inline">\(x^TAx\)</span>是正定二次型，并称实对称矩阵<span class="math inline">\(A\)</span>是正定矩阵。</p><p><span class="math inline">\(n\)</span>元二次型<span class="math inline">\(x^TAx\)</span>正定的充要条件有：</p><ol type="1"><li><span class="math inline">\(A\)</span>的正惯性指数是<span class="math inline">\(n\)</span>；</li><li><span class="math inline">\(A\)</span>与<span class="math inline">\(E\)</span>合同，即存在可逆矩阵<span class="math inline">\(C\)</span>，使<span class="math inline">\(C^TAC=E\)</span>；</li><li><span class="math inline">\(A\)</span>的所有特征值<span class="math inline">\(\lambda(i=1,2,\cdots,n)\)</span>均为正数；</li><li><span class="math inline">\(A\)</span>的各阶顺序主子式均大于零。</li></ol><p>例：设<span class="math inline">\(A\)</span>为<span class="math inline">\(m\)</span>阶实对称矩阵且正定，<span class="math inline">\(B\)</span>为<span class="math inline">\(m\timesn\)</span>实矩阵，<span class="math inline">\(B^T\)</span>为<span class="math inline">\(B\)</span>的转置矩阵，试证：<span class="math inline">\(B^TAB\)</span>为正定矩阵的充分必要条件是<span class="math inline">\(r(B)=n\)</span>。</p><p>证：必要性：设<span class="math inline">\(B^TAB\)</span>为正定矩阵</p><p>​ <span class="math inline">\(\therefore\)</span>对任意<span class="math inline">\(n\)</span>维列向量<span class="math inline">\(x≠0\)</span>，有<span class="math inline">\(x^TB^TABx&gt;0\)</span>，即<span class="math inline">\((Bx)^TA(Bx)&gt;0\)</span></p><p>​ 又<span class="math inline">\(\because A\)</span>正定</p><p>​ <span class="math inline">\(\therefore Bx≠0\)</span>，因此<span class="math inline">\(Bx=0\)</span>只有零解</p><p>​ <span class="math inline">\(\therefore r(B)=n\)</span></p><p>​ 充分性：设<span class="math inline">\(r(B)=n\)</span></p><p>​ <span class="math inline">\(\becauseB^TAB=(B^TAB)^T=B^TAB\)</span></p><p>​ <span class="math inline">\(\thereforeB^TAB\)</span>为实对称矩阵</p><p>​ <span class="math inline">\(\because r(B)=n\)</span></p><p>​ <span class="math inline">\(\therefore Bx=0\)</span>只有零解</p><p>​ <span class="math inline">\(\therefore\)</span>对任意<span class="math inline">\(n\)</span>维列向量<span class="math inline">\(x≠0\)</span>，都有<span class="math inline">\(Bx≠0\)</span></p><p>​ <span class="math inline">\(\because A\)</span>正定</p><p>​ <span class="math inline">\(\therefore(Bx)^TA(Bx)&gt;0\)</span>，即<span class="math inline">\(x^TB^TABx&gt;0\)</span></p><p>​ <span class="math inline">\(\therefore B^TAB\)</span>为正定矩阵</p><h1 id="三概率论与数理统计">三、概率论与数理统计</h1><h2 id="随机事件及其概率">1.随机事件及其概率</h2><h3 id="减法公式">1.1 减法公式</h3><p><span class="math inline">\(P(A\overline{B})=P(A-B)=P(A)-P(AB)\)</span></p><p><span class="math inline">\(P(\overline{A}B)=P(B-A)=P(B)-P(AB)\)</span></p><h2 id="一维随机变量及其分布">2.一维随机变量及其分布</h2><h3 id="泊松分布及指数分布">2.1 泊松分布及指数分布</h3><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">概率密度</th><th style="text-align: center;">E(x)</th><th style="text-align: center;">D(x)</th></tr></thead><tbody><tr><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><span class="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr><td style="text-align: center;">指数分布</td><td style="text-align: center;"><span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambda x}，x\ge0\\0，x&lt;0\end{cases}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda^2}\)</span></td></tr></tbody></table><h3 id="标准正态分布">2.2 标准正态分布</h3><p><span class="math inline">\(\Phi(\frac{X-4}{2})\)</span>是<span class="math inline">\(N(4,4)\)</span>的分布函数，<span class="math inline">\(Z=\frac{X-\mu}{\sigma}\sim N(0,1)\)</span>。</p><blockquote><p>正态分布图像特点：正态分布，方差越小，图像越高瘦。</p></blockquote><h2 id="二维随机变量及其分布">3.二维随机变量及其分布</h2><h3 id="判断xy是否独立">3.1 判断<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>是否独立</h3><p>看<span class="math inline">\(P\{X\le k,Y\lem\}\)</span>是否等于<span class="math inline">\(P\{X\le k\}·P\{Y\lem\}\)</span>，<span class="math inline">\(k\)</span>、<span class="math inline">\(m\)</span>为任取的值。</p><blockquote><p>证不独立时题中自己随便取即可。</p></blockquote><h3 id="f_zz直接求导求f_zz莱布尼兹公式">3.2 <span class="math inline">\(F_Z(z)\)</span>直接求导求<span class="math inline">\(f_Z(z)\)</span>（莱布尼兹公式）</h3><p>莱布尼兹公式： <span class="math display">\[\frac{d}{dz}\int_{\alpha(z)}^{\beta(z)}g(z,x)dx=\int_{\alpha(z)}^{\beta(z)}g_z&#39;(z,x)dx+\beta&#39;(z)·g(z,\beta(z))-\alpha&#39;(z)·g(z,\alpha(z))\]</span> 例：<span class="math inline">\(f(x,y)=\begin{cases}2-x-y,\quad0&lt;x&lt;1,0&lt;y&lt;1\\0,\quad其他\end{cases}\)</span>，求<span class="math inline">\(Z=X+Y\)</span>的概率密度<span class="math inline">\(f_Z(z)\)</span>。</p><p>解：<img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240128222426890.png" style="zoom: 20%;"></p><p><span class="math inline">\(0\le z&lt;1\)</span>时：<span class="math inline">\(F_Z(z)=P\{X+Y\lez\}=\int_{0}^{z}dx\int_{0}^{z-x}(2-x-y)dy\)</span></p><p>​ <span class="math inline">\(f_Z(z)=\frac{dF_Z(z)}{dz}=\int_{0}^{z}(2-z)dx+0-0=(2-z)·z\)</span></p><p><span class="math inline">\(1\le z&lt;2\)</span>时：<span class="math inline">\(F_Z(z)=1-\int_{z-1}^{1}dx\int_{z-x}^{1}(2-x-y)dy\)</span></p><p>​ <span class="math inline">\(f_Z(z)=\frac{dF_Z(z)}{dz}=-[\int_{z-1}^{1}(z-2)dx]=(z-2)^2\)</span></p><p><span class="math inline">\(\thereforef_Z(z)=\begin{cases}(2-z)·z,\quad0\le z&lt;1\\(z-2)^2,\quad1\lez&lt;2\\0,\quad其他\end{cases}\)</span></p><h2 id="数字特征">4.数字特征</h2><h3 id="方差的性质">4.1 方差的性质</h3><p><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>独立时：<span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\)</span></p><p><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>不独立时：<span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\pm2Cov(X,Y)\)</span></p><h3 id="协方差的性质">4.3 协方差的性质</h3><p><span class="math inline">\(Cov(X_1\pm X_2,Y)=Cov(X_1,Y)\pmCov(X_2,Y)\)</span></p><p><span class="math inline">\(Cov(aX,bY)=abCov(X,Y)\)</span></p><p><span class="math inline">\(Cov(X_1-\overline{X},X_n-\overline{X})=Cov(X_1-\overline{X},X_n)-Cov(X_1-\overline{X},\overline{X})=Cov(X_1,X_n)-Cov(\overline{X},X_n)-Cov(X_1,\overline{X})+Cov(\overline{X},\overline{X})\)</span></p><h2 id="大数定律和中心极限定理">5.大数定律和中心极限定理</h2><h3 id="辛钦大数定律">5.1 辛钦大数定律</h3><p>设随机变量<span class="math inline">\(X_1,X_2,\cdots,X_n,\cdots\)</span>独立同分布，<span class="math inline">\(E(X_i)=\mu(i=1,2,\cdots)\)</span>，则对任意的<span class="math inline">\(\epsilon&gt;0\)</span>，有 <span class="math display">\[\lim\limits_{n \to\infty}P\{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i-\mu|&lt;\epsilon\}=1,即\frac{1}{n}\displaystyle\sum_{i=1}^nX_i\xrightarrow{P}\mu\]</span></p><h3 id="切比雪夫不等式">5.2 切比雪夫不等式</h3><p><span class="math display">\[P\{|X-E(X)|\ge\epsilon\}\le \frac{D(X)}{\epsilon^2}\]</span></p><h2 id="数理统计的基本概念">6.数理统计的基本概念</h2><h3 id="常见统计量">6.1 常见统计量</h3><ul><li><p><span class="math inline">\(\overline{X}=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i\qquadE(\overline{X})=\mu\quadD(\overline{X})=\frac{\sigma^2}{n}\)</span></p></li><li><p><span class="math inline">\(S^2=\frac{1}{n-1}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2\qquadE(S^2)=\sigma^2\)</span></p></li></ul><blockquote><p><span class="math inline">\(S^2\)</span>除以<span class="math inline">\(n-1\)</span>的原因也就是<span class="math inline">\(E(S^2)=\sigma^2\)</span>，即<span class="math inline">\(S^2\)</span>为<span class="math inline">\(\sigma^2\)</span>的无偏估计量。</p></blockquote><h3 id="chi2分布t分布和f分布">6.2 <span class="math inline">\(\chi^2\)</span>分布、<span class="math inline">\(t\)</span>分布和<span class="math inline">\(F\)</span>分布</h3><ol type="1"><li><p><span class="math inline">\(\chi^2\)</span>分布：总体<span class="math inline">\(X\sim N(0,1)\)</span>，<span class="math inline">\(\chi^2=X_1^2+X_2^2+\cdots+X_n^2\)</span>为服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(\chi^2\)</span>分布，记作<span class="math inline">\(\chi^2\sim \chi^2(n)\)</span>。</p><blockquote><p>设<span class="math inline">\(\chi^2\sim \chi^2(n)\)</span>，则<span class="math inline">\(E(\chi^2)=n\)</span>，<span class="math inline">\(D(\chi^2)=2n\)</span></p></blockquote></li><li><p><span class="math inline">\(t\)</span>分布：设总体<span class="math inline">\(X\sim N(0,1)\)</span>，<span class="math inline">\(Y\sim \chi^2(n)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，则<span class="math inline">\(T=\frac{X}{\sqrt{Y/n}}\)</span>为服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(t\)</span>分布，记作<span class="math inline">\(T\sim t(n)\)</span>。</p></li><li><p><span class="math inline">\(F\)</span>分布：设总体<span class="math inline">\(X\sim \chi^2(n_1)\)</span>，<span class="math inline">\(Y\sim \chi^2(n_2)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，则称<span class="math inline">\(F=\frac{X/n_1}{Y/n_2}\)</span>为服从第一自由度为<span class="math inline">\(n_1\)</span>，第二自由度为<span class="math inline">\(n_2\)</span>的<span class="math inline">\(F\)</span>分布，记作<span class="math inline">\(F\sim F(n_1,n_2)\)</span>。</p><blockquote><p>若<span class="math inline">\(T\sim t(n)\)</span>，则<span class="math inline">\(T^2\sim F(1,n_2)\)</span></p></blockquote></li></ol><h3 id="正态总体的抽样分布">6.3 正态总体的抽样分布</h3><p>单正态总体：设总体<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>，<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>为来自<span class="math inline">\(X\)</span>的简单随机样本。</p><ol type="1"><li><span class="math inline">\(\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}\simN(0,1)\quad \frac{(\overline{X}-\overline{X})^2}{\sigma^2/n}\sim\chi^2(1)\)</span></li><li><span class="math inline">\(\overline{X}\)</span>与<span class="math inline">\(S^2\)</span><strong>相互独立</strong>，<span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}=\frac{\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2}{\sigma^2}\sim\chi^2(n-1)\)</span></li><li><span class="math inline">\(\frac{X_i-\mu}{\sigma}\sim N(0,1)\quad\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\sigma^2}\sim\chi^2(n)\)</span></li><li><span class="math inline">\(\frac{\overline{X}-\mu}{S/\sqrt{n}}\simt(n-1)\)</span></li></ol><p>双正态总体：设总体<span class="math inline">\(X\sim N(\mu_1,\sigma_1^2)\)</span>，<span class="math inline">\(Y\sim N(\mu_2,\sigma_2^2)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>、<span class="math inline">\((Y_1,Y_2,\cdots,Y_n)\)</span>为来自<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的简单随机样本。</p><ol type="1"><li><p><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1^2}+\frac{(n_2-1)S_2^2}{\sigma_2^2}\sim\chi^2(n_1+n_2-2)\)</span></p></li><li><p><span class="math inline">\(\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\simN(0,1)\)</span></p></li><li><p>当<span class="math inline">\(\sigma_1=\sigma_2=\sigma\)</span>时： <span class="math display">\[\frac{\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{\sigma\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}}{\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{\sigma^2(n_1+n_2-2)}}}=\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{S_\omega\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}\simt(n_1+n_2-2)\qquadS_\omega=\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\]</span></p></li><li><p><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1^2}\sim\chi^2(n_1-1)\quad\frac{(n_2-1)S_2^2}{\sigma_2^2}\sim\chi^2(n_2-1)\)</span></p><p><span class="math inline">\(\frac{S_1^2}{S_2^2}·\frac{\sigma_2^2}{\sigma_1^2}\simF(n_1-1,n_2-1)\)</span></p></li></ol><h2 id="参数估计与假设检验">7.参数估计与假设检验</h2><p>参数估计分为点估计和区间估计，点估计又分为矩估计和最大似然估计。</p><h3 id="估计量的无偏性">7.1 估计量的无偏性</h3><p>设<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的估计量，若<span class="math inline">\(E(\hat{\theta})=\theta\)</span>，就称<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的无偏估计，否则称为有偏估计。</p><p>若<span class="math inline">\(\lim\limits_{n \to\infty}E(\hat{\theta})=\theta\)</span>，就称<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的渐近无偏估计。</p><h3 id="离散总体的矩估计和最大似然估计">7.2离散总体的矩估计和最大似然估计</h3><p>例：总体<span class="math inline">\(X\)</span>的概率分布为</p><table><thead><tr><th style="text-align: center;">X</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr><td style="text-align: center;">P</td><td style="text-align: center;"><span class="math inline">\(\theta^2\)</span></td><td style="text-align: center;"><span class="math inline">\(2\theta(1-\theta)\)</span></td><td style="text-align: center;"><span class="math inline">\(\theta^2\)</span></td><td style="text-align: center;"><span class="math inline">\(1-2\theta\)</span></td></tr></tbody></table><p>其中<span class="math inline">\(\theta(0&lt;\theta&lt;\frac{1}{2})\)</span>是未知参数，利用总体<span class="math inline">\(X\)</span>的如下样本值$ 3,1,3,0,3,1,2,3<span class="math inline">\(，求\)</span>$的矩估计和最大似然估计值。</p><p>解：矩估计：<span class="math inline">\(E(X)=2\theta(1-\theta)+2\theta^2+3(1-2\theta)=3-4\theta=2\)</span></p><p>​ <span class="math inline">\(\therefore\hat{\theta}=\frac{1}{4}\)</span></p><p>​ 最大似然估计：<span class="math inline">\(L(\theta)=(1-2\theta)^4[2\theta(1-\theta)]^2(\theta^2)^2\)</span></p><p>​ <span class="math inline">\(\ln L(\theta)=4\ln (1-2\theta)+2\ln2\theta(1-\theta)+4\ln \theta\)</span></p><p>​ <span class="math inline">\(\frac{d\lnL(\theta)}{d\theta}=\frac{8}{2\theta-1}+\frac{2-4\theta}{\theta(1-\theta)}+\frac{4}{\theta}=0\)</span></p><p>​ <span class="math inline">\(\therefore\hat{\theta}=\frac{7-\sqrt{13}}{12}\)</span></p><h3 id="区间估计的置信区间">7.3 区间估计的置信区间</h3><p>设总体<span class="math inline">\(X\)</span>的分布中含有未知函数<span class="math inline">\(\theta\)</span>，<span class="math inline">\(P\{\hat{\theta}_1&lt;\theta&lt;\hat{\theta}_2\}=1-\alpha\)</span>，则称随机区间<span class="math inline">\((\hat{\theta}_1,\hat{\theta}_2)\)</span>为未知参数<span class="math inline">\(\theta\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间。<span class="math inline">\(\hat{\theta}_1\)</span>和<span class="math inline">\(\hat{\theta}_2\)</span>分别称为置信下限和置信上限，<span class="math inline">\(1-\alpha\)</span>称为置信度或置信水平。</p><p>设总体<span class="math inline">\(X\simN(\mu,\sigma^2)\)</span>，常见置信区间有：</p><ol type="1"><li><p>当<span class="math inline">\(\sigma^2\)</span>已知时，<span class="math inline">\(\mu\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{-U_{\frac{\alpha}{2}}&lt;\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}&lt;U_{\frac{\alpha}{2}}\}=1-\alpha\]</span></p><p><span class="math display">\[P\{\overline{X}-U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}}&lt;\mu&lt;\overline{X}+U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}}\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\overline{X}-U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}},\overline{X}+U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}})\]</span></p></li><li><p>当<span class="math inline">\(\sigma^2\)</span>未知时，<span class="math inline">\(\mu\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{-t_{\frac{\alpha}{2}}(n-1)&lt;\frac{\overline{X}-\mu}{S/\sqrt{n}}&lt;t_{\frac{\alpha}{2}}(n-1)\}=1-\alpha\]</span></p><p><span class="math display">\[P\{\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}}&lt;\mu&lt;\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}}\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}},\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}})\]</span></p></li><li><p>当<span class="math inline">\(\mu\)</span>已知时，<span class="math inline">\(\sigma^2\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{\chi^2_{1-\frac{\alpha}{2}}(n)&lt;\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\sigma^2}&lt;\chi^2_{\frac{\alpha}{2}}(n)\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\chi^2_{\frac{\alpha}{2}}(n)},\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\chi^2_{1-\frac{\alpha}{2}}(n)})\]</span></p></li><li><p>当<span class="math inline">\(\mu\)</span>未知时，<span class="math inline">\(\sigma^2\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间：</p></li></ol><p><span class="math display">\[P\{\chi^2_{1-\frac{\alpha}{2}}(n-1)&lt;\frac{(n-1)·S^2}{\sigma^2}&lt;\chi^2_{\frac{\alpha}{2}}(n-1)\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\frac{(n-1)·S^2}{\chi^2_{\frac{\alpha}{2}}(n-1)},\frac{(n-1)·S^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)})\]</span></p><h3 id="假设检验">7.4 假设检验</h3><p><span class="math inline">\(H_0\)</span>带等号，<span class="math inline">\(H_1\)</span>不带等号，其中<span class="math inline">\(H_1\)</span>对应于拒绝域。</p><p>第一类错误（弃真错误）：当原假设<span class="math inline">\(H_0\)</span>为真时，但检验结果为拒绝<span class="math inline">\(H_0\)</span>；</p><p>第二类错误（存伪错误）：当原假设<span class="math inline">\(H_0\)</span>不正确时，但检验结果为接受<span class="math inline">\(H_0\)</span>。</p><blockquote><p>不同的检验统计量对应的分布与置信区间那里一样。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>高等数学</tag>
      
      <tag>线性代数</tag>
      
      <tag>概率论与数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信网性能分析</title>
    <link href="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>2023/6/15 10:53 今天开始网络理论基础课程的复习及知识整理。</p><p>2023/6/21 23:14今天下午总算考完这门课，我也在今天晚上完成了通信网性能分析这门课知识的总结。另外说一句，今晚一边整理，一边发现今天下午考试时写错的，这种感觉真是苦不堪言啊......ps：明天开始高数的知识点梳理。</p><h1 id="一通信信源模型">一、通信信源模型</h1><h2 id="泊松过程">1.泊松过程</h2><p>对于Poisson呼叫流，长度为t的时间内到达k个呼叫的概率<span class="math inline">\(P_k(t)\)</span>服从Poisson分布，即 <span class="math display">\[p_k(t)=\frac{(\lambda t)^k}{k!}e^{-\lambda t}\qquad k=0,1,2,......\]</span> Poisson分布的均值：<span class="math inline">\(E[N(t)]=\lambdat\)</span></p><p>Poisson分布的方差：<span class="math inline">\(Var[N(t)]=\lambdat\)</span></p><p>m个Poisson流的参数分别为<span class="math inline">\(\lambda_1,\lambda_2,......,\lambda_m,\)</span>并且它们是相互<strong>独立</strong>的，合并流仍然为Poisson流，且参数为<span class="math inline">\(\lambda=\lambda_1+\lambda_2+...+\lambda_m\)</span>。</p><p>一个随机过程是参数 λ 的Poisson过程的充分必要条件为呼叫到达间隔<span class="math inline">\(X_i,i=1,2...\)</span>相互独立，且服从相同参数 λ的负指数分布。</p><h2 id="负指数分布">2.负指数分布</h2><p>随机变量X满足<span class="math inline">\(P\{X\ge t\}=e^{-\lambdat}\)</span>，或分布函数为：<span class="math inline">\(P\{X&lt;t\}=1-e^{-\lambdat},t\ge0\)</span>，则这个分布被称之为参数为λ的<strong>负指数分布</strong>。</p><p>这个分布的概率密度函数为：<span class="math inline">\(f_x(t)=\lambdae^{-\lambda t},t\ge0\)</span></p><p>负指数分布的均值：<span class="math inline">\(E[X]=\frac{1}{\lambda}\)</span></p><p>负指数分布的均值：<span class="math inline">\(Var[X]=\frac{1}{\lambda^2}\)</span></p><p>负指数分布具有无记忆特性：<span class="math inline">\(P\{X\get+s|X\ge t\}=P\{X\ge s\}\)</span></p><p>假设<span class="math inline">\(T_1,T_2\)</span>为<strong>相互独立的</strong>两个负指数分布，参数分别为<span class="math inline">\(\lambda_1,\lambda_2\)</span>，令<span class="math inline">\(T=min(T_1,T_2)\)</span>则：</p><ol type="1"><li><p>T 是一个以<span class="math inline">\(\lambda_1+\lambda_2\)</span>为参数的负指数分布；</p></li><li><p>T 的分布和<span class="math inline">\(T_i\)</span>谁是较小数无关；</p></li><li><p><span class="math inline">\(P\{T_1&lt;T_2|T=t\}=\frac{\lambda_1}{\lambda_1+\lambda_2}\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621204746403.png" style="zoom:80%;"></p></li></ol><h2 id="mm1排队系统">3.M/M/1排队系统</h2><h3 id="排队系统性能指标">3.1 排队系统性能指标</h3><p><em>λ</em>：排队系统到达率</p><p><span class="math inline">\(\mu\)</span>：服务率（离去率）</p><p>k：队长（系统中的顾客数）</p><p><span class="math inline">\(\omega\)</span>：等待时间</p><p><span class="math inline">\(\tau\)</span>：服务时间</p><p>s=<span class="math inline">\(\omega+\tau\)</span>：系统时间</p><p>η：系统效率</p><p><span class="math inline">\(\rho=\frac{\lambda}{\mu}\)</span></p><h3 id="mm1">3.2 M/M/1</h3><p>根据生灭过程的性质：<span class="math inline">\(p_k=\rho^kp_0\)</span></p><p>在<span class="math inline">\(\rho&lt;1\)</span>时，两边求和得到：<span class="math display">\[p_0=\frac{1}{1+\sum_{k=1}^{\infty}\rho^k}=1-\rho\]</span> M/M/1的队长分布：<span class="math inline">\(p_k=\rho^k(1-\rho)\qquad k=0,1,2,...\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200225503.png" alt="M/M/1的状态转移图" style="zoom: 80%;"></p><p>N：系统中的平均顾客数</p><p>T：顾客在系统中的平均时间 <span class="math display">\[平均队长:E[N]=\frac{\rho}{1-\rho}\]</span></p><p><span class="math display">\[Var[N]=\frac{\rho}{(1-\rho)^2}\]</span></p><p><span class="math display">\[在系统中的平均停留时间:E[s]=\frac{\frac{\rho}{1-\rho}}{\lambda}=\frac{1}{\mu-\lambda}\]</span></p><p><span class="math display">\[平均排队时间:E[\omega]=E[s]-\frac{1}{\mu}=\frac{\rho}{1-\rho}\frac{1}{\mu}\]</span></p><p><span class="math display">\[平均等待队长:E[N_w]=\lambdaE[\omega]=\frac{\rho}{1-\rho}\frac{\lambda}{\mu}\]</span></p><p>M/M/1排队系统在稳态时，系统时间 s 服从参数为<span class="math inline">\(\mu-\lambda\)</span>的负指数分布。</p><h1 id="二erlang拒绝和等待系统">二、Erlang拒绝和等待系统</h1><p>呼叫量=业务量/观察时间</p><p>呼叫量的单位为erl，这是一个无量纲的单位。</p><p>实际上，在一段时间T内通过的呼叫量就是该时段内被占用的平均中继线数目。</p><h2 id="erlang即使拒绝系统mmss">1.Erlang即使拒绝系统——M/M/s(s)</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200329406.png" alt="M/M/s(s)的状态转移图" style="zoom: 67%;"></p><p>令<span class="math inline">\(a=\frac{\lambda}{\mu}\)</span>，则<span class="math inline">\(p_k=\frac{a^k}{k!}p_0\qquadk=1,2,...,s\)</span></p><p>两边求和解得： <span class="math display">\[p_0=\frac{1}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 稳态分布为： <span class="math display">\[p_k=\frac{\frac{a^k}{k!}}{\sum_{r=0}^{s}\frac{a^r}{r!}}\qquadk=0,1,2,...,s\]</span> 特别，当k＝s时，p<sub>s</sub>表达了中继线全忙的概率，这个概率为系统的时间阻塞率，记为<span class="math display">\[p_s=B(s,a)=\frac{a^s/s!}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 通过的呼叫量：<span class="math inline">\(a&#39;=a[1-B(s,a)]\)</span></p><h2 id="erlang等待制系统mms">2.Erlang等待制系统—M/M/S</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615210209146.png" alt="M/M/S状态转移图" style="zoom: 80%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620225521649.png" alt="等待制系统分析" style="zoom: 67%;"></p><p><span class="math display">\[p_0=\frac{1}{\sum_{k=0}^{s-1}\frac{a^k}{k!}+\frac{a^s}{s!}\frac{1}{1-a/s}}\]</span> 一个呼叫需要等待的概率： <span class="math display">\[C(s,a)=\frac{a^s}{s!}\frac{p_0}{1-a/s}\]</span> 在a&lt;s的条件下：</p><p>通过的呼叫量：<span class="math inline">\(a&#39;=a\)</span></p><p>系统中的平均呼叫数：<span class="math inline">\(E[N]=\frac{\rho}{1-\rho}C(s,a)+a\qquad\rho=a/s\)</span></p><p>系统中的平均呼叫数为a，等待队列中的平均呼叫数为<span class="math inline">\(\frac{\rho}{1-\rho}C(s,a)\)</span></p><p>平均等待时间：<span class="math inline">\(E[\omega]=[\frac{\rho}{1-\rho}C(s,a)]/\lambda=\frac{C(s,a)}{s\mu(1-\rho)}\)</span></p><p>等待时间的分布：<span class="math inline">\(p\{\omega&gt;t\}=C(s,a)e^{-(s\mu-\lambda)t}\)</span></p><h2 id="一般混合制的mmsn系统">3.一般混合制的M/M/S(n)系统</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620231245977.png" alt="M/M/S(n)系统分析" style="zoom:67%;"></p><h1 id="三通信网络性能分析">三、通信网络性能分析</h1><h2 id="wilkinson定理算溢出呼叫流的统计特征">1.Wilkinson定理算溢出呼叫流的统计特征</h2><p><span class="math display">\[\alpha=aB(s,a)\qquad v=\alpha(1-\alpha+\frac{a}{s+1+\alpha-a})\]</span></p><blockquote><p>上面是溢出呼叫流和溢出呼叫流的方差</p></blockquote><p><span class="math display">\[峰值因子:z=\frac{v}{\alpha}\]</span></p><h2 id="呼损的近似计算方法rapp">2.呼损的近似计算方法Rapp</h2><ol type="1"><li><p>计算<span class="math inline">\(z=\frac{v}{\alpha}\)</span></p></li><li><p>令<span class="math inline">\(a=v+3z(z-1)\)</span> <span class="math display">\[然后,s=\frac{a(\alpha+z)}{\alpha+z-1}-\alpha-1\]</span> 但s一般不为整数，向下取整，记为[s]</p></li><li><p>重新计算： <span class="math display">\[a=\frac{([s]+\alpha+1)(\alpha+z-1)}{\alpha+z}\]</span></p></li><li><p>计算等效系统的呼损和拒绝的呼叫量<span class="math inline">\(B(s+c,a)\)</span>和<span class="math inline">\(aB(s+c,a)\)</span></p></li></ol><h1 id="四网络拓扑结构分析">四、网络拓扑结构分析</h1><h2 id="图论基础">1.图论基础</h2><h3 id="图的定义和基本概念">1.1 图的定义和基本概念</h3><p>图：所谓一个图G，是指给了一个端点集合V，以及边的集合或V中元素的序对集合E，图一般用G=(V,E)来表示。</p><p>端的度数：</p><ul><li>对无向图的端<span class="math inline">\(v_i\)</span>，与该端关联边的数目为该端的度数，记为：<span class="math inline">\(d(v_i)\)</span>。</li><li>对有向图的端<span class="math inline">\(v_i\)</span>，<span class="math inline">\(d^+(v_i)\)</span>表示离开<span class="math inline">\(v_i\)</span>的边数，<span class="math inline">\(d^-(v_i)\)</span>表示进入<span class="math inline">\(v_i\)</span>的边数。</li></ul><p>给定图G=(V,E)，若<span class="math inline">\(V_1\subseteqV,E_1=\{(u,v)\in E|u,v\in V_1\}\)</span>称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(V_1\)</span>生成的<strong>子图</strong>，记<span class="math inline">\(G[V_1]\)</span>。</p><p>特别，若子图的端点集合为V，这个图被称为图G的<strong>支撑子图</strong>。</p><p>若<span class="math inline">\(E_1\subseteq E,V_1=\{V\inV|v是E_1中某边的端点\}\)</span>， 称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(E_1\)</span>生成的子图，记为<span class="math inline">\(G[E_1]\)</span>。</p><p>考虑边的一个序列，相邻两边有公共端，如(v1，v2)， (v2，v3)，(v3，v4)，…… (vi，vi+1)，这个边序列称为<strong>链</strong>，链简单说就是一个连续轨迹。</p><p>没有重复边的链称为简单链；没有重复端的链称为初等链或<strong>道路</strong>。</p><p>若链的起点与终点重合，称之为<strong>圈</strong>；若道路的起点与终点重合,称之为<strong>初等圈</strong>。</p><p>任何两端间至少存在一条链的图，为<strong>连通图</strong>。否则，就是非连通图。</p><h3 id="树">1.2 树</h3><p>树的定义：</p><ul><li>任何二端有且只有一条道路的图称为树。</li><li>无圈的连通图称为树。</li></ul><p>如果树T是连通图G的子图，<span class="math inline">\(T\subseteqG\)</span>，且T包含G的所有端，称T是G的<strong>支撑树或主树</strong>。</p><p>树边，连枝：如果在一个连通图中确定了一个支撑树，图的边集合被分为两类，属于树的边称为树边；不属于树的边称为连枝。</p><h3 id="割集">1.3 割集</h3><p><strong>割集</strong>指的是某些端集或边子集，对连通图，去掉此类子集，图变为不连通（即图变成一个点）。</p><p>设v是图G的一个端，去掉<mark>v和其关联边</mark>后，G的部分数增加（或图变成一个点），则称v是图G的<strong>割端</strong>。</p><p>去掉一个端集合后，G的部分数增加，这个端的集合称为<strong>割端集</strong>。</p><p>对于连通图,在众多的割端集中至少存在一个端数最少的割端集，称为<strong>最小割端集</strong>。</p><p>最小割端集的端数目，称为图的<strong>点连通度或连通度</strong>，连通度用a表示。</p><p>设e是图G的一条边，去掉 e后，G的部分数增加，则称e是图G的<strong>割边</strong>。去掉一个边集合后，G的部分数增加，这个边的集合称为<strong>割边集</strong>。</p><p>割边集中边数最少的割边集，称为<strong>最小割边集</strong>。最小割边集的边数目，称为<strong>线连通度</strong>，线连通度用β表示。</p><p>确定了连通图的一个支撑树后，每条树边可以决定一个基本割集。</p><p>对于支撑树，去掉<strong>树</strong>上任何一条边，<strong>树</strong>便分为两个连通分支，从而将原图的<strong>端</strong>分为两个集合，这两个集合之间的所有<strong>边</strong>形成一个极小边割集，这个边割集称为<strong>基本割集</strong>。</p><blockquote><p>基本割集数等于树支数。</p></blockquote><p>对于任何一个连通图G，设T为G的一个支撑树，每一条连枝决定的圈是<strong>基本圈</strong>。</p><blockquote><p>基本圈的个数等于连枝数。</p></blockquote><p>反圈：给定图G=(V,E)，<span class="math inline">\(S,T\subseteqV\)</span>，记<span class="math inline">\([S,T]_G=\{(u,v)\in E|u\inS,v\in T \}\)</span>；特别，当T=V，将<span class="math inline">\([S,T]_G\)</span>记为<span class="math inline">\(\Phi_G(S)\)</span>或<span class="math inline">\(\Phi(S)\)</span>。设X是V的非空真子集，若<span class="math inline">\(\Phi_G(X)\not=\phi\)</span>，称<span class="math inline">\(\Phi_G(X)\)</span>为由X确定的反圈。</p><blockquote><p>反圈是一种特殊的边割集。</p></blockquote><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="最小支撑树">2.1 最小支撑树</h3><h4 id="prim算法反圈法">2.1.1 Prim算法－反圈法</h4><ol type="1"><li>任取一点作为初始的<span class="math inline">\(X^{(0)}\)</span>；</li><li>在反圈<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选边的原则是：<ul><li>从<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选一条权最小的边（如果有多条权最小的边，则任选一条）；</li><li>将选出边的邻端并入<span class="math inline">\(X^{(k)}\)</span>形成<span class="math inline">\(X^{(k+1)}\)</span>；</li></ul></li><li>若在某一步，<span class="math inline">\(\Phi[X^{(k)}]=\phi\)</span>，则G不含支撑树；若在某一步，<span class="math inline">\(X^{(k)}=V\)</span>，则由所有被选边生成的树是最小支撑树。</li></ol><h4 id="kruskal算法避圈法">2.1.2 Kruskal算法－避圈法</h4><p>将所有边排序，然后由小到大选边，保持所选的边不生成圈，如果选了n－1条边，则生成了一个最小支撑树。</p><h4 id="破圈法">2.1.3 破圈法</h4><p>从连通图中先寻找圈，然后在圈中删去权最大的边，最后剩下的无圈连通图为最小支撑树。</p><h3 id="端间最短距离和路由">2.2 端间最短距离和路由</h3><h4 id="dijkstra算法">2.2.1 Dijkstra算法</h4><p>在下图中求<span class="math inline">\(v_1\)</span>到其余端点的最短距离和路由：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230618194227852.png" alt style="zoom:50%;"></p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(v_1\)</span></th><th style="text-align: center;"><span class="math inline">\(v_5\)</span></th><th style="text-align: center;"><span class="math inline">\(v_2\)</span></th><th style="text-align: center;"><span class="math inline">\(v_3\)</span></th><th style="text-align: center;"><span class="math inline">\(v_4\)</span></th><th style="text-align: center;">置定端<span class="math inline">\(l_0\)</span></th><th style="text-align: center;">距离<span class="math inline">\(\lambda_{l_0}\)</span></th><th style="text-align: center;">路由<span class="math inline">\(i_0\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">6</td><td style="text-align: center;">V3</td><td style="text-align: center;">2</td><td style="text-align: center;">V1</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V2</td><td style="text-align: center;">3</td><td style="text-align: center;">V3</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V4</td><td style="text-align: center;">5</td><td style="text-align: center;">V3</td></tr><tr><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V5</td><td style="text-align: center;">6</td><td style="text-align: center;">V2</td></tr></tbody></table><h4 id="floyd算法">2.2.1 Floyd算法</h4><ul><li><p>给定图G及其边(i,j)的权<span class="math inline">\(w_{i,j}\)</span></p></li><li><p><span class="math inline">\(F_0\)</span>：初始化距离矩阵<span class="math inline">\(W^{(0)}\)</span>和路由矩阵<span class="math inline">\(R^{(0)}\)</span></p><ul><li><p><span class="math display">\[w_{ij}^{(0)}=\begin{cases}w_{ij} &amp;\text{若 $e_{ij}\in E$}\\\infty &amp;\text{若 $e_{ij}\not\in E$}\\0 &amp;\text{若 $i=j$}\\\end{cases}\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(0)}=\begin{cases}j &amp;\text{若 $w_{ij}^{(0)}\not=\infty,0$}\\0 &amp;\text{其它}\\\end{cases}\]</span></p></li></ul></li><li><p>迭代</p><ul><li><p><span class="math display">\[w_{i,j}^{(k)}=min(w_{i,j}^{(k-1)},w_{i,k}^{(k-1)}+w_{k,j}^{(k-1)})\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(k)}=\begin{cases}r_{i,k}^{(k-1)}&amp;\text{若 $w_{i,j}^{(k)}&lt;w_{i,j}^{(k-1)}$}\\r_{i,j}^{(k-1)} &amp;\text{若$w_{i,j}^{(k)}=w_{i,j}^{(k-1)}$}\\\end{cases}\]</span></p></li></ul></li><li><p>根据<span class="math inline">\(R^{(n)}\)</span>进行路由查找。</p></li><li><p>根据<span class="math inline">\(W^{(n)}\)</span>求图的中心与中点</p><ul><li>中心：先找每行最大值，再找里面最小的；</li><li>中点：先每行求和，再找里面最小的。</li></ul></li></ul><p>例：利用F算法求v2到 v4的最短距离和正向路由，并求网的中心和中点。</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621213119808.png" alt="例题解答"><figcaption aria-hidden="true">例题解答</figcaption></figure><p><span class="math inline">\(v_2\)</span>到<span class="math inline">\(v_4\)</span>的最短距离为4，正向路由为<span class="math inline">\(v_2\to v_1\to v_4\)</span>。</p><h2 id="网络流量问题">3.网络流量问题</h2><p>可行流的两个限制条件：</p><ol type="1"><li><p>非负有界性：对任意边<span class="math inline">\(e_{i,j}\)</span>有，<span class="math inline">\(0\le f_{i,j}\le c_{i,j}\)</span></p></li><li><p>连续性：对任意端<span class="math inline">\(v_t\)</span>有，<span class="math display">\[\sum_{(i,j)\in E}^{}f_{ij}-\sum_{(j,i)\in E}^{}f_{ji}=\begin{cases}F &amp;\text{$v_i$为源端$v_s$}\\-F &amp;\text{$v_i$为源端$v_t$}\\0 &amp;\text{其他}\\\end{cases}\]</span></p></li></ol><p>割量<span class="math inline">\(C(X,X^c)\)</span>定义为这个割集中所有边容量的和。</p><p>对于某条流，若在某条路中，前向边均不饱和（<span class="math inline">\(f_{i,j}&lt;c_{i,j}\)</span>），反向边均有非0流量（<span class="math inline">\(f_{j,j}\not=0\)</span>），称这条路为<strong>可增流路</strong>。</p><h3 id="最大流问题m算法">3.1 最大流问题—M算法</h3><p>例：利用M算法计算下图的最大流结果</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621215552636.png" alt="题目所给网络" style="zoom:80%;"></p><p>①标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_A(+,S,5)\)</span>，标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_A\)</span>：标<span class="math inline">\(V_C(+,A,5)\)</span>，<span class="math inline">\(V_A\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,5)\)</span></p><p>增流：<span class="math inline">\(f_{SA}=5,f_{AC}=5,f_{CT}=5\)</span></p><p>②重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,4)\)</span>，标<span class="math inline">\(V_D(+,B,4)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,3)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3,f_{BC}=3,f_{CT}=3\)</span></p><p>③重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,1)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,1)\)</span>，标<span class="math inline">\(V_D(+,B,1)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,D,1)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3+1,f_{BD}=1,f_{DT}=1\)</span></p><p>故最大可行流为5+3+1=9。</p><h3 id="最小费用流问题负价环法算法">3.2 最小费用流问题—负价环法算法</h3><p>例：图(a)为该通信网，一个可行流安排如图(b)，求最小费用流的流量安排。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222102785.png" alt="图(a)" style="zoom: 67%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222213322.png" alt="图(b)" style="zoom:67%;"></p><ol type="1"><li><p>图(b)的总费用为54，其补图为图(c)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120016583.png" alt="图(c)" style="zoom:67%;"></p><p>找到负圈(B,C,T,D)，沿其增流2单位，总费用减2×(-1)=-2</p><p>可行流为图(d)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621223124406.png" alt="图(d)" style="zoom:67%;"></p></li><li><p>图(d)的补图为图(e)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120102209.png" alt="图(e)" style="zoom:67%;"></p><p>找到负圈(A,C,B,S)，沿其增流1单位，总费用减1×(-1)=-1。</p><p>可行流为图(f)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120152137.png" alt="图(f)" style="zoom:67%;"></p></li><li><p>图(f)的补图为图(g)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120218809.png" alt="图(g)" style="zoom:67%;"></p><p>已找不到负圈，最小费用为51。</p></li></ol><h1 id="五网络可靠性分析">五、网络可靠性分析</h1><h2 id="可靠性理论基础">1.可靠性理论基础</h2><h3 id="寿命分布和失效率函数">1.1 寿命分布和失效率函数</h3><h3 id="寿命分布和可靠度">1.1.1 寿命分布和可靠度</h3><p>首先，考虑子系统的可靠性特点，然后考虑子系统依照不同方法构成的大系统的可靠性。</p><p>对于简单系统，假设它仅包含两个状态：正常和故障。如果用一个非负随机变量X来描述系统的寿命，X相应的分布函数为：</p><p><span class="math display">\[F(t)=P\{X \le t \}\]</span> 有了寿命分布，就知道了在时刻t以前都正常的概率： <span class="math display">\[R(t)=P\{X &gt; t \}=1-F(t)\]</span> 而R(t)表示系统的可靠度函数或可靠度。</p><p>平均寿命为： <span class="math display">\[E(X)=\int_{0}^{\infty}R(t)dt\]</span></p><h4 id="失效率函数">1.1.2 失效率函数</h4><p>设系统的寿命为非负连续型随机变量，其分布函数为F(t)，密度函数为f(t)，定义失效率函数如下：<span class="math display">\[对任意t,F(t)&lt;1, 失效率函数（简称失效率）:r(t)=\frac{f(t)}{1-F(t)}\]</span> 因系统在t时刻正常，在(t,t+△t]中失效的概率为： <span class="math display">\[P\{X \le t+\varDelta t|X&gt;t\}\frac{F(t+\varDelta t)-F(t)}{1-F(t)}\sim\frac{f(t)\varDelta t}{1-F(t)}=r(t)\varDelta t\]</span> 当△t很小时，r(t)△t表示在(t,t+△t]中失效的概率。</p><p>下图中表示了典型的失效率函数，也被称之为浴盆曲线：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615113134324.png" alt="浴盆曲线" style="zoom: 67%;"></p><h3 id="不可修复系统和可修复系统">1.2 不可修复系统和可修复系统</h3><p>如果一个子系统在故障后，不再修复，这个子系统称之为不可修复系统。</p><p>如果一个子系统在故障后，经历一段时间，修复又重新使用，如此循环往复，这种系统称之为可修复系统。</p><p>可修复系统和不可修复系统的区分并不是绝对的，在一定条件下它们可以相互转换。</p><h4 id="不可修复系统">1.2.1 不可修复系统</h4><p>对于不可修复系统，可靠性的重要指标为其寿命分布X和可靠度函数R(t)。若失效率函数为常数α，X服从负指数分布，则<span class="math display">\[R(t)=P\{X&gt;t\}=e^{-\alpha t}\]</span> 不可修复系统的平均寿命记为MTTF， <span class="math display">\[MTTF=\frac{1}{\alpha}\]</span> 一般地，系统的失效率函数不为常数，设为r(t)，则可靠度： <span class="math display">\[R(t)=e^{-\int_{0}^{t}r(x)dx}\]</span></p><h4 id="可修复系统">1.2.2 可修复系统</h4><p>对于可修复系统，系统处于故障、正常的循环交替中。系统的可靠度有时也被称为<strong>可用度</strong>，它表示在总时间中有多少比例的时间系统处于正常状态，其可靠度R应与时间t无关，<span class="math display">\[R=\frac{正常时间}{总时间}\]</span></p><h4 id="平均故障间隔时间mtbf和平均修复时间mttr">1.2.3平均故障间隔时间MTBF和平均修复时间MTTR</h4><p>可修复系统在故障之后，其修复时间的分布有多种类型。</p><p>下面假设系统的修复时间为参数β的负指数分布，系统正常工作时间为参数α的负指数分布，若R(t)为可靠度函数，则<span class="math display">\[R(t)=\frac{\beta}{\alpha+\beta}+\frac{\alpha}{\alpha+\beta}e^{-(\alpha+\beta)t}\]</span></p><p><span class="math display">\[在t\rightarrow\infty时,R(t)=R=\frac{\beta}{\alpha+\beta}或\frac{\frac{1}{\alpha}}{\frac{1}{\alpha}+\frac{1}{\beta}}\]</span></p><p>1/α为平均故障间隔时间，一般记为MTBF；</p><p>1/β为平均修复时间，一般记为MTTR。</p><p>同时β也被称为修复率。</p><p>对于可修复系统可以利用实测数据来估计它的可用度；而对于不可修复系统，容易根据实测数据获得可靠度的估计值，从而得到寿命分布函数。</p><h3 id="复杂系统的可靠度">1.3 复杂系统的可靠度</h3><p>子系统可以依照不同的方法构成大系统，最简单的如串接、并接。在下图中分别表示了串接、并接系统。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615143534212.png" alt="串接、并接系统" style="zoom: 67%;"></p><p>如果n个子系统只要有一个子系统故障，整个系统就故障，n个子系统就构成一个串接系统。</p><p>如果n个子系统只要有一个子系统正常，整个系统就正常，n个子系统就构成一个并接系统。</p><h5 id="独立系统可靠度计算">独立系统可靠度计算:</h5><p>当各个子系统独立时，串、并接系统的可靠度分别计算如下： <span class="math display">\[R_串=\prod_{i=1}^{n}R_i\]</span></p><p><span class="math display">\[R_并=1-\prod_{i=1}^{n}(1-R_i)\]</span></p><p>已知各子系统的可靠度R<sub>i</sub>总是小于1的，则串接系统的可靠度必小于任一子系统的可靠度。串接子系统愈多，可靠度也将愈小。</p><p>并接系统中的子系统愈多，系统的可靠度愈高。实际上这是采用备用系统的结果。备用系统愈多，当然愈不会失效。</p><h5 id="不可修复子系统的串接">不可修复子系统的串接：</h5><p>例如一个系统是由n个不可修复的子系统组成的串接系统，各子系统均相同，失效率均为α，或平均寿命均为1/α，则此系统的可靠度将为：<span class="math inline">\(R(t)=e^{-nat}\)</span>其平均寿命将为1/nα，即缩短到1/n。</p><p>当各不可修复的子系统有不同失效率α<sub>r</sub>时，可得全系统的可靠度为：<span class="math inline">\(R(t)=e^{-t\sum_{r=1}^{n}\alpha_r}\)</span></p><p>平均寿命为： <span class="math display">\[T=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 等效失效率为：<span class="math inline">\(\alpha=1/T\)</span></p><h5 id="非独立系统可靠度">非独立系统可靠度：</h5><p>n个子系统串接形成一个系统，每个子系统为可修复系统，其可靠度为<span class="math inline">\(\frac{\beta_i}{\alpha_i+\beta_i}\)</span>，但当某个子系统故障时，别的子系统停顿，等故障子系统修复后，其它子系统继续一起工作，求系统可靠度R。</p><p>若第r个子系统失效，平均修复时间为：<span class="math inline">\(1/\beta_r\)</span></p><p>各子系统的失效概率应与它的失效率α<sub>r</sub>成正比，第r个系统失效的概率为：<span class="math display">\[p_r=\frac{\alpha_r}{\sum_{k=1}^{n}\alpha_k}\]</span> 全系统的平均修复时间为： <span class="math display">\[MTTR=\sum_{r=1}^{n}\frac{p_r}{\beta_r}=\frac{\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}{\sum_{r=1}^{n}\alpha_r}\]</span> 平均故障间隔时间为： <span class="math display">\[MTBF=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 全系统的可靠度为： <span class="math display">\[R&#39;=\frac{MTBF}{MTBF+MTTR}=\frac{1}{1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}\]</span> 各子系统独立时的可靠度： <span class="math display">\[R=\prod_{r=1}^{n}\frac{\beta_r}{\alpha_r+\beta_r}=\frac{1}{\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})}\]</span> 许多子系统停止了不必要的运行：R'&gt;R <span class="math display">\[\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})&gt;1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}\]</span></p><h5 id="不可修复子系统的并接">不可修复子系统的并接：</h5><p>若各子系统都是不可修复的，全系统的可靠度为： <span class="math display">\[R(t)=1-\prod_{i=1}^{n}[1-R_r(t)]=1-\prod_{i=1}^{n}(1-e^{-\alpha_rt})=\sum_{r=1}^{n}e^{-\alpha_rt}-\sum_{r_1\not=r_2}^{}e^{-(\alpha_{r1}+\alpha_{r2})t}+\sum_{r_1\not=r_2\not=r_3}^{}e^{-(\alpha_{r1}+\alpha_{r2}+\alpha_{r3})t}-...\]</span> 平均寿命为：<span class="math inline">\(T=\sum_{r=1}^{n}\frac{1}{\alpha_r}-\sum_{r_1\not=r_2}^{}\frac{1}{\alpha_{r1}+\alpha_{r2}}+...\)</span></p><p>若各子系统的失效率均为α，则平均寿命为：<span class="math inline">\(T=\frac{n}{\alpha}-\frac{1}{2\alpha}C_n^2+\frac{1}{3\alpha}C_n^3-...+(-1)^n\frac{1}{n\alpha}\)</span></p><h2 id="网络可靠度的计算">2.网络可靠度的计算</h2><p>若考虑连通无向图G=(V,E)，<strong>点连通度α</strong>与<strong>线连通度β</strong>反映了图的可靠性大小，下面再定义一个混合连通度γ，其定义如下</p><p><span class="math inline">\(γ=min|X|\)</span>，其中X为混合割集。则<span class="math inline">\(\alpha=\gamma\le \beta\le \delta\le\frac{2m}{n}\)</span></p><p>为了更加细致地描述图的可靠性，引入三个辅助指标。它们的定义如下：</p><ul><li>C<sub>α</sub> = 最小割端集的数目；</li><li>B<sub>β</sub> = 最小割边集的数目；</li><li>A<sub>γ</sub> = 最小混合割集的数目；</li></ul><p>例题：<img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230044115.png" alt="题目" style="zoom:80%;"></p><p>解：</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230104150.png" alt="端和边的个数"><figcaption aria-hidden="true">端和边的个数</figcaption></figure><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230218619.png" alt="混合割集" style="zoom:80%;"><span class="math display">\[\alpha=3,\beta=3,\gamma=3\]</span></p><p><span class="math display">\[C_\alpha=60,B_\beta=60,A_\gamma=60+60+60*3+90*2=480\]</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230502255.png" alt="近似可靠度" style="zoom: 50%;"></p><h2 id="网络综合可靠度">3.网络综合可靠度</h2><p><strong>通信网的各种连通度以及一些辅助指标</strong>，这些指标仅仅依赖于拓扑结构，是对可靠性的<strong>确定性度量</strong>。</p><p>为了<strong>进一步</strong>分析网络的可靠度，需要考虑<strong>网络承载的业务</strong>。</p><p>考虑<strong>故障因素</strong>的电话网络平均呼损也可被称之为<strong>综合不可靠度</strong>。</p><h1 id="六溢出呼叫流的仿真实现与分析">六、溢出呼叫流的仿真实现与分析</h1><h2 id="研究背景与问题描述">1.研究背景与问题描述</h2>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信网</tag>
      
      <tag>泊松分布</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生物信息学</title>
    <link href="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    <url>/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>2023/6/14 12:15昨天结束了生物信息基础的期末考试，而在今天终于把生物信息学的知识整理完毕，历时一个星期，收工！</p><h1 id="一序列分析">一、序列分析</h1><h2 id="序列的相似性">1.序列的相似性</h2><h3 id="序列比较">1.1 序列比较</h3><p>序列比较是生物信息学中最基本、最重要的操作。通过序列比较可以发现生物序列中的结构、功能和进化的信息。找出具有生物学意义的相似性或差异，研究序列的同源性。</p><ul><li>同源（homology）: 两个序列有共同的祖先。</li><li>垂直同源序列：来自于不同种属的的同源序列，也叫直系同源</li><li>横向同源序列：来自于同一种属的序列，由进化过程中的序列复制而产生，也叫旁系同源。</li></ul><p>同源序列一般是相似的，相似序列不一定是同源的。</p><p>序列比较的基本任务：</p><ul><li>计算序列之间的<strong>相似性</strong></li><li>找出序列之间的<strong>共同区域</strong></li><li>辨别序列之间的<strong>差异</strong></li></ul><h3 id="子序列和字串">1.2 子序列和字串</h3><p>子序列的描述</p><ul><li>子序列 <sub>0</sub>:s:<sub>i</sub> 称为前缀，即prefix(s,i)</li><li>子序列 <sub>i</sub>:s:<sub>|s|</sub>称为后缀，即suffix(s,|s|-i)</li><li><sub>i</sub>:s: <sub>i</sub> — 为空序列</li><li><sub>j-1</sub>:s:<sub>j</sub> —表示s 中的第j个字符，简记为s<sub>j</sub></li></ul><p>子序列：选取s中的某些字符或删除s中的某些字符而形成s的一部分。</p><p>子串： 由s中相继的字符所组成</p><blockquote><p>子串是子序列，子序列不一定是字串</p></blockquote><h3 id="序列相似性比较">1.3 序列相似性比较</h3><p>相似程度的刻画：</p><ol type="1"><li>两个序列的相似度:它是两个序列的函数，其值越大，表示两个序列越相似</li><li>两个序列的距离：距离越大，则两个序列的相似度就越小。</li></ol><blockquote><p>汉明(Hamming)距离：对于两条长度相等的序列，汉明距离等于对应位点上字符不同的数目</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608114003804.png"></p></blockquote><p>序列比对(Alignment)是序列比较的基本操作。是关于序列相似性的定性描述。</p><p>两个序列的比对是指这两个序列中各个字符的一种一一对应关系(或各个字符的对比排列)。反映出两条序列在什么部位相同，什么部位存在差异。</p><blockquote><p>两个序列可以有多种不同的比对方式。</p></blockquote><h3 id="编辑距离">1.4 编辑距离</h3><p>度量两个字符串之间的距离的主要困难？</p><ul><li>两个字符串之间可能具有不同的长度，各自位置上的字符并不一定是真正的对应关系，直接计算汉明距离未必适当。</li></ul><p>如何合理度量？</p><ul><li>通过字符的插入、删除和替换等<strong>编辑操作</strong>把一个字符串变为另一个字符串</li></ul><ol type="1"><li>Match (a，a)：字符匹配</li><li>Delete (a，-) ：从第一条序列删除字符a(或在第二条序列相应的位置插入空位字符)</li><li>Insert(-，b)：在第一条序列插入空位字符(或删除第二条序列中的对应字符b)</li><li>Replace(a，b)：以第二条序列中的字符b替换第一条序列中的字符a，且a和b不相同</li></ol><p>编辑距离的定义：两个字符串之间，由一个字符串转换成另一个字符串所需要进行的<strong>最少</strong>编辑操作次数；其中的编辑操作包括把一个字符替换成另一个字符、插入一个字符和删除一个字符。</p><blockquote><p>编辑距离是所有可能的把s转换为t的<strong>编辑总代价的最小值</strong>。</p></blockquote><h3 id="序列比对的量化评价">1.5 序列比对的量化评价</h3><h4 id="代价函数法">1.5.1 代价函数法</h4><ul><li>首先定义一个<strong>代价函数</strong></li><li>然后定义序列比对的<strong>总代价</strong>等于各列的代价之和</li><li>其中，每一列考虑3种情况，其代价定义如下：<ul><li>匹配：0</li><li>替换：1</li><li>空位：1</li></ul></li></ul><h4 id="打分函数法">1.5.2 打分函数法</h4><ul><li>首先定义一个<strong>打分函数</strong></li><li>然后定义<strong>序列比对的打分值</strong>等于各列的打分之和</li><li>其中，每一列考虑3种情况，其打分定义如下：<ul><li>匹配：+1</li><li>替换：-1</li><li>空位：-1</li></ul></li></ul><blockquote><p>对于核酸序列或蛋白质序列的比对，打分函数的定义需要考虑其生物学意义。</p></blockquote><h4 id="序列比对与最优序列比对">1.5.3 序列比对与最优序列比对</h4><p>序列比对：通过字符匹配、替换、插入或删除，使两个序列的长度相等；但不能出现两者全为空位的列，且每一列只能出现匹配、失配和出现1个空位这3种可能情形之一。</p><p>两条序列比对的得分：将序列s转化为序列t所用的所有编辑操作的得分总和。</p><p>最优序列比对：在所有可能比对中得分最高或者编辑代价最小的比对。</p><p>如何寻找最优比对？</p><ul><li>寻找得分最高或代价最小的比对<ul><li>需要设计算法，求解组合优化问题</li></ul></li></ul><h3 id="编辑距离的应用">1.6 编辑距离的应用</h3><ul><li>自然语言处理</li><li>机器翻译的自动评测</li><li>识别平行网页对</li><li>字符串核函数 (String Kernel)</li><li>歌曲的哼唱检索 (Query by Humming: QbH）</li></ul><h3 id="矩阵作图法">1.7 矩阵作图法</h3><p>矩阵作图法（对角线作图法）基本步骤：</p><ol type="1"><li>将两条待比较的序列分别放在坐标系的两个轴上：s序列放在Y轴上，自下而上；t序列放在X轴上，从左到右。</li><li>当对应的行与列的序列字符匹配时，则在矩阵对应的位置作出“点”标记。</li><li>逐个比较所有字符对，最终形成点矩阵。</li></ol><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180444466.png"></p><p>把点矩阵中非重叠的与对角线平行的斜线组合起来，可以形成两条序列的一种比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180557387.png"></p><p>矩阵作图法找最佳比对:寻找对应位点的相同字符最多的比对——相当于在点矩阵中找<strong>非重叠的最长的平行斜线的组合</strong>。</p><p>除非已知待比较序列非常相似，一般先用矩阵作图法进行比较。</p><p>矩阵作图法的缺陷：当两条序列中存在很多匹配的位点对时，点矩阵中会形成很多点标记。当比较长的序列进行比较时，这样的点阵图会变得非常复杂和模糊。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180956992.png"></p><p>改进策略：滑动窗口技术</p><p>使用滑动窗口之间的比较去代替单个位点之间的比较。</p><ul><li>比如设窗口大小(windowsize)为10，相似度阈值为8，则每次比较取10个连续的字符，若相同字符数超过8个，则进行标记为窗口相似。</li></ul><p>优点：基于滑动窗口的点矩阵方法可以明显地降低点阵图的噪声，且明确无误的指示出两条序列具有显著相似性的区域。</p><p>滑动窗口法的效果比较：</p><ul><li>下图的(b)为人类(Homosapiens)与黑猩猩(Pongopygmaeus)的β球蛋白基因序列进行比较的完整点阵图。</li><li>(c)为利用滑动窗口对以上的两种球蛋白基因序列进行比较的点阵图，其中窗口大小为10个核苷酸，相似度阈值(threshold)为8。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608181834815.png"></p><h2 id="两条序列的比较">2.两条序列的比较</h2><h3 id="序列比对打分矩阵">2.1 序列比对打分矩阵</h3><p>两条序列 s 和 t 的比对得分等于将 s 转化为 t所用的所有编辑操作的得分总和。</p><p>详细列出各种字符替换的得分，并排列成表格(或矩阵)，即为打分矩阵。</p><blockquote><p>定义打分矩阵是进行序列比较的基础。</p></blockquote><p>选择不同的打分矩阵将得到不同的比较结果。</p><p>打分矩阵的定义需要依据其实际应用中生物学意义。</p><p>打分矩阵分为：</p><ul><li>核酸打分矩阵： 单位矩阵, BLAST矩阵, 转移矩阵<ul><li>单位矩阵 ：相同的核苷酸匹配得分为1，不同核苷酸替换为0。</li><li>BLAST矩阵 ：相同匹配得分为+5，反之为-4。</li><li>转移矩阵（transition）：相同匹配得分为+1，反之为-5。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608182752593.png"></p><ul><li>蛋白质打分矩阵：单位矩阵, 氨基酸突变代价矩阵GCM, 疏水矩阵…</li></ul><h3 id="最优序列比对">2.2 最优序列比对</h3><p>最优比对：在所有可能的比对中，得分最高(或编辑代价最小)的比对，把最优比对的得分值称为s和t的相似度，记作sim(s,t)。</p><ul><li>最高得分(相似度)是唯一的，但最佳比对方式不一定唯一。</li></ul><p>寻找最优比对：</p><ul><li>寻找得分最高(或代价最小)的比对</li><li>需要设计有效的最优化算法</li></ul><p>穷举法：穷举所有可能比对，选取最高得分者。</p><ul><li>穷举所有可能比对</li><li>分别计分</li><li>选取最高得分者</li></ul><p>两条序列可能的比对数目是<strong>序列长度的指数函数</strong>；随着序列长度的增长，计算量呈指数增长。穷举法不可行！<span class="math display">\[比对数目=\sum_{k=0}^{min(m,n)}\frac{(m+n-k)!}{(n-k)!(m-k)!k!}\]</span></p><h3 id="动态规划dynamic-programming全局序列比对">2.3 动态规划（DynamicProgramming）—全局序列比对</h3><h4 id="认识动态规划算法">2.3.1 认识动态规划算法</h4><p>动态规划算法是寻找最优比对的一个方法。</p><p>利用同一问题已计算出的局部解求解<strong>全局解</strong>。</p><ul><li>一般是通过把一个问题分解成计算量合理的子问题，并使用这些子问题的结果来计算最终解。</li></ul><p>应用场景举例：用于在一个复杂空间中寻找一条最优路径。</p><ul><li>如果该问题可以描述为一个对应的图论问题，且问题的解对应于图中从起点到终点的最短距离，那么就可以通过动态规划算法解决这个问题。</li></ul><p>动态规划是<strong>求解最优化问题的一种途径或框架</strong>：</p><ul><li>并不是某一个特殊算法。</li><li>不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。</li><li>动态规划算法往往是针对某一种特定最优化问题设计。</li><li>不存在一种可以解决各类最优化问题万能的动态规划算法。</li></ul><p>动态规划的<strong>基本思想</strong>：将待求解问题分解成若干个子问题，先求解子问题，再从子问题的解得到原问题的解。</p><ul><li>经分解得到子问题往往不是互相独立的。</li><li><strong>保存已解决的子问题的答案</strong>，而在需要时再找出已求得的答案，以避免大量的重复计算。<ul><li>在穷举法中存在大量重复计算</li></ul></li><li>用一个表来记录所有已解的子问题的答案<ul><li>具体的动态规划算法多种多样，但它们具有相同的填表格式。</li></ul></li></ul><h4 id="动态规划算法基本步骤">2.3.2 动态规划算法基本步骤</h4><p>设计动态规划算法的五个<strong>基本步骤</strong>：</p><ol type="1"><li>确定问题的决策对象</li><li>对决策过程划分阶段</li><li>对各阶段确定状态变量</li><li>根据状态变量确定代价函数和总的目标函数</li><li>建立各阶段状态变量的转移过程，确定状态转移方程</li></ol><p>利用<strong>动态规划算法寻找最优序列比对的基本建模步骤</strong>：</p><ol type="1"><li>确定问题的决策对象：<ul><li>确定各个位点上应采用何种编辑操作: 匹配/失配/空位</li></ul></li><li>对决策过程划分阶段：<ul><li>一个位点对应一个阶段</li></ul></li><li>对各阶段确定状态变量：<ul><li>序列前缀串的比对结果和当前位置的编辑操作是当前阶段的状态变量</li></ul></li><li>根据状态变量确定得分函数和总的目标函数：<ul><li>序列前缀串的得分作为各阶段的得分函数，完整序列的得分函数即构成总的目标函数</li></ul></li><li>建立各阶段状态变量的转移过程，确定状态转移方程：<ul><li>顺推方式：使用状态S<sub>k-1</sub>推导状态S<sub>k</sub> 的得分</li></ul></li></ol><h4 id="动态规划辅助矩阵">2.3.3 动态规划辅助矩阵</h4><p>在开始算法之前，我们还要理解一个概念是<strong>动态规划辅助矩阵</strong>：考虑两个序列s与t</p><ul><li><p>设 m = |s|, n= |t|, 则s共有m + 1个前缀串, t共有n +1个前缀(包括空串)</p></li><li><p>动态规划辅助矩阵A为：(m + 1) × (n + 1)</p></li><li><p>矩阵A的(i,j)元素为前缀的最优比对得分: <span class="math display">\[A(i,j)=sim(prefix(s,j),prefix(t,j))或A(i,j)=sim(s[0..i],t[0..j])\]</span></p></li><li><p><strong>算法的核心步骤</strong>：通过状态转移方程，维护一个动态规划辅助矩阵A用以存放这些得分。</p><ul><li>算法从最短的前缀开始，递推地得到更长的前缀串的相似度，并不直接计算sim(s,t)</li></ul></li><li><p>全局序列比对也称为Needleman-Wunsch(NW)算法。</p></li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure><p><strong>计算A(i,j)的方法</strong>：</p><ul><li><p>已知序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的前缀最优比对，即是已知3种子序列的最优比对</p><ul><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对</li><li><sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li></ul></li><li><p>则序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对必是上述3种情况之一的扩展，即</p><ul><li><p>替换或匹配(s<sub>i</sub> ,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195505891.png" style="zoom: 50%;"></p></li><li><p>删除(s<sub>i</sub> ,-)</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195559054.png" style="zoom: 50%;"></p></li><li><p>插入(-,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195946697.png" style="zoom: 50%;"></p></li></ul></li><li><p>状态转移方程： <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span></p></li></ul><h4 id="辅助矩阵的初始化">2.3.4 辅助矩阵的初始化</h4><ul><li>假设给定打分函数：<ul><li>匹配：1</li><li>失配：-1</li><li>空位：-2</li></ul></li><li>初始化辅助矩阵A：<ul><li>矩阵的纵轴方向自上而下对应于第1条序列(s)，横轴方向自左向右对应于第2条序列(t)</li><li>矩阵横向的移动表示在纵轴序列中加入一个空位</li><li>纵向的移动表示在横轴序列中加入了一个空位</li><li>而斜对角向的移动表示两序列各自相应的字符进行比对</li></ul></li></ul><blockquote><p>注意：各轴第一个元素的索引下标为0, 且初始化A(0,0)=0。</p></blockquote><h4 id="动态规划辅助矩阵的维护过程">2.3.5动态规划辅助矩阵的维护过程</h4><p>计算顺序：</p><ol type="1"><li>计算过程从A(0,0)开始，到A(m, n)结束。</li><li>计算A(i,j)时，只要已知A(i-1,j), A(i-1,j-1),A(i,j-1)即可使用递推公式计算。<ul><li>可按行计算——每行从左到右，也可按列计算—— 每列从上到下。</li><li>第一行第一列可以单纯的-2来计算，因为矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位。</li></ul></li><li>在计算A(i,j)后，需要<strong>保存</strong>A(i,j)是从(i − 1,j), (i −1,j − 1), (i,j − 1) 中的哪一个位置推进的。<ul><li>保存计算路径，以便于后续处理</li></ul></li></ol><h4 id="用序列比对的动态规划求解问题的实例">2.3.6用序列比对的动态规划求解问题的实例</h4><p>给定序列s和t，打分函数定义如下。请使用NW算法找出最优比对：s=AAAC，t=AGC</p><p>打分函数：<img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608202753737.png"></p><p><strong>基本求解步骤：</strong></p><ul><li><p>建立动态规划辅助矩阵</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure></li><li><p>初始化动态规划辅助矩阵</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203000442.png" style="zoom: 50%;"></p></li><li><p>根据状态转移方程不断维护辅助矩阵A</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203043267.png" style="zoom:50%;"></p><ul><li>最终得到的A(m,n)即为s与t的最佳比对得分(相似度)为-1。</li></ul></li><li><p>回溯计算的路径，以找到最优比对</p><ul><li><p>从A(m,n)开始，反推</p></li><li><p>假设在反推到达A(i,j)时，根据保存的计算路径判断A(i,j)究竟是利用A(i-1,j),A(i-1,j-1), A(i,j-1)中的哪一个计算而得到的</p></li><li><p>找到这个点后，由从此点出发，一直到A(0,0)为止</p></li><li><p>矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位；而斜对角向的移动表示两序列各自相应的字符进行比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203832883.png"></p></li><li><p>图中路径对应的最佳比对（有多种最佳比对方式）为：</p><ul><li>AAAC与AG-C</li><li>AAAC与A-GC</li><li>AAAC与-AGC</li></ul></li></ul></li></ul><h3 id="最优局部比对子序列与完整序列的比对">2.4最优局部比对—子序列与完整序列的比对</h3><h4 id="认识最优局部比对">2.4.1 认识最优局部比对</h4><p>最优全局比对：两条长度相近的序列进行比对。</p><p>最优局部比对：</p><ul><li><p>子序列与完整序列的比对；</p></li><li><p>寻找最大的相似子序列。</p></li></ul><p>基于动态规划的最优全局序列比对可以找出两条序列的最佳比对，但未必总是具有生物学意义。</p><ul><li>有些同源序列虽然全序列的相似性很小，但是存在高度相似的局部区域。</li><li>如果在进行比对时，注重序列的局部相似性，则可能会发现重要的比对。</li><li>Smith和Waterman在Needleman-Wunsch算法的基础上提出了序列最优局部比对算法。</li><li>最优局部比对算法叫做Smith-Waterman算法。</li></ul><p>把一个较短的序列与一个较长的完整序列进行比对，试图找出<strong>最优的局部匹配</strong>。</p><ul><li>给定两条序列<sub>0</sub>:s:<sub>m</sub>和<sub>0</sub>:t:<sub>n</sub>，<strong>从<sub>0</sub>:t:<sub>n</sub>中寻找一个子序列</strong>，使得两条序列sim(s, <sub>i</sub>:t:<sub>j</sub>)最大</li></ul><h4 id="最优局部序列比对的实现">2.4.2 最优局部序列比对的实现</h4><p>寻找最优的局部比对时，需要避免对序列一端或者两端出现的空位进行罚分。</p><p>由于不计删除序列t前缀的得分，因此在对动态规划辅助矩阵初始化时，按照下述方式处理：<span class="math display">\[A(_0:s:_0,_0:t:_j)=0\]</span> 局部比对也不计删除序列t后缀的得分，因此: <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)\\A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span> 动态规划辅助矩阵最后一行的更新公式: <span class="math display">\[A(m,j)=max\begin{cases} A(m,j-1)+0\\A(m-1,j-1)+p(s[m],t[j])\\A(m-1,j)+p(s[m],-)\end{cases}\]</span> 局部最优序列比对路径：</p><ul><li>从最后一行(第m行)中寻找最大值，反推最优路径到达第一行<ul><li>由位置(m, j)出发，反推最优比对路径，最终通过<strong>斜线</strong>(非空位)到达(1,i)，其中 j 是第 m 行中取得最大分值的最小列下标。</li></ul></li></ul><h3 id="最优局部比对寻找最大的相似子序列">2.5最优局部比对——寻找最大的相似子序列</h3><p>对两条序列都进行部分比对，以寻找最大的相似子串。</p><ul><li>初始化<ul><li>由于不计删除或插入序列前缀的得分，因此边界条件(即初始化)修改为：A(0,j)=0，A(i,0)=</li><li>即动态规划辅助矩阵A的第0行和第0列初始化为0</li></ul></li></ul><blockquote><p>相当于忽略前缀</p></blockquote><ul><li><p>状态转移方程 <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\\0\end{cases}\]</span></p><ul><li>对于每个A(i,j)，一定存在一个得分为“0”的空后缀比对，因此矩阵A中的所有元素大于或等于“0”</li><li>阈值为0意味着矩阵中的0元素分布区域对应于不相似的子序列，而正数区域则是局部相似的区域。</li></ul></li><li><p>在矩阵A中寻找最大值</p><ul><li>该值是最优局部比对得分</li><li>该值对应的位置为序列局部比对的末点</li><li>反向推演前面的最优路径，直到局部比对的起点——局部比对的起点取值为0</li><li>矩阵A中元素的含义与基本算法有所不同：A(i,j)中每个元素的值代表序列<sub>0</sub>:s:<sub>i</sub>某个后缀和序列<sub>0</sub>:t:<sub>j</sub> 某个后缀的最佳比对</li></ul></li></ul><h3 id="准全局比对">2.6 准全局比对</h3><p>准全局序列比对的四种常见情况对应于两个序列终端空位的四种可能：</p><ul><li>子序列与完整序列的比对</li><li>寻找最大的相似子序列</li><li>判断一条序列的前缀与另一条序列的后缀相似</li><li>判断一条序列的后缀与另一条序列的前缀相似</li></ul><p>准全局序列比对：在评价序列比对时，不计算序列终端出现“空位”情况的罚分。</p><p>所谓的序列终端空位包括：</p><ul><li>出现在序列第一个字符之前的空位</li><li>出现在序列最后一个字符之后的空位</li></ul><p>不计前端空位:</p><ul><li>不计s的前端空位：第0行初始值为“0”</li><li>不计t的前端空位：第0列初始值为“0”</li></ul><p>不计末端空位:：</p><ul><li>不计s的末端空位：在最后一行中寻找最大值</li><li>不计t的末端空位：在最后一列中寻找最大值</li></ul><p><strong>以上4条可任意组合</strong></p><h3 id="总结">2.7 总结</h3><p>全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221708590.png"></p><p>局部序列比对—子序列与完整序列的比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221811317.png"></p><p>局部序列比对——寻找最大的相似子序列：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221842345.png"></p><p>准全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221912089.png"></p><h2 id="多序列比对">3.多序列比对</h2><h3 id="多条序列比对的提出">3.1 多条序列比对的提出</h3><p>序列序列两两比对主要用于建立两条序列的同源关系和推测它们的结构、功能。</p><p>多条序列比对对于研究分子结构、功能及进化关系更为有用。</p><ul><li>在实际蛋白质研究中，并不是仅仅分析单个蛋白质，而是更着重于研究蛋白质之间的关系，研究一个家族中的相关蛋白质及序列中与结构域或功能相关的保守区域，进而分析蛋白质的结构和功能。<ul><li>序列两两比对不能满足这样的需要，难以发现多个序列的共性。</li><li>要得到一个序列家族的序列特征，需要同时比对多条同源序列。</li><li>当给定一个新序列时，根据序列特征，可以判断这个序列是否属于该家族。</li></ul></li></ul><p>多序列比对定义：有k ( &gt; 2 ) 个序列s<sub>1</sub> , s<sub>2</sub> ,...,s<sub>k</sub>，每个序列由同一个字母表中的字符组成。通过插入字符操作，使得各序列达到一样的长度，从而形成这些序列的多重比对。</p><p>目标：</p><p>发现多个序列的共性</p><p>发现与结构和功能相关的保守序列片段</p><p>推测各个序列的进化历史</p><h4 id="打分函数">3.1.1 打分函数</h4><p>具有k个变量, 可用一个k维数组来表示。</p><p>所期望的打分函数：</p><ul><li>函数在形式上应该简单，具有统一的形式。</li><li>不随序列的个数而发生形式变化。</li><li>函数值应独立于各参数的顺序，与比较的序列先后次序无关。</li><li>对相同或相似字符的比对，得分值高。</li></ul><h5 id="spsum-of-pairs模型">SP(Sum-of-Pairs)模型</h5><p>SP模型的思路：按照每个比对的列进行打分，然后求和。</p><p>SP打分函数： <span class="math display">\[SP(c_1,c_2,...,c_k)=\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}p(c_i,c_j)\]</span></p><ul><li><p>其中c<sub>1</sub> ,c<sub>2</sub>,…,c<sub>k</sub>是一列中的k个字符，p(. , .)是关于一对字符相似性的打分函数。</p><p>总得分基于字符两两比较得分。</p><p>把一个多重比对所有列的得分全部加起来，其和即为该多重序列比对的得分。</p></li></ul><p>多重序列比对的空位：</p><ul><li>进行多重序列比对时，可能<strong>会出现两个空位字符的比对</strong>，因此我们扩充打分函数p的定义域。<ul><li>即增加p(-,-)=0</li><li>在分析这两条序列时，可以同时去掉这些空位。这个结果称之为多重序列比对在两条特定序列上的投影(projection)。</li></ul></li></ul><p>基于SP打分函数的逐对比对：</p><ul><li><p>引入打分函数的定义域扩充p(−,−) =0后,则可以先对每一对序列进行两两比对，再求和： <span class="math display">\[SP(s_1,s_2,...,s_k)=\sum_{i&lt;j}^{k}sim(s_i,s_j)\]</span></p><ul><li>等价于对多重序列的每一列进行计算，然后将每一列的得分值相加。</li></ul></li></ul><p>穷举出所有可能的比对，取得分最高者！</p><h3 id="多条序列比对的方法">3.2 多条序列比对的方法</h3><p>精确比对：多重比对的动态规划算法</p><p>渐进比对：星形比对、树形比对</p><h4 id="多重序列比对的动态规划算法">3.2.1多重序列比对的动态规划算法</h4><p>对于3条序列，每1种可能的比对可以用3维晶格中的1条路径来表示，每1维对应于1条序列。</p><ul><li>路径的起点为晶格的<strong>左上后角</strong>，终点为晶格的<strong>右下前角</strong>。</li><li>对于多条序列，则形成超晶格(hyper-lattice)。</li><li>对于两条序列比对，其得分矩阵相当于2维晶格(平面)。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609103503859.png" alt="三条序列比对"><figcaption aria-hidden="true">三条序列比对</figcaption></figure><h5 id="多重比对的动态规划的基本原理">（1）多重比对的动态规划的<strong>基本原理</strong>：</h5><ul><li>在超晶格中，序列比对的计算是从左上后角坐标点(0,0,…,0)开始，按<strong>节点之间的依赖关系</strong>向右下前方推进，直至计算完最后一个节点。<ul><li>实际计算时可按先低维再高维(对应于先行后列)。</li><li>二重序列比对时，可将动态规划算法的计算过程看成是在二维平面上按照一定顺序访问每个节点，每个节点的得分代表两个序列前缀的最优比对的得分。</li></ul></li><li>当前位点的得分计算取决于与它相邻的(2k –1)条边，分别对应于匹配、替换或引入空位等3种编辑操作。</li><li>计算各操作的得分时，选择一个得分最大的操作，将得分和存放于该节点。</li></ul><h5 id="状态转移方程">（2）状态转移方程：</h5><p><span class="math display">\[s_{i,j,k}=max\begin{cases} s_{i-1,j,k} \enspace +\delta(\upsilon_i,-,-)\\ s_{i,j-1,k} \enspace +\delta(-,\omega_j,-)\\s_{i,j,k-1} \enspace+\delta(-,-,\mu_k)\\s_{i-1,j-1,k}  +\delta(\upsilon_i,\omega_j,-)\\s_{i-1,j,k-1}  +\delta(\upsilon_i,-,\mu_k)\\s_{i,j-1,k-1}  +\delta(-,\omega_j,\mu_k)\\s_{i-1,j-1,k-1}  +\delta(\upsilon_i,\omega_j,\mu_k)\end{cases}\]</span></p><h5 id="dp算法的计算过程">（3）DP算法的计算过程：</h5><p>动态规划的计算过程是一个递推更新动态规划辅助矩阵的过程。</p><ul><li>在计算每个节点得分时，将其<strong>各前趋节点</strong>的值分别加上从前趋节点到当前点的SP得分，取最大值作为当前节点的值。<ul><li>一般在3维(k=3)情况下，考虑7个前趋节点。</li><li>在k维情况下，前趋节点的个数等于2k –1。</li></ul></li></ul><p>多重比对的DP算法的计算复杂度：</p><ul><li>对于k条序列，动态算法需要处理k维空间的每个节点，计算量与节点数成正比（与各序列长度的乘积的乘积）。<ul><li>注意到前趋节点的个数为2<sup>k</sup> –1，因此动态规划算法复杂度为O(2<sup>k</sup> N<sup>k</sup>)。</li><li>随着待比对的序列数目k的增加，动态规划的计算量和所要求的计算空间呈<strong>指数</strong>形式猛增。</li></ul></li></ul><p>多重比对的动态规划的空间复杂度：</p><ul><li>动态规划辅助矩阵的大小 = N<sup>k</sup> 个元素<ul><li>N为序列长度</li><li>k为序列条数</li></ul></li><li>每个元素需要处理2<sup>k</sup> – 1个相邻元素<ul><li>时间复杂度: O(2<sup>k</sup> N<sup>k</sup>)</li></ul></li></ul><p>如果采用标准的动态规划算法计算最优的多重序列比对，k较大时所需要的时间和空间复杂度均是难以满足的。</p><h4 id="渐进方法星形比对">3.2.2 渐进方法—星形比对</h4><p><strong>渐进法</strong>的基本过程：</p><ul><li>把多重序列比对转化为两两序列比对。</li><li>再将两两比对聚合起来，最终形成完整的多序列比对。</li></ul><p><strong>渐进法</strong>的特点：</p><ul><li>属于启发式近似方法，能够大大减少所需的计算时间。</li><li>虽然无法保证最终得到最优解，但在大多数情况下，其计算结果接近最优结果。</li></ul><h5 id="星形比对的基本思路">（1）星形比对的基本思路：</h5><ol type="1"><li>在给定若干序列中，首先选出一个<strong>核心序列</strong>。</li><li>把该序列与其它序列进行两两比对。</li><li>最后聚合形成所有序列的多重比对。<ul><li>使得该多重比对在核心序列和任何一个其它序列方向的投影均为最优的两两比对。</li></ul></li></ol><blockquote><p>基本过程：</p></blockquote><ul><li>假设k条待比对的序列中核心序列是s<sub>c</sub>，那么：<ul><li>先利用标准的动态规划方法求出所有s<sub>i</sub>和s<sub>c</sub>的最优两两比对。</li><li>把得到的两两比对按一定规则<strong>聚合</strong>起来。</li></ul></li></ul><p>时间复杂度为 O(k N<sup>2</sup>)</p><h5 id="如何选择核心序列">（2）如何选择核心序列？</h5><ul><li><p>第一种方法是尝试将每一个序列分别作为核心序列，进行星形多重序列比对，取比对结果最好的一个。</p></li><li><p>另一种方法是计算所有的两两比对，取下式值最大的一个： <span class="math display">\[sim(s_j,s_c)\]</span></p></li></ul><h5 id="星形比对的基本过程">（3）星形比对的基本过程：</h5><ol type="1"><li>选定一个核心序列。</li><li>把多重比对转化为k个两两比对。</li><li>聚合过程：从某一个两两比对开始，比如sc和s1，然后逐步加上其他的两两比对。<ul><li>对于空位采用”一次加入空白，次次保留空白”原则: 逐增加s<sub>c</sub>中的空位字符，以适应其他的比对，但不删除s<sub>c</sub>中已经存在的空位字符。</li></ul></li></ol><h4 id="渐进方法树形比对">3.2.3 渐进方法—树形比对</h4><p>树形比对一般过程：</p><ol type="1"><li>先将多个序列进行两两比对，基于这些比对得到相似性矩阵。<ul><li>该矩阵反映逐对序列之间的关系。</li></ul></li><li>利用该相似性矩阵，构建一棵“<strong>指导树(guidetree)</strong>”。</li><li>从<strong>最接近的一对序列出发</strong>，根据指导树逐步填加序列，聚合成多重比对；直到所有序列处理完毕为止。</li></ol><h2 id="在数据库中进行序列同源搜索">4.在数据库中进行序列同源搜索</h2><h3 id="问题的提出">4.1 问题的提出</h3><p>在数据库中搜索相似的序列：</p><ul><li>查询序列（待查询的序列）</li><li>目标序列（数据库中的每条被搜索的序列）</li></ul><p>直接用两序列比对进行数据库搜索存在的问题：</p><ul><li>目标序列太长、数量巨大，穷举式搜索耗时过长。</li><li>解决办法：索引技术、启发式方法。</li><li>实用的数据库搜索算法：“最佳”→“较佳”。</li></ul><p>两大主要搜索算法：</p><ul><li>BLAST及其相关算法</li><li>FASTA及其相关算法</li></ul><h3 id="常用的搜索方法blast搜索算法">4.2常用的搜索方法—BLAST搜索算法</h3><p>主要特征：原始的BLAST算法是<strong>不带空位的局部比对方法</strong>。</p><p>给定一个查询序列，BLAST返回所有查询序列与数据库序列得分<strong>超过某个阈值S</strong>的片段对。</p><blockquote><p>阈值S可以由用户设置，但程序有一个默认的推荐值。</p></blockquote><ul><li><p>选择S的<strong>基本原则</strong>是：一条随机序列与查询序列比较的得分不会超过S。</p></li><li><p>由于在序列比对过程中不考虑空位的操作(没有插入和删除)，则对于二维平面上各点的计算问题可转化为一维点的计算问题，计算速度得以大幅提高。</p></li></ul><p>通过搜索序列数据库来找出<strong>最优的无空位局部比对</strong>。</p><ul><li>从数据库中找出与<strong>查询序列的某些子序列</strong>相似的子序列。</li><li>在进行数据库查询时，BLAST返回一个<strong>高得分的相似片段对列表</strong>，每个片段对包括查找序列的一个片段和数据库中待比较序列的一个片段。</li></ul><blockquote><p>BLAST算法把数据库搜索建立在严格的统计学基础上。</p></blockquote><h5 id="基本步骤">基本步骤：</h5><ol type="1"><li><p>利用<strong>滑动窗口</strong>将查询序列分解为定长的“单词”串(默认长度为4)。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164801077.png" style="zoom:67%;"></p></li><li><p>舍弃那些由最常见的残基组成的“单词”串，在数据库中精确匹配剩余“单词”串。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164946161.png" style="zoom:67%;"></p></li><li><p>对匹配上的单词串，逐步向两端延伸该匹配，直到得分低于某个阈值为止。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609165100296.png" style="zoom:67%;"></p></li></ol><h3 id="常用的搜索方法fasta搜索算法">4.3常用的搜索方法—FASTA搜索算法</h3><p>FASTA是另一种常用的序列比对及搜索工具：</p><ul><li>能够进行<strong>带空位的局部比对</strong>。</li><li>由于FASTA搜索时会将<strong>查询序列与数据库中每条序列进行细致比较</strong>，故通常比BLAST搜索要慢些。</li></ul><h5 id="基本步骤-1">基本步骤：</h5><ol type="1"><li><p>用滑动窗口将查询序列分隔成“单词”串：</p><ul><li>对于核苷酸序列， “单词”串长为4~6</li><li>对于氨基酸序列， “单词”串长为1~2</li></ul></li><li><p>为查询序列建立一个表格，记录下各个“单词”串在序列中出现的位置。</p><p>例：“单词”长度为1的序列如下：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609170226299.png" alt="查询序列" style="zoom:67%;"></p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171158162.png" alt="查询序列表格"><figcaption aria-hidden="true">查询序列表格</figcaption></figure></li><li><p>对目标序列建立另一个表格，用于比较目标序列与查询序列中各残基的位置之差。</p><p>查询序列：<strong>FAMLGFIKYLPGCM</strong></p><p>目标序列：<strong>TGFIKYLPGACT</strong></p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171928801.png"></p></li><li><p>从第二个表中发现有很多距离为3的位置，这表明：如果对目标序列<strong>偏移3个位置</strong>，则可得到一个较好的比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609172302785.png"></p></li></ol><p>通过比较两条序列的<strong>偏移表</strong>，可以很快地发现相同的区域，并将这些区域连接起来形成更长的序列，然后利用Smith-Waterman算法比对。</p><blockquote><p>由于FASTA是对已知区域进行比对，较原始算法(即用动态规划算法进行查询序列与所有目标序列间的比对)要快得多。</p></blockquote><h3 id="数据库搜索结果得分及统计显著性">4.4数据库搜索结果得分及统计显著性</h3><p>提出原因：</p><ul><li>数据库搜索总会产生结果，<strong>但找到的序列未必真与查询序列相关</strong>。</li><li>比对得分可以说明搜索的结果与查询序列之间的相似程度，但由于数据库搜索算法不同、比对打分标准不统一，因此<strong>比对得分值</strong>本身并不能充分指明两序列间的关系。</li></ul><p>设某个数据库搜索结果的比对得分为S，我们可以提出一个<strong>基本问题</strong>：</p><ul><li>若有一组与查询序列不相关的序列(<strong>如随机序列</strong>)，则在这些序列中随机找到一个得分同样为S的比对的概率有多大？</li></ul><p>为回答这个基本问题，数据库搜索引擎通常会为每个搜索结果提供P得分与E得分。</p><p>P得分：对于随机找出的一条或多条序列，其比对得分大于等于S的<strong>可能性</strong>(概率)。</p><p>E得分：随机找出的、与查询序列进行比对的<strong>得分大于等于S的目标序列的期望数目</strong>。</p><ul><li>如果E得分与P得分均<strong>较低</strong>，则说明搜索结果与查询序列<strong>具有进化上的关系</strong>，并不是由于<strong>随机因素</strong>得到的结果。</li></ul><blockquote><p>当E值&lt; 10<sup>-3</sup>时，通常认为搜索结果具有统计上的显著性；</p><p>–搜索得到的匹配序列在E值上可以低到<strong>10<sup>-50</sup></strong>，表明查询序列与搜索结果间<strong>具有进化关系的可能性极大</strong>。</p></blockquote><h2 id="dna片段组装">5.DNA片段组装</h2><h3 id="问题提出与定义">5.1 问题提出与定义</h3><p>问题描述：给定一组取自特定字母表的字符串集合F，寻找一个最短的字符串s，使得F中的每一个字符串均为s的一个连续子串。</p><ul><li>其中，集合F中的字符串是待组装的序列片段，s是序列片段组装的结果。</li></ul><p>DNA片段组装任务的提出：大规模基因组测序时，得到待测序列的<strong>一系列片段</strong>，这些序列片段<strong>覆盖待测序列</strong>，且序列片段之间存在相互覆盖或重叠；根据这些存在相互覆盖或重叠的序列片段，<strong>重建</strong>目标DNA序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609192717156.png"></p><h5 id="序列片段组装的基本原理">序列片段组装的基本原理：</h5><p>将输入的序列片段进行<strong>两两比对</strong>；</p><ul><li>与基本的序列两两比对算法不同，此时需要寻找一个序列的后缀与另一个序列的前缀相同或相似的部分。</li><li>通过准全局序列比对(忽略某一端的空白字符)，相当于各个片段之间进行相对定位；</li><li>由各个片段之间的相对定位，逐步确定目标序列。</li></ul><p>指导片段组装的因素是<strong>片段之间的覆盖</strong>。</p><ul><li>通过各个片段之间的覆盖，对片段实现<strong>相对定位</strong>，进而把所有片段连接起来。<ul><li>也可以看成是序列片段的特定多重比对。</li></ul></li><li>对于每一列，提取<strong>出现频率最大</strong>的一个字符。</li></ul><h3 id="dna片断组装的主要困难">5.2 DNA片断组装的主要困难</h3><h4 id="碱基标识错误">5.2.1 碱基标识错误</h4><p>在序列片段中存在碱基替换、插入和删除。</p><p>解决方案:</p><ul><li>考虑到序列的检测误差，序列片段组装的一个更准确定义为：给定一组取自特定字母表的字符串集合F，其中的字符串具有一定的误差，寻找一个<strong>最短的字符串s</strong>，使得在s中观察到F的可能性最大。</li></ul><blockquote><p>最大似然 (Maximum Likelihood)准则：以可能性最高为判断标准。</p></blockquote><h4 id="未知片段方向">5.2.2 未知片段方向</h4><p>如果一个片段是一条链的子串，根据互补原则，该片段的反向互补片段是另一条链的子串。</p><p>对于一条输入的片段，在进行组装时，既可以用其本身，也可以用其<strong>反向互补片段</strong>。</p><p>解决方案：按两个方向分别尝试。</p><h4 id="存在重复区域">5.2.3 存在重复区域</h4><p>重复区域是目标序列中多次出现的子序列。有的重复区域太长，超过片段的边界，造成无法给出确切相对定位，使片段组装变得不确定。</p><h4 id="缺少覆盖">5.2.4 缺少覆盖</h4><p>覆盖强度：定义为目标序列上某个位点上覆盖此位点的片段个数。</p><blockquote><p>平均覆盖强度:计算求所有覆盖片段的长度和，再除以目标序列长度的估计值。</p></blockquote><p>如果对于目标序列上的某个位点，覆盖该点的序列片段个数为零，则没有相关的序列信息来重建该点附近的目标序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609194833195.png"></p><h3 id="dna片段组装的基本过程与组装模型">5.3DNA片段组装的基本过程与组装模型</h3><h4 id="dna片段组装的基本过程">5.3.1 DNA片段组装的基本过程</h4><ol type="1"><li>首先进行序列片段的两两比对，确定可能的片段之间的覆盖（或者重叠）。</li><li>确定所有片段统一的覆盖模式，即确定各个序列片段的相对位置（最关键一步）。</li><li>最后确定片段组装结果，即确定目标序列。</li></ol><h4 id="最短公共超串模型">5.3.2 最短公共超串模型</h4><p>给定一个字符串集合F，求出一个<strong>最短</strong>的字符串S，使得对于所有属于F的字符串<em>f</em>，S是<em>f</em>的超串(或者<em>f</em>是S的子串)。</p><p>设F={ACT,CTA,AGT}，则S=ACTAGT是F的超串。</p><p>其中，S要求是各片段的严格超串，不允许片段中存在实验误差，而且<strong>各片段的方向必须已知</strong>。</p><h4 id="重建模型">5.3.3 重建模型</h4><h5 id="近似子串">（1）近似子串</h5><p>考虑到片段的误差和未知方向的问题，对于判别子串的序列比较不需要完全匹配，而是根据相似程度进行处理，需要引入“近似子串”的概念。</p><p>假设 <em>f</em>,<em>g</em>是代表两条序列的字符串，<em>f</em>作为<em>g</em>近似子串的代价为：<span class="math display">\[d_s(f,g)=\min_{s\in S(g)}d(f,s)\]</span></p><ul><li>其中，S(<em>g</em>)代表<em>g</em>的所有子串的集合，<em>d</em>(⋅ ,⋅)为一般编辑距离。</li></ul><p>设0 &lt; ε &lt; 1，如果<em>d<sub>s</sub>(f,g)</em> ≤ ε|<em>f</em>| ,则称字符串 <em>f</em>是误差 ε 下 <em>S</em> 的近似子串。</p><h5 id="重建模型的定义">（2）重建模型的定义</h5><p>给定一个字符串集合<em>F</em>，求一个最短的字符串<em>S</em>，使得对于所有字符串<em>f∈F</em>，有:<span class="math display">\[d_s(f,S)\le \epsilon|f|\]</span> 或者 <span class="math display">\[d_s(f^{&#39;},S)\le \epsilon|f|\]</span> 其中 <em>f′</em> 是 <em>f</em> 的反向互补串。</p><p>主要思路:寻找一个尽可能短的字符串<em>S</em>，使得每一个<em>f</em>或其反向互补串<em>f′</em>成为<em>S</em>的近似子串。</p><p>该模型可同时处理序列误差、未知序列方向的问题，但不能处理目标序列中的重复区域和缺少覆盖问题。</p><h4 id="多重连续区模型">5.3.4 多重连续区模型</h4><p>t-contig：在多重序列比对中，如果其<strong>最弱连接的交叠长度至少为t</strong>，则称为一个t-contig。</p><p><em>F</em>允许一个t-contig：在多重序列比对中，如果能够根据序列片段集合<em>F</em>构造一个t-contig，则称<em>F</em>允许1个t-contig。</p><p>多重连续区模型：</p><ul><li>通过构造t-contig来定义具体不同覆盖强度的序列组装结果。</li><li>给定一个片段集合<em>F</em>和一个整数 t ≥ 0,将<em>F</em>分割为最小数目的片段子集C<sub>i</sub>，其中1 ≤ i ≤ k，且每个C<sub>i</sub>允许一个t-contig。</li></ul><blockquote><p>把F分割为k个子集C<sub>i</sub>，根据序列片段子集C<sub>i</sub>构造出一个t-contig，进而完成最小覆盖强度为t的组装结果。</p></blockquote><h1 id="二基因组学与基因识别">二、基因组学与基因识别</h1><h2 id="基因与基因组">1.基因与基因组</h2><p>基因(Gene) ：编码一条多肽链或功能RNA所必需的全部核苷酸序列。</p><blockquote><p>DNA分子链上的特定区域。</p></blockquote><p>基因组(Genome)：一个细胞或者生物体所携带的一套完整的染色体单倍体序列。</p><blockquote><p>包括编码序列和非编码序列在内的全部DNA分子，包含全套基因序列和间隔序列。</p></blockquote><p>基因表达：利用存储在DNA中的遗传信息合成RNA分子，然后再合成相应蛋白质的过程，称为基因表达。</p><blockquote><p>基因表达包括转录与翻译两个子过程。</p></blockquote><h3 id="生物分子中的信息传递">1.1 生物分子中的信息传递</h3><p>在生物生长发育过程中，生物信息传递有两种方式：</p><ol type="1"><li>自我复制——在繁衍过程中传递遗传信息。</li><li>基因通过转录和翻译，使遗传信息在生物个体中表达，使后代表现出与亲代相似的生物性状。<ul><li>DNA→RNA→蛋白质</li><li>基因控制着蛋白质的合成，基因的DNA序列到蛋白质序列存在着一种明确的对应关系——遗传密码。</li></ul></li></ol><blockquote><p>遗传密码又称三联体密码，即DNA序列3个连续的碱基对应编码1个蛋白质的氨基酸，且对应关系具有通用性。</p><p>自然界中天然存在20种氨基酸(标准氨基酸)→21种或22种。</p><p>第21: 硒代半胱氨酸(Sec, U), 由终止密码子UGA有义编码Sec；</p><p>第22：吡咯赖氨酸(Pyl, O), 由终止密码子UAG的有义编码Pyl。</p></blockquote><h3 id="人类基因组">1.2 人类基因组</h3><p>人类基因组计划（Human Genome Project /HGP）：测定组成人类染色体（指单倍体）中所包含的30亿个碱基对组成的核苷酸序列，绘制人类基因组图谱，辨识其载有的基因及其序列，破译人类遗传信息。</p><blockquote><p>截止到2005年，人类基因组计划的测序工作已经完成。</p></blockquote><p>人类基因组：科学家研究的第一个脊椎动物染色体基因组，已成为其他脊椎动物中的代表。</p><blockquote><p>人类基因组约有3万多个基因，分布在染色体的DNA序列中。</p><p>目前已明确定位的基因仅占3万多个基因的一部分。</p></blockquote><p>基因识别：从序列中找到基因及其表达调控信息。</p><blockquote><p>通过识别特殊的序列功能位点、分析序列的组成特征来识别基因，发现与基因表达调控相关的信息。</p></blockquote><h4 id="人类基因组图谱">1.2.1 人类基因组图谱</h4><p>序列图谱：通过测序得到基因组的序列图谱。</p><p>遗传图谱（genetic map）：也叫连锁图谱(linkagemap)，它是以具有遗传多态性的遗传标记为“路标”，以遗传学距离为图距的基因组图。</p><p>物理图谱（physicalmap）：是指有关构成基因组的全部基因的排列和间距的信息，通过对构成基因组的DNA分子进行测定而绘制。</p><ul><li>DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。</li><li>目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。</li></ul><p>基因图谱：在识别基因组所包含的蛋白质编码序列的基础上所绘制的、结合有关基因序列、位置及表达模式等信息的图谱；其任务是在人类基因组中鉴别出占2%~5%的全部基因的位置、结构与功能。</p><blockquote><p>最主要的方法是通过基因表达产物mRNA反向追溯到染色体位置</p></blockquote><h4 id="人类基因组中的编码规律">1.2.2 人类基因组中的编码规律</h4><p>编码区域在人类基因组所占比例不超过3%。</p><p>97%是非编码序列：主要包括启动子、增强子、内含子、简单重复序列、移动元件及其遗留物、伪基因等。</p><p>对于非编码序列，目前了解得比较少，尚不完全清楚其含义或功能。</p><ul><li>从生物进化的观点来看，这部分序列具有重要的生物学功能；目前普遍认为:它们与基因在四维时空的表达调控有关。</li></ul><h4 id="遗传语言">1.2.3 遗传语言</h4><p>科学家认为：基因组DNA序列并非是一种简单的生物分子序列，而是一种<strong>遗传语言</strong>,用于描述遗传信息、控制生物体的性状、甚至规定生物体的生老病死。</p><ul><li>科学家们开始测序人类及其他模式生物基因组，希望解读和破译遗传信息。</li><li>迄今为止，用于理解DNA翻译成蛋白质的编码规律的<strong>遗传密码</strong>是人们对于生物体遗传语言了解最多的部分。</li></ul><p>把基因组DNA序列当作遗传语言，那么可用语言学的方法进行研究，以发现遗传语言的规律。</p><p>自然语言 vs. 程序语言 vs. 遗传语言：</p><ul><li>人类自然语言，用于人类之间描述、记录和交流思想，可以被转换成二进制序列，存放在数字图书馆中。</li><li>计算机高级程序语言经编译被转换成二进制机器指令，形成可执行程序。</li><li>遗传语言的代码实际上就是DNA序列，是由A/C/G/T(U)4种字符组成的一种四进制代码。</li></ul><h3 id="生物体的信息加工">1.3 生物体的信息加工</h3><p>从信息工程的角度来看：</p><p>蛋白质编码区域所包含的信息相当于待加工的“数据”，经加工处理后产生对应的氨基酸序列；非编码区域相当于“程序”，确定如何对数据进行处理，控制基因的表达和蛋白质的合成。</p><p>计算机中数据与程序是相对分立；在染色体上，数据与程序相互嵌套，染色体上的基因经过调控程序的转录和翻译，产生蛋白质的氨基酸序列，从而发挥生物学功能。</p><blockquote><p>一维线性的DNA分子在特定环境下，通过复杂而准确的信息程序处理，拓展为一个四维时空生命体。</p></blockquote><h2 id="原核生物基因组">2. 原核生物基因组</h2><p>原核生物基因组的许多信息仅是为维持细胞最基本的功能。</p><ul><li>构造和复制DNA(至多需要32种基因)。</li><li>产生蛋白质(需要100-150个基因)。</li><li>获得和存储能量(至少需要30个基因)。</li></ul><p>原核生物基因组中的基因密度高：一些非常简单的原核生物，如流感嗜血杆菌，其基因组仅包含由256-300个基因组成的最小集合。</p><ul><li>完全测序的细菌基因组数据表明：其中85%～88%的核酸序列与基因的编码直接相关。</li></ul><h3 id="原核基因的典型结构">2.1 原核基因的典型结构</h3><p>原核基因结构非常简单</p><ul><li><p>完整的基因结构从基因的5’ -端启动子区域开始，到3’-端终止区结束。</p></li><li><p>基因的转录开始位置由转录起始位点确定，转录过程直至遇到转录终止位点。</p></li><li><p>转录的内容包括5’-端不翻译区（UTR）、开放阅读框及3’-端不翻译区。</p></li><li><p>基因翻译的准确起止位置由起始密码子和终止密码子决定，翻译的对象即为介于这两者之间的开放阅读框。</p></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609231106118.png"></p><p>原核基因作为连续基因，其编码区是一个完整的DNA片段。</p><ul><li>负责基因表达的蛋白质可以识别各种调控信号。</li><li>调控信号是一些相对较短的核苷酸序列, 这些信号的微妙差别可以影响到:基因表达与否、基因的表达水平。</li></ul><p>启动子位点：长度为<strong>13个</strong>核苷酸的特定序列</p><ul><li>1个为转录起始位点(+1)</li><li>6个位于转录起始位点上游10个碱基处(-10)</li><li>6个位于转录起始位点上游35个碱基处(-35)</li></ul><p>这13个位点的核苷酸作为一个整体，称为启动子序列；它们之间的相对位置固定。</p><h3 id="开放阅读框orf">2.2 开放阅读框/ORF</h3><p>对于任何给定的核酸序列(单链DNA或mRNA)，根据密码子的起始位置，可以按照3种方式将其翻译成氨基酸肽链。</p><ul><li><p>例如：序列ATTCGATAACAA</p><p>—ATT CGA TAA CAA</p><p>—(A)TTC GAT AAC AA</p><p>—(AT)TCG ATA ACA A</p></li><li><p>这3种阅读顺序称为阅读框(reading frames)</p></li><li><p>不含终止密码子且有比较多的三联密码子的长序列被称为开放阅读框(OpenReading Frame: ORF)</p></li></ul><blockquote><p>存在ORF表明该区域可能对应于一个原核生物基因的编码序列。</p></blockquote><h3 id="原核基因组中的gc含量">2.3 原核基因组中的GC含量</h3><p>GC含量：GC含量是在DNA4种碱基中，鸟嘌呤和胞嘧啶所占的比率称为GC含量。</p><blockquote><p>在双链DNA中，腺嘌呤与胸腺嘧啶（A/T）之比，以及鸟嘌呤与胞嘧啶（G/C）之比都是1。但是，（A+T）/（G+C）之比则随DNA的种类不同而异。GC含量愈高，DNA的密度也愈高，同时热及碱不易使之变性，因此利用这一特性便可进行DNA的分离或测定。</p></blockquote><p>不同的原核生物中，GC含量在25%到75%之间变化。</p><ul><li>许多细菌基因组表现为具有不同GC含量区域的组合，这些区域反映了细菌的进化历史。</li><li>在原核生物中，双链DNA组成的基因组的GC含量是区分不同物种的特征之一。<ul><li>基于这种事实，测量基因组的GC含量被证明是一种识别细菌种类的有效方法。</li></ul></li></ul><h3 id="总结原核生物基因的特征">2.4 总结：原核生物基因的特征</h3><p>编码区是连续的，具有较长的开放阅读框。</p><ul><li>60+个密码子。</li></ul><p>较简单的启动子序列。</p><ul><li>+1/-10/-35处一共13个位点。</li></ul><p>转录终止信号。</p><ul><li>转录终止位点。</li></ul><p>原核生物基因组密度高，很少有空间浪费。</p><ul><li>随机选择一段原核生物基因组核苷酸序列，其中包含重要基因的编码序列或启动子的概率很大。</li></ul><h2 id="真核生物基因组">3.真核生物基因组</h2><h3 id="真核生物基因组的挑战">3.1 真核生物基因组的挑战</h3><p>真核生物的<strong>复杂性与灵活性</strong>：</p><ul><li>细胞的内部膜系统允许在细胞内维持各种变化较大的化学环境。</li><li>几乎全为多细胞生物，虽然每个细胞有相同的遗传“指令”，但其表达方式与表达水平可以有显著差异。</li><li>存在有大量的不表达区域（也被称为junk DNA区域）。</li></ul><blockquote><p>复杂性与灵活性导致对真核基因组的分析与注释成为目前极具挑战性的难题之一。</p></blockquote><p>基因组规模较大，真核生物基因组序列测定比原核生物更为困难：</p><ul><li>细胞核中一般包含多条线性染色体，且通常包含每条染色体的双拷贝。</li></ul><blockquote><p>比如：人类22条常染色体的双拷贝+2条性染色体，最短的为5500万个bp,最长有2.5亿个bp；全基因组长约32亿个bp。</p></blockquote><ul><li>真核生物基因数量不容易准确估计。</li></ul><p>真核生物基因编码区域是<strong>不连续</strong>的：</p><ul><li>能够编码蛋白质的序列被不能够编码蛋白质的序列分隔开来，成为一种不连续的形式。<ul><li>能够编码蛋白质的序列叫做外显子，不能够编码蛋白质的序列叫做内含子。</li></ul></li><li>在编码区域插入了不编码的内含子，大量内含子的存在，使得真核生物不存在像原核基因那样具有显著长度的ORF标志。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093206887.png" alt="内含子和外显子" style="zoom: 33%;"></p><h3 id="真核生物基因的结构特征">3.2 真核生物基因的结构特征</h3><p>完整的真核生物基因一般包含以下部分：</p><ol type="1"><li>转录起始区：含有对DNA序列转录起调控作用的启动子(Promoter)以及增强子(enhancer)等。</li><li>转录起始位点(TSS)</li><li>5‘- 非翻译区</li><li>翻译起始位点(TLSS)</li><li>外显子(exon),E-I剪切位点(doner),内含子(intron),I-E剪切位(acceptor),外显子, …</li><li>翻译终止位点TLSTOP</li><li>3 ‘- 非翻译区</li><li>转录终止位点</li></ol><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093843123.png" alt="真核生物基因的结构"><figcaption aria-hidden="true">真核生物基因的结构</figcaption></figure><blockquote><p>各部分的序列形态和长度并不确定，不同物种间的基因差别很大。</p></blockquote><h3 id="复杂的基因转录调控方式">3.3 复杂的基因转录调控方式</h3><p>真核生物基因的<strong>调控机制</strong>比原核生物复杂：</p><ul><li>真核基因的启动子序列更加分散，且距起始密码子较远；</li><li>启动子区域的信息提取比较困难；</li><li>在真核生物DNA序列中寻找基因相当于大海捞针。</li></ul><p>真核生物的细胞具有<strong>复杂的转录起始调控机制</strong>：</p><ul><li>真核生物的基因表达涉及多种RNA聚合酶。</li><li>真核生物至少使用由8～12个蛋白组成的3种不同类型的RNA聚合酶。<ul><li>原核生物只用一种由多个蛋白聚合而成的RNA聚合酶。</li></ul></li><li>每个真核生物的基因有自己的启动子。<ul><li>原核生物中多个基因共享一个启动子。</li></ul></li></ul><h3 id="剪切加工的方式">3.4 剪切加工的方式</h3><p>在把RNA聚合酶的转录产物运出细胞核之前，需要进行大量剪切加工过程。</p><ul><li>加工前的RNA聚合酶II转录物称为hnRNA。</li><li>加帽(capping)：在hnRNA的5’端发生的化学改变。</li><li>剪切(splicing)：切除其中的<strong>内含子</strong>片段。</li><li>多聚腺苷酸化(Poly-A): 在3’端连接多个(约250个)A。</li></ul><blockquote><p>这些加工过程，特别是剪切加工，具有组织特异性，这给基因识别带来了巨大挑战。</p></blockquote><h3 id="真核基因组gc含量">3.5 真核基因组GC含量</h3><p>真核生物基因组的GC含量差别没有原核生物明显，但GC含量对于识别真核基因仍有重要作用。</p><p>真核生物的ORF更难以识别。</p><p>真核基因组中GC含量的显著性变化是基因与上游启动子区域、密码子选择、基因长度以及基因密度之间相关性的基础。</p><h3 id="cpg岛">3.6 CpG岛</h3><p>CpG岛（CpG island）：</p><ul><li>CpG双核苷酸在人类基因组中的分布很不均匀，在基因组的某些区段，CpG保持或高于正常概率，这些区段被称作<strong>CpG岛</strong>。</li><li>CpG：胞嘧啶C—磷酸p—鸟嘌呤G</li><li>CG出现的频率远低于随机出现的概率, 但也有部分例外：</li><li>在许多基因的-1500~+500区域上往往形成<strong>CpG岛，其CG频率达到随机出现的水平</strong>。</li><li>人类基因组中大约有45000个CpG岛。</li></ul><p>CpG岛多与管家基因有关联，也与组织特异性基因的启动子有关。</p><ul><li>CpG岛很少出现在非基因区域或发生多次突变的基因中。<ul><li>管家基因：在所有组织和在发育的所有阶段都具有高水平表达的基因。</li></ul></li></ul><h3 id="遗传密码的使用偏性">3.7 遗传密码的使用偏性</h3><p>遗传密码的使用具有一定的统计规律，并不是完全随机的。</p><ul><li>如果密码子的第一、第二位碱基分别是A和U，则第三位尽可能使用G或C。</li><li>基因对同义密码子的使用也存在偏爱。<ul><li>不同种属所偏爱的密码子不同：<ul><li>人类基因组中，密码子第三位取A、U的情况占90%。</li><li>酵母基因组中的精氨酸：密码子AGA占48%，其它密码子CGT, CGC, CGA,CGG和AGG各约占10%。</li><li>果蝇基因组中的精氨酸CGC约占33%。</li></ul></li></ul></li></ul><h3 id="真核生物的基因识别">3.8 真核生物的基因识别</h3><p>真核生物基因识别主要考虑：</p><ul><li>已知的启动子元件(即TATA盒和CAAT盒)。</li><li>CpG岛</li><li>与内含子相关的剪接信号。</li><li>具有特定密码子使用偏好的开放阅读框。</li><li>与其它生物体EST或基因序列的相似程度。</li></ul><p>真核生物基因识别的解决方案:通过寻找已经注释的序列数据集的统计特性，来预测相关、但未经注释的序列数据的特性。</p><h2 id="基因组序列分析基因识别">4. 基因组序列分析—基因识别</h2><p>基因识别：也被称为基因组注释(genome annotation)。</p><ul><li>从基因组序列之中找到基因及其表达调控信息，包括识别基因编码区域(即外显子所在区域)和功能位点。</li></ul><blockquote><p>功能位点：存放基因表达调控信息的DNA片段，比如基因的启动子、剪切位点等。</p></blockquote><p>基因识别问题：对给定的DNA序列，确定出所有<strong>编码区域</strong>和<strong>基因结构</strong>。</p><ul><li>包含两个问题：<ul><li>确定出可能的编码区域</li><li>确定出编码和非编码区域的分界点</li></ul></li></ul><h4 id="基因识别与定位的方法">基因识别与定位的方法</h4><p>方法一：通过分子生物学实验确定基因的位置和序列。</p><p>方法二：通过信息分析寻找基因。</p><blockquote><p>方法二基本依据：</p><ul><li>在基因的前后两端存在一些特殊信号。</li><li>基因的蛋白质编码区域与非编码区域在序列的统计特征上有明显的差异。</li><li>可以使用模式识别方法识别DNA序列上与基因相关的信息，区分统计特性，从而识别基因。</li></ul></blockquote><p>根据是否利用同源序列的信息，把基因识别方法分为两类：</p><ul><li>基于同源序列比较的方法<ul><li>利用数据库中现有与基因有关的信息(如EST序列、cDNA、蛋白质序列)，借助同源序列比对去识别可能的基因序列。</li></ul></li><li>基于统计信息的方法<ul><li>从编码蛋白质基因的一般统计规律出发，利用基因序列和非基因序列以及外显子与内含子的统计信息差异性去识别可能的基因序列。</li></ul></li></ul><h4 id="基因编码区识别">基因编码区识别</h4><p>基因的编码区：一般是指预测DNA序列中编码蛋白质的部分(即基因的外显子部分)。</p><blockquote><p>预测编码区域是基因识别中的一个关键问题。</p></blockquote><p>基本依据：真核生物基因外显子(编码区域)具有特别的序列信号，根据这些特征信号可确定外显子的边界，从而识别编码区域。</p><blockquote><p>缺点: 特征信号强度弱，缺乏统计显著性，无法单独使用。</p></blockquote><p>对编码区域进行统计特性分析，可以确定编码区的粗略位置。</p><blockquote><p>DNA中密码子的使用频率不是平均分布的，使得编码区的序列呈现出一定的统计特异性(即密码子偏好性)。</p></blockquote><h3 id="模式识别问题">4.1 模式识别问题</h3><p>模式：观测数据中的某种规则性(regularities)，称为模式(patterns)。</p><p>模式识别：把给定观测数据中的某种规则性(regularities)识别出来(或确认出来)，并应用到新的观测数据上。</p><blockquote><p>给定的观测数据：训练数据集。</p><p>新的观测数据：测试数据集。</p></blockquote><h4 id="一个典型的模式识别问题分成下面4个步骤">4.1.1一个典型的模式识别问题分成下面4个步骤：</h4><ol type="1"><li>收集待解决问题的观测数据，进行特征抽取。<ul><li>把数据分成训练集和测试集两部分。</li></ul></li><li>选定或设计一个用于解决分类问题的数学模型。<ul><li>称为分类器设计；从数学上，即构造一个从数据到类别的映射。</li></ul></li><li>基于给定训练数据，确定分类模型中的参数。<ul><li>称为模型训练，或参数学习。</li></ul></li><li>在测试数据集上进行性能评价。</li></ol><h4 id="影响模式识别性能的因素">4.1.2 影响模式识别性能的因素：</h4><ul><li>特征表达或特征抽取方式<ul><li>对于一个特定模式分类问题，选定好的特征表达或抽取方式至关重要。</li></ul></li><li>分类器模型复杂度<ul><li>模型过于简单或过于复杂都不能获得好的性能。</li></ul></li><li>模型中参数的学习方法<ul><li>最大似然估计 /最大后验概率估计 /贝叶斯估计。</li></ul></li><li>训练样本数量<ul><li>在不考虑计算成本的情况下, 希望样本尽量多。</li></ul></li><li>训练样本的分布<ul><li>期望训练样本的分布体现数据的真实分布。</li></ul></li></ul><h4 id="模式识别问题举例">4.1.3 模式识别问题举例</h4><p>医生对患者进行疾病诊断的过程是一个典型的模式识别过程。</p><ul><li>医生的诊断过程是通过观察病人表现出的症状和各种化验检测数据来推断病情。</li><li>诊断过程是一个分类过程。<ul><li>医生就好比一个分类器</li><li>医生诊断的准确率与下列因素有密切关系：<ul><li>诊断方式(中医/西医)</li><li>病人的症状是否突出(待分类数据的特性)</li><li>诊断专长(训练样本的分布)</li><li>诊断经验(训练样本数量)</li></ul></li></ul></li></ul><h3 id="推理与决策">4.2 推理与决策</h3><p>推理的基本定义：</p><ul><li>从已知前提(或假设是正确的前提)出发，得出符合逻辑的结论的过程。</li><li>通过事实的模式的观测，间接地看到用于理解的某种新意义或上下文联系。</li></ul><p>对于模式分类来说，推理就是基于给定的数据，确定联合分布密度或者后验分布密度的过程。<span class="math display">\[D=\{(x_i,t_i)\}\to p(x,t)或p(t|x)\]</span> 决策：给定输入数据 x, 确定最优的输出 t。</p><p>贝叶斯决策：根据平均错误率最小的准则进行决策。</p><ul><li>贝叶斯决策是一种理想的判别规则，需要借助<mark>先验概率</mark>和<mark>似然度</mark>。</li><li>贝叶斯错误率是理论上可获得的最小错误率。</li></ul><p><span class="math display">\[P(mistake)=P(x\in R_1,C_2)+P(x\inR_2,C_1)=\int_{R_1}^{}p(x,C_2)dx+\int_{R_2}^{}p(x,C_1)dx\]</span></p><p>贝叶斯公式：贝叶斯公式用于把先验概率转化为后验概率。 <span class="math display">\[P(M|D)=\frac{P(D|M)P(M)}{P(D)}\qquad后验概率=\frac{似然度×先验概率}{边缘概率}\]</span>贝叶斯公式的意义：通过贝叶斯公式，我们把先验概率和从观测数据上得到的似然度相结合，从而得到后验概率。</p><blockquote><p>先验概率: 在获得观测数据之前对判别结果的认识。</p><p>后验概率: 基于观测数据而对判别结果的更新认识。</p></blockquote><p>计算后验概率的过程，也被称为推理；基于所计算的后验概率，可以进行决策。</p><h3 id="朴素贝叶斯方法">4.3 朴素贝叶斯方法</h3><p>在基因编码区，三联密码子出现的频率具有一定统计规律。</p><ul><li>在随机序列中，三联密码子出现的频率是相同的——可认为每个密码子出现的频率均为1/64。</li><li>在基因编码区域 ，三联密码子出现的频率并不是均匀的。</li></ul><p>根据这个差异，可以计算不同的阅读框属于基因编码序列的概率，并由此判断是否为基因编码区域。</p><h4 id="基于密码子的出现频率区分编码区">4.3.1基于密码子的出现频率区分编码区</h4><ul><li><p>基本原理：在DNA序列的编码区和非编码区，三联密码子出现的频率不同；因此基于三联密码子出现频率的差异，可以建立概率模型完成区分。</p></li><li><p>基本步骤：</p><ol type="1"><li><p>对基因编码区和非编码区域分别估计三联密码子的出现概率。</p><p>用C<sub>1</sub>表示非编码区， C<sub>2</sub>表示编码。</p></li><li><p><mark>建立概率模型</mark>，根据后验概率判别该序列否属于基因编码区域。</p></li></ol></li></ul><h4 id="朴素贝叶斯方法-1">4.3.2 朴素贝叶斯方法</h4><p>基本思路：假设各个特征相互条件独立，我们把联合分布或联合概率转化为各个边缘分布或边缘概率的乘积。<span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}\xrightarrow{S=s_1s_2...s_m}P(C_j|S)=\frac{P(C_j)\prod_{i=1}^{m}P(s_i|C_j)}{P(S)}\]</span> 判别规则：基于最大后验概率准则确定出序列S所属于的类别k <span class="math display">\[k=arg\thinspace \max_{j}\{P(C_j|S,j=1,...K\},其中C_j为类别j\]</span></p><ul><li>设计分类器，即构造一个从给定的数据S到各个类别的映射规则。</li></ul><h4 id="基于序列s建立概率模型">4.3.3 基于序列S建立概率模型</h4><p>考虑2个类别C<sub>1</sub> 和C<sub>2</sub>：其中用C<sub>1</sub>表示非编码区，C<sub>2</sub>表示编码区。</p><p>对于给定序列S，要判断S属于编码区还是非编码区，可以计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)。</p><ul><li>根据贝叶斯公式： <span class="math display">\[  P(C_1|S)=\frac{P(C_1,S)}{P(S)}∝P(S|C_1)P(C_1)\\\\P(C_2|S)=\frac{P(C_2,S)}{P(S)}∝P(S|C_2)P(C_2)  \]</span></li></ul><p>对于给定序列S，把S表示成 A<sub>1</sub> A<sub>2</sub>…A<sub>L</sub>（A<sub>i</sub>为三联密码子），则序列S的出现概率为：P(S)=P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>)。</p><p>假设序列中的3联密码子相互独立(且忽略3联密码子的顺序)，则序列S的出现概率可以转化为：P(S)= P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>) =P(A<sub>1</sub>)P(A<sub>2</sub> )…P(A<sub>L</sub>）</p><blockquote><p>若要计算P(S)，则需要估计出P(A<sub>1</sub>)，P(A<sub>2</sub>), …,P(A<sub>L</sub>）</p></blockquote><p>计算条件概率P(S|C<sub>2</sub>)：</p><p>在编码区(C<sub>2</sub>)观测到序列S的概率，把S表示成三联密码子序列A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>，则 P(S|C<sub>2</sub>)表达为:<span class="math display">\[P(S|C_2)=P(A_1A_2...A_L|C_2)=P(A_1|C_2)P(A_2|C_2)...P(A_L|C_2)\]</span></p><blockquote><p>这里假设了编码区的序列中的3联密码子相互独立(且忽略3联密码子的顺序)。</p></blockquote><p>则计算P(S|C<sub>2</sub>)需要估计出P(A<sub>1</sub>|C<sub>2</sub>) ,P(A<sub>2</sub>|C<sub>2</sub>) , …, P(A<sub>L</sub>|C<sub>2</sub>)。</p><blockquote><p>也就是基于编码区的序列去估计各个三联密码子的出现概率。</p></blockquote><p>计算条件概率P(S|C<sub>1</sub>)方法同理。</p><p>最后，利用贝叶斯公式： <span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}∝P(S|C_j)P(C_j)\]</span> <mark>分类规则：</mark></p><ul><li>如果P(C<sub>2</sub>|S)&gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S)&lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><h4 id="基于朴素贝叶斯方法识别编码区与非编码区4.3.3的总结">4.3.4基于朴素贝叶斯方法识别编码区与非编码区（4.3.3的总结）</h4><p>具体步骤：</p><ol type="1"><li><p>基于训练数据集, 估计各个三联密码子的出现概率 <span class="math display">\[P(C_j|S)∝P(C_j)P(A_1A_2...A_L|C_j)=P(C_j)P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span> 其中,P(A<sub>i</sub>|C<sub>j</sub>)为类别C<sub>j</sub>中3联密码子A<sub>i</sub>的出现概率，需要基于给定的训练样本序列去估计。</p><ul><li>计算每个三联体密码子出现的频率f<sub>AAA,</sub> f<sub>AAC</sub>,f<sub>AAG</sub>…, 用频率去估计三联密码子在当前序列中的出现概率。</li></ul></li><li><p>利用三联密码子出现频率，对于基因序列样本集中的每条序列S，计算S的出现概率P(S|C<sub>1</sub>)和P(S|C<sub>2</sub>）。 <span class="math display">\[P(S|C_j)=P(A_1A_2...A_L|C_j)=P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span></p></li><li><p>估计非编码区和编码区的先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)，计算后验概率P(S|C<sub>1</sub>)P(C<sub>1</sub>)和P(S|C<sub>2</sub>)P(C<sub>2</sub>)。</p><ul><li>先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)可根据训练集里两种类型的序列的比例去估计。</li></ul></li></ol><p>测试阶段：</p><p>给定序列S，计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)</p><ul><li>如果P(C<sub>2</sub>|S)&gt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>编码区</mark>。</li><li>如果P(C<sub>2</sub>|S)&lt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>非编码区</mark>。</li></ul><p>该方法优点：模型简便，易于实现。</p><p>该方法缺点：识别率较低。</p><p>改进的方向：</p><ul><li>考虑相邻密码子之间依存关系，建立一阶或高阶马尔科夫模型。</li><li>考虑描述序列的高维向量。</li></ul><h3 id="马尔科夫链markov-chain">4.4 马尔科夫链(Markov Chain）</h3><p>考虑一个具有多个状态的系统S，令O<sub>1</sub>, O<sub>2</sub>, ⋯,O<sub>n</sub>为系统在各个时刻的状态变量，即<mark>状态链</mark>。</p><p>无后效性：</p><ul><li><p>1阶马氏链: 系统在时间步 t 处于哪个状态,仅与时间t-1时系统所处的状态有关。 <span class="math display">\[P(O_1O_2O_3...O_n)=P(O_1)P(O_2|O_1)P(O_3|O_2)...P(O_n|O_n-1)\]</span></p><ul><li>系统未来的状态仅依赖于当前状态。</li><li>一条马尔可夫链完全决定于初始分布和状态转换概率。</li></ul></li><li><p>k阶马氏链：时间步t的状态仅与时间t-1, t-2, … ,t-k时刻的历史状态有关。</p></li></ul><h4 id="考虑三联密码子的1阶马尔科夫性">考虑三联密码子的1阶马尔科夫性：</h4><ul><li><p>给定DNA序列片段S =A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub>，其中A<sub>i</sub>为3联密码子。</p></li><li><p>在计算P(A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>)时，我们<mark>引入1阶马尔可夫模型</mark>，把P(A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>)转化为: <span class="math display">\[P(A_1A_2...A_n)=P(A_1)P(A_2|A_1)...P(A_n|A_{n-1})\]</span></p><ul><li>需要估计出三联密码子之间的转移概率P(A<sub>j</sub>|A<sub>j-1</sub>)和P(A<sub>1</sub>)</li></ul></li></ul><p>状态转移概率P(A<sub>j</sub>|A<sub>i</sub>)的估计:</p><ul><li><p>以编码区为例:A<sub>i</sub>到A<sub>j</sub>的转移概率，需要统计A<sub>i</sub>到A<sub>j</sub>的转移次数，除以所有以A<sub>i</sub>为起始状态转变为A<sub>k</sub>的转移次数:<span class="math display">\[\widetilde{P} (A_j|A_i)=\frac{T_{A_i\to A_j}}{\sum_{k=1}^{64}T_{A_i\toA_k}}\]</span></p><ul><li>其中T<sub>Ai→Aj</sub>表示从状态A<sub>i</sub>转移到状态A<sub>j</sub>的次数。</li></ul></li><li><p>第1个密码子和最后1个密码子需要单独统计: <span class="math display">\[开头:\widetilde{P} (A_i)=\widetilde{P} (A_i|[])=\frac{T_{[]\toA_i}}{\sum_{k=1}^{64}T_{[]\to A_k}}\]</span></p><p><span class="math display">\[结尾:\widetilde{P} (A_j)=\widetilde{P} ([]|A_j)=\frac{T_{A_j\to[]}}{\sum_{k=1}^{64}T_{A_k\to []}}\]</span></p><ul><li>即从训练样本序列中统计密码子A<sub>i</sub>出现在开始位置的频率和密码子A<sub>j</sub>出现在末尾的频率。</li></ul></li></ul><p>最后，利用贝叶斯公式计算后验概率： <span class="math display">\[P(C_j|A_1A_2...A_n)=\frac{P(A_1A_2...A_n|C_j)P(C_j)}{P(A_1A_2...A_n)}\]</span> 分类规则：</p><ul><li>如果P(C<sub>2</sub>|S)&gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S)&lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><p>在计算P(C<sub>1</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> ) 和P(C<sub>2</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>)时，引入<mark>1 阶马尔可夫链</mark>考虑三联密码子之间的依赖关系，即：<span class="math display">\[P(A_1A_2...A_n|C_j)=P(A_1|C_j)P(A_2|A_1,C_j)...P(A_n|A_{n-1},C_j)\]</span></p><ul><li>需要在编码区和非编码区分别估计出三联密码子的转移概率。</li></ul><p>如果S是编码区，那么序列<mark>S=A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>出现的概率P(S)用马氏链</mark>来刻画如下：<span class="math display">\[P(S|C_2)=P(A_1|C_2)\prod_{i=2}^{n}P(A_i|A_{i-1},C_2)\]</span></p><ul><li>若已知或给定从训练样本序列中估计的先验概率和状态转移概率，那么可直接带入公式计算序列S的似然度。<ul><li>P(A<sub>1</sub>|C<sub>2</sub>)是C<sub>2</sub>中以A<sub>1</sub>为第一个密码子的概率P(A<sub>1</sub>|[])</li><li>若考虑末尾A<sub>n</sub>转换为结束态，则还需再乘以P([]|A<sub>n</sub>)或P(A<sub>n</sub>)</li></ul></li></ul><h4 id="马尔科夫链模型的参数估计">马尔科夫链模型的参数估计：</h4><p>先验概率:</p><ul><li>序列属于编码区的先验概率P(C<sub>2</sub>)</li><li>序列属于非编码区的先验概率P(C<sub>1</sub>)</li></ul><p>状态转移概率：</p><p>需要根据训练数据,分别估计编码区C<sub>2</sub>和非编码区C<sub>1</sub>中各个3联密码子A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>之间的状态转移概率矩阵。</p><h3 id="基于同源序列比对的方法">4.5 基于同源序列比对的方法</h3><p>基本动机：</p><ul><li>部分物种的基因组中有大量基因已被实验证实，并在相应数据库中有注释(annotation)信息。</li><li>亲缘关系很近的生物体之间可能具有相似的基因。</li><li>用某个物种中的未知基因与亲缘关系相近的其它物种的基因作比较，对揭示未知基因的信息会有帮助。</li></ul><p>基本思路：充分利用序列同源性帮助进行基因识别问题。</p><p>比较两个基因组中的基因：计算最优剪接比对，以比较不同基因组中存在相似度很高的外显子“群岛”区域。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110107270.png" style="zoom:50%;"></p><p>比较基因组DNA与mRNA：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110150024.png" style="zoom:50%;"></p><h3 id="基因识别问题总结">4.6 基因识别问题总结</h3><p>基本任务：从DNA序列中识别出基因编码部分。</p><p>基本方法：基因识别问题归结为模式分类问题。</p><p>计算碱基/密码子的统计信息：</p><ul><li>在DNA的编码区和非编码区，碱基的信号特性是不相同的，比如基因编码区的周期性特征、功能位点。</li><li>在DNA的编码区和非编码区，3联密码子出现的频率是不相同的。</li><li>6联密码子的出现频率在编码区和非编码区具有差异性。<ul><li>比如: AAAAAA 在编码区出现概率为1%，而非编码区为5%。</li></ul></li></ul><p>建立识别模型： 贝叶斯决策 / 朴素贝叶斯 / 马尔科夫链 / HMM。</p><h4 id="基因识别方法的局限性">基因识别方法的局限性：</h4><p>目前的方法仅能识别蛋白质编码基因，对基因非编码部分还没有可靠的识别方法。</p><ul><li>识别原理与基因表达的真实分子机制没有多少关系。<ul><li>由于缺乏识别非编码基因的方法，无法统计在人类基因组中究竟隐藏多少非编码基因。</li></ul></li></ul><p>现有基因识别方法存在固有的保守性。</p><ul><li>不可能发现与数据库中已知基因有较大差别的基因或新基因。</li></ul><p>现有基因识别方法的最大缺陷在于忽视关于基因结构的生物学知识。</p><ul><li>从生物学家来看，现有的基因识别程序还不可靠，需要结合分子生物学、比较基因组学等其他方面研究。</li></ul><h1 id="三隐马尔可夫模型-hidden-markov-model-hmm">三、隐马尔可夫模型(Hidden Markov Model: HMM)</h1><h2 id="hmm的定义">1.HMM的定义</h2><p>一阶阶离散HMM是一个关于离散序列的随机生成模型。</p><p>基本要素：</p><ul><li>离散明字符集合：V = {V<sub>1</sub> , …, 𝑉<sub>M</sub>}</li><li>有限隐状态集合：S = {S<sub>1</sub> , …, 𝑆<sub>N</sub>}</li><li>初始状态概率向量：<em>π</em> = (<em>π</em><sub>1</sub> , …,<em>π</em><sub>N</sub>)</li><li>状态转移概率矩阵： A = { a<sub>ij</sub>, i,j = 1, …N}</li><li>明字符生成概率矩阵： B = { b<sub>jk</sub>, j = 1, …N, k=1,...M}</li></ul><p>HMM记作<em>λ</em>=(S,V,π,A,B)或<em>λ</em>=(π,A,B)</p><ul><li>一个HMM模型是一个三元组(S, V, λ)，其中λ为模型参数的集合，S是明字符集V是有限状态集合——每个状态可以产生明字符集中的字符。</li></ul><h2 id="评估问题">2.评估问题</h2><h3 id="前向算法">2.1 前向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\alpha(1,i)=\pi(i)b(i,o_1)\]</span></p></li><li><p>递推 <span class="math display">\[\alpha(t+1,j)=\Bigg[\sum_{i=1}^{N}\alpha(t,i)\alpha(i,j)\Bigg]b(j,o_{t+1})\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\sum_{i=1}^{N}\alpha(T,i)\]</span></p></li></ol><h3 id="前向算法例题">2.2 前向算法例题</h3><p>考虑一个包含两个字符的字符表{C,T}和包含3个状态的状态集{S<sub>1</sub>, S<sub>2</sub>,S<sub>3</sub>}，HMM的转移概率和字符生成概率如下表。请计算序列O =CCT的全概率。</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;">→0</th><th style="text-align: center;">→S<sub>1</sub></th><th style="text-align: center;">→S<sub>2</sub></th><th style="text-align: center;">→S<sub>3</sub></th><th style="text-align: center;">生成C</th><th style="text-align: center;">生成T</th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">S<sub>1</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.5</td><td style="text-align: center;">0.5</td></tr><tr><td style="text-align: center;">S<sub>2</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;"></td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.1</td><td style="text-align: center;">0.9</td></tr><tr><td style="text-align: center;">S<sub>3</sub></td><td style="text-align: center;">0.4</td><td style="text-align: center;"></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.9</td><td style="text-align: center;">0.1</td></tr></tbody></table><p><span class="math display">\[\Rightarrow\begin{cases}\begin{aligned}\alpha(1,1)=\pi(1)b_1(C)=0.33×0.5=0.165\\\alpha(1,2)=\pi(2)b_2(C)=0.33×0.1=0.033\\\alpha(1,3)=\pi(3)b_3(C)=0.33×0.9=0.297\end{aligned}\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(2,1)=b_1(C)\sum_{i=1}^{3}\alpha(1,i)a_{i1}=0.165×0.3×0.5=0.02475\\\alpha(2,2)=b_2(C)\sum_{i=1}^{3}\alpha(1,i)a_{i2}=(0.165×0.2+0.033×0.4+0.297×0.2)×0.1=0.01056\\\alpha(2,3)=b_3(C)\sum_{i=1}^{3}\alpha(1,i)a_{i3}=(0.165×0.3+0.033×0.4+0.297×0.4)×0.9=0.16335\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(3,1)=b_1(T)\sum_{i=1}^{3}\alpha(2,i)a_{i1}=0.02475×0.3×0.5=0.0037125\\\alpha(3,2)=b_2(T)\sum_{i=1}^{3}\alpha(2,i)a_{i2}=(0.02475×0.2+0.01056×0.4+0.16335×0.2)×0.9=0.0376596\\\alpha(3,3)=b_3(T)\sum_{i=1}^{3}\alpha(2,i)a_{i3}=(0.02475×0.3+0.01056×0.4+0.16335×0.4)×0.1=0.0076989\end{cases}\]</span></p><p><span class="math display">\[\RightarrowP(O)=P(CCT)=\sum_{i=1}^{3}\alpha(3,i)=0.0037125+0.0376596+0.0076989=0.049071\]</span></p><h3 id="后向算法">2.3 后向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\beta_T(i)=1\]</span></p></li><li><p>递推 <span class="math display">\[\beta_t(i)=\sum_{j=1}^{N}a_{ij}b_j(o_{t+1})\beta_{t+1}(j)\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\pi_ib_i(o_1)\beta_1(i)\]</span></p></li></ol><h2 id="解码问题">3.解码问题</h2><h3 id="维特比viterbi算法">3.1 维特比(Viterbi)算法</h3><p>维特比(Viterbi)算法过程：</p><ol type="1"><li><p>初始化： <span class="math display">\[\delta_1(i)=\pi_ib_i(o_1)\]</span></p></li><li><p>递归： <span class="math display">\[\delta_t(j)=\max_{1\le i\le N}[\delta_{t-1}(i)a_{ij}]*b_j(o_t)\]</span></p></li><li><p>终结： <span class="math display">\[P^*=\max_{1\le i\le N}[\delta_T(i)]\]</span></p></li><li><p>回溯： <span class="math display">\[q^*_T=arg\:\max_{1\le i\le N}[\delta_T(i)\]</span></p></li></ol><h3 id="解码问题例题">3.2 解码问题例题</h3><p>从3个盒子中随机摸出1个球，盒子中的球有黑白两个颜色，重复实验多次，观察球的颜色构成观测序列。</p><ul><li><p>隐含状态集合: {盒子1，盒子2，盒子3} ={S<sub>1</sub>,S<sub>2</sub>,S<sub>3</sub>}</p></li><li><p>观测集合：{黑球，白球} = {Black, White}</p></li><li><p>N=3,M=2</p></li><li><p>初始状态概率:<em>π</em> = (0.3 , 0.5, 0.2)<sup>T</sup></p></li><li><p>状态转移概率矩阵： <span class="math display">\[A = \begin{bmatrix}0.4 &amp; 0.4 &amp; 0.2\\0.3 &amp; 0.2 &amp; 0.5\\0.2 &amp; 0.6 &amp; 0.2\end{bmatrix}\]</span></p></li><li><p>观测生成概率矩阵： <span class="math display">\[B = \begin{bmatrix}0.2 &amp; 0.8\\0.6 &amp; 0.4\\0.4 &amp; 0.6\end{bmatrix}\]</span></p></li><li><p>请计算观测到序列<mark>O = {o<sub>1</sub> , o<sub>2</sub>,o<sub>3</sub>} = {′黑球′ ， ‘白球’ ， ‘黑球’}</mark>的最可能的盒子序列。</p></li></ul><p><strong>解：</strong></p><p><strong>t = 1观测到o<sub>1</sub>的概率δ<sub>1</sub>(i)：</strong><span class="math display">\[\Rightarrow\begin{cases}\delta_1(1)=\pi_1b_{1o_1}=0.3*0.2=0.06\\\delta_1(2)=\pi_2b_{2o_1}=0.5*0.6=0.3\\\delta_1(3)=\pi_3b_{3o_1}=0.2*0.4=0.08\end{cases}\]</span><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120605011.png" alt="t = 1 时的观测概率示意图" style="zoom:67%;"></p><p><strong>t =2观测到o<sub>1</sub>o<sub>2</sub>的概率δ<sub>2</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_2(1)=max[\delta_1(j)a_{j1}]b_{1o_2}=max\{\delta_1(1)a_{11},\delta_1(2)a_{21},\delta_1(3)a_{31}\}b_{1o_2}=max\{0.06*0.4,0.3*0.3,0.08*0.2\}*0.8=max\{0.024,0.09,0.016\}*0.8=0.072,同时记录t=1时的回溯为j=2(对应0.09的取值)\\\delta_2(2)=max[\delta_1(j)a_{j2}]b_{2o_2}=max\{\delta_1(1)a_{12},\delta_1(2)a_{22},\delta_1(3)a_{32}\}b_{2o_2}=max\{0.06*0.4,0.3*0.2,0.08*0.6\}*0.4=max\{0.024,0.06,0.048\}*0.4=0.024,同时记录t=1时的回溯为j=2(对应0.06的取值)\\\delta_2(3)=max[\delta_1(j)a_{j3}]b_{3o_2}=max\{\delta_1(1)a_{13},\delta_1(2)a_{23},\delta_1(3)a_{33}\}b_{3o_2}=max\{0.06*0.2,0.3*0.5,0.08*0.2\}*0.8=max\{0.012,0.15,0.016\}*0.6=0.09,同时记录t=1时的回溯为j=2(对应0.15的取值)\end{cases}\]</span> $$</p><p>$$</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120633023.png" alt="t = 2 时的观测概率示意图" style="zoom:50%;"></p><p><strong>t =3观测到o<sub>1</sub>o<sub>2</sub>o<sub>3</sub>的概率δ<sub>3</sub>(i)：</strong><span class="math display">\[\Rightarrow\begin{cases}\delta_3(1)=max[\delta_2(j)a_{j1}]b_{1o_3}=max\{\delta_2(1)a_{11},\delta_2(2)a_{21},\delta_2(3)a_{31}\}b_{1o_3}=max\{0.072*0.4,0.024*0.3,0.09*0.2\}*0.2=max\{0.0288,0.0072,0.018\}*0.2=0.00576,同时记录t=2时的回溯为j=1(对应0.0288的取值)\\\delta_3(2)=max[\delta_2(j)a_{j2}]b_{2o_3}=max\{\delta_2(1)a_{12},\delta_2(2)a_{22},\delta_2(3)a_{32}\}b_{2o_3}=max\{0.072*0.4,0.024*0.2,0.09*0.6\}*0.6=max\{0.0288,0.0048,0.054\}*0.6=0.0324,同时记录t=2时的回溯为j=3(对应0.054的取值)\\\delta_3(3)=max[\delta_2(j)a_{j3}]b_{3o_3}=max\{\delta_2(1)a_{13},\delta_2(2)a_{23},\delta_2(3)a_{33}\}b_{3o_3}=max\{0.072*0.2,0.024*0.5,0.09*0.2\}*0.4=max\{0.0144,0.012,0.018\}*0.4=0.0072,同时记录t=2时的回溯为j=3(对应0.018的取值)\end{cases}\]</span><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614121258299.png" alt="t = 3 时的观测概率示意图" style="zoom:50%;"></p><p>解码出的隐含状态序列是: <mark>盒子2，盒子3，盒子2</mark></p><h1 id="四系统发育分析">四、系统发育分析</h1><h2 id="系统发育树">1.系统发育树</h2><p>系统发生树：表达类群/物种/序列之间进化关系的一种树状图。</p><blockquote><p>也叫<mark>系统发育树(Phylogenetic Tree)</mark>、进化树。</p></blockquote><p>分子进化树：从DNA或蛋白质序列数据出发构建而成，用以揭示不同物种之间的进化联系的一种树状图。</p><blockquote><p>分子钟假设：两个物种的同源基因之间的差异程度与它们的共同祖先的存在时间有一定关系,分子进化速度大体恒定。</p></blockquote><h2 id="基因树和物种树">2.基因树和物种树</h2><p>基因树(gene tree)：基于单个同源基因差异构建的系统树。</p><p>物种树(species tree)：</p><ul><li>表达某一特定类群的进化路径。</li><li>由多个基因或基因组所建立的基因树通过综合而成。</li></ul><p>基因树和物种树两者的差异：</p><ul><li>从两个不同的物种中获取的两个基因，其分化可能早于物种的分化。</li><li>基因树的拓扑结构可能与物种树不一致，因为两个或多个基因树之间很可能存在不一致之处<ul><li>如何将由多个基因或基因组建立的基因树综合成为一个物种树，是分子系统学目前所面临的一个难题。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611221237122.png" alt="物种树" style="zoom: 67%;"></p><h2 id="进化树">3.进化树</h2><p>进化树由结点(node, 顶点)与分枝(branch, 边)组成。</p><p>结点分两类：</p><ul><li>叶结点代表一个分类单元（比如类群、物种或序列）。</li><li>内部结点(祖先结点)代表推断出的共同祖先,祖先结点可以对应于一种已知的物种，也可以没有对应的物种。</li></ul><p>分枝用以显示不同的遗传路线。</p><p>进化树在本质上包含两类信息：</p><ul><li>树的拓扑信息。</li><li>分枝的长度信息。</li></ul><p>对进化树的分类：</p><ul><li>标度树、非标度树</li><li>二叉树、k-叉树</li><li>有根树、无根树</li></ul><h3 id="标度树与非标度树">3.1 标度树与非标度树</h3><p>非标度树：枝长无意义；叶结点排列整齐，内部结点可以反映进化时间的顺序。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222054188.png" alt="非标度树"><figcaption aria-hidden="true">非标度树</figcaption></figure><p>标度树：枝长有意义；分枝长度与物种/序列的进化时间成正比。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222309737.png" alt="标度树"><figcaption aria-hidden="true">标度树</figcaption></figure><p>两种树都可在分枝上标注信息(分支长度、进化时间以及其它数值)。</p><h3 id="k-叉树">3.2 k −叉树</h3><p>k −叉树 (内部结点的分叉)：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222638711.png" alt="k −叉树" style="zoom:67%;"></p><h3 id="进化树是否有根root">3.3 进化树是否有根(root)</h3><p>有根进化树：</p><ul><li>根表示各个物种共同的祖先。</li><li>从祖先结点只有唯一的路径进化到达叶结点。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223144654.png" alt="有根树（可以明确进化路径）"><figcaption aria-hidden="true">有根树（可以明确进化路径）</figcaption></figure><p>无根进化树：</p><ul><li>没有指定各物种的共同祖先。</li><li>没有关于进化方向的信息。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223708792.png" alt="无根树（无进化方向）"><figcaption aria-hidden="true">无根树（无进化方向）</figcaption></figure><p>有些进化树构造算法产生有根树，也有些算法只能产生无根树。</p><p>无根树→有根树的转换</p><ul><li>利用一个外部类群(物种、序列)生成根。<ul><li>外部类群(outgroup)：与所有待研究类群亲缘关系都较远的类群。</li></ul></li></ul><h2 id="构建进化树的方法">4.构建进化树的方法</h2><h3 id="构建分子进化树">4.1 构建分子进化树</h3><p>推断分子进化树的基本原理：同源序列之间的差异是进化造成的，差异程度与进化时间成正比。</p><blockquote><p>分子钟假设</p></blockquote><p>构建分子进化树的基本方法：</p><ol type="1"><li>刻画多条同源序列的差异</li><li>构建反映序列间差异的树状图<ul><li>从现有数据出发,试图<mark>推断(或重构)</mark>进化树——真实的进化树是未知的。</li></ul></li></ol><p>推断分子进化树的关键：刻画出序列之间由进化造成的与进化时间成正比的差异。</p><p>刻画序列之间差异的方法：进行序列比对，由最佳比对构造距离(或不相似度)。</p><ul><li><p>设 最佳比对中不匹配位点所占的百分<em>f</em></p><ul><li>“每100个位点上不匹配位点的数目”</li></ul></li><li><p>比如: Jukes-Cantor模型构造的距离： <span class="math display">\[d_{ij}=-\frac{3}{4}log(1-\frac{4f}{3})\]</span></p></li></ul><p>进化树构建算法：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611233724121.png" alt="进化树构建算法"><figcaption aria-hidden="true">进化树构建算法</figcaption></figure><h3 id="非加权组算术平均法upgma">4.2 非加权组算术平均法(UPGMA)</h3><p>最早的基于距离矩阵的方法，最初产生于20世纪60年代早期。</p><ul><li>所有树重建方法中最简单的一种。</li></ul><p>算法特点：</p><ul><li>基于距离矩阵数据</li><li>使用层次式聚类算法</li></ul><p>步骤：</p><ol type="1"><li>初始化：每条序列自成一个组C<sub>i</sub>，分别对应于树中的一个叶结点。</li><li>迭代：<ul><li>寻找具有最小距离值d<sub>ij</sub>的两个组C<sub>i</sub>和C<sub>j</sub>, 合并成 一个新组C<sub>k</sub> = C<sub>i</sub>∪ C<sub>j</sub></li><li>更新C<sub>k</sub>与各旧组C<sub>ℓ</sub>的距离为d<sub>k,ℓ</sub> =(d<sub>i,ℓ</sub>+ d<sub>j,ℓ</sub>)/2</li><li>在树中增加一个分支点，同时与C<sub>i</sub>和C<sub>j</sub>相连接，<strong>两条分枝各为d<sub>i,j</sub>/2</strong></li></ul></li><li>终止：直到所有序列聚为一个组时终止，最终得到的分枝点为树的根。</li></ol><h4 id="例-利用非加权组算数平均法进行进化树构建">例:利用非加权组算数平均法进行进化树构建</h4><p>A: GTGCTGCACGG CTCAGTATA GCATTTACCC TTCCATCTTC AGATCCTGAA</p><p>B: ACGCTGCACGG CTCAGTGCG GTGCTTACCC TCCCATCTTC AGATCCTGAA</p><p>C: GTGCTCGCAGG CTCGGCGCA GCATTTACCC TCCCATCTTC AGATCCTATC</p><p>D: GTATCACACGA CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCCTAAA</p><p>E: GTATCACATAG CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCTAAA</p><p>1.初始化：计算序列之间的汉明距离，即对应位点上字符不同的数目</p><p>得到初始距离矩阵：</p><table><thead><tr><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table><p>2.迭代：选择最近结点进行合并，更新距离矩阵，更新进化树</p><p>第1次迭代：更新距离矩阵；合并分支（叶节点）</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201442420.png" alt="第一次迭代"><figcaption aria-hidden="true">第一次迭代</figcaption></figure><p>进化树上标注进化距离：两条分枝各为d<sub><em>ij</em></sub>/2</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201549550.png" alt="第一次迭代得到进化树"><figcaption aria-hidden="true">第一次迭代得到进化树</figcaption></figure><p>第2次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201712875.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201747559.png" alt="第二次迭代得到进化树"><figcaption aria-hidden="true">第二次迭代得到进化树</figcaption></figure><p>第3次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201825651.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201951538.png" alt="第三次迭代得到进化树"><figcaption aria-hidden="true">第三次迭代得到进化树</figcaption></figure><blockquote><p>左侧中间结点((A,C),B) 到中间结点 (A,C)的距离是: 10/2 – 4 = 1</p></blockquote><p>第4次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202054031.png" alt="第四次迭代"><figcaption aria-hidden="true">第四次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202212962.png" alt="第四次迭代得到进化树"><figcaption aria-hidden="true">第四次迭代得到进化树</figcaption></figure><p>3.算法终止：完成进化树构建</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202320043.png"></p><p>不带标度的文本表示法：(((A,C),B),(D,E))</p><p>带标度的文本表示法：(((A:4,C:4):1,B:5):2.25,(D:2.5,E:2.5):4.75)</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202350905.png" alt="最终进化树"><figcaption aria-hidden="true">最终进化树</figcaption></figure><ul><li><p>初始距离矩阵：</p><table><thead><tr><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li><li><p>进化距离矩阵：</p><table><thead><tr><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">B</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">D</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">E</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li></ul><blockquote><p>两个距离矩阵中的数值 并不严格匹配</p></blockquote><p>超度量(Ultrametric)：如果任何3个不同序列S<sub>i</sub>,S<sub>j</sub>,S<sub>k</sub>，距离函数d<sub>ij</sub>,d<sub>ik</sub>,d<sub>jk</sub>中的两个相等且不小于第3个,则称距离函数为超度量。</p><p>若初始距离矩阵为超度量矩阵，则UPGMA算法总能产生正确的进化树。即初始距离矩阵与所构造进化树对应的距离矩阵一致。</p><h1 id="五蛋白质结构分析与预测">五、蛋白质结构分析与预测</h1><h2 id="引言蛋白质">1.引言—蛋白质</h2><p>蛋白质是由<mark>氨基酸</mark>用<mark>肽键</mark>相连接起来的线性聚合物。</p><blockquote><p>蛋白质是平均长度为200个左右的氨基酸。</p><p>大的蛋白质可以达到上千个氨基酸。</p></blockquote><p>蛋白质决定的细胞的形状与结构。</p><ul><li>细胞中蛋白质的重量占细胞干重的一半以上。</li></ul><p>蛋白质是分子识别及催化作用的主要主体，执行生物体内各种重要工作：</p><ul><li>营养物质的运输</li><li>生物反应的催化</li><li>生物体的生长和分化的控制</li><li>生物信号的识别与传递</li></ul><blockquote><p>序列决定结构，结构决定功能。</p></blockquote><p>构成蛋白质的氨基酸序列的长度不同、排列不同和空间结构不同。</p><ul><li><p>一级结构：蛋白质中相邻的氨基酸通过肽键形成一条伸展的链。</p></li><li><p>二级结构：肽链上的氨基酸残基形成局部的二级结构。</p><blockquote><p>比如α螺旋是氨基酸的单链螺旋，而β片层则由序列片段“织”形成平面片状结构。</p></blockquote></li><li><p>空间结构：各种二级结构组合形成完整的折叠结构。</p></li></ul><h2 id="蛋白质结构预测">2.蛋白质结构预测</h2><h5 id="蛋白质结构预测问题的可行性">蛋白质结构预测问题的可行性</h5><p>自然界中实际存在的蛋白质种类是<strong>有限的</strong>，可能的结构类型并不多。</p><ul><li>结构的数目并未随蛋白质氨基残基的个数呈现指数增长。</li></ul><p>存在大量同源序列，序列到结构的关系有一定规律可循。</p><ul><li>相似的序列具有相似的结构。</li></ul><h5 id="蛋白质结构预测问题的数学本质">蛋白质结构预测问题的数学本质</h5><p>寻找一种从蛋白质的氨基酸<strong>线性序列</strong>到蛋白质所有原子<strong>三维坐标</strong>的<mark>一种映射</mark>。</p><h5 id="结构预测的基本方法">结构预测的基本方法</h5><p>统计分析方法：对已知结构的蛋白质进行统计分析，建立氨基酸序列到蛋白质结构的映射模型，进而对未知结构的氨基酸序列根据映射模型直接从序列预测结构。</p><ul><li>经验参数法</li><li>相似片断法</li><li>同源方法</li></ul><p>理论分析方法：假设蛋白质分子取能量最低的空间结构，根据物理化学原理，通过理论计算(如分子力学/分子动力学)进行对氨基酸序列结构预测。</p><ul><li>从头计算法</li></ul><h2 id="蛋白质二级结构预测">3.蛋白质二级结构预测</h2><p>基本依据：每一段相邻氨基酸残基具有形成一定二级结构的倾向。</p><p>问题的本质是模式分类问题。</p><ul><li>蛋白质二级结构的构成具有比较强的统计规律。</li><li>所有蛋白质中约85%的氨基酸残基处于三种基本二级结构状态之一。<ul><li>α螺旋、β折叠和 t 转角</li></ul></li></ul><p>二级结构预测的目标：判断每一段中心的残基是否处于二级结构的三态之一。</p><blockquote><p>三态：α螺旋、β折叠和 t 转角(或其它状态)</p></blockquote><p>二级结构预测的基本思路：相似序列对应着相似的结构。</p><ul><li>相似的一段相邻氨基酸残基，对应着相似的二级结构。</li></ul><p>二级结构预测的基本过程：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612215417920.png" alt="二级结构预测" style="zoom:50%;"></p><p>二级结构预测可利用的信息：</p><ol type="1"><li>单个氨基酸残基统计分析</li></ol><ul><li>从数据集中提取各种残基形成特定二级结构的倾向，以此作为预测依据。</li></ul><ol start="2" type="1"><li>基于氨基酸片断的统计分析<ul><li>统计对象氨基酸片断，片断体现了中心残基所处的环境。</li><li>以残基在特定环境中形成的特定二级结构的倾向作为预测依据。</li></ul></li><li>蛋白质序列的长程信息和进化信息<ul><li>二级结构的形成一定程度上受到长程残基的影响。</li><li>蛋白质家族具有特异的残基替换模式。</li><li>存在进化保守区域，该区域变化则会导致蛋白质结构的改变。</li></ul></li></ol><h5 id="经验参数法">(1)经验参数法</h5><p>根据不同氨基酸形成特定二级结构的倾向进行结构预测。</p><ul><li>通过对已知结构的蛋白质(如蛋白质结构数据库PDB、蛋白质二级结构数据库DSSP中的蛋白质)进行统计分析，可发现各种氨基酸形成不同二级结构的倾向，从而形成一系列关于二级结构预测的规则。</li></ul><h6 id="预测二级结构的经验规则">预测二级结构的经验规则</h6><p>基本思想：在序列中寻找符合某规则的二级结构的成核位点和终止位点。</p><p>基本步骤：扫描输入的氨基酸序列，利用一组规则发现可能成为特定二级结构<strong>成核区域</strong>的短序列，然后对于<strong>成核区域</strong>进行扩展，不断扩大<strong>成核区域</strong>，直到倾向性因子小于1.0为止。</p><ul><li>α螺旋规则</li><li>β折叠规则</li><li>转角规则</li><li>重叠规则</li></ul><h5 id="相似片段法">(2)相似片段法</h5><p>基本原理：最近邻方法。</p><ul><li>相似序列具有相似的结构，将相似序列或序列的片断所对应的二级结构作为预测结果；在预测中心残基的二级结构时，以残基在特定环境形成特定二级结构的倾向作为预测依据。</li></ul><p>基本统计信息：基于氨基酸片段的统计分析。</p><ul><li>统计的对象是氨基酸片段，片段体现了中心残基所处的上下文环境。<ul><li>片段的长度通常为11~21。</li></ul></li></ul><p>实现步骤：</p><ul><li>训练阶段<ul><li>通过窗口扫描已知结构的训练序列，形成大量短片断，即训练片断。</li><li>记录这些片断中心氨基酸残基的二级结构。</li></ul></li><li>预测阶段<ul><li>利用同样大小的窗口扫描待测序列u，在每个窗口位置下的序列片断与上述训练片断比较，找出最相似的k个训练片断。<ul><li>比如 k=20，50</li></ul></li><li>取出现频率最高的训练片断的二级结构作为待测片断二级结构的预测。</li></ul></li></ul><h5 id="同源分析法">(3)同源分析法</h5><p>基本思路：</p><ul><li>将待预测的片段与数据库中已知二级结构的片段进行相似性比较。</li><li>利用打分矩阵计算出相似性得分。</li><li>根据相似性得分以及数据库中的构象态，构建出待预测片段的二级结构。</li></ul><p>适用情况：</p><ul><li>该方法对数据库中同源序列的存在非常敏感。</li><li>若数据库中有相似性大于30%的序列，则预测准确率可大幅上升。</li></ul><h2 id="蛋白质三维空间结构预测">4.蛋白质三维空间结构预测</h2><ul><li>同源模型法</li><li>线索化方法</li><li>从头预测法</li></ul><h5 id="三种方法的比较">三种方法的比较：</h5><p>同源模型法需要得到一个好的序列比对。</p><ul><li>目标蛋白质序列与模板等同部分超过60%，则完全可以找到正确的比对；如果相似程度只有20%-25%，则很难找到正确的比对；如果相似度低于20%，无法应用同源模型化方法。<ul><li>同源模型法是预测结果最可靠的方法</li></ul></li></ul><p>线索化方法需要找到远程同源蛋白。</p><ul><li>如果能够找到同一家族的远程同源蛋白质，则可以获得比较好的预测结果；如果找到的模板属于不同的家族，则预测准确性难以保证。</li></ul><p>从头预测方法</p><ul><li>需要准确的能量函数和快速搜索策略。</li><li>通常难以产生准确的预测结构。</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>信息</tag>
      
      <tag>生物</tag>
      
      <tag>马尔可夫</tag>
      
      <tag>贝叶斯</tag>
      
      <tag>动态规划</tag>
      
      <tag>进化树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li><p><a href="https://www.bilibili.com/read/cv12633102/">hexo框架+部署到github</a></p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">前期准备的一些细节问题，这个是部署到gitee的</a>，我们要部署在github，这个只用来看一些细节</p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一些详细资料可以看这里</a></p></li></ul><hr><p>2023/6/7 22:49快要考试了，但是我还是想花点时间这里这个东西，等整理完这个，再去整理专业课程</p><hr><h1 id="一前期准备">一、前期准备</h1><h2 id="注意事项">1.注意事项</h2><ul><li><p>很多命令既可以用Windows的cmd来完成，也可以使用gitbash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用gitbash来执行</p></li><li><p>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</p></li><li><p>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</p></li></ul><h2 id="下载并安装node.js">2.下载并安装node.js</h2><p>Hexo 是基于Node.js 的博客框架，就像 Java 要依赖 JDK 环境一样。</p><ul><li>node下载地址：http://nodejs.cn/download/，傻瓜式安装，这里不再详述</li></ul><p><strong>NodeJS环境安装重点拓展：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 确认node.js安装成功：运行下面两个命令打印版本号即可</span><br>node -v<br>npm  -v<br><br><span class="hljs-comment"># 安装 Node.js 淘宝镜像加速器 （cnpm）</span><br>npm install -g cnpm <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 修改 node 类库默认安装位置</span><br><span class="hljs-comment"># 默认是在 C:\Users\lingStudy\AppData\Roaming\npm</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;D:\nodejs安装路径\node_global&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\nodejs安装路径\node_cache&quot;</span><br><span class="hljs-comment"># 查看修改是否成功</span><br>npm root -g<br><span class="hljs-comment"># 然后把D:\install\node\node_global配置到环境变量的 PATH 下即可</span><br><br></code></pre></td></tr></table></figure><h2 id="安装版本控制工具-git">3.安装版本控制工具 Git</h2><p>用来将本地项目托管到码云，所以还需要自己注册一个码云的账号。</p><p>下载地址：https://git-scm.com/download 学程序的，在工作中 Git是必知必会的，还没学的建议去看看，所以这里不再详细介绍 Git。</p><p>下面是部署到gitee（码云）上所需要的配置，我们<strong>不需要</strong>进行下面的步骤：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># Git一些重要配置</span><br>git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;lxxxxdy&quot;</span>  <span class="hljs-meta">#码云用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;xxx83@qq.com&quot;</span>   <span class="hljs-meta">#邮箱</span><br><br><span class="hljs-meta"># 生成SSH公钥并添加到码云，实现免密码登录</span><br><span class="hljs-meta"># 1、生成公钥</span><br>ssh-keygen -t rsa<br><span class="hljs-meta"># 2、进入 C:\Users\主机名\.ssh 目录，把 id_rsa.pub 里面的信息复制到码云的 SSH公钥 中即可</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo安装">4.Hexo安装</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 全局安装</span><br>npm install hexo-<span class="hljs-keyword">cli</span> -g<br><span class="hljs-meta"># 查看hexo版本</span><br>hexo -v<br></code></pre></td></tr></table></figure><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70-16861500587952.png"></p><h1 id="二配置github">二、配置github</h1><h2 id="在github上创建仓库">1.在github上创建仓库</h2><h3 id="创建">1.1 创建：</h3><ul><li><p>新建一个名为你的用户名.github.io的仓库。</p></li><li><p>比如说，如果你的github用户名是miqn，那么你就新建miqn.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是http://miqn.github.io了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p></li></ul><h3 id="注意">1.2 注意：</h3><ul><li><p>注册的邮箱一定要验证，否则不会成功；</p></li><li><p>仓库名字必须是：username.github.io，其中username是你的用户名；</p></li><li><p>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</p></li><li><p>创建页面如下：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ca3573693ec7d4b8f30b71b7f22a2003a9bac6e8.png@942w_675h_progressive-16861505570355.webp"></p></li></ul><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="绑定域名这步可省略">2.绑定域名（这步可省略）</h2><p>这里就不详细赘述了，想了解看相关资料。</p><h1 id="三配置ssh免密登录">三、配置SSH免密登录</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用sshkey来解决本地和服务器的连接问题。</p><ul><li><p>首先打开电脑文件夹，找到C:\86131 .ssh文件夹并删除 。</p></li><li><p>在C:\86131 文件夹下右键打开Git Bash Here输入命令：ssh-keygen -trsa -C github邮件地址生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8fb9a4ff9e0410bdbb1e4b89f34208ae2c6ecfd.jpg@942w_407h_progressive.webp"></p></li><li><p>最终生成了一个新的 C:\86131.ssh文件夹，打开这个文件夹，找到.ssh_rsa.pub文件，记事本打开并复制里面的内容。</p></li><li><p>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; NewSSHkey，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/cae65261511e4bf7e4ea0e7838a5bfc5f3560d20.png@942w_509h_progressive.webp"></p></li><li><p>检测是否设置成功：</p><p>输入命令： $ ssh -T git@github.com # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting(yes/no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You've successfully authenticated, but GitHub does notprovide shell access.</p><p>看到这个信息说明SSH已配置成功！</p></li><li><p>此时你还需要配置：</p><p>$ git config --global user.name "liuxianan"//你的github用户名，非昵称;</p><p>$ git config --global user.email "xxx@qq.com"//填写你的github注册邮箱。</p></li></ul><h1 id="四使用hexo搭建博客">四、使用hexo搭建博客</h1><h2 id="初始化">1.初始化</h2><p>第一步：在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是D:，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p>第二步：在D:Git Bash Here，输入hexo init 初始化</p><ul><li><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230607234808122.png"></p></li></ul><p>第三步：执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8d1a66cf00c3dfabb1bff69c531398ef0a33679.png@942w_56h_progressive.webp"></p><p>第四步：hexo s 是开启本地预览服务，打开浏览器访问http://localhost:4000即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">这篇文章</a></p><h2 id="将博客部署到-github-个人主页上">2.将博客部署到 github个人主页上</h2><p>第一步：在D:hexo-deployer-git 插件</p><ul><li><p>安装命令： npm install hexo-deployer-git --save</p></li><li><p>必须安装，否则执行hexo d 的话会报如下错误：</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f920d62b355a1a62bb9f6f37571edfb936fc03b2.png@815w_53h_progressive.webp"></p><p>第二步：编辑D:_config.yml 文件, 在文件末尾添加如下内容:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:miqn/miqn.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ul><li>注意：其中 repository 中的内容即为 github个人主页链接地址，具体看下图：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9cc1855324f9f968aa56d8a94a913475b3bc1d70.png@942w_437h_progressive.webp"></p><p>第三步：在D:，输入命令：hexo d 将本地 blog 推送到github仓库，也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问https://miqn.github.io/</li></ul><h1 id="五更换主题">五、更换主题</h1><h2 id="寻找主题">1.寻找主题</h2><ul><li><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</p></li><li><p>这是hexo官网：https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</p></li><li><p>在这里我使用github上一个大佬的主题blinkfox/hexo-theme-matery</p></li><li><p>链接：https://github.com/blinkfox/hexo-theme-matery</p></li></ul><h2 id="下载主题">2.下载主题</h2><p>第一步：Git Bash Here中先cd到D:</p><p>第二步：再输入命令 $ git clone 主题http链接 themes/主题名称</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/dc6cf704d5d468a2f02dcd044fc4a0b4daf78960.png@942w_507h_progressive.webp"></p><p>注意：</p><ul><li>D:theme文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/075cf0ecdb17fd480e0a705242cf9b6cf28510ee.png@942w_225h_progressive.webp"></p><h2 id="使用主题">3.使用主题</h2><ul><li><p>打开D:_config.yml文件，在里面找到theme: landscape改为theme:blinkfox （blinkfox为我们要使用的主题名）,然后重新执行hexog来重新生成。</p></li><li><p>如果出现一些莫名其妙的问题，可以先执行hexoclean来清理一下public的内容，然后再执行hexo g 和 hexo s重新生成和发布。</p></li><li><p>再次在浏览器中输入对应域名, 即可发现主题已更换。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/b122a24f4e848f12e98c105e30e57fdc770d6690.png@942w_251h_progressive.webp"></p><h2 id="修改主题内容">4.修改主题内容</h2><p>在这里我使用的是blinkfox主题，后期相关修改参考这个<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">主题文档</a></p><ul><li><p>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的。</p></li><li><p>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开GitBash Here，输入两个命令：hexo g 重新生成，hexo s开启本地预览服务,等修改的符合要求了，再输入 hexo d推送到github仓库即可。</p></li><li><p>这样就可以输入网址查看更改后的内容了。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/426b2c5a296d531dcae228493e6d63868179f132.png@942w_353h_progressive.webp"></p><p>文档上没有提及的修改：</p><ul><li>返回按钮样式修改：在主题下面的 blinkfox_partial 文件夹中的back-top.esj 文件中修改</li></ul><p>特别注意：</p><ul><li>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的_config.yml文件</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/312648b8eabe0b58395774e2742277f9690a94c6.png@942w_288h_progressive.webp"></p><ul><li>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9545db7dea8f6d676b15ebe2d5542fec221d22ca.png@942w_191h_progressive.webp"></p><h2 id="blinkfox主题的相关配置问题">5.blinkfox主题的相关配置问题</h2><p>配置音乐播放器：使用网易云音乐id不行，这里用的是QQ音乐</p><p>配置留言功能（利用Valine）：</p><ul><li><p>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</p></li><li><p>注册完以后需要创建一个应用，名字可以随便起，然后进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的_config.yml 文件里面搜索 valine，填入appid 和 appkey</p></li><li><p>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web安全域名 把你的域名加进去就可以了</p></li><li><p>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs文件里面更改</p></li></ul><h1 id="六利用typora软件来写博客">六、利用Typora软件来写博客</h1><h2 id="typora介绍">1.Typora介绍</h2><ul><li><p>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</p></li><li><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</p></li><li><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></p></li></ul><h2 id="安装typora">2.安装Typora</h2><p><a href="https://www.typora.io/#windows">Typora官网</a></p><h2 id="写博客的步骤">3.写博客的步骤</h2><p>先创建一个md文档，使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文档名&quot;</span><br></code></pre></td></tr></table></figure><p>用这个命令的好处是帮我们自动生成了时间，默认生成如下内容</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230608101831956.png"></p><p>如果没有这个内容，右键点击插入，再点击YAML Front Matter。</p><p>想要将个人博客同步到网站上，使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>清理缓存，接着使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>生成静态资源文件，此时可以使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>启动本地预览本地是否成功，若需要同步远端则使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>部署到服务器github。</p><p>补充：hexo new page 'postName'命令和hexo new 'postName'的区别？</p><ul><li>hexo new page'My-second-blog'最终部署时生成：hexo-second-blog.html，但是它不会作为文章出现在博文目录。</li></ul><h2 id="所使用的主题的文章-front-matter-语法">4.所使用的主题的文章Front-matter 语法</h2><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是blinkfox 主题，打开<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">blinkfox主题文档</a>，往下翻找到"文章 Front-matter 介绍 "即可。</p><h1 id="七如何向hexo博客中插入图片">七、如何向hexo博客中插入图片</h1><h2 id="前言">1.前言</h2><p>Hexo是个静态博客程序，使用markdown语法。而Typero是个编辑预览于一身的md编辑器。</p><p>在Typero写文章时候，如果能复制网络图片，或者是截图粘贴到Typero，并且可以<strong>直接在网站上查看该图片</strong>，这样是非常方便的。</p><h2 id="修改hexo">2.修改Hexo</h2><p>首先确认站点配置文件 _config.yml 中有 post_asset_folder:true这个需要去手动修改</p><p>接着打开git bash，在 hexo 站点目录，执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这样每次新建一篇文章，hexo同时会创建一个与文章名同名的文件夹，用来放图片。</p><h2 id="修改typora">3.修改Typora</h2><p>文件-&gt;偏好设置，下拉找到 <strong>图片插入</strong></p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5cdaf60e1fda7a3b8fb67be354a35485.png">sho</p><p>修改成上图的样子。填这个 <code>./$&#123;filename&#125;/</code></p><h1 id="八常见问题汇总">八、常见问题汇总</h1><h2 id="spawn-failed">1.spawn failed</h2><ul><li><a href="https://blog.csdn.net/m0_73820275/article/details/132088528">Hexo部署博客时出现spawnfailed问题解决方法</a></li><li><a href="https://www.cnblogs.com/Lutheran/p/15915295.html">github连接报"ssh:connect to host github.com port 22: Connection timed out"错误</a></li></ul><p>首先我通过查阅资料，试了先把目录下的.deploy_git目录删除，然后使用命令<code>git config --global core.autocrlf false</code>取消git网络代理，接着依次使用hexoclean/g/d的方法，发现问题依旧没有解决，但我看我没试把.deploy_git目录和public都删除，下次可以试一试。</p><p>但是通过查阅资料，我知道了问题出在我执行hexod时在访问github时出现了问题，所以我就追溯到安装时候的第三步即配置SSH免密登录，我输入<code>ssh -T git@github.com</code>命令时，出现了<code>ssh: connect to host github.com port 22: Connection timed out</code>的错误，通过查阅资料，我找到了解决办法。</p><p>在存放公钥私钥(id_rsa和id_rsa.pub)的文件里，新建config文本，内容如下：</p><p>第一步：打开终端并打开存放ssh的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>查看是否存在这些文件若不存在，则可能是ssh没配置对，首先需要配置ssh（看上面第三步）很简单若存在则在继续在终端输入以下命令新建一个文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vim config<br></code></pre></td></tr></table></figure><p>接着输入下面内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">注册github</span>的邮箱<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>最后:wq退出编辑即可 接着再执行</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>出现提示回车yes即可</p><p>验证就能顺利通过了，后面我再进行hexo d就能正常运行了。</p><h2 id="pandoc-exited-with-code-null">2.pandoc exited with codenull</h2><p><strong>1.使用Mathjax作为渲染器</strong> 使用 Mathjax进行数学公式渲染，需要使用 hexo-renderer-pandoc 或者hexo-renderer-kramed （官方不推荐）作为 Hexo 的 Markdown 渲染器。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> un hexo-renderer-marked  <span class="hljs-comment"># 先将原有的渲染器卸载</span><br><span class="hljs-built_in">npm</span> i hexo-renderer-pandoc<span class="hljs-comment"># 安装pandoc</span><br></code></pre></td></tr></table></figure><p><strong>2.本地安装pandoc</strong></p><p>使用pandoc还需要在本地安装，从 <a href="https://pandoc.org/installing.html">Pandoc 官网</a>下载并安装。直接安装即可，安装后重启。</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融领域问题匹配</title>
    <link href="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲：</h1><ul><li>任务描述</li><li>数据集介绍</li><li>代码实现——CNN</li><li>代码实现——BERT</li></ul><hr><h1 id="任务描述">任务描述</h1><p>本次任务是金融领域问题匹配。 即针对中文银行领域数据中的问句对，判定两个句子语义是否相同或者相近。</p><p>举例： &gt; Eg1:<br>&gt; Q1： “看图猜一电影名”<br>&gt; Q2： “看图猜电影”<br>&gt; Label：1</p><blockquote><p>Eg2:<br>Q1： “无线路由器怎么无线上网”<br>Q2： “无线上网卡和无线路由器怎么用”<br>Label：0</p></blockquote><p>label表示问句之间的语义是否相同。<br>若相同则标为1， 若不相同则标为0.</p><p><strong>要求：</strong><strong>基于示例CNN及BERT代码（或自行设计算法），实现在测试集上语义相似度判断任务（要包含F1值）</strong><br><strong>另外：</strong><strong>示例代码仅供参考，给出的参数仅仅是稍微试过的，而没经过精细化调参。</strong></p><hr><h1 id="数据集介绍">数据集介绍</h1><p>本次数据集是节选自节选自千言提供的BQ金融领域问题匹配数据集，格式为json文件。<br>数据存放位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/data/</span><br></code></pre></td></tr></table></figure><p>数据集概况如下：</p><table><thead><tr><th style="text-align: left;">名称</th><th>数量</th><th>标签</th></tr></thead><tbody><tr><td style="text-align: left;">train.json</td><td>90000</td><td>有</td></tr><tr><td style="text-align: left;">dev.json</td><td>10000</td><td>有</td></tr><tr><td style="text-align: left;">test.json</td><td>10000</td><td>有</td></tr></tbody></table><h1 id="一代码实现cnn">一、代码实现——CNN</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>CNN<br></code></pre></td></tr></table></figure><h2 id="读取数据集">1.读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">data_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    区分训练/验证/测试集</span><br><span class="hljs-string">    @param data_path: 数据json文件存放位置</span><br><span class="hljs-string">    @return: 训练/验证/测试集</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_path) <span class="hljs-keyword">as</span> f:<br>        data = json.load(f)<br><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>同学们直接打开json文件观察数据集看到的应该是ascii码，这和数据的写入方式有关。</p><h2 id="数据预处理">2.数据预处理</h2><p>一般来说，基于CNN的文本语义相似度任务需要如下预处理过程： -将原始文本分词并转换成以词的序列</p><ul><li><p>将词序列转换成以词编号（每个词表中的词都有唯一编号）为元素的序列</p></li><li><p>将词的编号序列中的每个元素（某个词）展开为词向量的形式。<br><strong>注意：转成词向量需要借助已经建立好的映射，文件太大就没有放进压缩包了。请大家自行下载网址：<a href="https://pan.baidu.com/s/1ZKePwxwsDdzNrfkc6WKdGQ">百度网盘</a> OR<a href="https://www.aliyundrive.com/s/5cCC1KXqft8">阿里云盘</a></strong><br><strong>下载之后放哪儿？这个无关紧要，只要把hyp.py中的<code>embed_path</code>修改成存放位置即可</strong></p><blockquote><p>注意记得把“[]”去掉。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># data_preprocess.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_sentences</span>(<span class="hljs-params">dataset, vocab, is_train, <span class="hljs-built_in">repr</span>=<span class="hljs-string">&#x27;word&#x27;</span>, test_vocab=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将输入转换为id，创建词表</span><br><span class="hljs-string">    参数pred_mode作用是控制是否返回标签</span><br><span class="hljs-string">    因为和gen_data共用一个函数，因此需要根据试验集合调整返回的参数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 数据读取</span><br>    question_1, question_2 = [], []<br>    max_len_1, max_len_2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    punc = punctuation + <span class="hljs-string">u&#x27;1-9.,;《》？！“”‘’@#￥%…&amp;×（）——+【】&#123;&#125;;；●，。&amp;～、|\s: &#x27;</span><br><br>    seq1 = []<br>    seq2 = []<br>    label = []<br><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataset:<br>        seq1.append(data[<span class="hljs-string">&#x27;q1&#x27;</span>])<br>        seq2.append(data[<span class="hljs-string">&#x27;q2&#x27;</span>])<br>        label.append(<span class="hljs-built_in">int</span>(data[<span class="hljs-string">&#x27;label&#x27;</span>]))<br><br>    <span class="hljs-comment"># 数据清洗</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(label)):<br>        <span class="hljs-keyword">if</span> label[i] &gt; <span class="hljs-number">0</span>:<br>            label[i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            label[i] = <span class="hljs-number">0</span><br><br><br>    <span class="hljs-comment"># 对每对问句处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(seq1)):<br>        seq1[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq1[i])<br>        seq2[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq2[i])<br><br>        <span class="hljs-comment"># 将问句分成一个个token</span><br>        q1_tokens = split_sent(seq1[i], <span class="hljs-built_in">repr</span>)<br>        q2_tokens = split_sent(seq2[i], <span class="hljs-built_in">repr</span>)<br><br>        <span class="hljs-comment"># 获取句子最长度</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q1_tokens) &gt; max_len_1:<br>            max_len_1 = <span class="hljs-built_in">len</span>(q1_tokens)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q2_tokens) &gt; max_len_2:<br>            max_len_2 = <span class="hljs-built_in">len</span>(q2_tokens)<br><br>        token_id1, token_id2 = [], []<br><br>        <span class="hljs-comment"># 对单个问句中的每个token进行处理</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q1_tokens:<br>            <span class="hljs-comment"># repr = &#x27;word&#x27;</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    <span class="hljs-comment"># 如果在训练集，就注册词库</span><br>                    <span class="hljs-comment"># eg: vocab[&#x27;word&#x27;][&#x27;我&#x27;] = 10</span><br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    <span class="hljs-comment"># 如果不是在训练集，且未在测试词库注册，则注册</span><br>                    <span class="hljs-comment"># eg&quot; test_vocab[&#x27;word&#x27;][&#x27;注册&#x27;] = 1000</span><br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-comment"># 如果这个token在词库注册了，那么就把对应的键值塞入列表</span><br>                token_id1.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id1.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id1.append(OOV_WORD_INDEX)<br>        <span class="hljs-comment"># print(&quot;-----&quot;, token_id1)</span><br>        question_1.append(token_id1)<br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q2_tokens:<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                token_id2.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id2.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id2.append(OOV_WORD_INDEX)<br>        question_2.append(token_id2)<br><br>    <span class="hljs-keyword">return</span> question_1, question_2, max_len_1, max_len_2, label<br><br><br></code></pre></td></tr></table></figure></p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">train_vocab_emb, test_vocab_emb = construct_vocab_emb(<span class="hljs-string">&quot;./experimental-data&quot;</span>, vocab[<span class="hljs-string">&#x27;word&#x27;</span>], test_vocab[<span class="hljs-string">&#x27;word&#x27;</span>], <span class="hljs-number">300</span>,<br>                                                      base_embed_path=embed_path)<br></code></pre></td></tr></table></figure><h2 id="参数设置">3.参数设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># hyp.py</span><br>hyp = &#123;<br>    <span class="hljs-string">&#x27;embed_path&#x27;</span>: <span class="hljs-string">&#x27;[Your &quot;sgns.wiki.bigram&quot; path]&#x27;</span>, <span class="hljs-comment"># 记得修改位置</span><br>    <span class="hljs-string">&#x27;data_path&#x27;</span>: <span class="hljs-string">&#x27;../../data&#x27;</span>,<br>    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;nb_filters&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;dropout_rate&#x27;</span>: <span class="hljs-number">0.3</span>,<br>    <span class="hljs-string">&#x27;embed_size&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.05</span>,<br>    <span class="hljs-string">&#x27;epoches&#x27;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">&#x27;save_model_name&#x27;</span>: <span class="hljs-string">&quot;checkpoint_textCNN.pt&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="网络模型">4.网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">creat_model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, batch_size, vocab_size, embedding_matrix,</span><br><span class="hljs-params">                 nb_filters, embed_size=<span class="hljs-number">300</span>, dropout_rate=<span class="hljs-number">0.5</span>, num_classes=<span class="hljs-number">2</span>,</span><br><span class="hljs-params">                 kernel_dim=<span class="hljs-number">100</span>, kernel_sizes=(<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>)</span>):<br>        <span class="hljs-built_in">super</span>(creat_model, self).__init__()<br>        self.batch_size = batch_size<br>        self.dropout_rate = dropout_rate<br>        self.embedding_matrix = embedding_matrix<br>        self.vocab_size = vocab_size<br>        self.embed_size = embed_size<br>        self.nb_filters = nb_filters<br>        self.kernel_dim = kernel_dim<br>        self.kernel_sizes = kernel_sizes<br>        self.num_class = num_classes<br>        <span class="hljs-comment"># 词嵌入层</span><br>        self.embedding_layer = self.add_embed_layer(self.embedding_matrix, <br>                                                    self.vocab_size[<span class="hljs-string">&#x27;word&#x27;</span>], self.embed_size)<br>        <span class="hljs-comment"># CNN编码层</span><br>        self.convs = nn.ModuleList([nn.Conv2d(<span class="hljs-number">1</span>, kernel_dim, (k, self.embed_size)) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> kernel_sizes])<br>        <span class="hljs-comment"># 输出分类层</span><br>        self.dropout_layer = nn.Dropout(self.dropout_rate)<br>        self.fc = nn.Linear(<span class="hljs-built_in">len</span>(kernel_sizes) * kernel_dim * <span class="hljs-number">2</span>, num_classes)<br>        nn.init.xavier_uniform_(self.fc.weight.data, gain=<span class="hljs-number">1</span>)<br>        nn.init.constant_(self.fc.bias.data, <span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_embed_layer</span>(<span class="hljs-params">self, vocab_emb, vocab_size, embed_size</span>):<br>        <span class="hljs-keyword">if</span> vocab_emb <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 预训练词向量</span><br>            embed_layer = nn.Embedding(vocab_size, embed_size)<br>            pretrained_weight = np.array(vocab_emb)<br>            embed_layer.weight.data.copy_(torch.from_numpy(pretrained_weight))<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> embed_layer.parameters():<br>                p.requires_grad = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 随机初始化</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Embedding with random weights&quot;</span>)<br>            embed_layer = nn.Embedding(num_embeddings=vocab_size, embedding_dim=embed_size)<br>        <span class="hljs-keyword">return</span> embed_layer<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, query_word_input, doc_word_input</span>):<br>        <span class="hljs-comment"># 这里对视频中的代码做了修改，使用了多个并行的卷积</span><br>        <span class="hljs-comment"># 经过词嵌入层，获得词向量</span><br>        query_word_emb = self.embedding_layer(query_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        doc_word_emb = self.embedding_layer(doc_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(query_word_emb.size())</span><br>        <span class="hljs-comment"># [batch_size, 1, seq_len, embedding_dim]</span><br>        <span class="hljs-comment"># 经过卷积层，和最大池化层</span><br>        query_word_emb = [F.relu(conv(query_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        query_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> query_word_emb]<br>        doc_word_emb = [F.relu(conv(doc_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        doc_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> doc_word_emb]<br>        <span class="hljs-comment"># 拼接不同卷积层的特征</span><br>        query_concated = torch.cat(query_word_emb, <span class="hljs-number">1</span>)<br>        query_concated = self.dropout_layer(query_concated)<br>        doc_concated = torch.cat(doc_word_emb, <span class="hljs-number">1</span>)<br>        doc_concated = self.dropout_layer(doc_concated)<br>        <span class="hljs-comment"># 拼接query和doc</span><br>        concated = torch.cat([query_concated, doc_concated], dim=-<span class="hljs-number">1</span>)<br>        prediction = self.fc(concated)<br>        <span class="hljs-keyword">return</span> prediction<br></code></pre></td></tr></table></figure><h2 id="训练过程">5.训练过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train_CNN.py</span><br>    <span class="hljs-comment"># ===================== TRAIN Model ======================</span><br>    <span class="hljs-comment"># ### 定义模型 ###</span><br>    model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>    model = model.to(device)<br>    <span class="hljs-comment"># 定义优化器</span><br>    opt = torch.optim.SGD(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> p: p.requires_grad, model.parameters()), lr=learning_rate,<br>                          weight_decay=<span class="hljs-number">1e-6</span>, momentum=<span class="hljs-number">0.9</span>, nesterov=<span class="hljs-literal">True</span>)<br>    lr_reducer = ReduceLROnPlateau(optimizer=opt, verbose=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use SGD optimizer&quot;</span>)<br>    <span class="hljs-comment"># 定义损失函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;compile model with binary_crossentropy&quot;</span>)<br>    criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>    criterion.to(device)<br><br>    <span class="hljs-keyword">try</span>:<br>        total_start_time = time.time()<br>        best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        best_auc = <span class="hljs-literal">None</span><br>        best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        train_auc_list, valid_auc_list = [], []<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>            epoch_start_time = time.time()<br>            <span class="hljs-comment"># 训练</span><br>            train_loss, train_fpr, train_tpr, train_auc = train_fc(model, train_dataset, train_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, opt, criterion)<br>            train_auc_list.append(train_auc)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|start of epoch&#123;:3d&#125; | time : &#123;:2.2f&#125;s | loss &#123;:5.6f&#125; | train_auc &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                time.time() - epoch_start_time,<br>                                                                                                train_loss, train_auc))<br>            <span class="hljs-comment"># 验证集上验证性能</span><br>            val_loss, val_fpr, val_tpr, val_auc, val_f1 = validate(model, valid_dataset, valid_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, criterion)<br>            valid_auc_list.append(val_auc)<br>            lr_reducer.step(val_loss)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;| end of epoch &#123;:3d&#125;| time: &#123;:2.2f&#125;s | loss: &#123;:.4f&#125; |valid_auc &#123;&#125; |valid_f1 &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                          time.time() - epoch_start_time,<br>                                                                                                          val_loss,<br>                                                                                                          val_auc,<br>                                                                                                          val_f1))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> best_auc <span class="hljs-keyword">or</span> best_auc &lt; val_auc:<br>                best_auc = val_auc<br>                best_fpr = val_fpr<br>                best_tpr = val_tpr<br>                model_state_dict = model.state_dict()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save the best model... best_auc: %s&quot;</span> % best_auc)<br>                model_weight = hyp[<span class="hljs-string">&#x27;save_model_name&#x27;</span>]<br>                torch.save(model_state_dict, model_weight)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(train_auc_list)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;valid_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(valid_auc_list)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exiting from training early | cost time: &#123;:5.2f&#125;min&quot;</span>.<span class="hljs-built_in">format</span>((time.time() - total_start_time) / <span class="hljs-number">60.0</span>))<br><br><br></code></pre></td></tr></table></figure><h2 id="测试过程">6.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># =================== Test model =====================</span><br>criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>criterion.to(device)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;load best model ... &quot;</span>)<br><span class="hljs-comment"># 定义一个新的模型</span><br>new_model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>new_model = new_model.to(device)<br><span class="hljs-comment"># 加载最佳模型的参数赋给新建模型</span><br><span class="hljs-comment"># model_weight = &quot;checkpoint_textCNN.pt&quot;</span><br>new_model.load_state_dict(torch.load(model_weight), strict=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(model_weight)<br><span class="hljs-comment"># 测试集测试</span><br>test_loss, test_fpr, test_tpr, test_auc, test_f1 = validate(new_model, test_dataset, test_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>], \<br>                                                            batch_size, criterion)<br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_loss:&quot;</span>, test_loss)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_auc:&quot;</span>, test_auc)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test_f1:&#x27;</span>, test_f1)<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><p>训练： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train_CNN.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure> 测试： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python test_CNN.py<br></code></pre></td></tr></table></figure></p><hr><h1 id="二代码实现bert">二、代码实现——BERT</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>BERT<br></code></pre></td></tr></table></figure><h2 id="bert介绍">1.BERT介绍</h2><p>BERT的全称为Bidirectional Encoder Representation fromTransformers，是一个预训练的语言表征模型，一经问世便火爆了NLP圈子，在 11项自然语言处理任务中均表现出惊人的成绩。</p><figure><img src="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/image-20230604002542014.png" alt="&#39;BERT模型图&#39;"><figcaption aria-hidden="true">'BERT模型图'</figcaption></figure><p>然而，原始的BERT参数量较大，对算力有一定的要求。为此，我们在<a href="https://huggingface.co">HuggingFace</a>的模型仓库中找了一个BERT-Tiny让大家体验它的工作流程。<strong>预训练模型的下载地址在这儿：<a href="https://pan.baidu.com/s/1wlSJL7l3koc6XUsrt9bTsg?pwd=igjr">百度网盘</a>OR <a href="https://www.aliyundrive.com/s/rmHMPzyECto">阿里云盘</a></strong></p><p><strong>下载之后放哪儿？这个无关紧要，只要把hyp.py中的<code>pretrained_dir</code>修改成存放位置即可</strong></p><p>在本实验中，我们将两个句子拼接后输入BERT，并用BERT的<code>[CLS]</code>token进行两个句子的类别预测工作。</p><h2 id="数据预处理-1">2.数据预处理</h2><p>和CNN中的预处理类似，我们需要将输入文本转换为词向量，才能输入到模型中。但是这些步骤可以利用HuggingFace的库函数实现。这边我们给了一个demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizerFast, BertModel<br><br>pretrained_dir = <span class="hljs-string">&#x27;./pretrained_model/bert-tiny&#x27;</span><br><br>tokenizer = BertTokenizerFast.from_pretrained(pretrained_dir)<br><br>test_word = [(<span class="hljs-string">&#x27;我来自人工智能学院&#x27;</span>,<span class="hljs-string">&#x27;我在学web搜索技术&#x27;</span>), (<span class="hljs-string">&#x27;天气真好&#x27;</span>,<span class="hljs-string">&#x27;我很高兴&#x27;</span>)]<br><br>encoded_word = tokenizer(test_word, padding=<span class="hljs-string">&#x27;longest&#x27;</span>, max_length=<span class="hljs-number">32</span>)<br><span class="hljs-built_in">print</span>(encoded_word)<br><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: <br>[[<span class="hljs-number">101</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">3341</span>, <span class="hljs-number">5632</span>, <span class="hljs-number">782</span>, <span class="hljs-number">2339</span>, <span class="hljs-number">3255</span>, <span class="hljs-number">5543</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">7368</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">1762</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">8353</span>, <span class="hljs-number">3017</span>, <span class="hljs-number">5164</span>, <span class="hljs-number">2825</span>, <span class="hljs-number">3318</span>, <span class="hljs-number">102</span>],<br> [<span class="hljs-number">101</span>, <span class="hljs-number">1921</span>, <span class="hljs-number">3698</span>, <span class="hljs-number">4696</span>, <span class="hljs-number">1962</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">2523</span>, <span class="hljs-number">7770</span>, <span class="hljs-number">1069</span>, <span class="hljs-number">102</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br> <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: <br> [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br>  <span class="hljs-string">&#x27;attention_mask&#x27;</span>: <br>  [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]&#125;<br></code></pre></td></tr></table></figure><p>其中<code>input_ids</code>表示的是输入词编号，<code>token_type_ids</code>表示token对应的句子id，第一句为0，第二句为1。<code>attention_mask</code>表示输入句子的mask，1表示原始token，0表示paddingtoken。由于输入的句子长度不一样，我们可以控制<code>padding</code>统一将所有输入句子的编码结果用0补齐至与最长句子一致。</p><h2 id="模型结构">3.模型结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERT_Tiny</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, pretrained_dir</span>):<br>        <span class="hljs-built_in">super</span>(BERT_Tiny, self).__init__()<br>        self.bert = BertModel.from_pretrained(pretrained_dir)<br>        self.drooput = nn.Dropout()<br>        self.linear = nn.Linear(<span class="hljs-number">312</span>, <span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids, token_type_ids, attention_mask</span>):<br><br>        outputs = self.bert(input_ids = input_ids, token_type_ids = token_type_ids, attention_mask = attention_mask)<br>        pooled_output = outputs[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 取出[cls]作为两个句子的分类表征</span><br>        <span class="hljs-keyword">return</span> self.linear(self.drooput(pooled_output))<br><br></code></pre></td></tr></table></figure><h2 id="训练过程-1">4.训练过程</h2><p><strong>训练损失和f1值不会在控制台打印，而是会以txt文档的形式保存在训练目录下，请同学们自行翻阅日志</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Training ==============================</span><br><br>best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>best_auc = <span class="hljs-literal">None</span><br>best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>train_auc_list, valid_auc_list = [], []<br>logger.info(<span class="hljs-string">&#x27;========= Training ===========&#x27;</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(epochs, desc=<span class="hljs-string">&#x27;Epoch&#x27;</span>):<br>  epoch += <span class="hljs-number">1</span><br>  logger.info(<span class="hljs-string">f&#x27;=========== Epoch<span class="hljs-subst">&#123;epoch&#125;</span> ==========&#x27;</span>)<br>  model.train()<br>  train_loss = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> iteration, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tqdm(train_loader, desc=<span class="hljs-string">&#x27;Iteration&#x27;</span>)):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    optimizer.zero_grad()<br>    loss = criterion(output, labels)<br>    loss.backward()<br><br>    <span class="hljs-comment"># for name, parms in model.named_parameters():</span><br>    <span class="hljs-comment">#     logger.info(f&#x27;--&gt;name: &#123;name&#125; --&gt;grad_requirs: &#123;parms.requires_grad&#125; --&gt;grad_value: &#123;parms.grad&#125;&#x27;)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> iteration % <span class="hljs-number">100</span>:<br>      logger.info(<span class="hljs-string">f&#x27;- batch: <span class="hljs-subst">&#123;iteration&#125;</span> loss: <span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>      train_loss += loss.item()<br>      optimizer.step()<br><br>      num_batches = <span class="hljs-built_in">len</span>(train_data) / batch_size<br>      batch_loss = train_loss / num_batches<br>      logger.info(<span class="hljs-string">f&#x27;train_loss: <span class="hljs-subst">&#123;batch_loss:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br><br>      logger.info(<span class="hljs-string">&#x27;=========== Evaluating on dev set ==========&#x27;</span>)<br>      model.<span class="hljs-built_in">eval</span>()<br>      y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>      corrects = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(dev_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>          input_ids, token_type_ids, attention_mask, labels = batch<br>          output = model(input_ids, token_type_ids, attention_mask)<br><br>          pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>          corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>          pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>          label = labels.data.cpu().numpy()<br><br>          <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            y_true = label<br>            y_pred = pred_label<br>            <span class="hljs-keyword">else</span>:<br>              y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>              y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>              r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>              auc = roc_auc_score(y_true, y_pred)<br>              logger.info(corrects)<br>              logger.info(thresh)<br>              acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(dev_data)<br>              logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>              <span class="hljs-keyword">if</span> best_f1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> f1 &gt; best_f1:<br>                best_f1 = f1<br>                logger.info(<span class="hljs-string">f&#x27;Get best dev model at epoch <span class="hljs-subst">&#123;epoch&#125;</span>, f1 <span class="hljs-subst">&#123;f1&#125;</span>&#x27;</span>)<br>                torch.save(model.state_dict(), save_model_name)<br><br></code></pre></td></tr></table></figure><h2 id="测试过程-1">5.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Load model ============================</span><br>logger.info(<span class="hljs-string">&#x27;============= Loading model ==============&#x27;</span>)<br>model = BERT_Tiny(pretrained_dir=pretrained_dir)<br>model.load_state_dict(torch.load(save_model_name))<br>model.to(device)<br><br>criterion = nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>logger.info(<span class="hljs-string">&#x27;=========== Testing on test set ==========&#x27;</span>)<br>model.<span class="hljs-built_in">eval</span>()<br>y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>corrects = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>  <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(test_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>    corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>    pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>    label = labels.data.cpu().numpy()<br><br>    <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>      y_true = label<br>      y_pred = pred_label<br>      <span class="hljs-keyword">else</span>:<br>        y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>        y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>        r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>        auc = roc_auc_score(y_true, y_pred)<br>        acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(test_data)<br>        logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="使用-1">使用</h4><p>训练：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> test.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>项目</tag>
      
      <tag>Web搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于文本和图像的多媒体检索系统</title>
    <link href="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料</p></blockquote><ul><li><a href="http://www.zzvips.com/article/214469.html">在pycharm中配置pyqt5</a></li></ul><hr><p>2023/6/2 22:44这是我基于《多媒体信息检索课程设计》所作的一个项目，涉及到了计算机视觉方面的知识，主要用到了BOW模型。代码语言为python，运行环境为pycharm。废话不多说，开始操作。</p><hr><h1 id="一所需安装的软件及库">一、所需安装的软件及库</h1><h2 id="anaconda及pycharm的安装">1.Anaconda及pycharm的安装</h2><p>详情见多媒体信息检索实验指导（一）。</p><h2 id="jieba的安装">2.jieba的安装</h2><h3 id="全自动安装">2.1 全自动安装</h3><p>在pycharm终端或cmd输入：</p><p><code>pip install jieba / pip3 install jieba</code></p><h3 id="pycharm安装">2.2 pycharm安装</h3><p>依次点击 文件-设置-项目-解释器-“加号”，接着搜索需要的库并添加。</p><h3 id="手动安装">2.3 手动安装：</h3><p>将 jieba 的整个目录放置于python的site-packages 目录中。</p><h2 id="在pycharm中配置pyqt5">3.在pycharm中配置pyqt5</h2><h3 id="pyqt5简介">3.1 PyQt5简介</h3><p>1.什么是<a href="http://www.zzvips.com/article/106394.html">GUI</a>：Graphical UserInterface，图形用户界面，用于人机交互。</p><p>2.怎么设计GUI：Qt。</p><p>3.什么是Qt：Qt是一种基于C++的跨平台图形用户界面应用程序开发框架。</p><p>4.学习python的我们怎么用Qt：PyQt5模块。</p><p>5.什么是PyQt5:Qt的python接口，pyqt5对Qt进行完全封装，我们可以利用python代码设计想要的图形界面。</p><h3 id="安装pyqt5模块">3.2 安装PyQt5模块</h3><p>(包括pyqt5,pyqt5-tools,pyqt5designer）</p><p>依次点击 文件-设置-项目-解释器-“加号” 来添加。</p><h3 id="配置pyqt5设计器qt-designer及转换工具">3.3 配置PyQt5设计器（QtDesigner）及转换工具</h3><h4 id="qt-designer">(1)Qt Designer</h4><p>用途：方便我们打开设计器。</p><p>首先同样是在file里面打开settings：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046403193-6.png"></p><p>Name：我们自己给这个tool起的名字。</p><p>Program：填入designer.exe的路径，每个人路径不同，找到自己计算机上的路径输进去。一般来说是在D:-packages.exe这里。</p><p>Working directory:填入$ProjectFileDir$，表示文件所在的项目路径。</p><h4 id="pyuic">(2)PyUIC</h4><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046402509-7.png"></p><p>Name:自己起的名字。</p><p>Program:python.exe所在的位置，一般在D:.exe这里。</p><p>Arguements:填入-m PyQt5.uic.pyuic $FileName$ -o$FileNameWithoutExtension$.py 是将.ui文件转化成.py文件的语句。</p><p>Working directory:$FileDir$,表示文件所在路径。</p><h2 id="pcv包的安装">4.PCV包的安装</h2><p>1.下载PCV包：https://codeload.github.com/Li-Shu14/PCV/zip/master；</p><p>2.打开Anaconda3的prompt窗口，切换到下载好的PCV包所在的路径下；</p><p>3.执行以下命令：</p><p><code>pip install PCV-master.zip</code></p><blockquote><p><strong>注：</strong> 压缩包不用解压，直接pip install即可。</p></blockquote><h2 id="vlfeat包安装">5.vlfeat包安装</h2><p>1.下载安装vlfeat包，版本0.9.20官方下载连接：http://www.vlfeat.org/download/（注意要下载20版本，不然会出现找不到.sift文件）</p><p>2.下载完成过后，把vlfeat里win64里的vl.dll和sift.exe和vl.lib复制粘贴到项目目录下：这样子环境配置基本上已完成。</p><blockquote><p><strong>注：</strong>vlfeat0.9.21版本太高导致部分电脑提取特征为空，要用9.20版本。</p></blockquote><h2 id="pysqlite3库安装">6.pysqlite3库安装</h2><ul><li><p>访问 https://www.sqlite.org/download.html 页面，下载 Windows 版SQLite 预编译二进制文件。</p><p>注意要下载与你 Python 版本和操作系统位数（32 位或 64位）对应的版本。</p></li><li><p>解压缩下载的 SQLite 文件。</p><p>在解压后的文件夹中，你将看到一些静态库和工具，以及一个名为sqlite3.dll 的共享库文件。这个文件是 <code>pysqlite3</code> 包所依赖的SQLite 动态链接库。</p></li><li><p>访问 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pysqlite页面，找到 <code>pysqlite3</code> 的适用于你的 Python版本和操作系统位数的安装包并下载。</p><p>下载后的文件名一般是这样的：<code>pysqlite3-x.x.x-cpXX-cpXXm-win_amd64.whl</code>，其中<code>x.x.x</code> 是版本号，<code>cpXX</code> 是 Python主版本和次版本号，例如 <code>cp39</code> 代表 Python3.9，<code>win_amd64</code> 表示 64 位 Windows 平台。</p></li><li><p>在命令提示符中使用 pip 安装刚才下载的 <code>pysqlite3</code>安装包。</p><p>进入 <code>pysqlite3</code> 安装包所在的目录，然后运行以下命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">`Copy Codepip install pysqlite<span class="hljs-number">3</span>-<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>-cpXX-cpXXm-win_amd<span class="hljs-number">64</span>.whl`<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>如果你 Python 版本为 32 位，请下载适用于 32 位 Python的安装包，并将含有 <code>win_amd64</code> 的部分替换为<code>win32</code> 即可。</p><p>pysqlite3这个库下载比较麻烦，下载之后需要重新编译python，并且要注意pycharm中的编译环境最好设置为python所在的python.exe这个环境，否则之前安装的一些库会不在列表中。</p><p>也要注意python3版本使用的是sqlite3这个库，尽管编辑器报错的时候会提醒一个跟pysqlite2有关的错误，最后解决的方法是同时更换文件中和PCV中imagesearch.py的import，尝试更改那里即可成功。</p></blockquote><h1 id="二文本检索部分算法说明">二、文本检索部分算法说明</h1><h2 id="文本爬取">1.文本爬取</h2><p>我对https://www.8lrc.com/网站的经典歌词进行了爬取，并将爬取到的歌词，用’lyrics’+歌名+歌手的命名方式，以记事本的文件类型保存在了当前文件夹里。并将标题与歌词的对应关系进行了保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lyrics_urls</span>():<br>    titles = []  <span class="hljs-comment"># 用于保存标题</span><br>    urls = []  <span class="hljs-comment"># 用于保存每首歌的链接</span><br>    qianzhui = <span class="hljs-string">&#x27;https://www.8lrc.com/&#x27;</span>  <span class="hljs-comment"># 爬取网站</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):  <span class="hljs-comment"># 共49页</span><br>        link = <span class="hljs-string">&#x27;https://www.8lrc.com/jingdian/32/&#x27;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27;.htm&#x27;</span>  <span class="hljs-comment"># 每页链接</span><br>        req = requests.get(link)    <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取排行榜中的30首歌信息</span><br>        lrcList = soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&#x27;lrcList&#x27;</span>)<br>        lrcList = BeautifulSoup(<span class="hljs-built_in">str</span>(lrcList), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        r = lrcList.find_all(<span class="hljs-string">&#x27;li&#x27;</span>, class_=<span class="hljs-string">&#x27;clearfix&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r:     <span class="hljs-comment"># 对于每首歌</span><br>            lrc = BeautifulSoup(<span class="hljs-built_in">str</span>(i), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>            Singer = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGeshou&#x27;</span>).get_text()  <span class="hljs-comment"># 获取歌手名</span><br>            Song = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get_text().split(<span class="hljs-string">&#x27;[&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取歌名</span><br>            urls.append(qianzhui + lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get(<span class="hljs-string">&#x27;href&#x27;</span>))  <span class="hljs-comment"># 获取链接</span><br>            titles.append((Song + <span class="hljs-string">&#x27; &#x27;</span> + Singer).replace(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment"># 标题记为歌名+歌手名</span><br>    <span class="hljs-keyword">return</span> titles, urls<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">titles, urls</span>):<br>    lyrics_set = &#123;&#125;  <span class="hljs-comment"># 用于保存标题与歌词的对应关系</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(urls)):  <span class="hljs-comment"># 对于每页歌词链接</span><br>        req = requests.get(urls[i])     <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取内容</span><br>        <span class="hljs-keyword">if</span> soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:   <span class="hljs-comment"># 排除没有歌词或链接失效等情况</span><br>            lrc = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>).text    <span class="hljs-comment"># 获取歌词</span><br>            lrc = lrc.split(<span class="hljs-string">&#x27;编辑于&#x27;</span>)[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 去掉每首歌都包含的编辑信息</span><br>            lyrics_set[titles[i]] = lrc   <span class="hljs-comment"># 保存标题与歌词的对应冠词</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>((<span class="hljs-string">&#x27;lyrics&#x27;</span> + titles[i] + <span class="hljs-string">&#x27;.txt&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># 将歌词以txt的格式下载</span><br>                f.writelines(lrc)  <span class="hljs-comment"># 写入歌词</span><br>    <span class="hljs-keyword">return</span> lyrics_set<br>titles, urls = lyrics_urls()<br>lyrics_set = download(titles, urls)<br><br></code></pre></td></tr></table></figure><h2 id="jieba分词">2.jieba分词</h2><p>使用jieba分词对每首歌进行分词并统计所有词(每个词的长度大于1)记为一个集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">all_words = []  <span class="hljs-comment"># 用于统计所有词</span><br>    split_lyric = &#123;&#125;  <span class="hljs-comment"># 用于统计每首歌包含的词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        lyric = lyrics_set[j]  <span class="hljs-comment"># 获取歌词</span><br>        word = jieba.lcut(lyric)  <span class="hljs-comment"># 分词并返回list</span><br>        word = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i) &gt; <span class="hljs-number">1</span>]  <span class="hljs-comment"># 去掉单字</span><br><br>        split_lyric[j] = word<br>        all_words.extend(word)<br><br>    set_all_words = <span class="hljs-built_in">set</span>(all_words)<br>    <br></code></pre></td></tr></table></figure><h2 id="倒排索引">3.倒排索引</h2><p>每个歌词文本都可以用一系列关键词来表示，如果按关键词建立到文本的倒排索引便可以实现根据关键词快速地检索到相关文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">invert_index = &#123;&#125;  <span class="hljs-comment"># 倒排索引</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> set_all_words:  <span class="hljs-comment"># 对于每个词</span><br>        temp = []  <span class="hljs-comment"># 用于保存包含词的歌名</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> split_lyric[j]:  <span class="hljs-comment"># 若词在歌中</span><br>                temp.append(j)  <span class="hljs-comment"># 保存歌名</span><br>        invert_index[i] = tempvert_index[i] = temp<br>        <br></code></pre></td></tr></table></figure><h2 id="建立vsm模型">4.建立VSM模型</h2><p>向量空间模型(Vector Space Model,VSM)可以把提取文本内容中的关键词作为向量空间中的向量，并将向量间的相似度作为衡量文本相似度的标准。</p><p>关键词的提取使用TF-IDF算法<strong>（term frequency–inverse documentfrequency，词频-逆文档频率）</strong>。TF是词频，表示词在文本中出现的频率；IDF是逆文档频率，表示词的常见程度。将两者相乘得到TF-IDF值，其大小表示了词对文本的重要程度，因此可以选取TF-IDF值大的作为文本的关键词。</p><p>我们取TF-IDF值最大的10个作为关键词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">VSM</span>(<span class="hljs-params">invert_index, split_lyric</span>):<br><br>    IDF = &#123;&#125;  <span class="hljs-comment"># 统计每次词的逆文档频率</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> invert_index.keys():  <span class="hljs-comment"># 对于每个词</span><br>        IDF[j] = math.log(<span class="hljs-built_in">len</span>(split_lyric) / (<span class="hljs-built_in">len</span>(invert_index[j]) + <span class="hljs-number">1</span>))<br><br>    TF = &#123;&#125;  <span class="hljs-comment"># 统计词频</span><br>    TF_IDF = &#123;&#125;   <span class="hljs-comment"># 统计TF-IDF值</span><br>    key_word = &#123;&#125;   <span class="hljs-comment"># 统计每首歌的关键词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> split_lyric.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        count = <span class="hljs-built_in">dict</span>(Counter(split_lyric[j]))   <span class="hljs-comment"># 统计每个词在歌词中的出现次数</span><br>        temp_TF = &#123;&#125;<br>        temp_TI = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> count.keys():  <span class="hljs-comment"># 对于每次词</span><br>            temp_TF[i] = count[i] / <span class="hljs-built_in">max</span>(count.values())  <span class="hljs-comment"># 计算TF</span><br>            temp_TI[i] = temp_TF[i] * IDF[i]    <span class="hljs-comment"># 计算TF-IDF</span><br>        TF[j] = temp_TF<br>        TF_IDF[j] = temp_TI<br>        all_sorted = <span class="hljs-built_in">sorted</span>(TF_IDF[j].items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将每个词的TF-IDF值从大到小排序</span><br>        key_word[j] = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> all_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> all_sorted[:<span class="hljs-number">10</span>]]    <span class="hljs-comment"># 取其中前10个作为关键词</span><br>    <span class="hljs-keyword">return</span> TF, key_word<br><br></code></pre></td></tr></table></figure><h2 id="计算余弦相似度">5.计算余弦相似度</h2><p>首先我们要获取关键词出现在歌曲里的词频：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tf</span>(<span class="hljs-params">keyword, song</span>):<br>    kw_tf = np.zeros(<span class="hljs-built_in">len</span>(keyword))  <span class="hljs-comment"># 若歌词中不包含关键词则词频为0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> keyword:   <span class="hljs-comment"># 对于每个关键词</span><br>        <span class="hljs-keyword">if</span> song <span class="hljs-keyword">in</span> invert_index[i]:  <span class="hljs-comment"># 若歌词中包含关键词</span><br><br>            kw_tf[keyword.index(i)] = TF[song][i]   <span class="hljs-comment"># 获取关键词的词频</span><br><br>    <span class="hljs-keyword">return</span> kw_tf<br><br></code></pre></td></tr></table></figure><p>然后就可以计算余弦相似度： <span class="math display">\[cos(q,d_j)=\frac{\sum_{i=1}^{m}w_{ij}*w_{iq}}{\sqrt{\sum_{i=1}^{m}w_{ij}^2}*\sqrt{\sum_{i=1}^{m}w_{iq}^2}}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">song1, song2</span>):<br>    keyword = <span class="hljs-built_in">set</span>(key_word[song1] + key_word[song2]) <span class="hljs-comment"># 获取两首歌的关键词集合</span><br>    keyword = <span class="hljs-built_in">list</span>(keyword)<br><br>    tf1 = get_tf(keyword, song1)<br>    tf2 = get_tf(keyword, song2)<br><br><br>    result = dot(tf1, tf2) / (norm(tf1) * norm(tf2))    <span class="hljs-comment"># 计算其余弦相似度</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h2 id="检索和输入歌曲相似度最高的十首歌曲">6.检索和输入歌曲相似度最高的十首歌曲</h2><p>首先用get_tf函数得到输入歌曲和每首歌曲的关键词的词频，然后计算输入歌曲和每首歌曲的余弦相似度。</p><p>最后比较余弦相似度，余弦相似度越高，则该歌曲与输入歌曲的歌词越相似，输出前十首余弦相似度最大的歌曲。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">song</span>):<br>    score = &#123;&#125;<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> TF.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        score[j] = compare(song, j)  <span class="hljs-comment"># 获取与指定歌曲比对所得的余弦相似度作为得分</span><br>    score_sorted = <span class="hljs-built_in">sorted</span>(score.items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将得分从大到小排序</span><br>    result = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> score_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> score_sorted[<span class="hljs-number">1</span>:<span class="hljs-number">11</span>]]<br><span class="hljs-comment"># 取其中得分最高的10个</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h1 id="三图像检索部分算法说明">三、图像检索部分算法说明</h1><h2 id="图片爬取">1.图片爬取</h2><p>我这里选择爬取百度图片，可以进行分类爬取，我这里爬取了30张猫的图片，30张花朵的图片，30张人脸图片，30张车的图片，30张轮船的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPages</span>():<span class="hljs-comment">#只能得到30张图片，想得到更多图片，需要变化params[&#x27;pn&#x27;]的值。</span><br>    headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77&quot;</span>&#125;<br>    url=<span class="hljs-string">&#x27;https://image.baidu.com/search/acjson&#x27;</span><br>    <span class="hljs-comment">#追加请求内容（负载）</span><br>    params=&#123;<br>        <span class="hljs-string">&#x27;tn&#x27;</span>:<span class="hljs-string">&#x27;resultjson_com&#x27;</span>,<br>        <span class="hljs-string">&#x27;logid&#x27;</span>:<span class="hljs-string">&#x27;5336511566462226640&#x27;</span>,<br>        <span class="hljs-string">&#x27;ipn&#x27;</span>:<span class="hljs-string">&#x27;rj&#x27;</span>,<br>        <span class="hljs-string">&#x27;ct&#x27;</span>:<span class="hljs-string">&#x27;201326592&#x27;</span>,<br>        <span class="hljs-string">&#x27;is&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;fp&#x27;</span>:<span class="hljs-string">&#x27;result&#x27;</span>,<br>        <span class="hljs-string">&#x27;fr&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;word&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cg&#x27;</span>:<span class="hljs-string">&#x27;girl&#x27;</span>,<br>        <span class="hljs-string">&#x27;queryWord&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cl&#x27;</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<br>        <span class="hljs-string">&#x27;lm&#x27;</span>:<span class="hljs-string">&#x27;-1&#x27;</span>,<br>        <span class="hljs-string">&#x27;ie&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;oe&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;adpicid&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;st&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;ic&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;hd&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;latest&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;copyright&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;se&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;tab&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;width&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;height&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;face&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;istype&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;qc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nc&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-string">&#x27;expermode&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nojc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;isAsync&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;pn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;rn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;gsm&#x27;</span>:<span class="hljs-string">&#x27;1e&#x27;</span>,<br>        <span class="hljs-string">&#x27;1660570401395&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span><br>        &#125;<br>    res=requests.get(url=url,headers=headers,params=params)<br>    <span class="hljs-comment"># print(res.json())</span><br>    data=res.json()[<span class="hljs-string">&#x27;data&#x27;</span>]<br>    <span class="hljs-comment"># print(data)</span><br>    <span class="hljs-comment">#得到所有图片地址</span><br>    urlPages=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> i.get(<span class="hljs-string">&#x27;thumbURL&#x27;</span>) !=<span class="hljs-literal">None</span>:<br>            urlPages.append(i[<span class="hljs-string">&#x27;thumbURL&#x27;</span>])<br>    <span class="hljs-comment"># print(urlPages)</span><br>    <span class="hljs-comment">#检测文件夹是否存在</span><br>    <span class="hljs-built_in">dir</span>=<span class="hljs-string">&#x27;D:\pycharm\picture&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-built_in">dir</span>):<br>        os.mkdir(<span class="hljs-built_in">dir</span>)<span class="hljs-comment">#创建目录方法</span><br>    <span class="hljs-comment">#向每个图片url发起请求</span><br>    x=<span class="hljs-number">70</span><br>    name1=<span class="hljs-string">&#x27;paris_invalides_00000&#x27;</span><br>    name2=<span class="hljs-string">&#x27;paris_invalides_0000&#x27;</span><br> <br>    <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> urlPages:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下载成功&#x27;</span>)<br>        res=requests.get(url=o,headers=headers)<br>        <span class="hljs-comment">#下载到dir文件夹</span><br>        <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">10</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name1&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">9</span>&lt;x&lt;<span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name2&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br> <br>        x+=<span class="hljs-number">1</span><br>getPages()<br></code></pre></td></tr></table></figure><h2 id="计算机视觉中的bag-of-words基础流程">2.计算机视觉中的Bag-of-words基础流程</h2><h3 id="特征提取-sift">2.1 特征提取 （SIFT）</h3><p>过分割、密集或随机采集、关键点或稳定区域、显著区域等方式使图像形成不同的图像块，并获得各图像块处的特征。</p><h3 id="学习-视觉词典visual-vocabulary-k-means">2.2 学习“视觉词典（visual vocabulary）” （k-means）</h3><p>在上面提取完SIFT特征的步骤后,利用K-means聚类算法将提取的SIFT特征聚类生成视觉词典。</p><p>K-means算法是度量样本间相似性的一种方法，该算法设置参数为K，把N个对象分成K个簇，簇内之间的相似度较高，而簇间的相似度较低。聚类中心有K个，视觉词典为K。</p><h3 id="针对输入特征集根据视觉词典进行量化">2.3针对输入特征集，根据视觉词典进行量化</h3><h3 id="把输入图像转化成视觉单词visual-words的频率直方图">2.4把输入图像转化成视觉单词（visual words）的频率直方图</h3><p>这一步骤通过对图像特征提取，然后将提取出来的特征点，根据第三步，转换为频率直方图。</p><p>这里在转换为频率直方图时候，有使用到TF-IDF，即词频(TermFrequency，TF)与逆文档频率(Inverse DocumentFrequency，IDF)乘积作为权值。引入这个权值的目的是为了降低一些重复特征所带来的影响。比如在BOW中，一些常用词汇譬如the，it，do等等词汇，不能体现文本内容特征，但是出现频率却很高，利用tf-idf可以降低这种不必要词汇的影响。同理，在BOF图像搜索中，图像之间也会有这样的无意义的特征出现，所以需要降低这类特征的权值。</p><h3 id="构造特征到图像的倒排表通过倒排表快速索引相关图像">2.5构造特征到图像的倒排表，通过倒排表快速索引相关图像</h3><p>倒排表是一种逆向的查找方式，在BOW中大体的思路是通过已经提取出来的词汇，反向查找出现过这个词汇的文章。</p><h3 id="根据索引结果进行直方图匹配">2.6 根据索引结果进行直方图匹配</h3><p>当我们做完上面的步骤，就需要对直方图进行匹配。直方图的匹配给出输入图像的频率直方图，在数据库中查找K个最近邻的图像，根据这K个近邻来投票图像的分类结果。</p><h2 id="特征提取">3.特征提取</h2><p>SIFT算法的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。</p><p>特征提取及描述主要是将一些<strong>具有代表性</strong>且<strong>区分性较强</strong>的<strong>全局或局部特征</strong>从图像中进行抽取，这些特征一般是类别之间差距比较<strong>明显的特征</strong>，可以将其与其他类别区分开，其次，这些特征还要求具有<strong>较好的稳定性</strong>，并对这些特征进行描述。</p><p>通常会使用SIFT算法从图片上提取出很多特征点，每个特征点都是128维的向量，因此，如果图片足够多的话,我们会提取出一个巨大的特征向量库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_image</span>(<span class="hljs-params">imagename, resultname, params=<span class="hljs-string">&quot;--edge-thresh 10 --peak-thresh 5&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Process an image and save the results in a file. &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> imagename[-<span class="hljs-number">3</span>:] != <span class="hljs-string">&#x27;pgm&#x27;</span>:<br>        <span class="hljs-comment"># create a pgm file</span><br>        im = Image.<span class="hljs-built_in">open</span>(imagename).convert(<span class="hljs-string">&#x27;L&#x27;</span>)  <span class="hljs-comment"># .convert(&#x27;L&#x27;) 将RGB图像转为灰度模式，灰度值范围[0,255]</span><br>        im.save(<span class="hljs-string">&#x27;tmp.pgm&#x27;</span>)  <span class="hljs-comment"># 将灰度值图像信息保存在.pgm文件中</span><br>        imagename = <span class="hljs-string">&#x27;tmp.pgm&#x27;</span><br><br>    cmmd = <span class="hljs-built_in">str</span>(<br>        <span class="hljs-string">&quot;D:\pycharm\picture\sift.exe &quot;</span> + imagename + <span class="hljs-string">&quot; --output=&quot;</span> + resultname +<br>        <span class="hljs-string">&quot; &quot;</span> + params)<br>    os.system(cmmd)  <span class="hljs-comment"># 执行sift可执行程序，生成resultname(test.sift)文件</span><br>    <span class="hljs-built_in">print</span><br>    <span class="hljs-string">&#x27;processed&#x27;</span>, imagename, <span class="hljs-string">&#x27;to&#x27;</span>, resultname<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_features_from_file</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Read feature properties and return in matrix form. &quot;&quot;&quot;</span><br><br>    f = loadtxt(filename)<br>    <span class="hljs-keyword">return</span> f[:, :<span class="hljs-number">4</span>], f[:, <span class="hljs-number">4</span>:]  <span class="hljs-comment"># feature locations, descriptors</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_features</span>(<span class="hljs-params">im, locs, circle=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Show image with features. input: im (image as array),</span><br><span class="hljs-string">        locs (row, col, scale, orientation of each feature). &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_circle</span>(<span class="hljs-params">c, r</span>):<br>        t = arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.01</span>, <span class="hljs-number">.01</span>) * <span class="hljs-number">2</span> * pi<br>        x = r * cos(t) + c[<span class="hljs-number">0</span>]<br>        y = r * sin(t) + c[<span class="hljs-number">1</span>]<br>        plot(x, y, <span class="hljs-string">&#x27;b&#x27;</span>, linewidth=<span class="hljs-number">2</span>)<br><br>    imshow(im)<br>    <span class="hljs-keyword">if</span> circle:<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> locs:<br>            draw_circle(p[:<span class="hljs-number">2</span>], p[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">else</span>:<br>        plot(locs[:, <span class="hljs-number">0</span>], locs[:, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;ob&#x27;</span>)<br>    axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="生成词汇">4.生成词汇</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> vocabulary<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br> <br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br> <br><span class="hljs-comment"># 提取文件夹下图像的sift特征</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images):<br>    im = array(Image.<span class="hljs-built_in">open</span>(imlist[i]).convert(<span class="hljs-string">&#x27;L&#x27;</span>))<br>    sift.process_image(imlist[i], featlist[i])<br> <br><span class="hljs-comment"># 生成词汇</span><br>voc = vocabulary.Vocabulary(<span class="hljs-string">&#x27; d:/pycharm/picture/paris_louvretest&#x27;</span>)<br>voc.train(featlist, <span class="hljs-number">500</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># 保存词汇</span><br><span class="hljs-comment"># saving vocabulary</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(voc, f)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;vocabulary is:&#x27;</span>, voc.name, voc.nbr_words)<br><br></code></pre></td></tr></table></figure><h2 id="图像索引创建数据库">5.图像索引（创建数据库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> imagesearch<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> sqlite3 <span class="hljs-keyword">import</span> dbapi2 <span class="hljs-keyword">as</span> sqlite<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br><span class="hljs-comment"># load vocabulary</span><br><span class="hljs-comment"># 载入词汇</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    voc = pickle.load(f)<br><span class="hljs-comment"># 创建索引</span><br>indx = imagesearch.Indexer(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>indx.create_tables()<br><span class="hljs-comment"># go through all images, project features on vocabulary and insert</span><br><span class="hljs-comment"># 遍历所有的图像，并将它们的特征投影到词汇上</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)[:<span class="hljs-number">1000</span>]:<br>    locs, descr = sift.read_features_from_file(featlist[i])<br>    indx.add_to_index(imlist[i], descr)<br><span class="hljs-comment"># commit to database</span><br><span class="hljs-comment"># 提交到数据库</span><br>indx.db_commit()<br><br>con = sqlite.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select count (filename) from imlist&#x27;</span>).fetchone())<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select * from imlist&#x27;</span>).fetchone())<br><br></code></pre></td></tr></table></figure><h2 id="图像检索">6.图像检索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">i</span>):<br>  <span class="hljs-comment"># 获取图像列表</span><br>  imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>  nbr_images = <span class="hljs-built_in">len</span>(imlist)<br>  <span class="hljs-comment"># 获取特征列表</span><br>  featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br>  <span class="hljs-comment"># 载入词汇</span><br>  f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>  voc = pickle.load(f)<br>  f.close()<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  locs, descr = sift.read_features_from_file(featlist[<span class="hljs-number">0</span>])<br>  iw = voc.project(descr)<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ask using a histogram...&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(src.candidates_from_histogram(iw)[:<span class="hljs-number">10</span>])<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try a query...&#x27;</span>)<br><br>  nbr_results = <span class="hljs-number">11</span><br>  res = [w[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> src.query(imlist[i-<span class="hljs-number">1</span>])[:nbr_results]]<br><br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算搜索结果得分:&quot;</span>)<br>  score=imagesearch.compute_ukbench_score(src, imlist[:<span class="hljs-number">10</span>])<br>  <span class="hljs-keyword">return</span> src, res, score<br><br></code></pre></td></tr></table></figure><h2 id="对数据库的操作">7.对数据库的操作</h2><p>我在最终运行的时候发现在图像检索时，有时会出现是个运行结果中有一两个显示不出来的问题，一开始我还以为是电脑卡顿的问题。然后我试着打印了res：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603231847152.png"></p><p>发现当运行结果中有一两个显示不出来时，res中有几个序号就大于我的图片总数，我知道了是我的数据库出现了问题，于是我用以下代码查看我的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>result = cursor.fetchall()<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(row)<br>    <br>conn.close()<br><br></code></pre></td></tr></table></figure><p>发现了下面的问题，我知道了是我之前在刚刚做图像检索时尝试代码，用了其他的命名方式给图片命名，这就导致了我后来的图片没有覆盖掉数据库中这些数据，其还占据着我的数据库，但图片和sift已经被我在文件夹中删掉了，如下图所示：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232019342.png"></p><p>而我之所以运行结果中有一两个显示不出来的问题，是因为它正好匹配到了那几个占据着我的数据库但不存在于我的图片库的序号。于是想着通过删除数据库的数据，来把数据库清空，再进行一次图像索引创建数据库，就可以删掉那几个多出的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br><span class="hljs-comment"># 1.创建数据库连接</span><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-comment"># 2.创建游标</span><br>cursor = conn.cursor()<br><br><span class="hljs-comment"># 删除数据库表记录</span><br><br>results = cursor.execute(<span class="hljs-string">&quot;DELETE  FROM imlist &quot;</span>)<br>conn.commit()  <span class="hljs-comment"># 更新数据库</span><br>results = cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>cursor.close()  <span class="hljs-comment"># 关闭cursor对象</span><br>conn.close()  <span class="hljs-comment"># 关闭数据库连接</span><br><br></code></pre></td></tr></table></figure><p>结果成功将那几个多余数据删除:</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232117000.png"></p><p>但当我很兴奋地去执行最后一步图像检索时，却出现了下面的报错：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232137227.png"></p><p>我尝试了各种办法，到处搜索，甚至还重新创建一个工程，用了一下午的时间，最终我突然想到，之所以会检索到有空的类型，是我之前删掉的那几个多余数据就变成了空的类型，我是150张图片，而数据库现在容量是153，3个位置是空的，于是我便又找了三张图片加入了进去，提取特征，生成词汇，再加入数据库，随后检索，果然成功，解决了这个问题。</p><p>最后，我一开始遇到的运行结果中有一两个显示不出来的问题也得到了解决。</p><blockquote><p>还有一个问题，导致如果匹配到前九张图片，就会显示不出来，原因是我的if语句用错了，应该是if,elif,else，而不是if,if,else。</p></blockquote><h1 id="三操作界面设计">三、操作界面设计</h1><p>利用了pyqt，点击工具中的QTdesigner，利用到了Push Button、Lable、TextBrowser。</p><p>然后保存得到一个.ui文件，然后利用工具中的PyUIC，将.ui文件转换为.py文件。</p><p>将输入的歌曲和图像显示在界面上，然后输出前十个候选结果，且将余弦相似度和得分显示在界面上。</p><p>图像显示和文本显示用的方法是不同的，文本显示直接用setText即可将结果写入：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232530108.png"></p><p>图像显示首先使用QtGui模块中的QPixmap类创建一个名为jpg的Pixmap对象，该对象表示Name路径指定的图像文件；然后使用.scaled()方法将图像缩放到与label标签具有相同的宽度和高度。这是为了确保图像适应标签的大小；最后用setPixmap()方法将缩放后的图像设置为label标签的当前图像。这将在界面上显示图像。</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232558759.png" alt="image-20230603232558759"><figcaption aria-hidden="true">image-20230603232558759</figcaption></figure><p>代码中在显示图片的输出结果时我没有用循环，只是笨拙的罗列，所以我就不都放完整代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QFileDialog, QApplication<br><span class="hljs-keyword">from</span> gui <span class="hljs-keyword">import</span> Ui_MainWindow<br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtGui<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(QMainWindow, Ui_MainWindow):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>(MyWindow, self).__init__(parent)<br>        self.setupUi(self)<br>        self.pushButton.clicked.connect(self.<span class="hljs-built_in">open</span>)  <span class="hljs-comment"># 将点击按钮与函数open连接</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):<br>        Name, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择歌词&quot;</span>, <span class="hljs-string">&quot;./lyrics/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.txt)&quot;</span>)  <span class="hljs-comment"># 获取选择的歌曲名字</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(Name, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-comment"># 打开所选歌曲的歌词</span><br>            data = f.read()     <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser.setText(data)      <span class="hljs-comment"># 将歌词显示在textBrowser上</span><br>        Name = <span class="hljs-built_in">str</span>(Name).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉歌名的位置信息</span><br>        Name = Name[<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉歌名的后缀(.txt)</span><br><br>        self.label.setText(Name)    <span class="hljs-comment"># 将歌名显示在label上</span><br>        self.label_4.setText(get_keyword(Name)) <span class="hljs-comment">#将歌的关键词显示在label_4上</span><br>        result = search(Name)   <span class="hljs-comment"># 检索与所选歌歌词最相似的十首歌</span><br>        best = result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]     <span class="hljs-comment"># 最相似的一首歌</span><br>        result = <span class="hljs-string">&#x27;\n&#x27;</span>.join([<span class="hljs-built_in">str</span>(x[<span class="hljs-number">1</span>]) + <span class="hljs-number">8</span> * <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(x[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result])  <span class="hljs-comment"># 调整检索结果</span><br>        self.label_2.setText(result)  <span class="hljs-comment"># 将检索结果显示在label_2上</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;lyrics&#x27;</span> + best + <span class="hljs-string">&#x27;.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:   <span class="hljs-comment"># 打开相似效果最好的歌词</span><br>            data = f.read()  <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser_2.setText(data)  <span class="hljs-comment"># 将歌词显示在textBrowser_2上</span><br>        self.label_5.setText(get_keyword(best)) <span class="hljs-comment">#将歌的关键词显示在label_5上</span><br><br>        Name0, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择图片&quot;</span>, <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.jpg)&quot;</span>)  <span class="hljs-comment"># 获取选择的图片名字</span><br>        jpg = QtGui.QPixmap(Name0).scaled(self.label_8.width(), self.label_8.height())<br>        self.label_8.setPixmap(jpg)     <span class="hljs-comment"># 将输入图片显示在label_8上</span><br><br>        Name0 = <span class="hljs-built_in">str</span>(Name0).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉图片的位置信息</span><br>        Name0 = Name0[-<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉图片的后缀(.txt)</span><br>        i=<span class="hljs-built_in">int</span>(Name0)<br>        src, res, score=get(i)<br>        self.label_10.setText(<span class="hljs-built_in">str</span>(score))  <span class="hljs-comment"># 将搜索得分显示在label_10上</span><br>        <span class="hljs-comment">#将搜索到的10张图片显示</span><br>        <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">10</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_00000&quot;</span>+<span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>        <span class="hljs-keyword">else</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_0000&quot;</span> + <span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>……<br><br></code></pre></td></tr></table></figure><h1 id="四程序运行结果图">四、程序运行结果图</h1><h2 id="歌词爬取结果">1.歌词爬取结果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232945163.png" alt="所有歌词"><figcaption aria-hidden="true">所有歌词</figcaption></figure><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233009341.png" alt="单个歌词"><figcaption aria-hidden="true">单个歌词</figcaption></figure><h2 id="图片爬取结果">2.图片爬取结果</h2><p>猫：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233058696.png" alt="“猫”的爬取结果"><figcaption aria-hidden="true">“猫”的爬取结果</figcaption></figure><p>车：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233130164.png" alt="“车”的爬取结果"><figcaption aria-hidden="true">“车”的爬取结果</figcaption></figure><p>......</p><h2 id="最终效果">3.最终效果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233219873.png" alt="最终运行结果"><figcaption aria-hidden="true">最终运行结果</figcaption></figure><h2 id="总结与不足">4.总结与不足</h2><p>可以看出文本检索实现的很好，图像检索有八个正确结果，还算不错。</p><p>不足的地方一是在图像检索中，由于图像集数目不足，以及图片背景过于丰富，会导致特征采集不准确，有几个出现错误；</p><p>BOW的一个主要缺点是在用视觉单词表示图像时不包含图像特征的位置信息，而图像特征的位置信息在人脸识别图像时起到了很好的作用；</p><p>我觉得可以改进的地方，输入一张非图像库内的图像，然后再与图像库图像进行检索和匹配。且可以让文本检索和图像检索联系起来，输入文本可以既能得到相似文本，又能得到对应语义的图片，实现更强的功能。</p>]]></content>
    
    
    <categories>
      
      <category>进阶项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>多媒体</tag>
      
      <tag>项目</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SYSTEMVIEW通信原理实验</title>
    <link href="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一简单介绍">一、简单介绍</h1><h3 id="内容介绍">内容介绍</h3><ul><li>AM的调制与解调</li><li>SSB的调制与解调</li><li>FM的调制与解调</li><li>数字信号的基带传输</li><li>MASK的调制与解调</li><li>2FSK的调制与解调</li><li>2PSK的调制与解调</li><li>16QAM调制与解调</li><li>抽样定理</li></ul><h3 id="报告截图">报告截图</h3><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122412650.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122519556.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122608610.png"></p><h1 id="二报告和软件自行提取">二、报告和软件自行提取</h1><p>链接：https://pan.baidu.com/s/1o5ZZVY0MbFcnZWClfQXSPQ</p><p>提取码：k783</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程</tag>
      
      <tag>实践课</tag>
      
      <tag>systemview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研规划</title>
    <link href="/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/"/>
    <url>/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理(Ⅰ)</title>
    <link href="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/"/>
    <url>/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li>视频教程<a href="https://www.bilibili.com/video/BV11x411G79C/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ef3842945b0f7729a278874a86c98aa5">北邮通信原理公开课 杨鸿文</a></li></ul><h1 id="一绪论">一、绪论</h1><h2 id="通信系统和通信网的构成">1.通信系统和通信网的构成</h2><h3 id="通信系统">1.1 通信系统</h3><p>通信系统：指点对点通信所需的全部设施</p><p>通信系统的香农模型:</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233002637.png"></p><p>信源：信息的发送者；信宿：信息的接收者。信源和信宿决定了通信系统的<strong>业务性质</strong>。例如电话系统传送语音信息，电报或数据通信系统传送代表某些信息的符号，电视系统传送活动图像的信息等。</p><p>编码：泛指把信源输出变换成适合信道传送的信号所需的设备。有信源编码、信道编码。</p><p>译码: 编码的反变换所需要的设备。</p><p>信道: 传送信息的通道。</p><p>以电信号为物理载体的通信系统（通信系统的另一种模型）：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233644437.png"></p><p>信源：</p><ul><li>模拟信源：各种传感器的输出，其存在形式一般是基带电信号；</li><li>数字信源：电脑、手机中存储的比特。</li></ul><p>信道：</p><ul><li>基带信道：一般可建模为低通型滤波器；</li><li>频带信道：一般可建模为带通型滤波器。</li></ul><p>故有这四种传输：</p><ul><li>模拟基带传输：最简单的传输</li><li>模拟频带传输：第四章</li><li>数字基带传输：第五章</li><li>数字频带传输：第六章</li></ul><h3 id="通信网">1.2 通信网</h3><p>通信网的构成：</p><ul><li><p>通信系统：终端设备（编码、译码）、传输设备（信道）；</p></li><li><p>交换设备：</p><ul><li><p>电路交换：如公共电话网，优点：实时、QoS(Quality ofService)高；缺点：信道利用率低。</p></li><li><p>分组交换：如Internet网，优点：信道利用率高；缺点：实时和QoS不易保证。</p></li></ul></li><li><p>信令和协议</p></li></ul><h3 id="信息消息信号">1.3 信息、消息、信号</h3><p>信息：要表示和传送的对象。</p><p><strong>消息</strong>：信息的表现形式，信息的数学表示形式。</p><p>信号：信号是与消息对应的某种物理量，信息的物理表示形式。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233053555.png" alt="信息、消息、信号"><figcaption aria-hidden="true">信息、消息、信号</figcaption></figure><p>香农信息论认为：信息的多少等于无知度的大小。人们已知的消息不是信息，而好像，大概，可能之类的不确切的内容包含着信息。<span class="math display">\[离散消息的熵定义:H(X)=-\sum{p(x)\log_2p(x)}\]</span></p><p><span class="math display">\[连续消息的熵定义:H(X)=-\int_{a}^{b}{p(x)\log_2p(x)}dx\]</span></p><ul><li>连续消息的信息量是无限的.</li><li>连续消息有无穷个状态，因此根据香农熵的定义必然为无穷大。</li></ul><h3 id="通信系统的主要性能指标">1.4 通信系统的主要性能指标</h3><ul><li><p>有效性：是指在给定信道内传输的信息量的多少</p></li><li><p>代价：资源占用情况</p></li><li><p>带宽；传输速率、频带利用率</p></li><li><p>可靠性：是指接收信息的准确度</p><ul><li>质量：失真大小</li><li>输出信噪比、调制增益；误码率、误比特率</li></ul></li><li><p>码元传输速率（R<sub>S</sub>或R<sub>B</sub>）：码元传输速率简称传码率，也称码元速率或符号速率。它被定义为单位时间（s<sup>-1</sup>）内传输码元的数目，单位为波特，记为Baud或B。</p></li><li><p>信息传输速率（R<sub>b</sub>）：信息传输速率简称传信率，又称信息速率。它被定义为单位时间（s<sup>-1</sup>）内传递的信息量（bit数），单位是比特/秒，也记为bit/ s或bps。</p></li></ul><h1 id="二确定信号分析">二、确定信号分析</h1><h2 id="傅里叶变换">1.傅里叶变换</h2><h3 id="傅里叶变换与反变换">1.1 傅里叶变换与反变换</h3><p><span class="math display">\[傅里叶变换:F(f)=\int_{-\infty}^{+\infty}{f(t)e^{-j2\pi ft}}dt\]</span></p><p><span class="math display">\[傅里叶反变换:f(t)=\int_{-\infty}^{+\infty}{F(f)e^{j2\pi ft}}df\]</span></p><h3 id="典型信号的傅里叶变换">1.2 典型信号的傅里叶变换</h3><ul><li><p>矩形脉冲信号： <span class="math display">\[E\tau sinc(t\tau)\LeftrightarrowE[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p><p><span class="math display">\[也可表示为:E\tau sinc(t\tau)\Leftrightarrow Erect(\frac{f}{\tau})\]</span></p><p><span class="math display">\[E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]\Leftrightarrow E\tausinc(f\tau)\]</span></p><p><span class="math display">\[sinc(x)=\frac{sin(\pi x)}{\pi x},Sa(x)=\frac{sin(x)}{x}\]</span></p><p><span class="math display">\[E\tau Sa(\pi t\tau)\LeftrightarrowE[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p></li></ul><p><span class="math display">\[拓展:Asinc^2(at)\Leftrightarrow\frac{A}{a}(1-\frac{|f|}{a})\]</span></p><ul><li><p>单边指数信号： <span class="math display">\[Ee^{-at}(t&gt;0,a&gt;0)\Leftrightarrow\frac{E}{a+j2\pi f}\]</span></p></li><li><p>直流信号：</p></li></ul><p><span class="math display">\[E\Leftrightarrow E\delta(f)\]</span></p><ul><li><p>单位冲激信号： <span class="math display">\[\delta(t)\Leftrightarrow 1\]</span></p></li><li><p>符号函数：</p></li></ul><p><span class="math display">\[f(t)=\begin{cases} +1，t&gt;0\\ -1， t&lt;0\end{cases},\quadF(w)=\frac{1}{j\pi f}\]</span></p><ul><li><p>阶跃函数： <span class="math display">\[  u(t)\Leftrightarrow\frac{1}{j2\pi f}+\frac{1}{2}\delta(f)  \]</span></p></li><li><p>正余弦函数： <span class="math display">\[cos(2\pi f_0)\Leftrightarrow\frac{1}{2}[\delta(f+f_0)+\delta(f-f_0)]\]</span></p><p><span class="math display">\[sin(2\pi f_0)\Leftrightarrow\frac{j}{2}[\delta(f+f_0)-\delta(f-f_0)]\]</span></p></li></ul><h3 id="傅里叶变换的性质">1.3 傅里叶变换的性质</h3><ul><li>尺度变换性质：</li></ul><p><span class="math display">\[若f(t)\LeftrightarrowF(w),则f(at)\Leftrightarrow\frac{1}{|a|}F(\frac{w}{a})\]</span></p><ul><li>时移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t-t_0)\Leftrightarrow\ F(w)e^{-jwt_0}\]</span></p><blockquote><p>同号</p></blockquote><ul><li>对称性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则F(t)\Leftrightarrow 2\pif(-w),或F(t)\Leftrightarrow f(-f)\]</span></p><p><span class="math display">\[若f(t)为偶函数,则F(t)\Leftrightarrow2\pi f(w)\]</span></p><ul><li>频移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t)e^{jw_0t}\Leftrightarrow\ F(w-w_0)\]</span></p><blockquote><p>异号</p></blockquote><ul><li>微分性质：</li></ul><p><span class="math display">\[f&#39;(t)\Leftrightarrow jwF(w),\quadf^{(n)}(t)\Leftrightarrow(jw)^{n}F(w)\]</span></p><p><span class="math display">\[tf(t)\Leftrightarrow jF&#39;(w),\quad t^{n}f(t)\Leftrightarrowj^{n}F^{(n)}(w)\]</span></p><ul><li>积分性质：</li></ul><p><span class="math display">\[F(0)=0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\frac{F(w)}{jw}\]</span></p><p><span class="math display">\[F(0)\neq0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\piF(0)\delta(w)+\frac{F(w)}{jw}\]</span></p><h3 id="积化和差公式">1.4 积化和差公式</h3><p><span class="math display">\[cosacosβ=\frac{1}{2}[cos(a+β)+cos(a-β)]\]</span></p><p><span class="math display">\[sinasinβ=-\frac{1}{2}[cos(a+β)-cos(a-β)]\]</span></p><p><span class="math display">\[sinacosβ=\frac{1}{2}[sin(a+β)+sin(a-β)]\]</span></p><p><span class="math display">\[cosasinβ=\frac{1}{2}[sin(a+β)-sin(a-β)]\]</span></p><h2 id="能量谱密度与功率谱密度及相关函数">2.能量谱密度与功率谱密度及相关函数</h2><h3 id="能量信号与功率信号">2.1 能量信号与功率信号</h3><ul><li>能量信号：</li></ul><p><span class="math display">\[E_f=\int_{-\infty}^{\infty}{f^{2}(t)}dt&lt;\infty(能量有限)\]</span></p><ul><li>功率信号：</li></ul><p><span class="math display">\[P_f=\lim_{T\rightarrow+\infty}\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{f^{2}(t)}dt&lt;\infty(能量无限，功率有限)\]</span></p><h3 id="能量信号的相关函数">2.2 能量信号的相关函数</h3><ul><li>能量信号x(t)与y(t)的互相关函数</li></ul><p><span class="math display">\[R_{xy}(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt\]</span></p><p><span class="math display">\[R_{yx}(\tau)=\int_{-\infty}^{\infty}{y(t+\tau)x^{*}(t)}dt\]</span></p><ul><li>能量信号x(t)的自相关函数：</li></ul><p><span class="math display">\[R_x(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)x^{*}(t)}dt\]</span></p><blockquote><p>实信号不需要共轭</p></blockquote><ul><li>相关函数的性质：</li></ul><p><span class="math display">\[共轭对称性:R_{xy}(\tau)=R^{*}_{yx}(-\tau)\]</span></p><p><span class="math display">\[R_{x}(\tau)=R^{*}_{x}(-\tau)\]</span></p><p><span class="math display">\[x(t)的能量是自相关函数在\tau=0处的值\]</span></p><ul><li><p>许瓦兹不等式： <span class="math display">\[许瓦兹不等式:\vert\int_{-\infty}^{\infty}{s_1(t)s_2^{*}(t)}dt\vert\leq\sqrt{E_1E_2}\]</span></p><p><span class="math display">\[互相关函数满足:|R_{xy}(\tau)|=|\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt|\leq\sqrt{E_xE_y}\]</span></p><p><span class="math display">\[自相关函数在\tau=0时最大:R_x(\tau)\leq R_x(0)=E_x\]</span></p></li></ul><h3 id="能量谱密度">2.3 能量谱密度</h3><p><span class="math display">\[互能量谱密度:E_{xy}(f)=X(f)Y^*(f)\]</span></p><p><span class="math display">\[能量谱密度:E_{x}(f)=X(f)X^*(f)=|X(f)|^2\]</span></p><p><span class="math display">\[能量（帕塞瓦尔定理）:E_x=\int_{-\infty}^{\infty}{|x(t)|^2}dt=\int_{-\infty}^{\infty}{|X(f)|^2}df\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是能量谱密度:R_x(\tau)\Leftrightarrow|X(f)|^2\]</span></p><h3 id="功率信号的相关函数">2.4 功率信号的相关函数</h3><p><span class="math display">\[R_x(\tau)=\overline{[x(t+\tau)x^{*}(t)]}\]</span></p><p><span class="math display">\[自相关函数在\tau=0的值是功率:R_x(0)=\overline{[x(t)x^{*}(t)]}=P_x\]</span></p><blockquote><p>其他性质可类比能量信号</p></blockquote><h3 id="功率谱密度">2.5 功率谱密度</h3><p><span class="math display">\[功率:P_x=R_x(0)=\overline{|x(t)|^2}=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|X_T(f)|^2}df\bigg)=\int_{-\infty}^{\infty}{\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)}df\]</span></p><p><span class="math display">\[功率谱密度:P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是功率谱密度:R_x(\tau)\Leftrightarrow P_x(f)\]</span></p><h2 id="带宽">3.带宽</h2><h3 id="单边功率谱">3.1 单边功率谱</h3><p>从数学上来说，当我们对一个信号作傅里叶变换时，f的定义域是(-∞，+∞)，频率可正可负。</p><p>但在物理测量当中，负频率是没有意义的，f的定义域是[0，+∞)。实信号的功率谱密度或能量谱密度是对称的，故在工程中常用单边谱密度。<span class="math display">\[P_x^单(f)=P_x(f)+P_x(-f)=2P_x(f)\qquad f\geq0\]</span></p><p><span class="math display">\[P_x=\int_{0}^{\infty}{P_x^单(f)}df\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/双边谱密度.png" alt="双边谱密度"><figcaption aria-hidden="true">双边谱密度</figcaption></figure><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/单边谱密度.png" alt="单边谱密度"><figcaption aria-hidden="true">单边谱密度</figcaption></figure><h3 id="基带信号与频带信号">3.2 基带信号与频带信号</h3><p>基带信号：信号的功率或能量主要集中在零频附近。</p><p>频带信号（带通信号）：信号的功率或能量集中在某个载频附近。</p><h3 id="带宽-1">3.3 带宽</h3><p>带宽：信号的带宽指单边谱密度的宽度。</p><ul><li><p>绝对带宽：频谱在某个区间之外为零，该区间的宽度就是绝对带宽。</p><blockquote><p>只是一种模型，一个信号若频域有限，则其时域无限，现实中的信号不可能时域无限。</p></blockquote></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/绝对带宽.png" alt="绝对带宽"><figcaption aria-hidden="true">绝对带宽</figcaption></figure><ul><li>主瓣带宽：有些信号频谱呈现出主瓣、旁瓣的特征，其带宽可采用主瓣宽度衡量。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/主瓣带宽.png" alt="主瓣带宽"><figcaption aria-hidden="true">主瓣带宽</figcaption></figure><ul><li>3dB带宽：功率谱密度从峰值下降一半（3dB)的宽度。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/3dB带宽.png" alt="3dB带宽"><figcaption aria-hidden="true">3dB带宽</figcaption></figure><ul><li><p>等效矩形带宽：功率谱同高同面积的矩形的宽度。</p></li><li><p>按能量占比定义的带宽</p></li></ul><blockquote><p>信号平方的带宽：x(t)的绝对带宽是W，x<sup>2</sup>(t)的绝对带宽是2W。</p><p>正弦调制的带宽：x(t)的绝对带宽是W，是s(t)=x(t)cos2πf<sub>c</sub>t的绝对带宽是2W。</p></blockquote><h2 id="线性时不变系统">4.线性时不变系统</h2><h3 id="线性时不变系统-1">4.1 线性时不变系统</h3><p>复单频信号通过滤波器后还是复单频信号： <span class="math display">\[x(t)=e^{j2\pi vt},\quad y(t)=e^{j2\pi vt}H(v)\]</span> 能量（功率）谱密度： <span class="math display">\[E_y(f)=|H(f)|^2E_x(f),\quad P_y(f)=|H(f)|^2P_x(f)\]</span></p><h3 id="希尔伯特变换与解析信号">4.2 希尔伯特变换与解析信号</h3><ul><li>希尔伯特变换： <span class="math display">\[实信号x(t)的希尔波特变换\widehat{x}(t)是将x(t)通过一个特定滤波器的输出。\]</span></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换.png" alt="希尔伯特变换"><figcaption aria-hidden="true">希尔伯特变换</figcaption></figure><p><span class="math display">\[H(f)=-j*sgn(f)=\begin{cases} -j，f&gt;0\\ j，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[h(t)=\frac{1}{\pi t}\]</span></p><p>​由于|H(f)|<sup>2</sup>=1，故希尔伯特变换不改变能量（功率）谱密度，不改变自相关函数。</p><p>​ 偶函数的希尔伯特变换是奇函数，奇函数的希尔伯特变换是偶函数。</p><p><span class="math display">\[x(t)与\widehat{x}(t)正交：\int_{-\infty}^{\infty}{\widehat{x}(t)x(t)}dt=0\]</span> ​ 常用希尔伯特变换对：</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换对.jpg" alt="希尔伯特变换对"><figcaption aria-hidden="true">希尔伯特变换对</figcaption></figure><ul><li><p>解析信号</p><p>实信号x(t)的解析信号z(t)定义为如下复信号：<span class="math display">\[z(t)=x(t)+j\widehat{x}(t)\]</span></p></li></ul><p><span class="math display">\[H(f)=1+j·[-j·sgn(f)]=1+sgn(f)=\begin{cases} 2，f&gt;0\\0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[Z(f)=H(f)X(f)=\begin{cases} 2X(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p>​ 功率谱密度： <span class="math display">\[P_Z(f)=|1+sgn(f)|^2P_x(f)=\begin{cases} 4P_x(f)，f&gt;0\\0，f&lt;0\end{cases}\]</span></p><h2 id="带通信号">5.带通信号</h2><h3 id="带通信号的复包络">5.1 带通信号的复包络</h3><p>带通信号：频谱集中在某个载频f<sub>c</sub>附近，默认假设最高频率不超过2f<sub>c</sub></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通信号.png" alt="带通信号"><figcaption aria-hidden="true">带通信号</figcaption></figure><p>复包络： <span class="math display">\[实带通信号x(t)的复包络定义为:x_L(t)=z(t)e^{-j2\pif_ct},其中z(t)=x(t)+j·\widehat{x}(t)\]</span></p><p><span class="math display">\[x_L(t)=[x(t)+j·\widehat{x}(t)]e^{-j2\pi f_ct}\]</span></p><ul><li>频谱关系</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/基带信号、解析信号、带通信号.png" alt="基带信号、解析信号、带通信号"><figcaption aria-hidden="true">基带信号、解析信号、带通信号</figcaption></figure><ul><li><p>功率谱密度关系 <span class="math display">\[解析信号的功率谱密度:P_Z(f)=\begin{cases} 4P_x(f)，f&gt;0\\0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[复包络的功率谱密度:P_L(f)=P_Z(f+f_c)=\begin{cases}4P_x(f+f_c)，|f|&lt;f_c\\ 0，else\end{cases}\]</span></p></li></ul><h3 id="带通信号的三种表示方法">5.2 带通信号的三种表示方法</h3><ul><li><p><span class="math display">\[x(t)=Re\{x_L(t)e^{j2\pi fct}\}\]</span></p></li><li><p><span class="math display">\[x(t)=x_c(t)cos2\pi f_ct-x_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[x_c(t)=Re\{x_L(t)\}\quad同相分量\]</span></p><p><span class="math display">\[x_s(t)=Im\{x_L(t)\}\quad正交分量\]</span></p><p><span class="math display">\[x_L(t)=x_c(t)+j·x_s(t)\]</span></p></li><li><p><span class="math display">\[x(t)=A(t)cos[2\pi f_ct+\varphi(t)]\]</span></p><p><span class="math display">\[A(t)=|x_L(t)|\quad包络\]</span></p><p><span class="math display">\[\varphi(t)=\angle x_L(t)\quad相位\]</span></p><p><span class="math display">\[x_L(t)=A(t)e^{j\varphi(t)}\]</span></p></li></ul><h3 id="带通系统的等效基带分析">5.3 带通系统的等效基带分析</h3><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通系统的等效基带分析.png" alt="带通系统的等效基带分析"> <span class="math display">\[H_e(f)=\frac{1}{2}H_L(f)=H(f+f_c),\quad h_e(t)=\frac{1}{2}h_L(t)\]</span></p><blockquote><p>例题：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419234031223.png"></p></blockquote><h1 id="三随机过程">三、随机过程</h1><h2 id="随机过程">1.随机过程</h2><p>随机变量X：随机实验的结果是确定实数，X∈{x<sub>1</sub>,x<sub>2</sub>,…}</p><p>随机过程X(t)：随机实验的结果是确定的函数，X(t)∈{x<sub>1</sub>(t),x<sub>2</sub>(t),…}</p><p>随机过程X(t)是沿时间轴-∞&lt;t&lt;∞排列的无数个随机变量。</p><h3 id="随机过程的统计特性">1.1 随机过程的统计特性</h3><p>随机过程的数学期望： <span class="math display">\[E[X(t)]=m_X(t)\]</span> 任意随机过程可以看成是零均值随机过程与确定函数的和。</p><p>X(t)，Y(t)的互相关函数： <span class="math display">\[R_{XY}(t_1,t_2)=E[X(t_1)Y(t_2)]\]</span></p><blockquote><p>X(t)，Y(t)是两个随机过程，随便在两个过程上取两个时间，这样得到两个随机变量。</p><p>确定信号的互相关函数取平均是时间平均，随机信号的互相关函数取平均是统计平均。</p></blockquote><p>X(t)的自相关函数： <span class="math display">\[R_{X}(t_1,t_2)=E[X(t_1)X(t_2)]\]</span></p><p><span class="math display">\[\tau=t_1-t_2\]</span></p><p>平均自相关函数：对t做时间平均： <span class="math display">\[\overline{R}_X(\tau)=\overline{E[X(t+\tau)X(t)]}=E[\overline{X(t+\tau)X(t)}]\]</span></p><h3 id="随机过程的功率谱密度">1.2 随机过程的功率谱密度</h3><p>随机过程X(t)是从样本空间中随机抽出一个确定的样本函数x(t)。 <span class="math display">\[P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)\]</span> 每个样函数x(t)都有各自的功率谱密度。</p><p>随机抽出的不同样函数的功率谱密度可能不同。随机过程的功率谱密度定义为<strong>所有样本函数的功率谱密度的统计平均</strong>：<span class="math display">\[\overline{P}_x(f)=E[\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)]=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}E[|F[x_T(t)]|^2]\bigg)\]</span>随机过程的功率谱密度是<strong>平均</strong>自相关函数的傅氏变换。</p><h2 id="平稳随机过程">2.平稳随机过程</h2><h3 id="狭义严平稳随机过程">2.1 狭义（严）平稳随机过程</h3><p>对于任意n和t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>以及τ有分布函数：<span class="math display">\[F_n(x_1,x_2,...,x_n;t_1.t_2,...,t_n)=F_n(x_1,x_2,...,x_n,t_1+\tau,t_2+\tau,...,t_n+\tau)\]</span> 称X(t)为狭义（严）平稳随机过程。</p><h3 id="广义宽平稳随机过程">2.2 广义（宽）平稳随机过程</h3><p><span class="math display">\[满足E[X(t)]=m_X,R_X(t+\tau,t)=R_X(\tau),称X(t)为宽平稳随机过程。\]</span></p><blockquote><p>均值和自相关满足遍历性的平稳过程叫做广义遍历过程。</p><p>遍历：每个样本函数的时间平均等于随机过程（所有样本函数）的统计平均。<span class="math display">\[例如X(t)=cos(2\pif_0t+\theta),X(t)就是随机过程，其中\theta可以取不同的值，求m_X也就是求X(t)的统计平均，一般是对\theta根据其所属分布求平均；而样本函数x(t)也就是确定了一个X(t)，\theta值固定，对其求时间平均就是对t求平均，\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{x_T(t)}dt\bigg)这样去求\]</span></p></blockquote><ul><li><p>功率谱密度 <span class="math display">\[随机过程的功率谱密度是平均自相关函数的傅氏变换。\]</span></p><p><span class="math display">\[因为平稳过程的自相关函数与t无关，故\overline{R}_X(\tau)=R_X(\tau)\]</span></p><p><span class="math display">\[P_X(f)=\int_{-\infty}^{\infty}{R_X(\tau)e^{-j2\pi f\tau}}d\tau\]</span></p></li></ul><h3 id="联合平稳">2.3 联合平稳</h3><p>X(t)、Y(t)联合平稳：除X(t)、Y(t)各自平稳外，还满足： <span class="math display">\[E[X(t+\tau)Y(t)]=R_{XY}(\tau)\]</span></p><blockquote><p>随机变量的不相关和独立： <span class="math display">\[不相关:E[XY]=E[X]E[Y]\]</span></p><p><span class="math display">\[独立:Pr\{A,B\}=Pr\{A\}Pr\{B\},f_{XY}(x,y)=f_X(x)f_Y(y)\]</span></p><p>若独立，则不相关。反之不一定。</p></blockquote><p>两个随机过程不相关：X(t<sub>1</sub>)，Y(t<sub>2</sub>) <span class="math display">\[E[X(t_1)Y(t_2)]=E[X(t_1)]E[Y(t_2)]\]</span></p><p><span class="math display">\[R_{XY}(t_1,t_2)=m_X(t_1)m_Y(t_2)\]</span></p><p>两个随机过程在同一时刻不相关： <span class="math display">\[t_1=t_2=t,E[X(t)Y(t)]=E[X(t)]E[Y(t)]\]</span></p><p><span class="math display">\[R_{XY}(t,t)=m_X(t)m_Y(t)\]</span></p><p>零均值平稳过程的相关系数：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/相关系数.png"></p><blockquote><p>看互相关函数，为零则不相关（因为是零均值平稳过程）</p></blockquote><h3 id="平稳过程通过线性系统">2.4 平稳过程通过线性系统</h3><p>平稳过程通过线性系统后还是平稳过程，且输入输出联合平稳。 <span class="math display">\[m_Y=m_XH(0)\quad P_Y(f)=|H(f)|^2P_X(f)\]</span>零均值平稳过程X(t)的希尔伯特变换是零均值平稳过程。希尔伯特变换不改变功率谱密度、自相关函数。<span class="math display">\[X(t)与\widehat{X}(t)在同一时刻不相关\]</span></p><h3 id="复平稳过程">2.5 复平稳过程</h3><ul><li><p>一种判断方法：Z(t)的实部X(t)、虚部Y(t)联合平稳。即X(t)、Y(t)各自平稳且互相关函数与t无关。</p></li><li><p>另一种判断方法：如果复过程的均值、自相关函数、共轭相关函数与t无关，则它是复平稳过程<span class="math display">\[E[Z(t)]=m_Z\quad 均值与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z^*(t)]=R_Z(\tau)\quad 自相关函数与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z(t)]=R_{ZZ^*}(\tau)\quad 共轭相关函数与t无关\]</span></p></li></ul><h3 id="平稳带通过程的解析信号及复包络">2.6平稳带通过程的解析信号及复包络</h3><p>零均值平稳过程X(t)的解析信号是零均值复平稳过程，且共轭不相关（共轭相关函数为0）。<span class="math display">\[解析信号的自相关函数是R_X(\tau)的解析信号的2倍；功率谱密度是P_X(f)正频率部分的4倍。\]</span></p><p><span class="math display">\[R_Z(\tau)=2[R_X(\tau)+j·\widehat{R}_X(\tau)]\]</span></p><p>零均值平稳带通过程X(t)的复包络X<sub>L(</sub>t)=Z(t)e<sup>-j2πf_<sub>c</sub>t</sup>是零均值复平稳过程，且共轭不相关。</p><p>复包络的功率谱密度是P<sub>X</sub>(f)正频率部分的4倍向下搬移。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)是零均值联合平稳，且有相同的功率谱密度及自相关函数。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)在同一时刻不相关。</p><h3 id="平稳序列和循环平稳过程">2.7 平稳序列和循环平稳过程</h3><ul><li><p>随机序列：{X<sub>n</sub>}是无限个随机变量</p></li><li><p>广义平稳序列：{X<sub>n</sub>}的均值及自相关函数与绝对时间n无关<span class="math display">\[E[X_n]=m_X(n)=m_X,\quad n=0,\pm1,\pm2,...\]</span></p><p><span class="math display">\[E[X_{n+m}X_n]=R_X(n+m,n)=R_X(m)\]</span></p></li><li><p>循环（周期）平稳过程：均值与自相关函数是t的周期函数 <span class="math display">\[E[X(t+T)]=E[X(t)]\]</span></p><p><span class="math display">\[E[X(t+T+\tau)X(t+T)]=E[X(t+\tau)X(t)]\]</span></p><p>循环平稳过程不是平稳过程。</p></li></ul><h2 id="高斯噪声">3.高斯噪声</h2><h3 id="高斯过程">3.1 高斯过程</h3><ul><li>高斯（正态）分布：</li></ul><p><span class="math display">\[高斯随机变量X\simN(a,\sigma^2)的概率密度函数为p_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-a)^2}{2\sigma^2}}\]</span></p><ul><li>Q函数：</li></ul><p><span class="math display">\[定义：Q(x)=Pr\{X&gt;x\}=\frac{1}{\sqrt{2\pi}}\int_{x}^{\infty}{e^{-\frac{t^2}{2}}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1)大于x的概率\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/Q函数.png" alt="Q函数"><figcaption aria-hidden="true">Q函数</figcaption></figure><ul><li>erfc函数：</li></ul><p><span class="math display">\[定义：erfc(x)=\frac{2}{\sqrt{\pi}}\int_{x}^{\infty}{e^{-t^2}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1/2),|X|大于x的概率\]</span></p><p><span class="math display">\[erfc(x)=Pr\{|X|&gt;x\}=\int_{x}^{\infty}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\int_{-\infty}^{-x}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/erfc函数.png" alt="erfc函数"><figcaption aria-hidden="true">erfc函数</figcaption></figure><ul><li><p>联合高斯： <span class="math display">\[设Z_1,Z_2,...,Z_n是一组独立同分布的标准正态随机变量，Z_i\simN(0,1)。若X_1,X_2,...,X_k中的每一个都是Z_1,Z_2,...,Z_n以及常数的线性组合，则称X_1,X_2,...,X_k服从联合高斯分布。\]</span></p><p><span class="math display">\[\begin{pmatrix}X_1  \\X_2  \\...  \\X_k  \\\end{pmatrix}=\begin{pmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}  \\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}  \\... &amp;...&amp;...&amp;... \\a_{k1}&amp;a_{k2}&amp;...&amp;a_{kn}  \\\end{pmatrix}\begin{pmatrix}Z_1  \\Z_2  \\...  \\Z_n  \\\end{pmatrix}+\begin{pmatrix}b_1  \\b_2  \\...  \\b_k  \\\end{pmatrix}\]</span>若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，则X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>的各种线性组合也是联合高斯。</p><p>若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，m<sub>1</sub>,m<sub>2</sub>,...,m<sub>k</sub>是常数，则m<sub>1</sub>X<sub>1</sub>,m<sub>2</sub>X<sub>2</sub>,...,m<sub>k</sub>X<sub>k</sub>是联合高斯。</p></li><li><p>高斯过程：设X(t)是随机过程，若对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，X(t<sub>1</sub>),X(t<sub>2</sub>),...X(t<sub>n</sub>)联合高斯，则称X(t)为高斯过程。</p><blockquote><p>随机过程是沿时间排列的无数个随机变量。</p></blockquote><p>设X(t)是高斯过程，m(t)是确定信号，则Y(t)=m(t)X(t)是高斯过程。</p><p>对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，Y(t<sub>i</sub>)=m(t<sub>i</sub>)X(t<sub>i</sub>)。而m(t<sub>1</sub>),m(t<sub>2</sub>),...m(t<sub>n</sub>)是一组确定的系数，故Y(t<sub>1</sub>),Y(t<sub>2</sub>),...Y(t<sub>n</sub>)联合高斯。</p></li></ul><h3 id="高斯白噪声">3.2 高斯白噪声</h3><ul><li>理想限带高斯白噪声：带宽为B的理想限带高斯白噪声n<sub>B</sub>(t)是一种零均值平稳高斯过程。</li></ul><p><span class="math display">\[其功率谱密度为：P_{n_B}(f)=\begin{cases}\frac{N_0}{2}，f\leq B\\0，else\end{cases}\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度.png" alt="功率谱密度"> <span class="math display">\[其自相关函数为：R_{n_B}(\tau)=N_0B·sinc(2B\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数.png" alt="自相关函数"> <span class="math display">\[功率:P=R_{n_B}(0)=\int_{-\infty}^{\infty}{P_{n_B}(f)}df=N_0B\]</span></p><ul><li>高斯白噪声：高斯白噪声是理想限带高斯白噪声的极限：</li></ul><p><span class="math display">\[n_w(t)=\lim_{B\rightarrow+\infty}n_B(t)\]</span></p><p><span class="math display">\[P_{n_w}(f)=\frac{N_0}{2}\]</span></p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度1.png" alt="功率谱密度"> <span class="math display">\[R_{n_w}(\tau)=\frac{N_0}{2}\delta(\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数1.png" alt="自相关函数"></p><h3 id="高斯白噪声与确定信号的内积">3.3 高斯白噪声与确定信号的内积</h3><p>高斯白噪声与确定信号的内积是零均值高斯随机变量，方差为 <span class="math display">\[\frac{N_0}{2}E_g\]</span>高斯白噪声在两个正交确定信号上的内积是两个独立的零均值高斯随机变量。</p><p>高斯白噪声在一组归一化正交函数上的投影是一组独立同分布的高斯随机变量，方差均为N<sub>0</sub>/2。</p><h3 id="窄带高斯噪声的解析信号及复包络">3.4窄带高斯噪声的解析信号及复包络</h3><p>窄带高斯噪声：窄带高斯噪声n(t)就是高斯白噪声通过带通滤波器的输出。n(t)是带通型的零均值平稳高斯过程。<span class="math display">\[解析信号:z(t)=n(t)+j·\widehat{n}(t)\]</span></p><p><span class="math display">\[复包络:n_L(t)=z(t)e^{-j2\pi f_ct}\]</span></p><p><span class="math display">\[同相分量:n_c(t)=Re\{n_L(t)\}\quad 正交分量:n_s(t)=Im\{n_L(t)\}\]</span></p><p><span class="math display">\[根据带通信号的表示方法:n(t)=n_c(t)cos2\pi f_ct-n_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[n(t)的功率谱密度为P_n(f)=\frac{N_0}{2}|H(f)|^2\]</span></p><p>n(t)的解析信号z(t)是零均值平稳复高斯过程，满足共轭不相关。 <span class="math display">\[z(t)的功率谱密度为P_Z(f)=\begin{cases} 4P_n(f),f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><h3 id="窄带高斯噪声的同相分量及正交分量">3.5窄带高斯噪声的同相分量及正交分量</h3><p>n(t)的同相分量n<sub>c</sub>(t)、正交分量n<sub>s</sub>(t)是联合平稳的零均值高斯过程，二者有相同的自相关函数和功率谱密度，在同一时刻独立。</p><blockquote><p>对于高斯过程，不相关等于独立。</p></blockquote><p><span class="math display">\[三者有相同的功率:P_{n_c}=P_{n_s}=P_{n}\]</span></p><p>n<sub>c</sub>(t)与n<sub>s</sub>(t)有相同的功率谱密度： <span class="math display">\[P_c(f)=P_s(f)=P_n(f+f_c)+P_n(f-f_c)\]</span> n(t)的包络A(t)服从瑞利分布，相位φ(t)服从均匀分布。</p><h1 id="四模拟通信系统">四、模拟通信系统</h1><p>模拟信号m(t)是模仿物理量变化的电信号，m(t)一般的特征：时间连续、取值连续。</p><blockquote><p>默认m(t)不包含直流分量，频域就体现为频谱不含f=0处的冲击δ(f)</p></blockquote><p>模拟基带信号的传输：</p><ul><li><p>基带传输： <span class="math display">\[\xrightarrow{m(t)} \boxed{基带信道}\to\]</span></p></li><li><p>频带传输: <span class="math display">\[\xrightarrow{m(t)}\boxed{调制器}\xrightarrow{s(t)}\boxed{带通信号}\xrightarrow{}\boxed{解调器}\xrightarrow{}\]</span></p></li><li><p>数字化传输： <span class="math display">\[\xrightarrow{m(t)}\boxed{数字化}\xrightarrow{}\boxed{数字传输}\xrightarrow{}\boxed{还原}\xrightarrow{}\]</span></p></li></ul><p>本章假设理想无失真信道；无失真：波形不变，可以有延迟，可以有幅度变化；默认假设K=1、t<sub>0</sub>=0。<span class="math display">\[s(t)\xrightarrow{}\boxed{信道}\xrightarrow{}K·s(t-t_0)\]</span> 系统模型：称m(t)为调制信号，称s(t)为已调信号。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/系统模型.png" alt="系统模型"><figcaption aria-hidden="true">系统模型</figcaption></figure><p>模拟调制的基本思路：</p><ul><li><p>目标：发送端：把基带信号m(t)变成带通信号s(t)；</p><p>​ 接收端：从带通信号s(t)中恢复出m(t)。</p></li><li><p>思路：发送端：让s(t)的复包络s<sub>L</sub>(t)携带m(t);</p><p>​ 接收端：先取复包络，再恢复m(t)。</p></li></ul><p>模拟调制的典型方法：</p><ul><li><p>幅度类调制：复包络就是m(t)—DSB-SC</p><p>​ 包络携带m(t)—AM</p><p>​ 复包络的实部是m(t)—SSB</p></li><li><p>角度类调制：复包络的相位φ(t)与mO(t)成比例—PM</p><p>​ φ(t)的斜率与m(t)成比例—FM</p></li></ul><p>关键性能指标：</p><ul><li><p>发送端：已调信号的带宽及频谱特征，涉及对频谱资源的耗费情况。</p></li><li><p>接收端：输出信噪比： <span class="math display">\[\Big(\frac{S}{N}\Big)_o=\frac{\overline{m^2(t)}}{E[n^2_o(t)]}\]</span> 涉及对功率资源的耗费情况。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
