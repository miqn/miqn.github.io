<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>通信网性能分析</title>
    <link href="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>2023/6/15 10:53 今天开始网络理论基础课程的复习及知识整理。</p><p>2023/6/21 23:14 今天下午总算考完这门课，我也在今天晚上完成了通信网性能分析这门课知识的总结。另外说一句，今晚一边整理，一边发现今天下午考试时写错的，这种感觉真是苦不堪言啊......ps：明天开始高数的知识点梳理。</p><h1 id="一通信信源模型">一、通信信源模型</h1><h2 id="泊松过程">1.泊松过程</h2><p>对于Poisson呼叫流，长度为t的时间内到达k个呼叫的概率<span class="math inline">\(P_k(t)\)</span>服从Poisson分布，即 <span class="math display">\[p_k(t)=\frac{(\lambda t)^k}{k!}e^{-\lambda t}\qquad k=0,1,2,......\]</span> Poisson分布的均值：<span class="math inline">\(E[N(t)]=\lambda t\)</span></p><p>Poisson分布的方差：<span class="math inline">\(Var[N(t)]=\lambda t\)</span></p><p>m个Poisson流的参数分别为<span class="math inline">\(\lambda_1,\lambda_2,......,\lambda_m,\)</span>并且它们是相互<strong>独立</strong>的，合并流仍然为Poisson流，且参数为<span class="math inline">\(\lambda=\lambda_1+\lambda_2+...+\lambda_m\)</span>。</p><p>一个随机过程是参数 λ 的Poisson过程的充分必要条件为呼叫到达间隔<span class="math inline">\(X_i,i=1,2...\)</span>相互独立，且服从相同参数 λ 的负指数分布。</p><h2 id="负指数分布">2.负指数分布</h2><p>随机变量X满足<span class="math inline">\(P\{X\ge t\}=e^{-\lambda t}\)</span>，或分布函数为：<span class="math inline">\(P\{X&lt;t\}=1-e^{-\lambda t},t\ge0\)</span>，则这个分布被称之为参数为λ的<strong>负指数分布</strong>。</p><p>这个分布的概率密度函数为：<span class="math inline">\(f_x(t)=\lambda e^{-\lambda t},t\ge0\)</span></p><p>负指数分布的均值：<span class="math inline">\(E[X]=\frac{1}{\lambda}\)</span></p><p>负指数分布的均值：<span class="math inline">\(Var[X]=\frac{1}{\lambda^2}\)</span></p><p>负指数分布具有无记忆特性：<span class="math inline">\(P\{X\ge t+s|X\ge t\}=P\{X\ge s\}\)</span></p><p>假设<span class="math inline">\(T_1,T_2\)</span>为<strong>相互独立的</strong>两个负指数分布，参数分别为<span class="math inline">\(\lambda_1,\lambda_2\)</span>，令<span class="math inline">\(T=min(T_1,T_2)\)</span>则：</p><ol type="1"><li><p>T 是一个以<span class="math inline">\(\lambda_1+\lambda_2\)</span>为参数的负指数分布；</p></li><li><p>T 的分布和<span class="math inline">\(T_i\)</span>谁是较小数无关；</p></li><li><p><span class="math inline">\(P\{T_1&lt;T_2|T=t\}=\frac{\lambda_1}{\lambda_1+\lambda_2}\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621204746403.png" style="zoom:80%;"></p></li></ol><h2 id="mm1排队系统">3.M/M/1排队系统</h2><h3 id="排队系统性能指标">3.1 排队系统性能指标</h3><p><em>λ</em>：排队系统到达率</p><p><span class="math inline">\(\mu\)</span>：服务率（离去率）</p><p>k：队长（系统中的顾客数）</p><p><span class="math inline">\(\omega\)</span>：等待时间</p><p><span class="math inline">\(\tau\)</span>：服务时间</p><p>s=<span class="math inline">\(\omega+\tau\)</span>：系统时间</p><p>η：系统效率</p><p><span class="math inline">\(\rho=\frac{\lambda}{\mu}\)</span></p><h3 id="mm1">3.2 M/M/1</h3><p>根据生灭过程的性质：<span class="math inline">\(p_k=\rho^kp_0\)</span></p><p>在<span class="math inline">\(\rho&lt;1\)</span>时，两边求和得到： <span class="math display">\[p_0=\frac{1}{1+\sum_{k=1}^{\infty}\rho^k}=1-\rho\]</span> M/M/1的队长分布：<span class="math inline">\(p_k=\rho^k(1-\rho)\qquad k=0,1,2,...\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200225503.png" alt="M/M/1的状态转移图" style="zoom: 80%;"></p><p>N：系统中的平均顾客数</p><p>T：顾客在系统中的平均时间 <span class="math display">\[平均队长:E[N]=\frac{\rho}{1-\rho}\]</span></p><p><span class="math display">\[Var[N]=\frac{\rho}{(1-\rho)^2}\]</span></p><p><span class="math display">\[在系统中的平均停留时间:E[s]=\frac{\frac{\rho}{1-\rho}}{\lambda}=\frac{1}{\mu-\lambda}\]</span></p><p><span class="math display">\[平均排队时间:E[\omega]=E[s]-\frac{1}{\mu}=\frac{\rho}{1-\rho}\frac{1}{\mu}\]</span></p><p><span class="math display">\[平均等待队长:E[N_w]=\lambda E[\omega]=\frac{\rho}{1-\rho}\frac{\lambda}{\mu}\]</span></p><p>M/M/1排队系统在稳态时，系统时间 s 服从参数为<span class="math inline">\(\mu-\lambda\)</span>的负指数分布。</p><h1 id="二erlang拒绝和等待系统">二、Erlang拒绝和等待系统</h1><p>呼叫量=业务量/观察时间</p><p>呼叫量的单位为erl，这是一个无量纲的单位。</p><p>实际上，在一段时间T内通过的呼叫量就是该时段内被占用的平均中继线数目。</p><h2 id="erlang即使拒绝系统mmss">1.Erlang即使拒绝系统——M/M/s(s)</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200329406.png" alt="M/M/s(s)的状态转移图" style="zoom: 67%;"></p><p>令<span class="math inline">\(a=\frac{\lambda}{\mu}\)</span>，则<span class="math inline">\(p_k=\frac{a^k}{k!}p_0\qquad k=1,2,...,s\)</span></p><p>两边求和解得： <span class="math display">\[p_0=\frac{1}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 稳态分布为： <span class="math display">\[p_k=\frac{\frac{a^k}{k!}}{\sum_{r=0}^{s}\frac{a^r}{r!}}\qquad k=0,1,2,...,s\]</span> 特别，当k＝s 时，p<sub>s</sub>表达了中继线全忙的概率，这个概率为系统的时间阻塞率，记为 <span class="math display">\[p_s=B(s,a)=\frac{a^s/s!}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 通过的呼叫量：<span class="math inline">\(a&#39;=a[1-B(s,a)]\)</span></p><h2 id="erlang等待制系统mms">2.Erlang等待制系统—M/M/S</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615210209146.png" alt="M/M/S状态转移图" style="zoom: 80%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620225521649.png" alt="等待制系统分析" style="zoom: 67%;"></p><p><span class="math display">\[p_0=\frac{1}{\sum_{k=0}^{s-1}\frac{a^k}{k!}+\frac{a^s}{s!}\frac{1}{1-a/s}}\]</span> 一个呼叫需要等待的概率： <span class="math display">\[C(s,a)=\frac{a^s}{s!}\frac{p_0}{1-a/s}\]</span> 在a&lt;s的条件下：</p><p>通过的呼叫量：<span class="math inline">\(a&#39;=a\)</span></p><p>系统中的平均呼叫数：<span class="math inline">\(E[N]=\frac{\rho}{1-\rho}C(s,a)+a\qquad \rho=a/s\)</span></p><p>系统中的平均呼叫数为a，等待队列中的平均呼叫数为<span class="math inline">\(\frac{\rho}{1-\rho}C(s,a)\)</span></p><p>平均等待时间：<span class="math inline">\(E[\omega]=[\frac{\rho}{1-\rho}C(s,a)]/\lambda=\frac{C(s,a)}{s\mu(1-\rho)}\)</span></p><p>等待时间的分布：<span class="math inline">\(p\{\omega&gt;t\}=C(s,a)e^{-(s\mu-\lambda)t}\)</span></p><h2 id="一般混合制的mmsn系统">3.一般混合制的M/M/S(n)系统</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620231245977.png" alt="M/M/S(n)系统分析" style="zoom:67%;"></p><h1 id="三通信网络性能分析">三、通信网络性能分析</h1><h2 id="wilkinson定理算溢出呼叫流的统计特征">1.Wilkinson定理算溢出呼叫流的统计特征</h2><p><span class="math display">\[\alpha=aB(s,a)\qquad v=\alpha(1-\alpha+\frac{a}{s+1+\alpha-a})\]</span></p><blockquote><p>上面是溢出呼叫流和溢出呼叫流的方差</p></blockquote><p><span class="math display">\[峰值因子:z=\frac{v}{\alpha}\]</span></p><h2 id="呼损的近似计算方法rapp">2.呼损的近似计算方法Rapp</h2><ol type="1"><li><p>计算<span class="math inline">\(z=\frac{v}{\alpha}\)</span></p></li><li><p>令<span class="math inline">\(a=v+3z(z-1)\)</span> <span class="math display">\[然后,s=\frac{a(\alpha+z)}{\alpha+z-1}-\alpha-1\]</span> 但s一般不为整数，向下取整，记为[s]</p></li><li><p>重新计算： <span class="math display">\[a=\frac{([s]+\alpha+1)(\alpha+z-1)}{\alpha+z}\]</span></p></li><li><p>计算等效系统的呼损和拒绝的呼叫量<span class="math inline">\(B(s+c,a)\)</span>和<span class="math inline">\(aB(s+c,a)\)</span></p></li></ol><h1 id="四网络拓扑结构分析">四、网络拓扑结构分析</h1><h2 id="图论基础">1.图论基础</h2><h3 id="图的定义和基本概念">1.1 图的定义和基本概念</h3><p>图：所谓一个图G，是指给了一个端点集合V，以及边的集合或V中元素的序对集合E，图一般用G=(V,E)来表示。</p><p>端的度数：</p><ul><li>对无向图的端<span class="math inline">\(v_i\)</span>，与该端关联边的数目为该端的度数，记为：<span class="math inline">\(d(v_i)\)</span>。</li><li>对有向图的端<span class="math inline">\(v_i\)</span>，<span class="math inline">\(d^+(v_i)\)</span>表示离开<span class="math inline">\(v_i\)</span>的边数，<span class="math inline">\(d^-(v_i)\)</span>表示进入<span class="math inline">\(v_i\)</span>的边数。</li></ul><p>给定图G=(V,E)，若<span class="math inline">\(V_1\subseteq V,E_1=\{(u,v)\in E|u,v\in V_1\}\)</span>称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(V_1\)</span>生成的<strong>子图</strong>，记<span class="math inline">\(G[V_1]\)</span>。</p><p>特别，若子图的端点集合为V，这个图被称为图G的<strong>支撑子图</strong>。</p><p>若<span class="math inline">\(E_1\subseteq E,V_1=\{V\in V|v是E_1中某边的端点\}\)</span>， 称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(E_1\)</span>生成的子图，记为<span class="math inline">\(G[E_1]\)</span>。</p><p>考虑边的一个序列，相邻两边有公共端，如(v1，v2)， (v2，v3)， (v3，v4)，…… (vi ，vi+1)，这个边序列称为<strong>链</strong>，链简单说就是一个连续轨迹。</p><p>没有重复边的链称为简单链；没有重复端的链称为初等链或<strong>道路</strong>。</p><p>若链的起点与终点重合，称之为<strong>圈</strong>；若道路的起点与终点重合,称之为<strong>初等圈</strong>。</p><p>任何两端间至少存在一条链的图，为<strong>连通图</strong>。否则，就是非连通图。</p><h3 id="树">1.2 树</h3><p>树的定义：</p><ul><li>任何二端有且只有一条道路的图称为树。</li><li>无圈的连通图称为树。</li></ul><p>如果树T是连通图G的子图，<span class="math inline">\(T\subseteq G\)</span>，且T包含G的所有端，称T是G的<strong>支撑树或主树</strong>。</p><p>树边，连枝：如果在一个连通图中确定了一个支撑树，图的边集合被分为两类，属于树的边称为树边；不属于树的边称为连枝。</p><h3 id="割集">1.3 割集</h3><p><strong>割集</strong>指的是某些端集或边子集，对连通图，去掉此类子集，图变为不连通（即图变成一个点）。</p><p>设v是图G的一个端，去掉<mark>v和其关联边</mark>后，G的部分数增加（或图变成一个点），则称v是图G的<strong>割端</strong>。</p><p>去掉一个端集合后，G的部分数增加，这个端的集合称为<strong>割端集</strong>。</p><p>对于连通图, 在众多的割端集中至少存在一个端数最少的割端集，称为<strong>最小割端集</strong>。</p><p>最小割端集的端数目，称为图的<strong>点连通度或连通度</strong>，连通度用a 表示。</p><p>设e是图G的一条边，去掉 e 后，G的部分数增加，则称e是图G的<strong>割边</strong>。去掉一个边集合后，G的部分数增加，这个边的集合称为<strong>割边集</strong>。</p><p>割边集中边数最少的割边集，称为<strong>最小割边集</strong>。最小割边集的边数目，称为<strong>线连通度</strong>，线连通度用β 表示。</p><p>确定了连通图的一个支撑树后，每条树边可以决定一个基本割集。</p><p>对于支撑树，去掉<strong>树</strong>上任何一条边，<strong>树</strong>便分为两个连通分支，从而将原图的<strong>端</strong>分为两个集合，这两个集合之间的所有<strong>边</strong>形成一个极小边割集，这个边割集称为<strong>基本割集</strong>。</p><blockquote><p>基本割集数等于树支数。</p></blockquote><p>对于任何一个连通图G，设T为G的一个支撑树，每一条连枝决定的圈是<strong>基本圈</strong>。</p><blockquote><p>基本圈的个数等于连枝数。</p></blockquote><p>反圈：给定图G=(V,E)，<span class="math inline">\(S,T\subseteq V\)</span>，记<span class="math inline">\([S,T]_G=\{(u,v)\in E|u\in S,v\in T \}\)</span>；特别，当T=V，将<span class="math inline">\([S,T]_G\)</span>记为<span class="math inline">\(\Phi_G(S)\)</span>或<span class="math inline">\(\Phi(S)\)</span>。设X是V的非空真子集，若<span class="math inline">\(\Phi_G(X)\not=\phi\)</span>，称<span class="math inline">\(\Phi_G(X)\)</span>为由X确定的反圈。</p><blockquote><p>反圈是一种特殊的边割集。</p></blockquote><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="最小支撑树">2.1 最小支撑树</h3><h4 id="prim算法反圈法">2.1.1 Prim算法－反圈法</h4><ol type="1"><li>任取一点作为初始的<span class="math inline">\(X^{(0)}\)</span>；</li><li>在反圈<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选边的原则是：<ul><li>从<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选一条权最小的边（如果有多条权最小的边，则任选一条）；</li><li>将选出边的邻端并入<span class="math inline">\(X^{(k)}\)</span>形成<span class="math inline">\(X^{(k+1)}\)</span>；</li></ul></li><li>若在某一步，<span class="math inline">\(\Phi[X^{(k)}]=\phi\)</span>，则G不含支撑树；若在某一步，<span class="math inline">\(X^{(k)}=V\)</span>，则由所有被选边生成的树是最小支撑树。</li></ol><h4 id="kruskal算法避圈法">2.1.2 Kruskal算法－避圈法</h4><p>将所有边排序，然后由小到大选边，保持所选的边不生成圈，如果选了n－1条边，则生成了一个最小支撑树。</p><h4 id="破圈法">2.1.3 破圈法</h4><p>从连通图中先寻找圈，然后在圈中删去权最大的边，最后剩下的无圈连通图为最小支撑树。</p><h3 id="端间最短距离和路由">2.2 端间最短距离和路由</h3><h4 id="dijkstra算法">2.2.1 Dijkstra算法</h4><p>在下图中求<span class="math inline">\(v_1\)</span>到其余端点的最短距离和路由：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230618194227852.png" alt style="zoom:50%;"></p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(v_1\)</span></th><th style="text-align: center;"><span class="math inline">\(v_5\)</span></th><th style="text-align: center;"><span class="math inline">\(v_2\)</span></th><th style="text-align: center;"><span class="math inline">\(v_3\)</span></th><th style="text-align: center;"><span class="math inline">\(v_4\)</span></th><th style="text-align: center;">置定端<span class="math inline">\(l_0\)</span></th><th style="text-align: center;">距离<span class="math inline">\(\lambda_{l_0}\)</span></th><th style="text-align: center;">路由<span class="math inline">\(i_0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">6</td><td style="text-align: center;">V3</td><td style="text-align: center;">2</td><td style="text-align: center;">V1</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V2</td><td style="text-align: center;">3</td><td style="text-align: center;">V3</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V4</td><td style="text-align: center;">5</td><td style="text-align: center;">V3</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V5</td><td style="text-align: center;">6</td><td style="text-align: center;">V2</td></tr></tbody></table><h4 id="floyd算法">2.2.1 Floyd算法</h4><ul><li><p>给定图G及其边(i,j)的权<span class="math inline">\(w_{i,j}\)</span></p></li><li><p><span class="math inline">\(F_0\)</span>：初始化距离矩阵<span class="math inline">\(W^{(0)}\)</span>和路由矩阵<span class="math inline">\(R^{(0)}\)</span></p><ul><li><p><span class="math display">\[w_{ij}^{(0)}=\begin{cases}w_{ij} &amp;\text{若 $e_{ij}\in E$}\\\infty &amp;\text{若 $e_{ij}\not\in E$}\\0 &amp;\text{若 $i=j$}\\\end{cases}\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(0)}=\begin{cases}j &amp;\text{若 $w_{ij}^{(0)}\not=\infty,0$}\\0 &amp;\text{其它}\\\end{cases}\]</span></p></li></ul></li><li><p>迭代</p><ul><li><p><span class="math display">\[w_{i,j}^{(k)}=min(w_{i,j}^{(k-1)},w_{i,k}^{(k-1)}+w_{k,j}^{(k-1)})\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(k)}=\begin{cases}r_{i,k}^{(k-1)}&amp;\text{若 $w_{i,j}^{(k)}&lt;w_{i,j}^{(k-1)}$}\\r_{i,j}^{(k-1)} &amp;\text{若$w_{i,j}^{(k)}=w_{i,j}^{(k-1)}$}\\\end{cases}\]</span></p></li></ul></li><li><p>根据<span class="math inline">\(R^{(n)}\)</span>进行路由查找。</p></li><li><p>根据<span class="math inline">\(W^{(n)}\)</span>求图的中心与中点</p><ul><li>中心：先找每行最大值，再找里面最小的；</li><li>中点：先每行求和，再找里面最小的。</li></ul></li></ul><p>例：利用F算法求v2到 v4的最短距离和正向路由，并求网的中心和中点。</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621213119808.png" alt="例题解答"><figcaption aria-hidden="true">例题解答</figcaption></figure><p><span class="math inline">\(v_2\)</span>到<span class="math inline">\(v_4\)</span>的最短距离为4，正向路由为<span class="math inline">\(v_2\to v_1\to v_4\)</span>。</p><h2 id="网络流量问题">3.网络流量问题</h2><p>可行流的两个限制条件：</p><ol type="1"><li><p>非负有界性：对任意边<span class="math inline">\(e_{i,j}\)</span>有，<span class="math inline">\(0\le f_{i,j}\le c_{i,j}\)</span></p></li><li><p>连续性：对任意端<span class="math inline">\(v_t\)</span>有， <span class="math display">\[\sum_{(i,j)\in E}^{}f_{ij}-\sum_{(j,i)\in E}^{}f_{ji}=\begin{cases}F &amp;\text{$v_i$为源端$v_s$}\\-F &amp;\text{$v_i$为源端$v_t$}\\0 &amp;\text{其他}\\\end{cases}\]</span></p></li></ol><p>割量<span class="math inline">\(C(X,X^c)\)</span>定义为这个割集中所有边容量的和。</p><p>对于某条流，若在某条路中，前向边均不饱和（<span class="math inline">\(f_{i,j}&lt;c_{i,j}\)</span>），反向边均有非0流量（<span class="math inline">\(f_{j,j}\not=0\)</span>），称这条路为<strong>可增流路</strong>。</p><h3 id="最大流问题m算法">3.1 最大流问题—M算法</h3><p>例：利用M算法计算下图的最大流结果</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621215552636.png" alt="题目所给网络" style="zoom:80%;"></p><p>①标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_A(+,S,5)\)</span>，标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_A\)</span>：标<span class="math inline">\(V_C(+,A,5)\)</span>，<span class="math inline">\(V_A\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,5)\)</span></p><p>增流：<span class="math inline">\(f_{SA}=5,f_{AC}=5,f_{CT}=5\)</span></p><p>②重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,4)\)</span>，标<span class="math inline">\(V_D(+,B,4)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,3)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3,f_{BC}=3,f_{CT}=3\)</span></p><p>③重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,1)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,1)\)</span>，标<span class="math inline">\(V_D(+,B,1)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,D,1)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3+1,f_{BD}=1,f_{DT}=1\)</span></p><p>故最大可行流为5+3+1=9。</p><h3 id="最小费用流问题负价环法算法">3.2 最小费用流问题—负价环法算法</h3><p>例：图(a)为该通信网，一个可行流安排如图(b)，求最小费用流的流量安排。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222102785.png" alt="图(a)" style="zoom: 67%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222213322.png" alt="图(b)" style="zoom:67%;"></p><ol type="1"><li><p>图(b)的总费用为54，其补图为图(c)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120016583.png" alt="图(c)" style="zoom:67%;"></p><p>找到负圈(B,C,T,D)，沿其增流2单位，总费用减2×(-1)=-2</p><p>可行流为图(d)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621223124406.png" alt="图(d)" style="zoom:67%;"></p></li><li><p>图(d)的补图为图(e)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120102209.png" alt="图(e)" style="zoom:67%;"></p><p>找到负圈(A,C,B,S)，沿其增流1单位，总费用减1×(-1)=-1。</p><p>可行流为图(f)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120152137.png" alt="图(f)" style="zoom:67%;"></p></li><li><p>图(f)的补图为图(g)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120218809.png" alt="图(g)" style="zoom:67%;"></p><p>已找不到负圈，最小费用为51。</p></li></ol><h1 id="五网络可靠性分析">五、网络可靠性分析</h1><h2 id="可靠性理论基础">1.可靠性理论基础</h2><h3 id="寿命分布和失效率函数">1.1 寿命分布和失效率函数</h3><h3 id="寿命分布和可靠度">1.1.1 寿命分布和可靠度</h3><p>首先，考虑子系统的可靠性特点，然后考虑子系统依照不同方法构成的大系统的可靠性。</p><p>对于简单系统，假设它仅包含两个状态：正常和故障。如果用一个非负随机变量X来描述系统的寿命，X相应的分布函数为：</p><p><span class="math display">\[F(t)=P\{X \le t \}\]</span> 有了寿命分布，就知道了在时刻t以前都正常的概率： <span class="math display">\[R(t)=P\{X &gt; t \}=1-F(t)\]</span> 而R(t)表示系统的可靠度函数或可靠度。</p><p>平均寿命为： <span class="math display">\[E(X)=\int_{0}^{\infty}R(t)dt\]</span></p><h4 id="失效率函数">1.1.2 失效率函数</h4><p>设系统的寿命为非负连续型随机变量，其分布函数为F(t)，密度函数为f(t)，定义失效率函数如下： <span class="math display">\[对任意t,F(t)&lt;1, 失效率函数（简称失效率）:r(t)=\frac{f(t)}{1-F(t)}\]</span> 因系统在t时刻正常，在(t,t+△t]中失效的概率为： <span class="math display">\[P\{X \le t+\varDelta t|X&gt;t\}\frac{F(t+\varDelta t)-F(t)}{1-F(t)} \sim\frac{f(t)\varDelta t}{1-F(t)}=r(t)\varDelta t\]</span> 当△t很小时，r(t)△t表示在(t,t+△t]中失效的概率。</p><p>下图中表示了典型的失效率函数，也被称之为浴盆曲线：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615113134324.png" alt="浴盆曲线" style="zoom: 67%;"></p><h3 id="不可修复系统和可修复系统">1.2 不可修复系统和可修复系统</h3><p>如果一个子系统在故障后，不再修复，这个子系统称之为不可修复系统。</p><p>如果一个子系统在故障后，经历一段时间，修复又重新使用，如此循环往复，这种系统称之为可修复系统。</p><p>可修复系统和不可修复系统的区分并不是绝对的，在一定条件下它们可以相互转换。</p><h4 id="不可修复系统">1.2.1 不可修复系统</h4><p>对于不可修复系统，可靠性的重要指标为其寿命分布X和可靠度函数R(t)。若失效率函数为常数α，X服从负指数分布，则 <span class="math display">\[R(t)=P\{X&gt;t\}=e^{-\alpha t}\]</span> 不可修复系统的平均寿命记为MTTF， <span class="math display">\[MTTF=\frac{1}{\alpha}\]</span> 一般地，系统的失效率函数不为常数，设为r(t)，则可靠度： <span class="math display">\[R(t)=e^{-\int_{0}^{t}r(x)dx}\]</span></p><h4 id="可修复系统">1.2.2 可修复系统</h4><p>对于可修复系统，系统处于故障、正常的循环交替中。系统的可靠度有时也被称为<strong>可用度</strong>，它表示在总时间中有多少比例的时间系统处于正常状态，其可靠度R应与时间t无关， <span class="math display">\[R=\frac{正常时间}{总时间}\]</span></p><h4 id="平均故障间隔时间mtbf和平均修复时间mttr">1.2.3 平均故障间隔时间MTBF和平均修复时间MTTR</h4><p>可修复系统在故障之后，其修复时间的分布有多种类型。</p><p>下面假设系统的修复时间为参数β的负指数分布，系统正常工作时间为参数α的负指数分布，若R(t)为可靠度函数，则 <span class="math display">\[R(t)=\frac{\beta}{\alpha+\beta}+\frac{\alpha}{\alpha+\beta}e^{-(\alpha+\beta)t}\]</span></p><p><span class="math display">\[在t\rightarrow\infty时,R(t)=R=\frac{\beta}{\alpha+\beta}或\frac{\frac{1}{\alpha}}{\frac{1}{\alpha}+\frac{1}{\beta}}\]</span></p><p>1/α为平均故障间隔时间，一般记为MTBF；</p><p>1/β为平均修复时间，一般记为MTTR。</p><p>同时β也被称为修复率。</p><p>对于可修复系统可以利用实测数据来估计它的可用度；而对于不可修复系统，容易根据实测数据获得可靠度的估计值，从而得到寿命分布函数。</p><h3 id="复杂系统的可靠度">1.3 复杂系统的可靠度</h3><p>子系统可以依照不同的方法构成大系统，最简单的如串接、并接。在下图中分别表示了串接、并接系统。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615143534212.png" alt="串接、并接系统" style="zoom: 67%;"></p><p>如果n个子系统只要有一个子系统故障，整个系统就故障，n个子系统就构成一个串接系统。</p><p>如果n个子系统只要有一个子系统正常，整个系统就正常，n个子系统就构成一个并接系统。</p><h5 id="独立系统可靠度计算">独立系统可靠度计算:</h5><p>当各个子系统独立时，串、并接系统的可靠度分别计算如下： <span class="math display">\[R_串=\prod_{i=1}^{n}R_i\]</span></p><p><span class="math display">\[R_并=1-\prod_{i=1}^{n}(1-R_i)\]</span></p><p>已知各子系统的可靠度R<sub>i</sub>总是小于1的，则串接系统的可靠度必小于任一子系统的可靠度。串接子系统愈多，可靠度也将愈小。</p><p>并接系统中的子系统愈多，系统的可靠度愈高。实际上这是采用备用系统的结果。备用系统愈多，当然愈不会失效。</p><h5 id="不可修复子系统的串接">不可修复子系统的串接：</h5><p>例如一个系统是由n个不可修复的子系统组成的串接系统，各子系统均相同，失效率均为α，或平均寿命均为1/α，则此系统的可靠度将为：<span class="math inline">\(R(t)=e^{-nat}\)</span> 其平均寿命将为1/nα，即缩短到1/n。</p><p>当各不可修复的子系统有不同失效率α<sub>r</sub>时，可得全系统的可靠度为：<span class="math inline">\(R(t)=e^{-t\sum_{r=1}^{n}\alpha_r}\)</span></p><p>平均寿命为： <span class="math display">\[T=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 等效失效率为：<span class="math inline">\(\alpha=1/T\)</span></p><h5 id="非独立系统可靠度">非独立系统可靠度：</h5><p>n个子系统串接形成一个系统，每个子系统为可修复系统，其可靠度为<span class="math inline">\(\frac{\beta_i}{\alpha_i+\beta_i}\)</span>，但当某个子系统故障时，别的子系统停顿，等故障子系统修复后，其它子系统继续一起工作，求系统可靠度R。</p><p>若第r个子系统失效，平均修复时间为：<span class="math inline">\(1/\beta_r\)</span></p><p>各子系统的失效概率应与它的失效率α<sub>r</sub>成正比，第r个系统失效的概率为： <span class="math display">\[p_r=\frac{\alpha_r}{\sum_{k=1}^{n}\alpha_k}\]</span> 全系统的平均修复时间为： <span class="math display">\[MTTR=\sum_{r=1}^{n}\frac{p_r}{\beta_r}=\frac{\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}{\sum_{r=1}^{n}\alpha_r}\]</span> 平均故障间隔时间为： <span class="math display">\[MTBF=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 全系统的可靠度为： <span class="math display">\[R&#39;=\frac{MTBF}{MTBF+MTTR}=\frac{1}{1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}\]</span> 各子系统独立时的可靠度： <span class="math display">\[R=\prod_{r=1}^{n}\frac{\beta_r}{\alpha_r+\beta_r}=\frac{1}{\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})}\]</span> 许多子系统停止了不必要的运行：R'&gt;R <span class="math display">\[\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})&gt;1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}\]</span></p><h5 id="不可修复子系统的并接">不可修复子系统的并接：</h5><p>若各子系统都是不可修复的，全系统的可靠度为： <span class="math display">\[R(t)=1-\prod_{i=1}^{n}[1-R_r(t)]=1-\prod_{i=1}^{n}(1-e^{-\alpha_rt})=\sum_{r=1}^{n}e^{-\alpha_rt}-\sum_{r_1\not=r_2}^{}e^{-(\alpha_{r1}+\alpha_{r2})t}+\sum_{r_1\not=r_2\not=r_3}^{}e^{-(\alpha_{r1}+\alpha_{r2}+\alpha_{r3})t}-...\]</span> 平均寿命为：<span class="math inline">\(T=\sum_{r=1}^{n}\frac{1}{\alpha_r}-\sum_{r_1\not=r_2}^{}\frac{1}{\alpha_{r1}+\alpha_{r2}}+...\)</span></p><p>若各子系统的失效率均为α，则平均寿命为：<span class="math inline">\(T=\frac{n}{\alpha}-\frac{1}{2\alpha}C_n^2+\frac{1}{3\alpha}C_n^3-...+(-1)^n\frac{1}{n\alpha}\)</span></p><h2 id="网络可靠度的计算">2.网络可靠度的计算</h2><p>若考虑连通无向图G=(V,E)，<strong>点连通度α</strong>与<strong>线连通度β</strong>反映了图的可靠性大小，下面再定义一个混合连通度γ，其定义如下</p><p><span class="math inline">\(γ=min|X|\)</span>，其中X为混合割集。则<span class="math inline">\(\alpha=\gamma\le \beta\le \delta\le \frac{2m}{n}\)</span></p><p>为了更加细致地描述图的可靠性，引入三个辅助指标。它们的定义如下：</p><ul><li>C<sub>α</sub> = 最小割端集的数目；</li><li>B<sub>β</sub> = 最小割边集的数目；</li><li>A<sub>γ</sub> = 最小混合割集的数目；</li></ul><p>例题：<img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230044115.png" alt="题目" style="zoom:80%;"></p><p>解：</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230104150.png" alt="端和边的个数"><figcaption aria-hidden="true">端和边的个数</figcaption></figure><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230218619.png" alt="混合割集" style="zoom:80%;"> <span class="math display">\[\alpha=3,\beta=3,\gamma=3\]</span></p><p><span class="math display">\[C_\alpha=60,B_\beta=60,A_\gamma=60+60+60*3+90*2=480\]</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230502255.png" alt="近似可靠度" style="zoom: 50%;"></p><h2 id="网络综合可靠度">3.网络综合可靠度</h2><p><strong>通信网的各种连通度以及一些辅助指标</strong>，这些指标仅仅依赖于拓扑结构，是对可靠性的<strong>确定性度量</strong>。</p><p>为了<strong>进一步</strong>分析网络的可靠度，需要考虑<strong>网络承载的业务</strong>。</p><p>考虑<strong>故障因素</strong>的电话网络平均呼损也可被称之为<strong>综合不可靠度</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信网，泊松分布，数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生物信息学</title>
    <link href="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    <url>/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>2023/6/14 12:15 昨天结束了生物信息基础的期末考试，而在今天终于把生物信息学的知识整理完毕，历时一个星期，收工！</p><h1 id="一序列分析">一、序列分析</h1><h2 id="序列的相似性">1.序列的相似性</h2><h3 id="序列比较">1.1 序列比较</h3><p>序列比较是生物信息学中最基本、最重要的操作。通过序列比较可以发现生物序列中的结构、功能和进化的信息。找出具有生物学意义的相似性或差异，研究序列的同源性。</p><ul><li>同源（homology）: 两个序列有共同的祖先。</li><li>垂直同源序列：来自于不同种属的的同源序列，也叫直系同源</li><li>横向同源序列：来自于同一种属的序列，由进化过程中的序列复制而产生，也叫旁系同源。</li></ul><p>同源序列一般是相似的，相似序列不一定是同源的。</p><p>序列比较的基本任务：</p><ul><li>计算序列之间的<strong>相似性</strong></li><li>找出序列之间的<strong>共同区域</strong></li><li>辨别序列之间的<strong>差异</strong></li></ul><h3 id="子序列和字串">1.2 子序列和字串</h3><p>子序列的描述</p><ul><li>子序列 <sub>0</sub>:s:<sub>i</sub> 称为前缀，即prefix(s,i)</li><li>子序列 <sub>i</sub>:s:<sub>|s|</sub>称为后缀，即suffix(s, |s|-i)</li><li><sub>i</sub>:s: <sub>i</sub> — 为空序列</li><li><sub>j-1</sub>:s:<sub>j</sub> —表示s 中的第j 个字符，简记为s<sub>j</sub></li></ul><p>子序列：选取s中的某些字符或删除s中的某些字符而形成s的一部分。</p><p>子串： 由s中相继的字符所组成</p><blockquote><p>子串是子序列，子序列不一定是字串</p></blockquote><h3 id="序列相似性比较">1.3 序列相似性比较</h3><p>相似程度的刻画：</p><ol type="1"><li>两个序列的相似度: 它是两个序列的函数，其值越大，表示两个序列越相似</li><li>两个序列的距离：距离越大，则两个序列的相似度就越小。</li></ol><blockquote><p>汉明(Hamming)距离：对于两条长度相等的序列，汉明距离等于对应位点 上字符不同的数目</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608114003804.png"></p></blockquote><p>序列比对(Alignment)是序列比较的基本操作。是关于序列相似性的定性描述。</p><p>两个序列的比对是指这两个序列中各个字符的一种一一对应关系(或各个字符的对比排列)。反映出两条序列在什么部位相同，什么部位存在差异。</p><blockquote><p>两个序列可以有多种不同的比对方式。</p></blockquote><h3 id="编辑距离">1.4 编辑距离</h3><p>度量两个字符串之间的距离的主要困难？</p><ul><li>两个字符串之间可能具有不同的长度，各自位置上的字符并不一定是真正的对应关系，直接计算汉明距离未必适当。</li></ul><p>如何合理度量？</p><ul><li>通过字符的插入、删除和替换等<strong>编辑操作</strong>把一个字符串变为另一个字符串</li></ul><ol type="1"><li>Match (a，a)：字符匹配</li><li>Delete (a，-) ：从第一条序列删除字符a (或在第二条序列相应的位置插入空位字符)</li><li>Insert (-，b)：在第一条序列插入空位字符(或删除第二条序列中的对应字符b)</li><li>Replace (a，b)：以第二条序列中的字符b替换第一条序列中的字符a，且a和b不相同</li></ol><p>编辑距离的定义：两个字符串之间，由一个字符串转换成另一个字符串所需要进行的<strong>最少</strong>编辑操作次数；其中的编辑操作包括把一个字符替换成另一个字符、插入一个字符和删除一个字符。</p><blockquote><p>编辑距离是所有可能的把s转换为t的<strong>编辑总代价的最小值</strong>。</p></blockquote><h3 id="序列比对的量化评价">1.5 序列比对的量化评价</h3><h4 id="代价函数法">1.5.1 代价函数法</h4><ul><li>首先定义一个<strong>代价函数</strong></li><li>然后定义序列比对的<strong>总代价</strong>等于各列的代价之和</li><li>其中，每一列考虑3种情况，其代价定义如下：<ul><li>匹配：0</li><li>替换：1</li><li>空位：1</li></ul></li></ul><h4 id="打分函数法">1.5.2 打分函数法</h4><ul><li>首先定义一个<strong>打分函数</strong></li><li>然后定义<strong>序列比对的打分值</strong>等于各列的打分之和</li><li>其中，每一列考虑3种情况，其打分定义如下：<ul><li>匹配：+1</li><li>替换：-1</li><li>空位：-1</li></ul></li></ul><blockquote><p>对于核酸序列或蛋白质序列的比对，打分函数 的定义需要考虑其生物学意义。</p></blockquote><h4 id="序列比对与最优序列比对">1.5.3 序列比对与最优序列比对</h4><p>序列比对：通过字符匹配、替换、插入或删除，使两个序列的长度相等；但不能出现两者全为空位的列，且每一列只能出现匹配、失配和出现1个空位这3种可能情形之一。</p><p>两条序列比对的得分：将序列s转化为序列t所用的所有编辑操作的得分总和。</p><p>最优序列比对：在所有可能比对中得分最高或者编辑代价最小的比对。</p><p>如何寻找最优比对？</p><ul><li>寻找得分最高或代价最小的比对<ul><li>需要设计算法，求解组合优化问题</li></ul></li></ul><h3 id="编辑距离的应用">1.6 编辑距离的应用</h3><ul><li>自然语言处理</li><li>机器翻译的自动评测</li><li>识别平行网页对</li><li>字符串核函数 (String Kernel)</li><li>歌曲的哼唱检索 (Query by Humming: QbH）</li></ul><h3 id="矩阵作图法">1.7 矩阵作图法</h3><p>矩阵作图法（对角线作图法）基本步骤：</p><ol type="1"><li>将两条待比较的序列分别放在坐标系的两个轴上：s序列放在Y轴上，自下而上；t序列放在X轴上，从左到右。</li><li>当对应的行与列的序列字符匹配时，则在矩阵对应的位置作出“点”标记。</li><li>逐个比较所有字符对，最终形成点矩阵。</li></ol><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180444466.png"></p><p>把点矩阵中非重叠的与对角线平行的斜线组合起来，可以形成两条序列的一种比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180557387.png"></p><p>矩阵作图法找最佳比对:寻找对应位点的相同字符最多的比对——相当于在点矩阵中找<strong>非重叠的最长的平行斜线的组合</strong>。</p><p>除非已知待比较序列非常相似，一般先用矩阵作图法进行比较。</p><p>矩阵作图法的缺陷：当两条序列中存在很多匹配的位点对时，点矩阵中会形成很多点标记。当比较长的序列进行比较时，这样的点阵图会变得非常复杂和模糊。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180956992.png"></p><p>改进策略：滑动窗口技术</p><p>使用滑动窗口之间的比较去代替单个位点之间的比较。</p><ul><li>比如设窗口大小(window size)为10，相似度阈值为8，则每次比较取10个连续的字符，若相同字符数超过8个，则进行标记为窗口相似。</li></ul><p>优点：基于滑动窗口的点矩阵方法可以明显地降低点阵图的噪声，且明确无误的指示出两条序列具有显著相似性的区域。</p><p>滑动窗口法的效果比较：</p><ul><li>下图的(b)为人类(Homosapiens)与黑猩猩(Pongo pygmaeus)的β球蛋白基因序列进行比较的完整点阵图。</li><li>(c)为利用滑动窗口对以上的两种球蛋白基因序列进行比较的点阵图，其中窗口大小为10个核苷酸，相似度阈值(threshold)为8。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608181834815.png"></p><h2 id="两条序列的比较">2.两条序列的比较</h2><h3 id="序列比对打分矩阵">2.1 序列比对打分矩阵</h3><p>两条序列 s 和 t 的比对得分等于将 s 转化为 t 所用的所有编辑操作的得分总和。</p><p>详细列出各种字符替换的得分，并排列成表格(或矩阵)，即为打分矩阵。</p><blockquote><p>定义打分矩阵是进行序列比较的基础。</p></blockquote><p>选择不同的打分矩阵将得到不同的比较结果。</p><p>打分矩阵的定义需要依据其实际应用中生物学意义。</p><p>打分矩阵分为：</p><ul><li>核酸打分矩阵： 单位矩阵, BLAST矩阵, 转移矩阵<ul><li>单位矩阵 ：相同的核苷酸匹配得分为1，不同核苷酸替换为0。</li><li>BLAST矩阵 ：相同匹配得分为+5，反之为-4。</li><li>转移矩阵（transition）：相同匹配得分为+1，反之为-5。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608182752593.png"></p><ul><li>蛋白质打分矩阵：单位矩阵, 氨基酸突变代价矩阵GCM, 疏水矩阵…</li></ul><h3 id="最优序列比对">2.2 最优序列比对</h3><p>最优比对：在所有可能的比对中，得分最高(或编辑代价最小)的比对，把最优比对的得分值称为s和t的相似度，记作sim(s,t)。</p><ul><li>最高得分(相似度)是唯一的，但最佳比对方式不一定唯一。</li></ul><p>寻找最优比对：</p><ul><li>寻找得分最高(或代价最小)的比对</li><li>需要设计有效的最优化算法</li></ul><p>穷举法：穷举所有可能比对，选取最高得分者。</p><ul><li>穷举所有可能比对</li><li>分别计分</li><li>选取最高得分者</li></ul><p>两条序列可能的比对数目是<strong>序列长度的指数函数</strong>；随着序列长度的增长，计算量呈指数增长。穷举法不可行！ <span class="math display">\[比对数目=\sum_{k=0}^{min(m,n)}\frac{(m+n-k)!}{(n-k)!(m-k)!k!}\]</span></p><h3 id="动态规划dynamic-programming全局序列比对">2.3 动态规划（Dynamic Programming）—全局序列比对</h3><h4 id="认识动态规划算法">2.3.1 认识动态规划算法</h4><p>动态规划算法是寻找最优比对的一个方法。</p><p>利用同一问题已计算出的局部解求解<strong>全局解</strong>。</p><ul><li>一般是通过把一个问题分解成计算量合理的子问题，并使用这些子问题的结果来计算最终解。</li></ul><p>应用场景举例：用于在一个复杂空间中寻找一条最优路径。</p><ul><li>如果该问题可以描述为一个对应的图论问题，且问题的解对应于图中从起点到终点的最短距离，那么就可以通过动态规划算法解决这个问题。</li></ul><p>动态规划是<strong>求解最优化问题的一种途径或框架</strong>：</p><ul><li>并不是某一个特殊算法。</li><li>不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。</li><li>动态规划算法往往是针对某一种特定最优化问题设计。</li><li>不存在一种可以解决各类最优化问题万能的动态规划算法。</li></ul><p>动态规划的<strong>基本思想</strong>：将待求解问题分解成若干个子问题，先求解子问题，再从子问题的解得到原问题的解。</p><ul><li>经分解得到子问题往往不是互相独立的。</li><li><strong>保存已解决的子问题的答案</strong>，而在需要时再找出已求得的答案，以避免大量的重复计算。<ul><li>在穷举法中存在大量重复计算</li></ul></li><li>用一个表来记录所有已解的子问题的答案<ul><li>具体的动态规划算法多种多样，但它们具有相同的填表格式。</li></ul></li></ul><h4 id="动态规划算法基本步骤">2.3.2 动态规划算法基本步骤</h4><p>设计动态规划算法的五个<strong>基本步骤</strong>：</p><ol type="1"><li>确定问题的决策对象</li><li>对决策过程划分阶段</li><li>对各阶段确定状态变量</li><li>根据状态变量确定代价函数和总的目标函数</li><li>建立各阶段状态变量的转移过程，确定状态转移方程</li></ol><p>利用<strong>动态规划算法寻找最优序列比对的基本建模步骤</strong>：</p><ol type="1"><li>确定问题的决策对象：<ul><li>确定各个位点上应采用何种编辑操作: 匹配/失配/空位</li></ul></li><li>对决策过程划分阶段：<ul><li>一个位点对应一个阶段</li></ul></li><li>对各阶段确定状态变量：<ul><li>序列前缀串的比对结果和当前位置的编辑操作是当前阶段的状态变量</li></ul></li><li>根据状态变量确定得分函数和总的目标函数：<ul><li>序列前缀串的得分作为各阶段的得分函数，完整 序列的得分函数即构成总的目标函数</li></ul></li><li>建立各阶段状态变量的转移过程，确定状态转移方程：<ul><li>顺推方式：使用状态S<sub>k-1</sub>推导状态S<sub>k</sub> 的得分</li></ul></li></ol><h4 id="动态规划辅助矩阵">2.3.3 动态规划辅助矩阵</h4><p>在开始算法之前，我们还要理解一个概念是<strong>动态规划辅助矩阵</strong>：考虑两个序列s与t</p><ul><li><p>设 m = |s|, n= |t|, 则s共有m + 1个前缀串, t共有n + 1个前缀(包括空串)</p></li><li><p>动态规划辅助矩阵A为：(m + 1) × (n + 1)</p></li><li><p>矩阵A的(i,j)元素为前缀的最优比对得分: <span class="math display">\[A(i,j)=sim(prefix(s,j),prefix(t,j))或A(i,j)=sim(s[0..i],t[0..j])\]</span></p></li><li><p><strong>算法的核心步骤</strong>：通过状态转移方程，维护一个动态规划辅助矩阵A用以存放这些得分。</p><ul><li>算法从最短的前缀开始，递推地得到更长的前缀串的相似度，并不直接计算 sim(s,t)</li></ul></li><li><p>全局序列比对也称为Needleman-Wunsch(NW)算法。</p></li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure><p><strong>计算A(i,j)的方法</strong>：</p><ul><li><p>已知序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的前缀最优比对，即是已知3种子序列的最优比对</p><ul><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对</li><li><sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li></ul></li><li><p>则序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对必是上述3种情况之一的扩展，即</p><ul><li><p>替换或匹配(s<sub>i</sub> ,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195505891.png" style="zoom: 50%;"></p></li><li><p>删除(s<sub>i</sub> ,-)</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195559054.png" style="zoom: 50%;"></p></li><li><p>插入(-,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195946697.png" style="zoom: 50%;"></p></li></ul></li><li><p>状态转移方程： <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span></p></li></ul><h4 id="辅助矩阵的初始化">2.3.4 辅助矩阵的初始化</h4><ul><li>假设给定打分函数：<ul><li>匹配：1</li><li>失配：-1</li><li>空位：-2</li></ul></li><li>初始化辅助矩阵A：<ul><li>矩阵的纵轴方向自上而下对应于第1条序列(s)，横轴方向自左向右对应于第2条序列(t)</li><li>矩阵横向的移动表示在纵轴序列中加入一个空位</li><li>纵向的移动表示在横轴序列中加入了一个空位</li><li>而斜对角向的移动表示两序列各自相应的字符进行比对</li></ul></li></ul><blockquote><p>注意：各轴第一个元素的索引下标为0, 且初始化A(0,0)=0。</p></blockquote><h4 id="动态规划辅助矩阵的维护过程">2.3.5 动态规划辅助矩阵的维护过程</h4><p>计算顺序：</p><ol type="1"><li>计算过程从A(0,0)开始，到A(m, n)结束。</li><li>计算A(i,j)时，只要已知A(i-1,j), A(i-1,j-1), A(i,j-1)即可使用递推公式计算。<ul><li>可按行计算——每行从左到右，也可按列计算—— 每列从上到下。</li><li>第一行第一列可以单纯的-2来计算，因为矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位。</li></ul></li><li>在计算A(i,j)后，需要<strong>保存</strong>A(i,j)是从(i − 1,j), (i − 1,j − 1), (i,j − 1) 中的哪一个位置推进的。<ul><li>保存计算路径，以便于后续处理</li></ul></li></ol><h4 id="用序列比对的动态规划求解问题的实例">2.3.6 用序列比对的动态规划求解问题的实例</h4><p>给定序列s和t，打分函数定义如下。请使用NW算法找出最优比对：s=AAAC，t=AGC</p><p>打分函数：<img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608202753737.png"></p><p><strong>基本求解步骤：</strong></p><ul><li><p>建立动态规划辅助矩阵</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure></li><li><p>初始化动态规划辅助矩阵</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203000442.png" style="zoom: 50%;"></p></li><li><p>根据状态转移方程不断维护辅助矩阵A</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203043267.png" style="zoom:50%;"></p><ul><li>最终得到的A(m,n)即为s与t的最佳比对得分(相似度)为-1。</li></ul></li><li><p>回溯计算的路径，以找到最优比对</p><ul><li><p>从A(m,n)开始，反推</p></li><li><p>假设在反推到达A(i,j)时，根据保存的计算路径判断A(i,j)究竟是利用A(i-1,j), A(i-1,j-1), A(i,j-1)中的哪一个计算而得到的</p></li><li><p>找到这个点后，由从此点出发，一直到A(0,0)为止</p></li><li><p>矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位；而斜对角向的移动表示两序列各自相应的字符进行比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203832883.png"></p></li><li><p>图中路径对应的最佳比对（有多种最佳比对方式）为：</p><ul><li>AAAC与AG-C</li><li>AAAC与A-GC</li><li>AAAC与-AGC</li></ul></li></ul></li></ul><h3 id="最优局部比对子序列与完整序列的比对">2.4 最优局部比对—子序列与完整序列的比对</h3><h4 id="认识最优局部比对">2.4.1 认识最优局部比对</h4><p>最优全局比对：两条长度相近的序列进行比对。</p><p>最优局部比对：</p><ul><li><p>子序列与完整序列的比对；</p></li><li><p>寻找最大的相似子序列。</p></li></ul><p>基于动态规划的最优全局序列比对可以找出两条序列的最佳比对，但未必总是具有生物学意义。</p><ul><li>有些同源序列虽然全序列的相似性很小，但是存在高度相似的局部区域。</li><li>如果在进行比对时，注重序列的局部相似性，则可能会发现重要的比对。</li><li>Smith和Waterman在Needleman-Wunsch算法的基础上提出了序列最优局部比对算法。</li><li>最优局部比对算法叫做Smith-Waterman算法。</li></ul><p>把一个较短的序列与一个较长的完整序列进行比对，试图找出<strong>最优的局部匹配</strong>。</p><ul><li>给定两条序列 <sub>0</sub>:s:<sub>m</sub>和<sub>0</sub>:t:<sub>n</sub> ，<strong>从<sub>0</sub>:t:<sub>n</sub>中寻找一个子序列</strong>，使得两条序列 sim(s, <sub>i</sub>:t:<sub>j</sub>)最大</li></ul><h4 id="最优局部序列比对的实现">2.4.2 最优局部序列比对的实现</h4><p>寻找最优的局部比对时，需要避免对序列一端或者两端出现的空位进行罚分。</p><p>由于不计删除序列t前缀的得分，因此在对动态规划辅助矩阵初始化时，按照下述方式处理： <span class="math display">\[A(_0:s:_0,_0:t:_j)=0\]</span> 局部比对也不计删除序列t后缀的得分，因此: <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span> 动态规划辅助矩阵最后一行的更新公式: <span class="math display">\[A(m,j)=max\begin{cases} A(m,j-1)+0\\ A(m-1,j-1)+p(s[m],t[j])\\A(m-1,j)+p(s[m],-)\end{cases}\]</span> 局部最优序列比对路径：</p><ul><li>从最后一行(第m行)中寻找最大值，反推最优路径到达第一行<ul><li>由位置(m, j) 出发，反推最优比对路径，最终通过<strong>斜线</strong>(非空位)到达(1, i)，其中 j 是第 m 行中取得最大分值的最小列下标。</li></ul></li></ul><h3 id="最优局部比对寻找最大的相似子序列">2.5 最优局部比对——寻找最大的相似子序列</h3><p>对两条序列都进行部分比对，以寻找最大的相似子串。</p><ul><li>初始化<ul><li>由于不计删除或插入序列前缀的得分，因此边界条件(即初始化)修改为：A(0,j)=0，A(i,0)=</li><li>即动态规划辅助矩阵A的第0行和第0列初始化为0</li></ul></li></ul><blockquote><p>相当于忽略前缀</p></blockquote><ul><li><p>状态转移方程 <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\\0\end{cases}\]</span></p><ul><li>对于每个A(i,j)，一定存在一个得分为“0”的空后缀比对，因此矩阵A中的所有元素大于或等于“0”</li><li>阈值为0意味着矩阵中的0元素分布区域对应于不相似的子序列，而正数区域则是局部相似的区域。</li></ul></li><li><p>在矩阵A中寻找最大值</p><ul><li>该值是最优局部比对得分</li><li>该值对应的位置为序列局部比对的末点</li><li>反向推演前面的最优路径，直到局部比对的起点——局部比对的起点取值为0</li><li>矩阵A中元素的含义与基本算法有所不同：A(i,j)中每个元素的值代表序列<sub>0</sub>:s:<sub>i</sub> 某个后缀和序列<sub>0</sub>:t:<sub>j</sub> 某个后缀的最佳比对</li></ul></li></ul><h3 id="准全局比对">2.6 准全局比对</h3><p>准全局序列比对的四种常见情况对应于两个序列终端空位的四种可能：</p><ul><li>子序列与完整序列的比对</li><li>寻找最大的相似子序列</li><li>判断一条序列的前缀与另一条序列的后缀相似</li><li>判断一条序列的后缀与另一条序列的前缀相似</li></ul><p>准全局序列比对：在评价序列比对时，不计算序列终端出现“空位”情况的罚分。</p><p>所谓的序列终端空位包括：</p><ul><li>出现在序列第一个字符之前的空位</li><li>出现在序列最后一个字符之后的空位</li></ul><p>不计前端空位:</p><ul><li>不计s的前端空位：第0行初始值为“0”</li><li>不计t的前端空位：第0列初始值为“0”</li></ul><p>不计末端空位:：</p><ul><li>不计s的末端空位：在最后一行中寻找最大值</li><li>不计t的末端空位：在最后一列中寻找最大值</li></ul><p><strong>以上4条可任意组合</strong></p><h3 id="总结">2.7 总结</h3><p>全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221708590.png"></p><p>局部序列比对—子序列与完整序列的比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221811317.png"></p><p>局部序列比对——寻找最大的相似子序列：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221842345.png"></p><p>准全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221912089.png"></p><h2 id="多序列比对">3.多序列比对</h2><h3 id="多条序列比对的提出">3.1 多条序列比对的提出</h3><p>序列序列两两比对主要用于建立两条序列的同源关系和推测它们的结构、功能。</p><p>多条序列比对对于研究分子结构、功能及进化关系更为有用。</p><ul><li>在实际蛋白质研究中，并不是仅仅分析单个蛋白质，而是更着重于研究蛋白质之间的关系，研究一个家族中的相关蛋白质及序列中与结构域或功能相关的保守区域，进而分析蛋白质的结构和功能。<ul><li>序列两两比对不能满足这样的需要，难以发现多个序列的共性。</li><li>要得到一个序列家族的序列特征，需要同时比对多条同源序列。</li><li>当给定一个新序列时，根据序列特征，可以判断这个序列是否属于该家族。</li></ul></li></ul><p>多序列比对定义：有k ( &gt; 2 ) 个序列s<sub>1</sub> , s<sub>2</sub> , ... ,s<sub>k</sub>，每个序列由同一个字母表中的字符组成。通过插入字符操作，使得各序列达到一样的长度，从而形成这些序列的多重比对。</p><p>目标：</p><p>发现多个序列的共性</p><p>发现与结构和功能相关的保守序列片段</p><p>推测各个序列的进化历史</p><h4 id="打分函数">3.1.1 打分函数</h4><p>具有k个变量, 可用一个k维数组来表示。</p><p>所期望的打分函数：</p><ul><li>函数在形式上应该简单，具有统一的形式。</li><li>不随序列的个数而发生形式变化。</li><li>函数值应独立于各参数的顺序，与比较的序列先后次序无关。</li><li>对相同或相似字符的比对，得分值高。</li></ul><h5 id="spsum-of-pairs模型">SP(Sum-of-Pairs)模型</h5><p>SP模型的思路：按照每个比对的列进行打分，然后求和。</p><p>SP打分函数： <span class="math display">\[SP(c_1,c_2,...,c_k)=\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}p(c_i,c_j)\]</span></p><ul><li><p>其中c<sub>1</sub> ,c<sub>2</sub> ,…,c<sub>k</sub>是一列中的k个字符，p(. , . )是关于一对字符相似性的打分函数。</p><p>总得分基于字符两两比较得分。</p><p>把一个多重比对所有列的得分全部加起来，其和即为该多重序列比对的得分。</p></li></ul><p>多重序列比对的空位：</p><ul><li>进行多重序列比对时，可能<strong>会出现两个空位字符的比对</strong>，因此我们扩充打分函数p的定义域。<ul><li>即增加p(-,-)=0</li><li>在分析这两条序列时，可以同时去掉这些空位。这个结果称之为多重序列比对在两条特定序列上的投影(projection)。</li></ul></li></ul><p>基于SP打分函数的逐对比对：</p><ul><li><p>引入打分函数的定义域扩充p(−,−) = 0后,则可以先对每一对序列进行两两比对，再求和： <span class="math display">\[SP(s_1,s_2,...,s_k)=\sum_{i&lt;j}^{k}sim(s_i,s_j)\]</span></p><ul><li>等价于对多重序列的每一列进行计算，然后将每一列的得分值相加。</li></ul></li></ul><p>穷举出所有可能的比对，取得分最高者！</p><h3 id="多条序列比对的方法">3.2 多条序列比对的方法</h3><p>精确比对：多重比对的动态规划算法</p><p>渐进比对：星形比对、树形比对</p><h4 id="多重序列比对的动态规划算法">3.2.1 多重序列比对的动态规划算法</h4><p>对于3条序列，每1种可能的比对可以用3维晶格中的1条路径来表示，每1维对应于1条序列。</p><ul><li>路径的起点为晶格的<strong>左上后角</strong>，终点为晶格的<strong>右下前角</strong>。</li><li>对于多条序列，则形成超晶格(hyper-lattice)。</li><li>对于两条序列比对，其得分矩阵相当于2维晶格(平面)。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609103503859.png" alt="三条序列比对"><figcaption aria-hidden="true">三条序列比对</figcaption></figure><h5 id="多重比对的动态规划的基本原理">（1）多重比对的动态规划的<strong>基本原理</strong>：</h5><ul><li>在超晶格中，序列比对的计算是从左上后角坐标点(0,0,…,0)开始，按<strong>节点之间的依赖关系</strong>向右下前方推进，直至计算完最后一个节点。<ul><li>实际计算时可按先低维再高维(对应于先行后列)。</li><li>二重序列比对时，可将动态规划算法的计算过程看成是在二维平面上按照一定顺序访问每个节点，每个节点的得分代表两个序列前缀的最优比对的得分。</li></ul></li><li>当前位点的得分计算取决于与它相邻的(2k – 1)条边，分别对应于匹配、替换或引入空位等3种编辑操作。</li><li>计算各操作的得分时，选择一个得分最大的操作，将得分和存放于该节点。</li></ul><h5 id="状态转移方程">（2）状态转移方程：</h5><p><span class="math display">\[s_{i,j,k}=max\begin{cases} s_{i-1,j,k} \enspace +\delta(\upsilon_i,-,-) \\ s_{i,j-1,k} \enspace +\delta(-,\omega_j,-)\\s_{i,j,k-1} \enspace +\delta(-,-,\mu_k)\\s_{i-1,j-1,k}  +\delta(\upsilon_i,\omega_j,-)\\s_{i-1,j,k-1}  +\delta(\upsilon_i,-,\mu_k)\\s_{i,j-1,k-1}  +\delta(-,\omega_j,\mu_k)\\s_{i-1,j-1,k-1}  +\delta(\upsilon_i,\omega_j,\mu_k)\end{cases}\]</span></p><h5 id="dp算法的计算过程">（3）DP算法的计算过程：</h5><p>动态规划的计算过程是一个递推更新动态规划辅助矩阵的过程。</p><ul><li>在计算每个节点得分时，将其<strong>各前趋节点</strong>的值分别加上从前趋节点到当前点的SP得分，取最大值作为当前节点的值。<ul><li>一般在3维(k=3)情况下，考虑7个前趋节点。</li><li>在k维情况下，前趋节点的个数等于2k –1。</li></ul></li></ul><p>多重比对的DP算法的计算复杂度：</p><ul><li>对于k条序列，动态算法需要处理k维空间的每个节点，计算量与节点数成正比（与各序列长度的乘积的乘积）。<ul><li>注意到前趋节点的个数为2<sup>k</sup> – 1，因此动态规划算法复杂度为O(2<sup>k</sup> N<sup>k</sup>)。</li><li>随着待比对的序列数目k的增加，动态规划的计算量和所要求的计算空间呈<strong>指数</strong>形式猛增。</li></ul></li></ul><p>多重比对的动态规划的空间复杂度：</p><ul><li>动态规划辅助矩阵的大小 = N<sup>k</sup> 个元素<ul><li>N为序列长度</li><li>k为序列条数</li></ul></li><li>每个元素需要处理2<sup>k</sup> – 1个相邻元素<ul><li>时间复杂度: O(2<sup>k</sup> N<sup>k</sup>)</li></ul></li></ul><p>如果采用标准的动态规划算法计算最优的多重序列比对，k较大时所需要的时间和空间复杂度均是难以满足的。</p><h4 id="渐进方法星形比对">3.2.2 渐进方法—星形比对</h4><p><strong>渐进法</strong>的基本过程：</p><ul><li>把多重序列比对转化为两两序列比对。</li><li>再将两两比对聚合起来，最终形成完整的多序列比对。</li></ul><p><strong>渐进法</strong>的特点：</p><ul><li>属于启发式近似方法，能够大大减少所需的计算时间。</li><li>虽然无法保证最终得到最优解，但在大多数情况下，其计算结果接近最优结果。</li></ul><h5 id="星形比对的基本思路">（1）星形比对的基本思路：</h5><ol type="1"><li>在给定若干序列中，首先选出一个<strong>核心序列</strong>。</li><li>把该序列与其它序列进行两两比对。</li><li>最后聚合形成所有序列的多重比对。<ul><li>使得该多重比对在核心序列和任何一个其它序列方向的投影均为最优的两两比对。</li></ul></li></ol><blockquote><p>基本过程：</p></blockquote><ul><li>假设k条待比对的序列中核心序列是s<sub>c</sub>，那么：<ul><li>先利用标准的动态规划方法求出所有s<sub>i</sub>和s<sub>c</sub>的最优两两比对。</li><li>把得到的两两比对按一定规则<strong>聚合</strong>起来。</li></ul></li></ul><p>时间复杂度为 O(k N<sup>2</sup>)</p><h5 id="如何选择核心序列">（2）如何选择核心序列？</h5><ul><li><p>第一种方法是尝试将每一个序列分别作为核心序列，进行星形多重序列比对，取比对结果最好的一个。</p></li><li><p>另一种方法是计算所有的两两比对，取下式值最大的一个： <span class="math display">\[sim(s_j,s_c)\]</span></p></li></ul><h5 id="星形比对的基本过程">（3）星形比对的基本过程：</h5><ol type="1"><li>选定一个核心序列。</li><li>把多重比对转化为k个两两比对。</li><li>聚合过程：从某一个两两比对开始，比如sc和s1，然后逐步加上其他的两两比对。<ul><li>对于空位采用”一次加入空白，次次保留空白”原则: 逐增加 s<sub>c</sub>中的空位字符，以适应其他的比对，但不删除s<sub>c</sub>中已经存在的空位字符。</li></ul></li></ol><h4 id="渐进方法树形比对">3.2.3 渐进方法—树形比对</h4><p>树形比对一般过程：</p><ol type="1"><li>先将多个序列进行两两比对，基于这些比对得到相似性矩阵。<ul><li>该矩阵反映逐对序列之间的关系。</li></ul></li><li>利用该相似性矩阵，构建一棵“<strong>指导树(guide tree)</strong>”。</li><li>从<strong>最接近的一对序列出发</strong>，根据指导树逐步填加序列，聚合成多重比对；直到所有序列处理完毕为止。</li></ol><h2 id="在数据库中进行序列同源搜索">4.在数据库中进行序列同源搜索</h2><h3 id="问题的提出">4.1 问题的提出</h3><p>在数据库中搜索相似的序列：</p><ul><li>查询序列（待查询的序列）</li><li>目标序列（数据库中的每条被搜索的序列）</li></ul><p>直接用两序列比对进行数据库搜索存在的问题：</p><ul><li>目标序列太长、数量巨大，穷举式搜索耗时过长。</li><li>解决办法：索引技术、启发式方法。</li><li>实用的数据库搜索算法：“最佳”→“较佳”。</li></ul><p>两大主要搜索算法：</p><ul><li>BLAST及其相关算法</li><li>FASTA及其相关算法</li></ul><h3 id="常用的搜索方法blast搜索算法">4.2 常用的搜索方法—BLAST搜索算法</h3><p>主要特征：原始的BLAST算法是<strong>不带空位的局部比对方法</strong>。</p><p>给定一个查询序列，BLAST返回所有查询序列与数据库序列得分<strong>超过某个阈值S</strong>的片段对。</p><blockquote><p>阈值S可以由用户设置，但程序有一个默认的推荐值。</p></blockquote><ul><li><p>选择S的<strong>基本原则</strong>是：一条随机序列与查询序列比较的得分不会超过S。</p></li><li><p>由于在序列比对过程中不考虑空位的操作(没有插入和删除)，则对于二维平面上各点的计算问题可转化为一维点的计算问题，计算速度得以大幅提高。</p></li></ul><p>通过搜索序列数据库来找出<strong>最优的无空位局部比对</strong>。</p><ul><li>从数据库中找出与<strong>查询序列的某些子序列</strong>相似的子序列。</li><li>在进行数据库查询时，BLAST返回一个<strong>高得分的相似片段对列表</strong>，每个片段对包括查找序列的一个片段和数据库中待比较序列的一个片段。</li></ul><blockquote><p>BLAST算法把数据库搜索建立在严格的统计学基础上。</p></blockquote><h5 id="基本步骤">基本步骤：</h5><ol type="1"><li><p>利用<strong>滑动窗口</strong>将查询序列分解为定长的“单词”串(默认长度为4)。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164801077.png" style="zoom:67%;"></p></li><li><p>舍弃那些由最常见的残基组成的“单词”串，在数据库中精确匹配剩余“单词”串。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164946161.png" style="zoom:67%;"></p></li><li><p>对匹配上的单词串，逐步向两端延伸该匹配，直到得分低于某个阈值为止。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609165100296.png" style="zoom:67%;"></p></li></ol><h3 id="常用的搜索方法fasta搜索算法">4.3 常用的搜索方法—FASTA搜索算法</h3><p>FASTA是另一种常用的序列比对及搜索工具：</p><ul><li>能够进行<strong>带空位的局部比对</strong>。</li><li>由于FASTA搜索时会将<strong>查询序列与数据库中每条序列进行细致比较</strong>，故通常比BLAST搜索要慢些。</li></ul><h5 id="基本步骤-1">基本步骤：</h5><ol type="1"><li><p>用滑动窗口将查询序列分隔成“单词”串：</p><ul><li>对于核苷酸序列， “单词”串长为4~6</li><li>对于氨基酸序列， “单词”串长为1~2</li></ul></li><li><p>为查询序列建立一个表格，记录下各个“单词”串在序列中出现的位置。</p><p>例：“单词”长度为1的序列如下：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609170226299.png" alt="查询序列" style="zoom:67%;"></p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171158162.png" alt="查询序列表格"><figcaption aria-hidden="true">查询序列表格</figcaption></figure></li><li><p>对目标序列建立另一个表格，用于比较目标序列与查询序列中各残基的位置之差。</p><p>查询序列：<strong>FAMLGFIKYLPGCM</strong></p><p>目标序列：<strong>TGFIKYLPGACT</strong></p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171928801.png"></p></li><li><p>从第二个表中发现有很多距离为3的位置，这表明：如果对目标序列<strong>偏移3个位置</strong>，则可得到一个较好的比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609172302785.png"></p></li></ol><p>通过比较两条序列的<strong>偏移表</strong>，可以很快地发现相同的区域，并将这些区域连接起来形成更长的序列，然后利用Smith-Waterman算法比对。</p><blockquote><p>由于FASTA是对已知区域进行比对，较原始算法(即用动态规划算法进行查询序列与所有目标序列间的比对)要快得多。</p></blockquote><h3 id="数据库搜索结果得分及统计显著性">4.4 数据库搜索结果得分及统计显著性</h3><p>提出原因：</p><ul><li>数据库搜索总会产生结果，<strong>但找到的序列未必真与查询序列相关</strong>。</li><li>比对得分可以说明搜索的结果与查询序列之间的相似程度，但由于数据库搜索算法不同、比对打分标准不统一 ，因此<strong>比对得分值</strong>本身并不能充分指明两序列间的关系。</li></ul><p>设某个数据库搜索结果的比对得分为S，我们可以提出一个<strong>基本问题</strong>：</p><ul><li>若有一组与查询序列不相关的序列(<strong>如随机序列</strong>)，则在这些序列中随机找到一个得分同样为S的比对的概率有多大？</li></ul><p>为回答这个基本问题，数据库搜索引擎通常会为每个搜索结果提供P得分与E得分。</p><p>P得分：对于随机找出的一条或多条序列，其比对得分大于等于S的<strong>可能性</strong>(概率)。</p><p>E得分：随机找出的、与查询序列进行比对的<strong>得分大于等于S的目标序列的期望数目</strong>。</p><ul><li>如果E得分与P得分均<strong>较低</strong>，则说明搜索结果与查询序列<strong>具有进化上的关系</strong>，并不是由于<strong>随机因素</strong>得到的结果。</li></ul><blockquote><p>当E值&lt; 10<sup>-3</sup>时，通常认为搜索结果具有统计上的显著性；</p><p>–搜索得到的匹配序列在E值上可以低到<strong>10<sup>-50</sup></strong> ，表明查询序列与搜索结果间<strong>具有进化关系的可能性极大</strong>。</p></blockquote><h2 id="dna片段组装">5.DNA片段组装</h2><h3 id="问题提出与定义">5.1 问题提出与定义</h3><p>问题描述：给定一组取自特定字母表的字符串集合F，寻找一个最短的字符串s，使得F中的每一个字符串均为s的一个连续子串。</p><ul><li>其中，集合F中的字符串是待组装的序列片段，s 是序列片段组装的结果。</li></ul><p>DNA片段组装任务的提出：大规模基因组测序时，得到待测序列的<strong>一系列片段</strong>，这些序列片段<strong>覆盖待测序列</strong>，且序列片段之间存在相互覆盖或重叠；根据这些存在相互覆盖或重叠的序列片段，<strong>重建</strong>目标DNA序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609192717156.png"></p><h5 id="序列片段组装的基本原理">序列片段组装的基本原理：</h5><p>将输入的序列片段进行<strong>两两比对</strong>；</p><ul><li>与基本的序列两两比对算法不同，此时需要寻找一个序列的后缀与另一个序列的前缀相同或相似的部分。</li><li>通过准全局序列比对(忽略某一端的空白字符)，相当于各个片段之间进行相对定位；</li><li>由各个片段之间的相对定位，逐步确定目标序列。</li></ul><p>指导片段组装的因素是<strong>片段之间的覆盖</strong>。</p><ul><li>通过各个片段之间的覆盖，对片段实现<strong>相对定位</strong>，进而把所有片段连接起来。<ul><li>也可以看成是序列片段的特定多重比对。</li></ul></li><li>对于每一列，提取<strong>出现频率最大</strong>的一个字符。</li></ul><h3 id="dna片断组装的主要困难">5.2 DNA片断组装的主要困难</h3><h4 id="碱基标识错误">5.2.1 碱基标识错误</h4><p>在序列片段中存在碱基替换、插入和删除。</p><p>解决方案:</p><ul><li>考虑到序列的检测误差，序列片段组装的一个更准确定义为：给定一组取自特定字母表的字符串集合F，其中的字符串具有一定的误差，寻找一个<strong>最短的字符串s</strong>，使得在s中观察到F的可能性最大。</li></ul><blockquote><p>最大似然 (Maximum Likelihood)准则：以可能性最高为判断标准。</p></blockquote><h4 id="未知片段方向">5.2.2 未知片段方向</h4><p>如果一个片段是一条链的子串， 根据互补原则，该片段的反向互补片段是另一条链的子串。</p><p>对于一条输入的片段，在进行组装时，既可以用其本身，也可以用其<strong>反向互补片段</strong>。</p><p>解决方案：按两个方向分别尝试。</p><h4 id="存在重复区域">5.2.3 存在重复区域</h4><p>重复区域是目标序列中多次出现的子序列。有的重复区域太长，超过片段的边界，造成无法给出确切相对定位，使片段组装变得不确定。</p><h4 id="缺少覆盖">5.2.4 缺少覆盖</h4><p>覆盖强度：定义为目标序列上某个位点上覆盖此位点的片段个数。</p><blockquote><p>平均覆盖强度: 计算求所有覆盖片段的长度和，再除以目标序列长度的估计值。</p></blockquote><p>如果对于目标序列上的某个位点，覆盖该点的序列片段个数为零，则没有相关的序列信息来重建该点附近的目标序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609194833195.png"></p><h3 id="dna片段组装的基本过程与组装模型">5.3 DNA片段组装的基本过程与组装模型</h3><h4 id="dna片段组装的基本过程">5.3.1 DNA片段组装的基本过程</h4><ol type="1"><li>首先进行序列片段的两两比对，确定可能的片段之间的覆盖（或者重叠）。</li><li>确定所有片段统一的覆盖模式，即确定各个序列片段的相对位置（最关键一步）。</li><li>最后确定片段组装结果，即确定目标序列。</li></ol><h4 id="最短公共超串模型">5.3.2 最短公共超串模型</h4><p>给定一个字符串集合F，求出一个<strong>最短</strong>的字符串S，使得对于所有属于F 的字符串<em>f</em>，S是<em>f</em>的超串(或者<em>f</em>是S的子串)。</p><p>设F={ACT,CTA,AGT}，则S=ACTAGT是F的超串。</p><p>其中，S要求是各片段的严格超串，不允许片段中存在实验误差，而且<strong>各片段的方向必须已知</strong>。</p><h4 id="重建模型">5.3.3 重建模型</h4><h5 id="近似子串">（1）近似子串</h5><p>考虑到片段的误差和未知方向的问题，对于判别子串的序列比较不需要完全匹配，而是根据相似程度进行处理，需要引入“近似子串”的概念。</p><p>假设 <em>f</em>, <em>g</em>是代表两条序列的字符串，<em>f</em>作为<em>g</em>近似子串的代价为： <span class="math display">\[d_s(f,g)=\min_{s\in S(g)}d(f,s)\]</span></p><ul><li>其中，S(<em>g</em>)代表<em>g</em>的所有子串的集合，<em>d</em>(⋅ , ⋅)为一般编辑距离。</li></ul><p>设0 &lt; ε &lt; 1，如果<em>d<sub>s</sub>(f,g)</em> ≤ ε|<em>f</em>| , 则称字符串 <em>f</em>是误差 ε 下 <em>S</em> 的近似子串。</p><h5 id="重建模型的定义">（2）重建模型的定义</h5><p>给定一个字符串集合<em>F</em>，求一个最短的字符串<em>S</em>，使得对于所有字符串<em>f∈F</em>，有: <span class="math display">\[d_s(f,S)\le \epsilon|f|\]</span> 或者 <span class="math display">\[d_s(f^{&#39;},S)\le \epsilon|f|\]</span> 其中 <em>f′</em> 是 <em>f</em> 的反向互补串。</p><p>主要思路: 寻找一个尽可能短的字符串<em>S</em>，使得每一个<em>f</em>或其反向 互补串<em>f′</em>成为<em>S</em>的近似子串。</p><p>该模型可同时处理序列误差、未知序列方向的问题，但不能处理目标序列中的重复区域和缺少覆盖问题。</p><h4 id="多重连续区模型">5.3.4 多重连续区模型</h4><p>t-contig：在多重序列比对中，如果其<strong>最弱连接的交叠长度至少为t</strong>，则称为一个t-contig。</p><p><em>F</em> 允许一个t-contig：在多重序列比对中，如果能够根据序列片段集合<em>F</em>构造一个t-contig，则称<em>F</em>允许1个t-contig。</p><p>多重连续区模型：</p><ul><li>通过构造t-contig来定义具体不同覆盖强度的序列组装结果。</li><li>给定一个片段集合<em>F</em>和一个整数 t ≥ 0, 将<em>F</em>分割为最小数目的片段子集C<sub>i</sub>，其中1 ≤ i ≤ k，且 每个C<sub>i</sub>允许一个t-contig。</li></ul><blockquote><p>把F分割为k个子集C<sub>i</sub>，根据序列片段子集C<sub>i</sub>构造出一个t-contig，进而完成最小覆盖强度为t的组装结果。</p></blockquote><h1 id="二基因组学与基因识别">二、基因组学与基因识别</h1><h2 id="基因与基因组">1.基因与基因组</h2><p>基因(Gene) ：编码一条多肽链或功能RNA所必需的全部核苷酸序列。</p><blockquote><p>DNA分子链上的特定区域。</p></blockquote><p>基因组(Genome)：一个细胞或者生物体所携带的一套完整的染色体单倍体序列。</p><blockquote><p>包括编码序列和非编码序列在内的全部DNA分子，包含全套基因序列和间隔序列。</p></blockquote><p>基因表达：利用存储在DNA中的遗传信息合成RNA分子，然后再合成相应蛋白质的过程，称为基因表达。</p><blockquote><p>基因表达包括转录与翻译两个子过程。</p></blockquote><h3 id="生物分子中的信息传递">1.1 生物分子中的信息传递</h3><p>在生物生长发育过程中，生物信息传递有两种方式：</p><ol type="1"><li>自我复制——在繁衍过程中传递遗传信息。</li><li>基因通过转录和翻译，使遗传信息在生物个体 中表达，使后代表现出与亲代相似的生物性状。<ul><li>DNA→RNA→蛋白质</li><li>基因控制着蛋白质的合成，基因的DNA序列到蛋白质序列存在着一种明确的对应关系——遗传密码。</li></ul></li></ol><blockquote><p>遗传密码又称三联体密码，即DNA序列3个连续的碱基对应编码1个蛋白质的氨基酸，且对应关系具有通用性。</p><p>自然界中天然存在20种氨基酸(标准氨基酸)→21种或22种。</p><p>第21: 硒代半胱氨酸(Sec, U), 由终止密码子UGA有义编码Sec；</p><p>第22：吡咯赖氨酸(Pyl, O), 由终止密码子UAG的有义编码Pyl。</p></blockquote><h3 id="人类基因组">1.2 人类基因组</h3><p>人类基因组计划（Human Genome Project / HGP）：测定组成人类染色体（指单倍体）中所包含的30亿个碱基对组成的核苷酸序列，绘制人类基因组图谱， 辨识其载有的基因及其序列，破译人类遗传信息。</p><blockquote><p>截止到2005年，人类基因组计划的测序工作已经完成。</p></blockquote><p>人类基因组：科学家研究的第一个脊椎动物染色体基因组，已成为其他脊椎动物中的代表。</p><blockquote><p>人类基因组约有3万多个基因，分布在染色体的DNA序列中。</p><p>目前已明确定位的基因仅占3万多个基因的一部分。</p></blockquote><p>基因识别：从序列中找到基因及其表达调控信息。</p><blockquote><p>通过识别特殊的序列功能位点、分析序列的组成特征来识别基因，发现与基因表达调控相关的信息。</p></blockquote><h4 id="人类基因组图谱">1.2.1 人类基因组图谱</h4><p>序列图谱：通过测序得到基因组的序列图谱。</p><p>遗传图谱（genetic map）：也叫连锁图谱(linkage map)，它是以具有遗传多态性的遗传标记为“路标” ，以遗传学距离为图距的基因组图。</p><p>物理图谱（physical map）：是指有关构成基因组的全部基因的排列和间距的信息，通过对构成基因组的DNA分子进行测定而绘制。</p><ul><li>DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。</li><li>目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。</li></ul><p>基因图谱：在识别基因组所包含的蛋白质编码序列的基础上所绘制的、结合有关基因序列、位置及表达模式等信息的图谱；其任务是在人类基因组中鉴别出占2%~5%的全部基因的位置、结构与功能。</p><blockquote><p>最主要的方法是通过基因表达产物mRNA反向追溯到染色体位置</p></blockquote><h4 id="人类基因组中的编码规律">1.2.2 人类基因组中的编码规律</h4><p>编码区域在人类基因组所占比例不超过3%。</p><p>97%是非编码序列：主要包括启动子、增强子、内含子、简单重复序列、移动元件及其遗留物、伪基因等。</p><p>对于非编码序列，目前了解得比较少，尚不完全清楚其含义或功能。</p><ul><li>从生物进化的观点来看，这部分序列具有重要的生物学功能；目前普遍认为: 它们与基因在四维时空的表达调控有关。</li></ul><h4 id="遗传语言">1.2.3 遗传语言</h4><p>科学家认为：基因组DNA序列并非是一种简单的生物分子序列，而是一种<strong>遗传语言</strong>, 用于描述遗传信息、控制生物体的性状、甚至规定生物体的生老病死。</p><ul><li>科学家们开始测序人类及其他模式生物基因组，希望解读和破译遗传信息。</li><li>迄今为止，用于理解DNA翻译成蛋白质的编码规律的<strong>遗传密码</strong>是人们对于生物体遗传语言了解最多的部分。</li></ul><p>把基因组DNA序列当作遗传语言，那么可用语言学的方法进行研究，以发现遗传语言的规律。</p><p>自然语言 vs. 程序语言 vs. 遗传语言：</p><ul><li>人类自然语言，用于人类之间描述、记录和交流思想，可以被转换成二进制序列，存放在数字图书馆中。</li><li>计算机高级程序语言经编译被转换成二进制机器指令，形成可执行程序。</li><li>遗传语言的代码实际上就是DNA序列，是由A/C/G/T(U) 4种字符组成的一种四进制代码。</li></ul><h3 id="生物体的信息加工">1.3 生物体的信息加工</h3><p>从信息工程的角度来看：</p><p>蛋白质编码区域所包含的信息相当于待加工的“数据” ，经加工处理后产生对应的氨基酸序列；非编码区域相当于“程序” ，确定如何对数据进行处理，控制基因的表达和蛋白质的合成。</p><p>计算机中数据与程序是相对分立；在染色体上，数据与程序相互嵌套，染色体上的基因经过调控程序的转录和翻译，产生蛋白质的氨基酸序列，从而发挥生物学功能。</p><blockquote><p>一维线性的DNA分子在特定环境下，通过复杂而准确的信息程序处理，拓展为一个四维时空生命体。</p></blockquote><h2 id="原核生物基因组">2. 原核生物基因组</h2><p>原核生物基因组的许多信息仅是为维持细胞最基本的功能。</p><ul><li>构造和复制DNA(至多需要32种基因)。</li><li>产生蛋白质(需要100-150个基因)。</li><li>获得和存储能量(至少需要30个基因)。</li></ul><p>原核生物基因组中的基因密度高：一些非常简单的原核生物，如流感嗜血杆菌，其基因组仅包含由256-300个基因组成的最小集合。</p><ul><li>完全测序的细菌基因组数据表明：其中85%～88%的核酸序列与基因的编码直接相关。</li></ul><h3 id="原核基因的典型结构">2.1 原核基因的典型结构</h3><p>原核基因结构非常简单</p><ul><li><p>完整的基因结构从基因的5’ -端启动子区域开始，到3’ -端终止区结束。</p></li><li><p>基因的转录开始位置由转录起始位点确定，转录过程直至遇到转录终止位点。</p></li><li><p>转录的内容包括5’-端不翻译区（UTR）、开放阅读框及3’-端不翻译区。</p></li><li><p>基因翻译的准确起止位置由起始密码子和终止密码子决定，翻译的对象即为介于这两者之间的开放阅读框。</p></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609231106118.png"></p><p>原核基因作为连续基因，其编码区是一个完整的DNA片段。</p><ul><li>负责基因表达的蛋白质可以识别各种调控信号。</li><li>调控信号是一些相对较短的核苷酸序列, 这些信号的微妙差别可以影响到: 基因表达与否、基因的表达水平。</li></ul><p>启动子位点：长度为<strong>13个</strong>核苷酸的特定序列</p><ul><li>1个为转录起始位点(+1)</li><li>6个位于转录起始位点上游10个碱基处(-10)</li><li>6个位于转录起始位点上游35个碱基处(-35)</li></ul><p>这13个位点的核苷酸作为一个整体，称为启动子序列；它们之间的相对位置固定。</p><h3 id="开放阅读框orf">2.2 开放阅读框/ORF</h3><p>对于任何给定的核酸序列(单链DNA或mRNA)，根据密码子的起始位置，可以按照3种方式将其翻译成氨基酸肽链。</p><ul><li><p>例如：序列ATTCGATAACAA</p><p>—ATT CGA TAA CAA</p><p>—(A)TTC GAT AAC AA</p><p>—(AT)TCG ATA ACA A</p></li><li><p>这3种阅读顺序称为阅读框(reading frames)</p></li><li><p>不含终止密码子且有比较多的三联密码子的长序列被称为开放阅读框(Open Reading Frame: ORF)</p></li></ul><blockquote><p>存在ORF表明该区域可能对应于一个原核生物基因的编码序列。</p></blockquote><h3 id="原核基因组中的gc含量">2.3 原核基因组中的GC含量</h3><p>GC含量：GC含量是在DNA4种碱基中，鸟嘌呤和胞嘧啶所占的比率称为GC含量。</p><blockquote><p>在双链DNA中，腺嘌呤与胸腺嘧啶（A/T）之比，以及鸟嘌呤与胞嘧啶（G/C）之比都是1。但是，（A+T）/（G+C）之比则随DNA的种类不同而异。GC含量愈高，DNA的密度也愈高，同时热及碱不易使之变性，因此利用这一特性便可进行DNA的分离或测定。</p></blockquote><p>不同的原核生物中，GC含量在25%到75%之间变化。</p><ul><li>许多细菌基因组表现为具有不同GC含量区域的组合，这些区域反映了细菌的进化历史。</li><li>在原核生物中，双链DNA组成的基因组的GC含量是区分不同物种的特征之一。<ul><li>基于这种事实，测量基因组的GC含量被证明是一种识别细菌种类的有效方法。</li></ul></li></ul><h3 id="总结原核生物基因的特征">2.4 总结：原核生物基因的特征</h3><p>编码区是连续的，具有较长的开放阅读框。</p><ul><li>60+个密码子。</li></ul><p>较简单的启动子序列。</p><ul><li>+1/-10/-35处一共13个位点。</li></ul><p>转录终止信号。</p><ul><li>转录终止位点。</li></ul><p>原核生物基因组密度高，很少有空间浪费。</p><ul><li>随机选择一段原核生物基因组核苷酸序列，其中包含重要基因的编码序列或启动子的概率很大。</li></ul><h2 id="真核生物基因组">3.真核生物基因组</h2><h3 id="真核生物基因组的挑战">3.1 真核生物基因组的挑战</h3><p>真核生物的<strong>复杂性与灵活性</strong>：</p><ul><li>细胞的内部膜系统允许在细胞内维持各种变化较大的化学环境。</li><li>几乎全为多细胞生物，虽然每个细胞有相同的遗传“指令” ，但其表达方式与表达水平可以有显著差异。</li><li>存在有大量的不表达区域（也被称为junk DNA区域）。</li></ul><blockquote><p>复杂性与灵活性导致对真核基因组的分析与注释成为目前极具挑战性的难题之一。</p></blockquote><p>基因组规模较大，真核生物基因组序列测定比原核生物更为困难：</p><ul><li>细胞核中一般包含多条线性染色体，且通常包含每条染色体的双拷贝。</li></ul><blockquote><p>比如：人类22条常染色体的双拷贝+2条性染色体，最短的为5500万个bp,最长有2.5亿个bp；全基因组长约32亿个bp。</p></blockquote><ul><li>真核生物基因数量不容易准确估计。</li></ul><p>真核生物基因编码区域是<strong>不连续</strong>的：</p><ul><li>能够编码蛋白质的序列被不能够编码蛋白质的序列分隔开来，成为一种不连续的形式。<ul><li>能够编码蛋白质的序列叫做外显子，不能够编码蛋白质的序列叫做内含子。</li></ul></li><li>在编码区域插入了不编码的内含子，大量内含子的存在，使得真核生物不存在像原核基因那样具有显著长度的ORF标志。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093206887.png" alt="内含子和外显子" style="zoom: 33%;"></p><h3 id="真核生物基因的结构特征">3.2 真核生物基因的结构特征</h3><p>完整的真核生物基因一般包含以下部分：</p><ol type="1"><li>转录起始区：含有对DNA序列转录起调控作用的启动子(Promoter)以及增强子(enhancer)等。</li><li>转录起始位点(TSS)</li><li>5‘- 非翻译区</li><li>翻译起始位点(TLSS)</li><li>外显子(exon), E-I剪切位点(doner),内含子(intron),I-E剪切位(acceptor),外显子, …</li><li>翻译终止位点TLSTOP</li><li>3 ‘- 非翻译区</li><li>转录终止位点</li></ol><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093843123.png" alt="真核生物基因的结构"><figcaption aria-hidden="true">真核生物基因的结构</figcaption></figure><blockquote><p>各部分的序列形态和长度并不确定，不同物种间的基因差别很大。</p></blockquote><h3 id="复杂的基因转录调控方式">3.3 复杂的基因转录调控方式</h3><p>真核生物基因的<strong>调控机制</strong>比原核生物复杂：</p><ul><li>真核基因的启动子序列更加分散，且距起始密码子较远；</li><li>启动子区域的信息提取比较困难；</li><li>在真核生物DNA序列中寻找基因相当于大海捞针。</li></ul><p>真核生物的细胞具有<strong>复杂的转录起始调控机制</strong>：</p><ul><li>真核生物的基因表达涉及多种RNA聚合酶。</li><li>真核生物至少使用由8～12个蛋白组成的3种不同类型的RNA聚合酶。<ul><li>原核生物只用一种由多个蛋白聚合而成的RNA聚合酶。</li></ul></li><li>每个真核生物的基因有自己的启动子。<ul><li>原核生物中多个基因共享一个启动子。</li></ul></li></ul><h3 id="剪切加工的方式">3.4 剪切加工的方式</h3><p>在把RNA聚合酶的转录产物运出细胞核之前，需要进行大量剪切加工过程。</p><ul><li>加工前的RNA聚合酶II转录物称为hnRNA。</li><li>加帽(capping)：在hnRNA的5’端发生的化学改变。</li><li>剪切(splicing)：切除其中的<strong>内含子</strong>片段。</li><li>多聚腺苷酸化(Poly-A): 在3’端连接多个(约250个)A。</li></ul><blockquote><p>这些加工过程，特别是剪切加工，具有组织特异性，这给基因识别带来了巨大挑战。</p></blockquote><h3 id="真核基因组gc含量">3.5 真核基因组GC含量</h3><p>真核生物基因组的GC含量差别没有原核生物明显，但GC含量对于识别真核基因仍有重要作用。</p><p>真核生物的ORF更难以识别。</p><p>真核基因组中GC含量的显著性变化是基因与上游启动子区域、密码子选择、基因长度以及基因密度之间相关性的基础。</p><h3 id="cpg岛">3.6 CpG岛</h3><p>CpG岛（CpG island）：</p><ul><li>CpG双核苷酸在人类基因组中的分布很不均匀，在基因组的某些区段，CpG保持或高于正常概率，这些区段被称作<strong>CpG岛</strong>。</li><li>CpG：胞嘧啶C—磷酸p—鸟嘌呤G</li><li>CG出现的频率远低于随机出现的概率, 但也有部分例外：</li><li>在许多基因的-1500~+500区域上往往形成<strong>CpG岛，其CG频率达到随机出现的水平</strong>。</li><li>人类基因组中大约有45000个CpG岛。</li></ul><p>CpG岛多与管家基因有关联，也与组织特异性基因的启动子有关。</p><ul><li>CpG岛很少出现在非基因区域或发生多次突变的基因中。<ul><li>管家基因：在所有组织和在发育的所有阶段都具有高水平表达的基因。</li></ul></li></ul><h3 id="遗传密码的使用偏性">3.7 遗传密码的使用偏性</h3><p>遗传密码的使用具有一定的统计规律，并不是完全随机的。</p><ul><li>如果密码子的第一、第二位碱基分别是A和U，则第三位尽可能使用G或C。</li><li>基因对同义密码子的使用也存在偏爱。<ul><li>不同种属所偏爱的密码子不同：<ul><li>人类基因组中，密码子第三位取A、U的情况占90%。</li><li>酵母基因组中的精氨酸：密码子AGA占48%，其它密码子CGT, CGC, CGA, CGG和AGG各约占10%。</li><li>果蝇基因组中的精氨酸CGC约占33%。</li></ul></li></ul></li></ul><h3 id="真核生物的基因识别">3.8 真核生物的基因识别</h3><p>真核生物基因识别主要考虑：</p><ul><li>已知的启动子元件(即TATA盒和CAAT盒)。</li><li>CpG岛</li><li>与内含子相关的剪接信号。</li><li>具有特定密码子使用偏好的开放阅读框。</li><li>与其它生物体EST或基因序列的相似程度。</li></ul><p>真核生物基因识别的解决方案: 通过寻找已经注释的序列数据集的统计特性，来预测相关、但未经注释的序列数据的特性。</p><h2 id="基因组序列分析基因识别">4. 基因组序列分析—基因识别</h2><p>基因识别：也被称为基因组注释(genome annotation)。</p><ul><li>从基因组序列之中找到基因及其表达调控信息， 包括识别基因编码区域(即外显子所在区域)和功能位点。</li></ul><blockquote><p>功能位点：存放基因表达调控信息的DNA片段，比如基因的启动子、剪切位点等。</p></blockquote><p>基因识别问题：对给定的DNA序列，确定出所有<strong>编码区域</strong>和<strong>基因结构</strong>。</p><ul><li>包含两个问题：<ul><li>确定出可能的编码区域</li><li>确定出编码和非编码区域的分界点</li></ul></li></ul><h4 id="基因识别与定位的方法">基因识别与定位的方法</h4><p>方法一：通过分子生物学实验确定基因的位置和序列。</p><p>方法二：通过信息分析寻找基因。</p><blockquote><p>方法二基本依据：</p><ul><li>在基因的前后两端存在一些特殊信号。</li><li>基因的蛋白质编码区域与非编码区域在序列的统计特征上有明显的差异。</li><li>可以使用模式识别方法识别DNA序列上与基因相关的信息，区分统计特性，从而识别基因。</li></ul></blockquote><p>根据是否利用同源序列的信息，把基因识别方法分为两类：</p><ul><li>基于同源序列比较的方法<ul><li>利用数据库中现有与基因有关的信息(如EST序列、cDNA、蛋白质序列)，借助同源序列比对去识别可能的基因序列。</li></ul></li><li>基于统计信息的方法<ul><li>从编码蛋白质基因的一般统计规律出发，利用基因序列和非基因序列以及外显子与内含子的统计信息差异性去识别可能的基因序列。</li></ul></li></ul><h4 id="基因编码区识别">基因编码区识别</h4><p>基因的编码区：一般是指预测DNA序列中编码蛋白质的部分(即基因的外显子部分)。</p><blockquote><p>预测编码区域是基因识别中的一个关键问题。</p></blockquote><p>基本依据：真核生物基因外显子(编码区域)具有特别的序列信号，根据这些特征信号可确定外显子的边界，从而识别编码区域。</p><blockquote><p>缺点: 特征信号强度弱，缺乏统计显著性，无法单独使用。</p></blockquote><p>对编码区域进行统计特性分析，可以确定编码区的粗略位置。</p><blockquote><p>DNA中密码子的使用频率不是平均分布的，使得编码区的序列呈现出一定的统计特异性(即密码子偏好性)。</p></blockquote><h3 id="模式识别问题">4.1 模式识别问题</h3><p>模式：观测数据中的某种规则性(regularities)，称为模式(patterns)。</p><p>模式识别：把给定观测数据中的某种规则性(regularities)识别出来(或确认出来)，并应用到新的观测数据上。</p><blockquote><p>给定的观测数据：训练数据集。</p><p>新的观测数据：测试数据集。</p></blockquote><h4 id="一个典型的模式识别问题分成下面4个步骤">4.1.1 一个典型的模式识别问题分成下面4个步骤：</h4><ol type="1"><li>收集待解决问题的观测数据，进行特征抽取。<ul><li>把数据分成训练集和测试集两部分。</li></ul></li><li>选定或设计一个用于解决分类问题的数学模型。<ul><li>称为分类器设计；从数学上，即构造一个从数据到类别的映射。</li></ul></li><li>基于给定训练数据，确定分类模型中的参数。<ul><li>称为模型训练，或参数学习。</li></ul></li><li>在测试数据集上进行性能评价。</li></ol><h4 id="影响模式识别性能的因素">4.1.2 影响模式识别性能的因素：</h4><ul><li>特征表达或特征抽取方式<ul><li>对于一个特定模式分类问题，选定好的特征表达或抽取方式至关重要。</li></ul></li><li>分类器模型复杂度<ul><li>模型过于简单或过于复杂都不能获得好的性能。</li></ul></li><li>模型中参数的学习方法<ul><li>最大似然估计 /最大后验概率估计 /贝叶斯估计。</li></ul></li><li>训练样本数量<ul><li>在不考虑计算成本的情况下, 希望样本尽量多。</li></ul></li><li>训练样本的分布<ul><li>期望训练样本的分布体现数据的真实分布。</li></ul></li></ul><h4 id="模式识别问题举例">4.1.3 模式识别问题举例</h4><p>医生对患者进行疾病诊断的过程是一个典型的模式识别过程。</p><ul><li>医生的诊断过程是通过观察病人表现出的症状和各种化验检测数据来推断病情。</li><li>诊断过程是一个分类过程。<ul><li>医生就好比一个分类器</li><li>医生诊断的准确率与下列因素有密切关系：<ul><li>诊断方式(中医/西医)</li><li>病人的症状是否突出(待分类数据的特性)</li><li>诊断专长(训练样本的分布)</li><li>诊断经验(训练样本数量)</li></ul></li></ul></li></ul><h3 id="推理与决策">4.2 推理与决策</h3><p>推理的基本定义：</p><ul><li>从已知前提(或假设是正确的前提)出发，得出符合逻辑的结论的过程。</li><li>通过事实的模式的观测，间接地看到用于理解的某种新意义或上下文联系。</li></ul><p>对于模式分类来说，推理就是基于给定的数据，确定联合分布密度或者后验分布密度的过程。 <span class="math display">\[D=\{(x_i,t_i)\}\to p(x,t)或p(t|x)\]</span> 决策：给定输入数据 x, 确定最优的输出 t。</p><p>贝叶斯决策：根据平均错误率最小的准则进行决策。</p><ul><li>贝叶斯决策是一种理想的判别规则，需要借助<mark>先验概率</mark>和<mark>似然度</mark>。</li><li>贝叶斯错误率是理论上可获得的最小错误率。</li></ul><p><span class="math display">\[P(mistake)=P(x\in R_1,C_2)+P(x\in R_2,C_1)=\int_{R_1}^{}p(x,C_2)dx+\int_{R_2}^{}p(x,C_1)dx\]</span></p><p>贝叶斯公式：贝叶斯公式用于把先验概率转化为后验概率。 <span class="math display">\[P(M|D)=\frac{P(D|M)P(M)}{P(D)}\qquad 后验概率=\frac{似然度×先验概率}{边缘概率}\]</span> 贝叶斯公式的意义：通过贝叶斯公式，我们把先验概率和从观测数据上得到的似然度相结合，从而得到后验概率。</p><blockquote><p>先验概率: 在获得观测数据之前对判别结果的认识。</p><p>后验概率: 基于观测数据而对判别结果的更新认识。</p></blockquote><p>计算后验概率的过程，也被称为推理；基于所计算的后验概率，可以进行决策。</p><h3 id="朴素贝叶斯方法">4.3 朴素贝叶斯方法</h3><p>在基因编码区，三联密码子出现的频率具有一定统计规律。</p><ul><li>在随机序列中 ，三联密码子出现的频率是相同的——可认为每个密码子出现的频率均为1/64。</li><li>在基因编码区域 ，三联密码子出现的频率并不是均匀的。</li></ul><p>根据这个差异，可以计算不同的阅读框属于基因编码序列的概率，并由此判断是否为基因编码区域。</p><h4 id="基于密码子的出现频率区分编码区">4.3.1 基于密码子的出现频率区分编码区</h4><ul><li><p>基本原理：在DNA序列的编码区和非编码区，三联密码子出现的频率不同；因此基于三联密码子出现频率的差异，可以建立概率模型完成区分。</p></li><li><p>基本步骤：</p><ol type="1"><li><p>对基因编码区和非编码区域分别估计三联密码子的出现概率。</p><p>用C<sub>1</sub>表示非编码区， C<sub>2</sub>表示编码。</p></li><li><p><mark>建立概率模型</mark>，根据后验概率判别该序列否属于基因编码区域。</p></li></ol></li></ul><h4 id="朴素贝叶斯方法-1">4.3.2 朴素贝叶斯方法</h4><p>基本思路：假设各个特征相互条件独立，我们把联合分布或联合概率转化为各个边缘分布或边缘概率的乘积。 <span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}\xrightarrow{S=s_1s_2...s_m} P(C_j|S)=\frac{P(C_j)\prod_{i=1}^{m}P(s_i|C_j)}{P(S)}\]</span> 判别规则：基于最大后验概率准则确定出序列S所属于的类别k <span class="math display">\[k=arg\thinspace \max_{j}\{P(C_j|S,j=1,...K\},其中C_j为类别j\]</span></p><ul><li>设计分类器，即构造一个从给定的数据S到各个类别的映射规则。</li></ul><h4 id="基于序列s建立概率模型">4.3.3 基于序列S建立概率模型</h4><p>考虑2个类别C<sub>1</sub> 和 C<sub>2</sub>：其中用C<sub>1</sub>表示非编码区，C<sub>2</sub>表示编码区。</p><p>对于给定序列S，要判断S属于编码区还是非编码区，可以计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)。</p><ul><li>根据贝叶斯公式： <span class="math display">\[  P(C_1|S)=\frac{P(C_1,S)}{P(S)}∝P(S|C_1)P(C_1)\\\\P(C_2|S)=\frac{P(C_2,S)}{P(S)}∝P(S|C_2)P(C_2)  \]</span></li></ul><p>对于给定序列S，把S表示成 A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>（A<sub>i</sub>为三联密码子），则序列S的出现概率为：P(S) =P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>)。</p><p>假设序列中的3联密码子相互独立(且忽略3联密码子的顺序)，则序列S的出现概率可以转化为：P(S) = P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>) = P(A<sub>1</sub>)P(A<sub>2</sub> )…P(A<sub>L</sub>）</p><blockquote><p>若要计算P(S)，则需要估计出P(A<sub>1</sub>)，P(A<sub>2</sub>), …, P(A<sub>L</sub>）</p></blockquote><p>计算条件概率P(S|C<sub>2</sub>)：</p><p>在编码区(C<sub>2</sub>)观测到序列S的概率，把S表示成三联密码子序列 A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>，则 P(S|C<sub>2</sub>)表达为: <span class="math display">\[P(S|C_2)=P(A_1A_2...A_L|C_2)=P(A_1|C_2)P(A_2|C_2)...P(A_L|C_2)\]</span></p><blockquote><p>这里假设了编码区的序列中的3联密码子相互独立(且忽略3联密码子的顺序)。</p></blockquote><p>则计算P(S|C<sub>2</sub>)需要估计出P(A<sub>1</sub>|C<sub>2</sub>) , P(A<sub>2</sub>|C<sub>2</sub>) , …, P(A<sub>L</sub>|C<sub>2</sub>) 。</p><blockquote><p>也就是基于编码区的序列去估计各个三联密码子的出现概率。</p></blockquote><p>计算条件概率P(S|C<sub>1</sub>)方法同理。</p><p>最后，利用贝叶斯公式： <span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}∝P(S|C_j)P(C_j)\]</span> <mark>分类规则：</mark></p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><h4 id="基于朴素贝叶斯方法识别编码区与非编码区4.3.3的总结">4.3.4 基于朴素贝叶斯方法识别编码区与非编码区（4.3.3的总结）</h4><p>具体步骤：</p><ol type="1"><li><p>基于训练数据集, 估计各个三联密码子的出现概率 <span class="math display">\[P(C_j|S)∝P(C_j)P(A_1A_2...A_L|C_j)=P(C_j)P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span> 其中, P(A<sub>i</sub>|C<sub>j</sub>)为类别C<sub>j</sub>中3联密码子A<sub>i</sub>的出现概率，需要基于给定的训练样本序列去估计。</p><ul><li>计算每个三联体密码子出现的频率f<sub>AAA,</sub> f<sub>AAC</sub>, f<sub>AAG</sub>…, 用频率去估计三联密码子在当前序列中的出现概率。</li></ul></li><li><p>利用三联密码子出现频率，对于基因序列样本集中的每条序列S，计算S的出现概率 P(S|C<sub>1</sub>)和P(S|C<sub>2</sub>）。 <span class="math display">\[P(S|C_j)=P(A_1A_2...A_L|C_j)=P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span></p></li><li><p>估计非编码区和编码区的先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)，计算后验概率P(S|C<sub>1</sub>)P(C<sub>1</sub>)和P(S|C<sub>2</sub>)P(C<sub>2</sub>)。</p><ul><li>先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)可根据训练集里两种类型的序列的比例去估计。</li></ul></li></ol><p>测试阶段：</p><p>给定序列S，计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)</p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>编码区</mark>。</li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>非编码区</mark>。</li></ul><p>该方法优点：模型简便，易于实现。</p><p>该方法缺点：识别率较低。</p><p>改进的方向：</p><ul><li>考虑相邻密码子之间依存关系，建立一阶或高阶马尔科夫模型。</li><li>考虑描述序列的高维向量。</li></ul><h3 id="马尔科夫链markov-chain">4.4 马尔科夫链(Markov Chain）</h3><p>考虑一个具有多个状态的系统S，令O<sub>1</sub>, O<sub>2</sub>, ⋯, O<sub>n</sub>为系统在各个时刻的状态变量，即<mark>状态链</mark>。</p><p>无后效性：</p><ul><li><p>1阶马氏链: 系统在时间步 t 处于哪个状态, 仅与时间t-1时系统所处的状态有关。 <span class="math display">\[P(O_1O_2O_3...O_n)=P(O_1)P(O_2|O_1)P(O_3|O_2)...P(O_n|O_n-1)\]</span></p><ul><li>系统未来的状态仅依赖于当前状态。</li><li>一条马尔可夫链完全决定于初始分布和状态转换概率。</li></ul></li><li><p>k阶马氏链：时间步t的状态仅与时间t-1, t-2, … , t-k时刻的历史状态有关。</p></li></ul><h4 id="考虑三联密码子的1阶马尔科夫性">考虑三联密码子的1阶马尔科夫性：</h4><ul><li><p>给定DNA序列片段S =A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub> ，其中A<sub>i</sub>为3联密码子。</p></li><li><p>在计算P(A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub>)时，我们<mark>引入1阶马尔可夫模型</mark>，把P(A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub>)转化为: <span class="math display">\[P(A_1A_2...A_n)=P(A_1)P(A_2|A_1)...P(A_n|A_{n-1})\]</span></p><ul><li>需要估计出三联密码子之间的转移概率P(A<sub>j</sub>|A<sub>j-1</sub>)和P(A<sub>1</sub>)</li></ul></li></ul><p>状态转移概率P(A<sub>j</sub>|A<sub>i</sub>)的估计:</p><ul><li><p>以编码区为例:A<sub>i</sub>到A<sub>j</sub>的转移概率，需要统计A<sub>i</sub>到A<sub>j</sub>的转移次数，除以所有以A<sub>i</sub>为起始状态转变为A<sub>k</sub>的转移次数: <span class="math display">\[\widetilde{P} (A_j|A_i)=\frac{T_{A_i\to A_j}}{\sum_{k=1}^{64}T_{A_i\to A_k}}\]</span></p><ul><li>其中T<sub>Ai→Aj</sub>表示从状态A<sub>i</sub>转移到状态A<sub>j</sub>的次数。</li></ul></li><li><p>第1个密码子和最后1个密码子需要单独统计: <span class="math display">\[开头:\widetilde{P} (A_i)=\widetilde{P} (A_i|[])=\frac{T_{[]\to A_i}}{\sum_{k=1}^{64}T_{[]\to A_k}}\]</span></p><p><span class="math display">\[结尾:\widetilde{P} (A_j)=\widetilde{P} ([]|A_j)=\frac{T_{A_j\to []}}{\sum_{k=1}^{64}T_{A_k\to []}}\]</span></p><ul><li>即从训练样本序列中统计密码子A<sub>i</sub>出现在开始位置的频率和密码子A<sub>j</sub>出现在末尾的频率。</li></ul></li></ul><p>最后，利用贝叶斯公式计算后验概率： <span class="math display">\[P(C_j|A_1A_2...A_n)=\frac{P(A_1A_2...A_n|C_j)P(C_j)}{P(A_1A_2...A_n)}\]</span> 分类规则：</p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><p>在计算P(C<sub>1</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> ) 和 P(C<sub>2</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> )时，引入<mark>1 阶马尔可夫链</mark>考虑三联密码子之间的依赖关系，即： <span class="math display">\[P(A_1A_2...A_n|C_j)=P(A_1|C_j)P(A_2|A_1,C_j)...P(A_n|A_{n-1},C_j)\]</span></p><ul><li>需要在编码区和非编码区分别估计出三联密码子的转移概率。</li></ul><p>如果S是编码区，那么序列<mark>S=A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>出现的概率P(S)用马氏链</mark>来刻画如下： <span class="math display">\[P(S|C_2)=P(A_1|C_2)\prod_{i=2}^{n}P(A_i|A_{i-1},C_2)\]</span></p><ul><li>若已知或给定从训练样本序列中估计的先验概率和状态转移概率，那么可直接带入公式计算序列S的似然度。<ul><li>P(A<sub>1</sub>|C<sub>2</sub>)是C<sub>2</sub>中以A<sub>1</sub>为第一个密码子的概率P(A<sub>1</sub>|[])</li><li>若考虑末尾A<sub>n</sub>转换为结束态，则还需再乘以P([]|A<sub>n</sub>)或P(A<sub>n</sub>)</li></ul></li></ul><h4 id="马尔科夫链模型的参数估计">马尔科夫链模型的参数估计：</h4><p>先验概率:</p><ul><li>序列属于编码区的先验概率P(C<sub>2</sub>)</li><li>序列属于非编码区的先验概率P(C<sub>1</sub>)</li></ul><p>状态转移概率：</p><p>需要根据训练数据, 分别估计编码区C<sub>2</sub>和非编码区C<sub>1</sub>中各个3联密码子A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>之间的状态转移概率矩阵。</p><h3 id="基于同源序列比对的方法">4.5 基于同源序列比对的方法</h3><p>基本动机：</p><ul><li>部分物种的基因组中有大量基因已被实验证实， 并在相应数据库中有注释(annotation)信息。</li><li>亲缘关系很近的生物体之间可能具有相似的基因。</li><li>用某个物种中的未知基因与亲缘关系相近的其它物种的基因作比较，对揭示未知基因的信息会有帮助。</li></ul><p>基本思路：充分利用序列同源性帮助进行基因识别问题。</p><p>比较两个基因组中的基因：计算最优剪接比对，以比较不同基因组中存在相似度很高的外显子“群岛”区域。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110107270.png" style="zoom:50%;"></p><p>比较基因组DNA与mRNA：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110150024.png" style="zoom:50%;"></p><h3 id="基因识别问题总结">4.6 基因识别问题总结</h3><p>基本任务：从DNA序列中识别出基因编码部分。</p><p>基本方法：基因识别问题归结为模式分类问题。</p><p>计算碱基/密码子的统计信息：</p><ul><li>在DNA的编码区和非编码区，碱基的信号特性是不相同的，比如基因编码区的周期性特征、功能位点。</li><li>在DNA的编码区和非编码区，3联密码子出现的频率是不相同的。</li><li>6联密码子的出现频率在编码区和非编码区具有差异性。<ul><li>比如: AAAAAA 在编码区出现概率为1%，而非编码区为5%。</li></ul></li></ul><p>建立识别模型： 贝叶斯决策 / 朴素贝叶斯 / 马尔科夫链 / HMM。</p><h4 id="基因识别方法的局限性">基因识别方法的局限性：</h4><p>目前的方法仅能识别蛋白质编码基因，对基因非编码部分还没有可靠的识别方法。</p><ul><li>识别原理与基因表达的真实分子机制没有多少关系。<ul><li>由于缺乏识别非编码基因的方法，无法统计在人类基因组中究竟隐藏多少非编码基因。</li></ul></li></ul><p>现有基因识别方法存在固有的保守性。</p><ul><li>不可能发现与数据库中已知基因有较大差别的基因或新基因。</li></ul><p>现有基因识别方法的最大缺陷在于忽视关于基因结构的生物学知识。</p><ul><li>从生物学家来看，现有的基因识别程序还不可靠，需要结合分子生物学、比较基因组学等其他方面研究。</li></ul><h1 id="三隐马尔可夫模型-hidden-markov-model-hmm">三、隐马尔可夫模型 (Hidden Markov Model: HMM)</h1><h2 id="hmm的定义">1.HMM的定义</h2><p>一阶阶离散HMM是一个关于离散序列的随机生成模型。</p><p>基本要素：</p><ul><li>离散明字符集合：V = {V<sub>1</sub> , …, 𝑉<sub>M</sub>}</li><li>有限隐状态集合：S = {S<sub>1</sub> , …, 𝑆<sub>N</sub>}</li><li>初始状态概率向量：<em>π</em> = (<em>π</em><sub>1</sub> , …, <em>π</em><sub>N</sub>)</li><li>状态转移概率矩阵： A = { a<sub>ij</sub>, i,j = 1, …N}</li><li>明字符生成概率矩阵： B = { b<sub>jk</sub>, j = 1, …N, k=1,...M}</li></ul><p>HMM记作<em>λ</em>=(S,V,π,A,B)或<em>λ</em>=(π,A,B)</p><ul><li>一个HMM模型是一个三元组(S, V, λ)，其中λ为模型参数的集合，S 是明字符集V是有限状态集合——每个状态可以产生明字符集中的字符。</li></ul><h2 id="评估问题">2.评估问题</h2><h3 id="前向算法">2.1 前向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\alpha(1,i)=\pi(i)b(i,o_1)\]</span></p></li><li><p>递推 <span class="math display">\[\alpha(t+1,j)=\Bigg[\sum_{i=1}^{N}\alpha(t,i)\alpha(i,j)\Bigg]b(j,o_{t+1})\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\sum_{i=1}^{N}\alpha(T,i)\]</span></p></li></ol><h3 id="前向算法例题">2.2 前向算法例题</h3><p>考虑一个包含两个字符的字符表{C, T}和包含3个状态的状态集{S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>}，HMM的转移概率和字符生成概率如下表。请计算序列O = CCT的全概率。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">→0</th><th style="text-align: center;">→S<sub>1</sub></th><th style="text-align: center;">→S<sub>2</sub></th><th style="text-align: center;">→S<sub>3</sub></th><th style="text-align: center;">生成C</th><th style="text-align: center;">生成T</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">S<sub>1</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.5</td><td style="text-align: center;">0.5</td></tr><tr class="odd"><td style="text-align: center;">S<sub>2</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;"></td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.1</td><td style="text-align: center;">0.9</td></tr><tr class="even"><td style="text-align: center;">S<sub>3</sub></td><td style="text-align: center;">0.4</td><td style="text-align: center;"></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.9</td><td style="text-align: center;">0.1</td></tr></tbody></table><p><span class="math display">\[\Rightarrow\begin{cases}\begin{aligned}\alpha(1,1)=\pi(1)b_1(C)=0.33×0.5=0.165\\\alpha(1,2)=\pi(2)b_2(C)=0.33×0.1=0.033\\\alpha(1,3)=\pi(3)b_3(C)=0.33×0.9=0.297\end{aligned}\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(2,1)=b_1(C)\sum_{i=1}^{3}\alpha(1,i)a_{i1}=0.165×0.3×0.5=0.02475\\\alpha(2,2)=b_2(C)\sum_{i=1}^{3}\alpha(1,i)a_{i2}=(0.165×0.2+0.033×0.4+0.297×0.2)×0.1=0.01056\\\alpha(2,3)=b_3(C)\sum_{i=1}^{3}\alpha(1,i)a_{i3}=(0.165×0.3+0.033×0.4+0.297×0.4)×0.9=0.16335\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(3,1)=b_1(T)\sum_{i=1}^{3}\alpha(2,i)a_{i1}=0.02475×0.3×0.5=0.0037125\\\alpha(3,2)=b_2(T)\sum_{i=1}^{3}\alpha(2,i)a_{i2}=(0.02475×0.2+0.01056×0.4+0.16335×0.2)×0.9=0.0376596\\\alpha(3,3)=b_3(T)\sum_{i=1}^{3}\alpha(2,i)a_{i3}=(0.02475×0.3+0.01056×0.4+0.16335×0.4)×0.1=0.0076989\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow P(O)=P(CCT)=\sum_{i=1}^{3}\alpha(3,i)=0.0037125+0.0376596+0.0076989=0.049071\]</span></p><h3 id="后向算法">2.3 后向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\beta_T(i)=1\]</span></p></li><li><p>递推 <span class="math display">\[\beta_t(i)=\sum_{j=1}^{N}a_{ij}b_j(o_{t+1})\beta_{t+1}(j)\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\pi_ib_i(o_1)\beta_1(i)\]</span></p></li></ol><h2 id="解码问题">3.解码问题</h2><h3 id="维特比viterbi算法">3.1 维特比(Viterbi)算法</h3><p>维特比(Viterbi)算法过程：</p><ol type="1"><li><p>初始化： <span class="math display">\[\delta_1(i)=\pi_ib_i(o_1)\]</span></p></li><li><p>递归： <span class="math display">\[\delta_t(j)=\max_{1\le i\le N}[\delta_{t-1}(i)a_{ij}]*b_j(o_t)\]</span></p></li><li><p>终结： <span class="math display">\[P^*=\max_{1\le i\le N}[\delta_T(i)]\]</span></p></li><li><p>回溯： <span class="math display">\[q^*_T=arg\:\max_{1\le i\le N}[\delta_T(i)\]</span></p></li></ol><h3 id="解码问题例题">3.2 解码问题例题</h3><p>从3个盒子中随机摸出1个球，盒子中的球有黑白两个颜色，重复实验多次，观察球的颜色构成观测序列。</p><ul><li><p>隐含状态集合: {盒子1，盒子2，盒子3} = {S<sub>1</sub>,S<sub>2</sub>,S<sub>3</sub>}</p></li><li><p>观测集合：{黑球，白球} = {Black, White}</p></li><li><p>N=3,M=2</p></li><li><p>初始状态概率:<em>π</em> = (0.3 , 0.5, 0.2)<sup>T</sup></p></li><li><p>状态转移概率矩阵： <span class="math display">\[A = \begin{bmatrix}0.4 &amp; 0.4 &amp; 0.2\\0.3 &amp; 0.2 &amp; 0.5\\0.2 &amp; 0.6 &amp; 0.2\end{bmatrix}\]</span></p></li><li><p>观测生成概率矩阵： <span class="math display">\[B = \begin{bmatrix}0.2 &amp; 0.8\\0.6 &amp; 0.4\\0.4 &amp; 0.6 \end{bmatrix}\]</span></p></li><li><p>请计算观测到序列<mark>O = {o<sub>1</sub> , o<sub>2</sub>, o<sub>3</sub>} = {′黑球′ ， ‘白球’ ， ‘黑球’ }</mark>的最可能的盒子序列。</p></li></ul><p><strong>解：</strong></p><p><strong>t = 1观测到o<sub>1</sub>的概率δ<sub>1</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_1(1)=\pi_1b_{1o_1}=0.3*0.2=0.06\\\delta_1(2)=\pi_2b_{2o_1}=0.5*0.6=0.3\\\delta_1(3)=\pi_3b_{3o_1}=0.2*0.4=0.08\end{cases}\]</span> <img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120605011.png" alt="t = 1 时的观测概率示意图" style="zoom:67%;"></p><p><strong>t = 2观测到o<sub>1</sub>o<sub>2</sub>的概率δ<sub>2</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_2(1)=max[\delta_1(j)a_{j1}]b_{1o_2}=max\{\delta_1(1)a_{11},\delta_1(2)a_{21},\delta_1(3)a_{31}\}b_{1o_2}=max\{0.06*0.4,0.3*0.3,0.08*0.2\}*0.8=max\{0.024,0.09,0.016\}*0.8=0.072,同时记录t=1时的回溯为j=2(对应0.09的取值)\\\delta_2(2)=max[\delta_1(j)a_{j2}]b_{2o_2}=max\{\delta_1(1)a_{12},\delta_1(2)a_{22},\delta_1(3)a_{32}\}b_{2o_2}=max\{0.06*0.4,0.3*0.2,0.08*0.6\}*0.4=max\{0.024,0.06,0.048\}*0.4=0.024,同时记录t=1时的回溯为j=2(对应0.06的取值)\\\delta_2(3)=max[\delta_1(j)a_{j3}]b_{3o_2}=max\{\delta_1(1)a_{13},\delta_1(2)a_{23},\delta_1(3)a_{33}\}b_{3o_2}=max\{0.06*0.2,0.3*0.5,0.08*0.2\}*0.8=max\{0.012,0.15,0.016\}*0.6=0.09,同时记录t=1时的回溯为j=2(对应0.15的取值)\end{cases}\]</span> $$</p><p>$$</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120633023.png" alt="t = 2 时的观测概率示意图" style="zoom:50%;"></p><p><strong>t = 3观测到o<sub>1</sub>o<sub>2</sub>o<sub>3</sub>的概率δ<sub>3</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_3(1)=max[\delta_2(j)a_{j1}]b_{1o_3}=max\{\delta_2(1)a_{11},\delta_2(2)a_{21},\delta_2(3)a_{31}\}b_{1o_3}=max\{0.072*0.4,0.024*0.3,0.09*0.2\}*0.2=max\{0.0288,0.0072,0.018\}*0.2=0.00576,同时记录t=2时的回溯为j=1(对应0.0288的取值)\\\delta_3(2)=max[\delta_2(j)a_{j2}]b_{2o_3}=max\{\delta_2(1)a_{12},\delta_2(2)a_{22},\delta_2(3)a_{32}\}b_{2o_3}=max\{0.072*0.4,0.024*0.2,0.09*0.6\}*0.6=max\{0.0288,0.0048,0.054\}*0.6=0.0324,同时记录t=2时的回溯为j=3(对应0.054的取值)\\\delta_3(3)=max[\delta_2(j)a_{j3}]b_{3o_3}=max\{\delta_2(1)a_{13},\delta_2(2)a_{23},\delta_2(3)a_{33}\}b_{3o_3}=max\{0.072*0.2,0.024*0.5,0.09*0.2\}*0.4=max\{0.0144,0.012,0.018\}*0.4=0.0072,同时记录t=2时的回溯为j=3(对应0.018的取值)\end{cases}\]</span> <img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614121258299.png" alt="t = 3 时的观测概率示意图" style="zoom:50%;"></p><p>解码出的隐含状态序列是: <mark>盒子2，盒子3，盒子2</mark></p><h1 id="四系统发育分析">四、系统发育分析</h1><h2 id="系统发育树">1.系统发育树</h2><p>系统发生树：表达类群/物种/序列之间进化关系的一种树状图。</p><blockquote><p>也叫<mark>系统发育树(Phylogenetic Tree)</mark>、进化树。</p></blockquote><p>分子进化树：从DNA或蛋白质序列数据出发构建而成，用以揭示不同物种之间的进化联系的一种树状图。</p><blockquote><p>分子钟假设：两个物种的同源基因之间的差异程度与它们的共同祖先的存在时间有一定关系, 分子进化速度大体恒定。</p></blockquote><h2 id="基因树和物种树">2.基因树和物种树</h2><p>基因树(gene tree)：基于单个同源基因差异构建的系统树。</p><p>物种树(species tree)：</p><ul><li>表达某一特定类群的进化路径。</li><li>由多个基因或基因组所建立的基因树通过综合而成。</li></ul><p>基因树和物种树两者的差异：</p><ul><li>从两个不同的物种中获取的两个基因，其分化可能早于物种的分化。</li><li>基因树的拓扑结构可能与物种树不一致，因为两个或多个基因树之间很可能存在不一致之处<ul><li>如何将由多个基因或基因组建立的基因树综合成为一个物种树，是分子系统学目前所面临的一个难题。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611221237122.png" alt="物种树" style="zoom: 67%;"></p><h2 id="进化树">3.进化树</h2><p>进化树由结点(node, 顶点)与分枝(branch, 边)组成。</p><p>结点分两类：</p><ul><li>叶结点代表一个分类单元（比如类群、物种或序列）。</li><li>内部结点(祖先结点)代表推断出的共同祖先, 祖先结点可以对应于一种已知的物种，也可以没有对应的物种。</li></ul><p>分枝用以显示不同的遗传路线。</p><p>进化树在本质上包含两类信息：</p><ul><li>树的拓扑信息。</li><li>分枝的长度信息。</li></ul><p>对进化树的分类：</p><ul><li>标度树、非标度树</li><li>二叉树、k-叉树</li><li>有根树、无根树</li></ul><h3 id="标度树与非标度树">3.1 标度树与非标度树</h3><p>非标度树：枝长无意义；叶结点排列整齐，内部结点可以反映进化时间的顺序。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222054188.png" alt="非标度树"><figcaption aria-hidden="true">非标度树</figcaption></figure><p>标度树：枝长有意义；分枝长度与物种/序列的进化时间成正比。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222309737.png" alt="标度树"><figcaption aria-hidden="true">标度树</figcaption></figure><p>两种树都可在分枝上标注信息(分支长度、进化时间以及其它数值)。</p><h3 id="k-叉树">3.2 k −叉树</h3><p>k −叉树 (内部结点的分叉)：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222638711.png" alt="k −叉树" style="zoom:67%;"></p><h3 id="进化树是否有根root">3.3 进化树是否有根(root)</h3><p>有根进化树：</p><ul><li>根表示各个物种共同的祖先。</li><li>从祖先结点只有唯一的路径进化到达叶结点。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223144654.png" alt="有根树（可以明确进化路径）"><figcaption aria-hidden="true">有根树（可以明确进化路径）</figcaption></figure><p>无根进化树：</p><ul><li>没有指定各物种的共同祖先。</li><li>没有关于进化方向的信息。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223708792.png" alt="无根树（无进化方向）"><figcaption aria-hidden="true">无根树（无进化方向）</figcaption></figure><p>有些进化树构造算法产生有根树，也有些算法只能产生无根树。</p><p>无根树→有根树的转换</p><ul><li>利用一个外部类群(物种、序列)生成根。<ul><li>外部类群(outgroup)：与所有待研究类群亲缘关系都较远的类群。</li></ul></li></ul><h2 id="构建进化树的方法">4.构建进化树的方法</h2><h3 id="构建分子进化树">4.1 构建分子进化树</h3><p>推断分子进化树的基本原理：同源序列之间的差异是进化造成的，差异程度与进化时间成正比。</p><blockquote><p>分子钟假设</p></blockquote><p>构建分子进化树的基本方法：</p><ol type="1"><li>刻画多条同源序列的差异</li><li>构建反映序列间差异的树状图<ul><li>从现有数据出发, 试图<mark>推断(或重构)</mark>进化树——真实的进化树是未知的。</li></ul></li></ol><p>推断分子进化树的关键：刻画出序列之间由进化造成的与进化时间成正比的差异。</p><p>刻画序列之间差异的方法：进行序列比对，由最佳比对构造距离(或不相似度)。</p><ul><li><p>设 最佳比对中不匹配位点所占的百分<em>f</em></p><ul><li>“每100个位点上不匹配位点的数目”</li></ul></li><li><p>比如: Jukes-Cantor模型构造的距离： <span class="math display">\[d_{ij}=-\frac{3}{4}log(1-\frac{4f}{3})\]</span></p></li></ul><p>进化树构建算法：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611233724121.png" alt="进化树构建算法"><figcaption aria-hidden="true">进化树构建算法</figcaption></figure><h3 id="非加权组算术平均法upgma">4.2 非加权组算术平均法(UPGMA)</h3><p>最早的基于距离矩阵的方法，最初产生于20世纪60年代早期。</p><ul><li>所有树重建方法中最简单的一种。</li></ul><p>算法特点：</p><ul><li>基于距离矩阵数据</li><li>使用层次式聚类算法</li></ul><p>步骤：</p><ol type="1"><li>初始化：每条序列自成一个组C<sub>i</sub>，分别对应于树中的一个叶结点。</li><li>迭代：<ul><li>寻找具有最小距离值d<sub>ij</sub>的两个组C<sub>i</sub>和C<sub>j</sub> , 合并成 一个新组C<sub>k</sub> = C<sub>i</sub>∪ C<sub>j</sub></li><li>更新C<sub>k</sub>与各旧组C<sub>ℓ</sub>的距离为d<sub>k,ℓ</sub> = (d<sub>i,ℓ</sub>+ d<sub>j,ℓ</sub>)/2</li><li>在树中增加一个分支点，同时与C<sub>i</sub>和C<sub>j</sub>相连接，<strong>两条分枝各为d<sub>i,j</sub>/2</strong></li></ul></li><li>终止：直到所有序列聚为一个组时终止，最终得到的分枝点为树的根。</li></ol><h4 id="例-利用非加权组算数平均法进行进化树构建">例: 利用非加权组算数平均法进行进化树构建</h4><p>A: GTGCTGCACGG CTCAGTATA GCATTTACCC TTCCATCTTC AGATCCTGAA</p><p>B: ACGCTGCACGG CTCAGTGCG GTGCTTACCC TCCCATCTTC AGATCCTGAA</p><p>C: GTGCTCGCAGG CTCGGCGCA GCATTTACCC TCCCATCTTC AGATCCTATC</p><p>D: GTATCACACGA CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCCTAAA</p><p>E: GTATCACATAG CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCTAAA</p><p>1.初始化：计算序列之间的汉明距离，即对应位点上字符不同的数目</p><p>得到初始距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table><p>2.迭代：选择最近结点进行合并，更新距离矩阵，更新进化树</p><p>第1次迭代：更新距离矩阵；合并分支（叶节点）</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201442420.png" alt="第一次迭代"><figcaption aria-hidden="true">第一次迭代</figcaption></figure><p>进化树上标注进化距离：两条分枝各为d<sub><em>ij</em></sub>/2</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201549550.png" alt="第一次迭代得到进化树"><figcaption aria-hidden="true">第一次迭代得到进化树</figcaption></figure><p>第2次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201712875.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201747559.png" alt="第二次迭代得到进化树"><figcaption aria-hidden="true">第二次迭代得到进化树</figcaption></figure><p>第3次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201825651.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201951538.png" alt="第三次迭代得到进化树"><figcaption aria-hidden="true">第三次迭代得到进化树</figcaption></figure><blockquote><p>左侧中间结点((A,C),B) 到中间结点 (A,C)的距离是: 10/2 – 4 = 1</p></blockquote><p>第4次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202054031.png" alt="第四次迭代"><figcaption aria-hidden="true">第四次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202212962.png" alt="第四次迭代得到进化树"><figcaption aria-hidden="true">第四次迭代得到进化树</figcaption></figure><p>3.算法终止：完成进化树构建</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202320043.png"></p><p>不带标度的文本表示法：(((A,C),B),(D,E))</p><p>带标度的文本表示法：(((A:4,C:4):1,B:5):2.25,(D:2.5,E:2.5):4.75)</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202350905.png" alt="最终进化树"><figcaption aria-hidden="true">最终进化树</figcaption></figure><ul><li><p>初始距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li><li><p>进化距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li></ul><blockquote><p>两个距离矩阵中的数值 并不严格匹配</p></blockquote><p>超度量(Ultrametric)：如果任何3个不同序列S<sub>i</sub>,S<sub>j</sub>,S<sub>k</sub>，距离函数d<sub>ij</sub>,d<sub>ik</sub>,d<sub>jk</sub>中的两个相等且不小于第3个, 则称距离函数为超度量。</p><p>若初始距离矩阵为超度量矩阵，则UPGMA算法总能产生正确的进化树。即初始距离矩阵与所构造进化树对应的距离矩阵一致。</p><h1 id="五蛋白质结构分析与预测">五、蛋白质结构分析与预测</h1><h2 id="引言蛋白质">1.引言—蛋白质</h2><p>蛋白质是由<mark>氨基酸</mark>用<mark>肽键</mark>相连接起来的线性聚合物。</p><blockquote><p>蛋白质是平均长度为200个左右的氨基酸。</p><p>大的蛋白质可以达到上千个氨基酸。</p></blockquote><p>蛋白质决定的细胞的形状与结构。</p><ul><li>细胞中蛋白质的重量占细胞干重的一半以上。</li></ul><p>蛋白质是分子识别及催化作用的主要主体，执行生物体内各种重要工作：</p><ul><li>营养物质的运输</li><li>生物反应的催化</li><li>生物体的生长和分化的控制</li><li>生物信号的识别与传递</li></ul><blockquote><p>序列决定结构，结构决定功能。</p></blockquote><p>构成蛋白质的氨基酸序列的长度不同、排列不同和空间结构不同。</p><ul><li><p>一级结构：蛋白质中相邻的氨基酸通过肽键形成一条伸展的链。</p></li><li><p>二级结构：肽链上的氨基酸残基形成局部的二级结构。</p><blockquote><p>比如α螺旋是氨基酸的单链螺旋，而β片层则由序列片段“织”形成平面片状结构。</p></blockquote></li><li><p>空间结构：各种二级结构组合形成完整的折叠结构。</p></li></ul><h2 id="蛋白质结构预测">2.蛋白质结构预测</h2><h5 id="蛋白质结构预测问题的可行性">蛋白质结构预测问题的可行性</h5><p>自然界中实际存在的蛋白质种类是<strong>有限的</strong>，可能的结构类型并不多。</p><ul><li>结构的数目并未随蛋白质氨基残基的个数呈现指数增长。</li></ul><p>存在大量同源序列，序列到结构的关系有一定规律可循。</p><ul><li>相似的序列具有相似的结构。</li></ul><h5 id="蛋白质结构预测问题的数学本质">蛋白质结构预测问题的数学本质</h5><p>寻找一种从蛋白质的氨基酸<strong>线性序列</strong>到蛋白质所有原子<strong>三维坐标</strong>的<mark>一种映射</mark>。</p><h5 id="结构预测的基本方法">结构预测的基本方法</h5><p>统计分析方法：对已知结构的蛋白质进行统计分析，建立氨基酸序列到蛋白质结构的映射模型，进而对未知结构的氨基酸序列根据映射模型直接从序列预测结构。</p><ul><li>经验参数法</li><li>相似片断法</li><li>同源方法</li></ul><p>理论分析方法：假设蛋白质分子取能量最低的空间结构，根据物理化学原理，通过理论计算(如分子力学/分子动力学)进行对氨基酸序列结构预测。</p><ul><li>从头计算法</li></ul><h2 id="蛋白质二级结构预测">3.蛋白质二级结构预测</h2><p>基本依据：每一段相邻氨基酸残基具有形成一定二级结构的倾向。</p><p>问题的本质是模式分类问题。</p><ul><li>蛋白质二级结构的构成具有比较强的统计规律。</li><li>所有蛋白质中约85%的氨基酸残基处于三种基本二级结构状态之一。<ul><li>α螺旋、β折叠和 t 转角</li></ul></li></ul><p>二级结构预测的目标：判断每一段中心的残基是否处于二级结构的三态之一。</p><blockquote><p>三态：α螺旋、β折叠和 t 转角(或其它状态)</p></blockquote><p>二级结构预测的基本思路：相似序列对应着相似的结构。</p><ul><li>相似的一段相邻氨基酸残基，对应着相似的二级结构。</li></ul><p>二级结构预测的基本过程：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612215417920.png" alt="二级结构预测" style="zoom:50%;"></p><p>二级结构预测可利用的信息：</p><ol type="1"><li>单个氨基酸残基统计分析</li></ol><ul><li>从数据集中提取各种残基形成特定二级结构的倾向，以此作为预测依据。</li></ul><ol start="2" type="1"><li>基于氨基酸片断的统计分析<ul><li>统计对象氨基酸片断，片断体现了中心残基所处的环境。</li><li>以残基在特定环境中形成的特定二级结构的倾向作为预测依据。</li></ul></li><li>蛋白质序列的长程信息和进化信息<ul><li>二级结构的形成一定程度上受到长程残基的影响。</li><li>蛋白质家族具有特异的残基替换模式。</li><li>存在进化保守区域，该区域变化则会导致蛋白质结构的改变。</li></ul></li></ol><h5 id="经验参数法">(1)经验参数法</h5><p>根据不同氨基酸形成特定二级结构的倾向进行结构预测。</p><ul><li>通过对已知结构的蛋白质(如蛋白质结构数据库PDB、蛋白质二级结构数据库DSSP中的蛋白质)进行统计分析，可发现各种氨基酸形成不同二级结构的倾向，从而形成一系列关于二级结构预测的规则。</li></ul><h6 id="预测二级结构的经验规则">预测二级结构的经验规则</h6><p>基本思想：在序列中寻找符合某规则的二级结构的成核位点和终止位点。</p><p>基本步骤：扫描输入的氨基酸序列，利用一组规则发现可能成为特定二级结构<strong>成核区域</strong>的短序列，然后对于<strong>成核区域</strong>进行扩展，不断扩大<strong>成核区域</strong>，直到倾向性因子小于1.0为止。</p><ul><li>α螺旋规则</li><li>β折叠规则</li><li>转角规则</li><li>重叠规则</li></ul><h5 id="相似片段法">(2)相似片段法</h5><p>基本原理：最近邻方法。</p><ul><li>相似序列具有相似的结构，将相似序列或序列的片断所对应的二级结构作为预测结果；在预测中心残基的二级结构时，以残基在特定环境形成特定二级结构的倾向作为预测依据。</li></ul><p>基本统计信息：基于氨基酸片段的统计分析。</p><ul><li>统计的对象是氨基酸片段，片段体现了中心残基所处的上下文环境。<ul><li>片段的长度通常为11~21。</li></ul></li></ul><p>实现步骤：</p><ul><li>训练阶段<ul><li>通过窗口扫描已知结构的训练序列，形成大量短片断，即训练片断。</li><li>记录这些片断中心氨基酸残基的二级结构。</li></ul></li><li>预测阶段<ul><li>利用同样大小的窗口扫描待测序列u，在每个窗口位置下的序列片断与上述训练片断比较，找出最相似的k个训练片断。<ul><li>比如 k=20，50</li></ul></li><li>取出现频率最高的训练片断的二级结构作为待测片断二级结构的预测。</li></ul></li></ul><h5 id="同源分析法">(3)同源分析法</h5><p>基本思路：</p><ul><li>将待预测的片段与数据库中已知二级结构的片段进行相似性比较。</li><li>利用打分矩阵计算出相似性得分。</li><li>根据相似性得分以及数据库中的构象态，构建出待预测片段的二级结构。</li></ul><p>适用情况：</p><ul><li>该方法对数据库中同源序列的存在非常敏感。</li><li>若数据库中有相似性大于30%的序列，则预测准确率可大幅上升。</li></ul><h2 id="蛋白质三维空间结构预测">4.蛋白质三维空间结构预测</h2><ul><li>同源模型法</li><li>线索化方法</li><li>从头预测法</li></ul><h5 id="三种方法的比较">三种方法的比较：</h5><p>同源模型法需要得到一个好的序列比对。</p><ul><li>目标蛋白质序列与模板等同部分超过60%，则完全可以找到正确的比对；如果相似程度只有20%-25%，则很难找到正确的比对；如果相似度低于20%，无法应用同源模型化方法。<ul><li>同源模型法是预测结果最可靠的方法</li></ul></li></ul><p>线索化方法需要找到远程同源蛋白。</p><ul><li>如果能够找到同一家族的远程同源蛋白质，则可以获得比较好的预测结果；如果找到的模板属于不同的家族，则预测准确性难以保证。</li></ul><p>从头预测方法</p><ul><li>需要准确的能量函数和快速搜索策略。</li><li>通常难以产生准确的预测结构。</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息，生物，专业课程，马尔可夫，贝叶斯，动态规划，进化树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li><p><a href="https://www.bilibili.com/read/cv12633102/">hexo框架+部署到github</a></p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">前期准备的一些细节问题，这个是部署到gitee的</a>，我们要部署在github，这个只用来看一些细节</p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一些详细资料可以看这里</a></p></li></ul><hr><p>2023/6/7 22:49 快要考试了，但是我还是想花点时间这里这个东西，等整理完这个，再去整理专业课程</p><hr><h1 id="一前期准备">一、前期准备</h1><h2 id="注意事项">1.注意事项</h2><ul><li><p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行</p></li><li><p>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</p></li><li><p>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</p></li></ul><h2 id="下载并安装node.js">2.下载并安装node.js</h2><p>Hexo 是基于Node.js 的博客框架，就像 Java 要依赖 JDK 环境一样。</p><ul><li>node下载地址：http://nodejs.cn/download/ ，傻瓜式安装，这里不再详述</li></ul><p><strong>NodeJS环境安装重点拓展：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 确认node.js安装成功：运行下面两个命令打印版本号即可</span><br>node -v<br>npm  -v<br><br><span class="hljs-comment"># 安装 Node.js 淘宝镜像加速器 （cnpm）</span><br>npm install -g cnpm <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 修改 node 类库默认安装位置</span><br><span class="hljs-comment"># 默认是在 C:\Users\lingStudy\AppData\Roaming\npm</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;D:\nodejs安装路径\node_global&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\nodejs安装路径\node_cache&quot;</span><br><span class="hljs-comment"># 查看修改是否成功</span><br>npm root -g<br><span class="hljs-comment"># 然后把D:\install\node\node_global配置到环境变量的 PATH 下即可</span><br><br></code></pre></td></tr></table></figure><h2 id="安装版本控制工具-git">3.安装版本控制工具 Git</h2><p>用来将本地项目托管到码云，所以还需要自己注册一个码云的账号。</p><p>下载地址：https://git-scm.com/download 学程序的，在工作中 Git 是必知必会的，还没学的建议去看看，所以这里不再详细介绍 Git。</p><p>下面是部署到gitee（码云）上所需要的配置，我们<strong>不需要</strong>进行下面的步骤：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># Git一些重要配置</span><br>git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;lxxxxdy&quot;</span>  <span class="hljs-meta">#码云用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;xxx83@qq.com&quot;</span>   <span class="hljs-meta">#邮箱</span><br><br><span class="hljs-meta"># 生成SSH公钥并添加到码云，实现免密码登录</span><br><span class="hljs-meta"># 1、生成公钥</span><br>ssh-keygen -t rsa<br><span class="hljs-meta"># 2、进入 C:\Users\主机名\.ssh 目录，把 id_rsa.pub 里面的信息复制到码云的 SSH公钥 中即可</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo安装">4.Hexo安装</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 全局安装</span><br>npm install hexo-<span class="hljs-keyword">cli</span> -g<br><span class="hljs-meta"># 查看hexo版本</span><br>hexo -v<br></code></pre></td></tr></table></figure><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70-16861500587952.png"></p><h1 id="二配置github">二、配置github</h1><h2 id="在github上创建仓库">1.在github上创建仓库</h2><h3 id="创建">1.1 创建：</h3><ul><li><p>新建一个名为你的用户名.github.io的仓库。</p></li><li><p>比如说，如果你的github用户名是miqn，那么你就新建miqn.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://miqn.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p></li></ul><h3 id="注意">1.2 注意：</h3><ul><li><p>注册的邮箱一定要验证，否则不会成功；</p></li><li><p>仓库名字必须是：username.github.io，其中username是你的用户名；</p></li><li><p>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</p></li><li><p>创建页面如下：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ca3573693ec7d4b8f30b71b7f22a2003a9bac6e8.png@942w_675h_progressive-16861505570355.webp"></p></li></ul><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="绑定域名这步可省略">2.绑定域名（这步可省略）</h2><p>这里就不详细赘述了，想了解看相关资料。</p><h1 id="三配置ssh免密登录">三、配置SSH免密登录</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><ul><li><p>首先打开电脑文件夹，找到C:\86131 .ssh文件夹并删除 。</p></li><li><p>在C:\86131 文件夹下右键打开Git Bash Here输入命令：ssh-keygen -t rsa -C github邮件地址 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8fb9a4ff9e0410bdbb1e4b89f34208ae2c6ecfd.jpg@942w_407h_progressive.webp"></p></li><li><p>最终生成了一个新的 C:\86131 .ssh文件夹，打开这个文件夹，找到.ssh_rsa.pub文件，记事本打开并复制里面的内容。</p></li><li><p>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/cae65261511e4bf7e4ea0e7838a5bfc5f3560d20.png@942w_509h_progressive.webp"></p></li><li><p>检测是否设置成功：</p><p>输入命令： $ ssh -T git@github.com # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You've successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p></li><li><p>此时你还需要配置：</p><p>$ git config --global user.name "liuxianan"// 你的github用户名，非昵称;</p><p>$ git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱。</p></li></ul><h1 id="四使用hexo搭建博客">四、使用hexo搭建博客</h1><h2 id="初始化">1.初始化</h2><p>第一步：在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是D:，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p>第二步：在D:Git Bash Here，输入hexo init 初始化</p><ul><li><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230607234808122.png"></p></li></ul><p>第三步：执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8d1a66cf00c3dfabb1bff69c531398ef0a33679.png@942w_56h_progressive.webp"></p><p>第四步：hexo s 是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">这篇文章</a></p><h2 id="将博客部署到-github-个人主页上">2.将博客部署到 github 个人主页上</h2><p>第一步：在D:hexo-deployer-git 插件</p><ul><li><p>安装命令： npm install hexo-deployer-git --save</p></li><li><p>必须安装，否则执行hexo d 的话会报如下错误：</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f920d62b355a1a62bb9f6f37571edfb936fc03b2.png@815w_53h_progressive.webp"></p><p>第二步：编辑D:_config.yml 文件, 在文件末尾添加如下内容:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:miqn/miqn.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ul><li>注意：其中 repository 中的内容即为 github 个人主页链接地址，具体看下图：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9cc1855324f9f968aa56d8a94a913475b3bc1d70.png@942w_437h_progressive.webp"></p><p>第三步：在D:，输入命令：hexo d 将本地 blog 推送到 github仓库，也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问 https://miqn.github.io/</li></ul><h1 id="五更换主题">五、更换主题</h1><h2 id="寻找主题">1.寻找主题</h2><ul><li><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</p></li><li><p>这是hexo官网：https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</p></li><li><p>在这里我使用github上一个大佬的主题blinkfox/hexo-theme-matery</p></li><li><p>链接：https://github.com/blinkfox/hexo-theme-matery</p></li></ul><h2 id="下载主题">2.下载主题</h2><p>第一步：Git Bash Here中先cd到D:</p><p>第二步：再输入命令 $ git clone 主题http链接 themes/主题名称</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/dc6cf704d5d468a2f02dcd044fc4a0b4daf78960.png@942w_507h_progressive.webp"></p><p>注意：</p><ul><li>D:theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/075cf0ecdb17fd480e0a705242cf9b6cf28510ee.png@942w_225h_progressive.webp"></p><h2 id="使用主题">3.使用主题</h2><ul><li><p>打开D:_config.yml文件，在里面找到theme: landscape改为theme: blinkfox （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</p></li><li><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</p></li><li><p>再次在浏览器中输入对应域名, 即可发现主题已更换。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/b122a24f4e848f12e98c105e30e57fdc770d6690.png@942w_251h_progressive.webp"></p><h2 id="修改主题内容">4.修改主题内容</h2><p>在这里我使用的是blinkfox主题，后期相关修改参考这个<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">主题文档</a></p><ul><li><p>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的。</p></li><li><p>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开Git Bash Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d 推送到github仓库即可。</p></li><li><p>这样就可以输入网址查看更改后的内容了。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/426b2c5a296d531dcae228493e6d63868179f132.png@942w_353h_progressive.webp"></p><p>文档上没有提及的修改：</p><ul><li>返回按钮样式修改：在主题下面的 blinkfox_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p>特别注意：</p><ul><li>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的 _config.yml文件</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/312648b8eabe0b58395774e2742277f9690a94c6.png@942w_288h_progressive.webp"></p><ul><li>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9545db7dea8f6d676b15ebe2d5542fec221d22ca.png@942w_191h_progressive.webp"></p><h2 id="blinkfox主题的相关配置问题">5.blinkfox主题的相关配置问题</h2><p>配置音乐播放器：使用网易云音乐id不行，这里用的是QQ音乐</p><p>配置留言功能（利用Valine）：</p><ul><li><p>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</p></li><li><p>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的 _config.yml 文件里面搜索 valine，填入appid 和 appkey</p></li><li><p>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去就可以了</p></li><li><p>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs 文件里面更改</p></li></ul><h1 id="六利用typora软件来写博客">六、利用Typora软件来写博客</h1><h2 id="typora介绍">1.Typora介绍</h2><ul><li><p>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</p></li><li><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</p></li><li><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></p></li></ul><h2 id="安装typora">2.安装Typora</h2><p><a href="https://www.typora.io/#windows">Typora官网</a></p><h2 id="写博客的步骤">3.写博客的步骤</h2><p>先创建一个md文档，使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文档名&quot;</span><br></code></pre></td></tr></table></figure><p>用这个命令的好处是帮我们自动生成了时间，默认生成如下内容</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230608101831956.png"></p><p>如果没有这个内容，右键点击插入，再点击YAML Front Matter。</p><p>想要将个人博客同步到网站上，使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>清理缓存，接着使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>生成静态资源文件，此时可以使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>启动本地预览本地是否成功，若需要同步远端则使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>部署到服务器github。</p><p>补充：hexo new page 'postName'命令和hexo new 'postName'的区别？</p><ul><li>hexo new page 'My-second-blog'最终部署时生成：hexo-second-blog.html，但是它不会作为文章出现在博文目录。</li></ul><h2 id="所使用的主题的文章-front-matter-语法">4.所使用的主题的文章 Front-matter 语法</h2><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是 blinkfox 主题，打开<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">blinkfox主题文档</a>，往下翻找到" 文章 Front-matter 介绍 "即可。</p><h1 id="七如何向hexo博客中插入图片">七、如何向hexo博客中插入图片</h1><h2 id="前言">1.前言</h2><p>Hexo是个静态博客程序，使用markdown语法。而Typero是个编辑预览于一身的md编辑器。</p><p>在Typero写文章时候，如果能复制网络图片，或者是截图粘贴到Typero，并且可以<strong>直接在网站上查看该图片</strong>，这样是非常方便的。</p><h2 id="修改hexo">2.修改Hexo</h2><p>首先确认站点配置文件 _config.yml 中有 post_asset_folder:true 这个需要去手动修改</p><p>接着打开git bash，在 hexo 站点目录，执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这样每次新建一篇文章，hexo同时会创建一个与文章名同名的文件夹，用来放图片。</p><h2 id="修改typora">3.修改Typora</h2><p>文件-&gt;偏好设置，下拉找到 <strong>图片插入</strong></p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5cdaf60e1fda7a3b8fb67be354a35485.png"></p><p>修改成上图的样子。填这个 <code>./$&#123;filename&#125;/</code></p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融领域问题匹配</title>
    <link href="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲：</h1><ul><li>任务描述</li><li>数据集介绍</li><li>代码实现——CNN</li><li>代码实现——BERT</li></ul><hr><h1 id="任务描述">任务描述</h1><p>本次任务是金融领域问题匹配。 即针对中文银行领域数据中的问句对， 判定两个句子语义是否相同或者相近。</p><p>举例： &gt; Eg1:<br>&gt; Q1： “看图猜一电影名”<br>&gt; Q2： “看图猜电影”<br>&gt; Label：1</p><blockquote><p>Eg2:<br>Q1： “无线路由器怎么无线上网”<br>Q2： “无线上网卡和无线路由器怎么用”<br>Label：0</p></blockquote><p>label表示问句之间的语义是否相同。<br>若相同则标为1， 若不相同则标为0.</p><p><strong>要求：</strong> <strong>基于示例CNN及BERT代码（或自行设计算法），实现在测试集上语义相似度判断任务（要包含F1值）</strong><br><strong>另外：</strong> <strong>示例代码仅供参考，给出的参数仅仅是稍微试过的，而没经过精细化调参。</strong></p><hr><h1 id="数据集介绍">数据集介绍</h1><p>本次数据集是节选自节选自千言提供的BQ金融领域问题匹配数据集，格式为json文件。<br>数据存放位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/data/</span><br></code></pre></td></tr></table></figure><p>数据集概况如下：</p><table><thead><tr class="header"><th style="text-align: left;">名称</th><th>数量</th><th>标签</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">train.json</td><td>90000</td><td>有</td></tr><tr class="even"><td style="text-align: left;">dev.json</td><td>10000</td><td>有</td></tr><tr class="odd"><td style="text-align: left;">test.json</td><td>10000</td><td>有</td></tr></tbody></table><h1 id="一代码实现cnn">一、代码实现——CNN</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>CNN<br></code></pre></td></tr></table></figure><h2 id="读取数据集">1.读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">data_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    区分训练/验证/测试集</span><br><span class="hljs-string">    @param data_path: 数据json文件存放位置</span><br><span class="hljs-string">    @return: 训练/验证/测试集</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_path) <span class="hljs-keyword">as</span> f:<br>        data = json.load(f)<br><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>同学们直接打开json文件观察数据集看到的应该是ascii码，这和数据的写入方式有关。</p><h2 id="数据预处理">2.数据预处理</h2><p>一般来说，基于CNN的文本语义相似度任务需要如下预处理过程： - 将原始文本分词并转换成以词的序列</p><ul><li><p>将词序列转换成以词编号（每个词表中的词都有唯一编号）为元素的序列</p></li><li><p>将词的编号序列中的每个元素（某个词）展开为词向量的形式。<br><strong>注意：转成词向量需要借助已经建立好的映射，文件太大就没有放进压缩包了。请大家自行下载 网址：<a href="https://pan.baidu.com/s/1ZKePwxwsDdzNrfkc6WKdGQ">百度网盘</a> OR <a href="https://www.aliyundrive.com/s/5cCC1KXqft8">阿里云盘</a></strong><br><strong>下载之后放哪儿？ 这个无关紧要，只要把hyp.py中的<code>embed_path</code>修改成存放位置即可</strong></p><blockquote><p>注意记得把“[]”去掉。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># data_preprocess.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_sentences</span>(<span class="hljs-params">dataset, vocab, is_train, <span class="hljs-built_in">repr</span>=<span class="hljs-string">&#x27;word&#x27;</span>, test_vocab=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将输入转换为id，创建词表</span><br><span class="hljs-string">    参数pred_mode作用是控制是否返回标签</span><br><span class="hljs-string">    因为和gen_data共用一个函数，因此需要根据试验集合调整返回的参数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 数据读取</span><br>    question_1, question_2 = [], []<br>    max_len_1, max_len_2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    punc = punctuation + <span class="hljs-string">u&#x27;1-9.,;《》？！“”‘’@#￥%…&amp;×（）——+【】&#123;&#125;;；●，。&amp;～、|\s: &#x27;</span><br><br>    seq1 = []<br>    seq2 = []<br>    label = []<br><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataset:<br>        seq1.append(data[<span class="hljs-string">&#x27;q1&#x27;</span>])<br>        seq2.append(data[<span class="hljs-string">&#x27;q2&#x27;</span>])<br>        label.append(<span class="hljs-built_in">int</span>(data[<span class="hljs-string">&#x27;label&#x27;</span>]))<br><br>    <span class="hljs-comment"># 数据清洗</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(label)):<br>        <span class="hljs-keyword">if</span> label[i] &gt; <span class="hljs-number">0</span>:<br>            label[i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            label[i] = <span class="hljs-number">0</span><br><br><br>    <span class="hljs-comment"># 对每对问句处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(seq1)):<br>        seq1[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq1[i])<br>        seq2[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq2[i])<br><br>        <span class="hljs-comment"># 将问句分成一个个token</span><br>        q1_tokens = split_sent(seq1[i], <span class="hljs-built_in">repr</span>)<br>        q2_tokens = split_sent(seq2[i], <span class="hljs-built_in">repr</span>)<br><br>        <span class="hljs-comment"># 获取句子最长度</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q1_tokens) &gt; max_len_1:<br>            max_len_1 = <span class="hljs-built_in">len</span>(q1_tokens)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q2_tokens) &gt; max_len_2:<br>            max_len_2 = <span class="hljs-built_in">len</span>(q2_tokens)<br><br>        token_id1, token_id2 = [], []<br><br>        <span class="hljs-comment"># 对单个问句中的每个token进行处理</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q1_tokens:<br>            <span class="hljs-comment"># repr = &#x27;word&#x27;</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    <span class="hljs-comment"># 如果在训练集，就注册词库</span><br>                    <span class="hljs-comment"># eg: vocab[&#x27;word&#x27;][&#x27;我&#x27;] = 10</span><br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    <span class="hljs-comment"># 如果不是在训练集，且未在测试词库注册，则注册</span><br>                    <span class="hljs-comment"># eg&quot; test_vocab[&#x27;word&#x27;][&#x27;注册&#x27;] = 1000</span><br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-comment"># 如果这个token在词库注册了，那么就把对应的键值塞入列表</span><br>                token_id1.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id1.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id1.append(OOV_WORD_INDEX)<br>        <span class="hljs-comment"># print(&quot;-----&quot;, token_id1)</span><br>        question_1.append(token_id1)<br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q2_tokens:<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                token_id2.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id2.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id2.append(OOV_WORD_INDEX)<br>        question_2.append(token_id2)<br><br>    <span class="hljs-keyword">return</span> question_1, question_2, max_len_1, max_len_2, label<br><br><br></code></pre></td></tr></table></figure></p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">train_vocab_emb, test_vocab_emb = construct_vocab_emb(<span class="hljs-string">&quot;./experimental-data&quot;</span>, vocab[<span class="hljs-string">&#x27;word&#x27;</span>], test_vocab[<span class="hljs-string">&#x27;word&#x27;</span>], <span class="hljs-number">300</span>,<br>                                                      base_embed_path=embed_path)<br></code></pre></td></tr></table></figure><h2 id="参数设置">3.参数设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># hyp.py</span><br>hyp = &#123;<br>    <span class="hljs-string">&#x27;embed_path&#x27;</span>: <span class="hljs-string">&#x27;[Your &quot;sgns.wiki.bigram&quot; path]&#x27;</span>, <span class="hljs-comment"># 记得修改位置</span><br>    <span class="hljs-string">&#x27;data_path&#x27;</span>: <span class="hljs-string">&#x27;../../data&#x27;</span>,<br>    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;nb_filters&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;dropout_rate&#x27;</span>: <span class="hljs-number">0.3</span>,<br>    <span class="hljs-string">&#x27;embed_size&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.05</span>,<br>    <span class="hljs-string">&#x27;epoches&#x27;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">&#x27;save_model_name&#x27;</span>: <span class="hljs-string">&quot;checkpoint_textCNN.pt&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="网络模型">4.网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">creat_model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, batch_size, vocab_size, embedding_matrix,</span><br><span class="hljs-params">                 nb_filters, embed_size=<span class="hljs-number">300</span>, dropout_rate=<span class="hljs-number">0.5</span>, num_classes=<span class="hljs-number">2</span>,</span><br><span class="hljs-params">                 kernel_dim=<span class="hljs-number">100</span>, kernel_sizes=(<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>)</span>):<br>        <span class="hljs-built_in">super</span>(creat_model, self).__init__()<br>        self.batch_size = batch_size<br>        self.dropout_rate = dropout_rate<br>        self.embedding_matrix = embedding_matrix<br>        self.vocab_size = vocab_size<br>        self.embed_size = embed_size<br>        self.nb_filters = nb_filters<br>        self.kernel_dim = kernel_dim<br>        self.kernel_sizes = kernel_sizes<br>        self.num_class = num_classes<br>        <span class="hljs-comment"># 词嵌入层</span><br>        self.embedding_layer = self.add_embed_layer(self.embedding_matrix, <br>                                                    self.vocab_size[<span class="hljs-string">&#x27;word&#x27;</span>], self.embed_size)<br>        <span class="hljs-comment"># CNN编码层</span><br>        self.convs = nn.ModuleList([nn.Conv2d(<span class="hljs-number">1</span>, kernel_dim, (k, self.embed_size)) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> kernel_sizes])<br>        <span class="hljs-comment"># 输出分类层</span><br>        self.dropout_layer = nn.Dropout(self.dropout_rate)<br>        self.fc = nn.Linear(<span class="hljs-built_in">len</span>(kernel_sizes) * kernel_dim * <span class="hljs-number">2</span>, num_classes)<br>        nn.init.xavier_uniform_(self.fc.weight.data, gain=<span class="hljs-number">1</span>)<br>        nn.init.constant_(self.fc.bias.data, <span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_embed_layer</span>(<span class="hljs-params">self, vocab_emb, vocab_size, embed_size</span>):<br>        <span class="hljs-keyword">if</span> vocab_emb <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 预训练词向量</span><br>            embed_layer = nn.Embedding(vocab_size, embed_size)<br>            pretrained_weight = np.array(vocab_emb)<br>            embed_layer.weight.data.copy_(torch.from_numpy(pretrained_weight))<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> embed_layer.parameters():<br>                p.requires_grad = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 随机初始化</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Embedding with random weights&quot;</span>)<br>            embed_layer = nn.Embedding(num_embeddings=vocab_size, embedding_dim=embed_size)<br>        <span class="hljs-keyword">return</span> embed_layer<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, query_word_input, doc_word_input</span>):<br>        <span class="hljs-comment"># 这里对视频中的代码做了修改，使用了多个并行的卷积</span><br>        <span class="hljs-comment"># 经过词嵌入层，获得词向量</span><br>        query_word_emb = self.embedding_layer(query_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        doc_word_emb = self.embedding_layer(doc_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(query_word_emb.size())</span><br>        <span class="hljs-comment"># [batch_size, 1, seq_len, embedding_dim]</span><br>        <span class="hljs-comment"># 经过卷积层，和最大池化层</span><br>        query_word_emb = [F.relu(conv(query_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        query_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> query_word_emb]<br>        doc_word_emb = [F.relu(conv(doc_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        doc_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> doc_word_emb]<br>        <span class="hljs-comment"># 拼接不同卷积层的特征</span><br>        query_concated = torch.cat(query_word_emb, <span class="hljs-number">1</span>)<br>        query_concated = self.dropout_layer(query_concated)<br>        doc_concated = torch.cat(doc_word_emb, <span class="hljs-number">1</span>)<br>        doc_concated = self.dropout_layer(doc_concated)<br>        <span class="hljs-comment"># 拼接query和doc</span><br>        concated = torch.cat([query_concated, doc_concated], dim=-<span class="hljs-number">1</span>)<br>        prediction = self.fc(concated)<br>        <span class="hljs-keyword">return</span> prediction<br></code></pre></td></tr></table></figure><h2 id="训练过程">5.训练过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train_CNN.py</span><br>    <span class="hljs-comment"># ===================== TRAIN Model ======================</span><br>    <span class="hljs-comment"># ### 定义模型 ###</span><br>    model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>    model = model.to(device)<br>    <span class="hljs-comment"># 定义优化器</span><br>    opt = torch.optim.SGD(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> p: p.requires_grad, model.parameters()), lr=learning_rate,<br>                          weight_decay=<span class="hljs-number">1e-6</span>, momentum=<span class="hljs-number">0.9</span>, nesterov=<span class="hljs-literal">True</span>)<br>    lr_reducer = ReduceLROnPlateau(optimizer=opt, verbose=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use SGD optimizer&quot;</span>)<br>    <span class="hljs-comment"># 定义损失函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;compile model with binary_crossentropy&quot;</span>)<br>    criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>    criterion.to(device)<br><br>    <span class="hljs-keyword">try</span>:<br>        total_start_time = time.time()<br>        best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        best_auc = <span class="hljs-literal">None</span><br>        best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        train_auc_list, valid_auc_list = [], []<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>            epoch_start_time = time.time()<br>            <span class="hljs-comment"># 训练</span><br>            train_loss, train_fpr, train_tpr, train_auc = train_fc(model, train_dataset, train_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, opt, criterion)<br>            train_auc_list.append(train_auc)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|start of epoch&#123;:3d&#125; | time : &#123;:2.2f&#125;s | loss &#123;:5.6f&#125; | train_auc &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                time.time() - epoch_start_time,<br>                                                                                                train_loss, train_auc))<br>            <span class="hljs-comment"># 验证集上验证性能</span><br>            val_loss, val_fpr, val_tpr, val_auc, val_f1 = validate(model, valid_dataset, valid_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, criterion)<br>            valid_auc_list.append(val_auc)<br>            lr_reducer.step(val_loss)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;| end of epoch &#123;:3d&#125;| time: &#123;:2.2f&#125;s | loss: &#123;:.4f&#125; |valid_auc &#123;&#125; |valid_f1 &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                          time.time() - epoch_start_time,<br>                                                                                                          val_loss,<br>                                                                                                          val_auc,<br>                                                                                                          val_f1))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> best_auc <span class="hljs-keyword">or</span> best_auc &lt; val_auc:<br>                best_auc = val_auc<br>                best_fpr = val_fpr<br>                best_tpr = val_tpr<br>                model_state_dict = model.state_dict()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save the best model... best_auc: %s&quot;</span> % best_auc)<br>                model_weight = hyp[<span class="hljs-string">&#x27;save_model_name&#x27;</span>]<br>                torch.save(model_state_dict, model_weight)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(train_auc_list)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;valid_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(valid_auc_list)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exiting from training early | cost time: &#123;:5.2f&#125;min&quot;</span>.<span class="hljs-built_in">format</span>((time.time() - total_start_time) / <span class="hljs-number">60.0</span>))<br><br><br></code></pre></td></tr></table></figure><h2 id="测试过程">6.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># =================== Test model =====================</span><br>criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>criterion.to(device)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;load best model ... &quot;</span>)<br><span class="hljs-comment"># 定义一个新的模型</span><br>new_model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>new_model = new_model.to(device)<br><span class="hljs-comment"># 加载最佳模型的参数赋给新建模型</span><br><span class="hljs-comment"># model_weight = &quot;checkpoint_textCNN.pt&quot;</span><br>new_model.load_state_dict(torch.load(model_weight), strict=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(model_weight)<br><span class="hljs-comment"># 测试集测试</span><br>test_loss, test_fpr, test_tpr, test_auc, test_f1 = validate(new_model, test_dataset, test_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>], \<br>                                                            batch_size, criterion)<br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_loss:&quot;</span>, test_loss)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_auc:&quot;</span>, test_auc)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test_f1:&#x27;</span>, test_f1)<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><p>训练： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train_CNN.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure> 测试： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python test_CNN.py<br></code></pre></td></tr></table></figure></p><hr><h1 id="二代码实现bert">二、代码实现——BERT</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>BERT<br></code></pre></td></tr></table></figure><h2 id="bert介绍">1.BERT介绍</h2><p>BERT的全称为Bidirectional Encoder Representation from Transformers，是一个预训练的语言表征模型，一经问世便火爆了NLP圈子，在 11 项自然语言处理任务中均表现出惊人的成绩。</p><figure><img src="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/image-20230604002542014.png" alt="&#39;BERT模型图&#39;"><figcaption aria-hidden="true">'BERT模型图'</figcaption></figure><p>然而，原始的BERT参数量较大，对算力有一定的要求。为此，我们在<a href="https://huggingface.co">Hugging Face</a>的模型仓库中找了一个BERT-Tiny让大家体验它的工作流程。<strong>预训练模型的下载地址在这儿：<a href="https://pan.baidu.com/s/1wlSJL7l3koc6XUsrt9bTsg?pwd=igjr">百度网盘</a> OR <a href="https://www.aliyundrive.com/s/rmHMPzyECto">阿里云盘</a></strong></p><p><strong>下载之后放哪儿？ 这个无关紧要，只要把hyp.py中的<code>pretrained_dir</code>修改成存放位置即可</strong></p><p>在本实验中，我们将两个句子拼接后输入BERT，并用BERT的<code>[CLS]</code> token进行两个句子的类别预测工作。</p><h2 id="数据预处理-1">2.数据预处理</h2><p>和CNN中的预处理类似，我们需要将输入文本转换为词向量，才能输入到模型中。但是这些步骤可以利用Hugging Face的库函数实现。这边我们给了一个demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizerFast, BertModel<br><br>pretrained_dir = <span class="hljs-string">&#x27;./pretrained_model/bert-tiny&#x27;</span><br><br>tokenizer = BertTokenizerFast.from_pretrained(pretrained_dir)<br><br>test_word = [(<span class="hljs-string">&#x27;我来自人工智能学院&#x27;</span>,<span class="hljs-string">&#x27;我在学web搜索技术&#x27;</span>), (<span class="hljs-string">&#x27;天气真好&#x27;</span>,<span class="hljs-string">&#x27;我很高兴&#x27;</span>)]<br><br>encoded_word = tokenizer(test_word, padding=<span class="hljs-string">&#x27;longest&#x27;</span>, max_length=<span class="hljs-number">32</span>)<br><span class="hljs-built_in">print</span>(encoded_word)<br><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: <br>[[<span class="hljs-number">101</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">3341</span>, <span class="hljs-number">5632</span>, <span class="hljs-number">782</span>, <span class="hljs-number">2339</span>, <span class="hljs-number">3255</span>, <span class="hljs-number">5543</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">7368</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">1762</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">8353</span>, <span class="hljs-number">3017</span>, <span class="hljs-number">5164</span>, <span class="hljs-number">2825</span>, <span class="hljs-number">3318</span>, <span class="hljs-number">102</span>],<br> [<span class="hljs-number">101</span>, <span class="hljs-number">1921</span>, <span class="hljs-number">3698</span>, <span class="hljs-number">4696</span>, <span class="hljs-number">1962</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">2523</span>, <span class="hljs-number">7770</span>, <span class="hljs-number">1069</span>, <span class="hljs-number">102</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br> <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: <br> [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br>  <span class="hljs-string">&#x27;attention_mask&#x27;</span>: <br>  [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]&#125;<br></code></pre></td></tr></table></figure><p>其中<code>input_ids</code>表示的是输入词编号，<code>token_type_ids</code>表示token对应的句子id，第一句为0，第二句为1。<code>attention_mask</code>表示输入句子的mask，1表示原始token，0表示padding token。由于输入的句子长度不一样，我们可以控制<code>padding</code>统一将所有输入句子的编码结果用0补齐至与最长句子一致。</p><h2 id="模型结构">3.模型结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERT_Tiny</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, pretrained_dir</span>):<br>        <span class="hljs-built_in">super</span>(BERT_Tiny, self).__init__()<br>        self.bert = BertModel.from_pretrained(pretrained_dir)<br>        self.drooput = nn.Dropout()<br>        self.linear = nn.Linear(<span class="hljs-number">312</span>, <span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids, token_type_ids, attention_mask</span>):<br><br>        outputs = self.bert(input_ids = input_ids, token_type_ids = token_type_ids, attention_mask = attention_mask)<br>        pooled_output = outputs[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 取出[cls]作为两个句子的分类表征</span><br>        <span class="hljs-keyword">return</span> self.linear(self.drooput(pooled_output))<br><br></code></pre></td></tr></table></figure><h2 id="训练过程-1">4.训练过程</h2><p><strong>训练损失和f1值不会在控制台打印，而是会以txt文档的形式保存在训练目录下，请同学们自行翻阅日志</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Training ==============================</span><br><br>best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>best_auc = <span class="hljs-literal">None</span><br>best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>train_auc_list, valid_auc_list = [], []<br>logger.info(<span class="hljs-string">&#x27;========= Training ===========&#x27;</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(epochs, desc=<span class="hljs-string">&#x27;Epoch&#x27;</span>):<br>  epoch += <span class="hljs-number">1</span><br>  logger.info(<span class="hljs-string">f&#x27;=========== Epoch<span class="hljs-subst">&#123;epoch&#125;</span> ==========&#x27;</span>)<br>  model.train()<br>  train_loss = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> iteration, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tqdm(train_loader, desc=<span class="hljs-string">&#x27;Iteration&#x27;</span>)):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    optimizer.zero_grad()<br>    loss = criterion(output, labels)<br>    loss.backward()<br><br>    <span class="hljs-comment"># for name, parms in model.named_parameters():</span><br>    <span class="hljs-comment">#     logger.info(f&#x27;--&gt;name: &#123;name&#125; --&gt;grad_requirs: &#123;parms.requires_grad&#125; --&gt;grad_value: &#123;parms.grad&#125;&#x27;)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> iteration % <span class="hljs-number">100</span>:<br>      logger.info(<span class="hljs-string">f&#x27;- batch: <span class="hljs-subst">&#123;iteration&#125;</span> loss: <span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>      train_loss += loss.item()<br>      optimizer.step()<br><br>      num_batches = <span class="hljs-built_in">len</span>(train_data) / batch_size<br>      batch_loss = train_loss / num_batches<br>      logger.info(<span class="hljs-string">f&#x27;train_loss: <span class="hljs-subst">&#123;batch_loss:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br><br>      logger.info(<span class="hljs-string">&#x27;=========== Evaluating on dev set ==========&#x27;</span>)<br>      model.<span class="hljs-built_in">eval</span>()<br>      y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>      corrects = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(dev_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>          input_ids, token_type_ids, attention_mask, labels = batch<br>          output = model(input_ids, token_type_ids, attention_mask)<br><br>          pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>          corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>          pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>          label = labels.data.cpu().numpy()<br><br>          <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            y_true = label<br>            y_pred = pred_label<br>            <span class="hljs-keyword">else</span>:<br>              y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>              y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>              r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>              auc = roc_auc_score(y_true, y_pred)<br>              logger.info(corrects)<br>              logger.info(thresh)<br>              acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(dev_data)<br>              logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>              <span class="hljs-keyword">if</span> best_f1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> f1 &gt; best_f1:<br>                best_f1 = f1<br>                logger.info(<span class="hljs-string">f&#x27;Get best dev model at epoch <span class="hljs-subst">&#123;epoch&#125;</span>, f1 <span class="hljs-subst">&#123;f1&#125;</span>&#x27;</span>)<br>                torch.save(model.state_dict(), save_model_name)<br><br></code></pre></td></tr></table></figure><h2 id="测试过程-1">5.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Load model ============================</span><br>logger.info(<span class="hljs-string">&#x27;============= Loading model ==============&#x27;</span>)<br>model = BERT_Tiny(pretrained_dir=pretrained_dir)<br>model.load_state_dict(torch.load(save_model_name))<br>model.to(device)<br><br>criterion = nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>logger.info(<span class="hljs-string">&#x27;=========== Testing on test set ==========&#x27;</span>)<br>model.<span class="hljs-built_in">eval</span>()<br>y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>corrects = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>  <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(test_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>    corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>    pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>    label = labels.data.cpu().numpy()<br><br>    <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>      y_true = label<br>      y_pred = pred_label<br>      <span class="hljs-keyword">else</span>:<br>        y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>        y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>        r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>        auc = roc_auc_score(y_true, y_pred)<br>        acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(test_data)<br>        logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="使用-1">使用</h4><p>训练：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> test.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web搜索，专业课程，项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于文本和图像的多媒体检索系统</title>
    <link href="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料</p></blockquote><ul><li><a href="http://www.zzvips.com/article/214469.html">在pycharm中配置pyqt5</a></li></ul><hr><p>2023/6/2 22:44 这是我基于《多媒体信息检索课程设计》所作的一个项目，涉及到了计算机视觉方面的知识，主要用到了BOW模型。代码语言为python，运行环境为pycharm。废话不多说，开始操作。</p><hr><h1 id="一所需安装的软件及库">一、所需安装的软件及库</h1><h2 id="anaconda及pycharm的安装">1.Anaconda及pycharm的安装</h2><p>详情见多媒体信息检索实验指导（一）。</p><h2 id="jieba的安装">2.jieba的安装</h2><h3 id="全自动安装">2.1 全自动安装</h3><p>在pycharm终端或cmd输入：</p><p><code>pip install jieba / pip3 install jieba</code></p><h3 id="pycharm安装">2.2 pycharm安装</h3><p>依次点击 文件-设置-项目-解释器-“加号”，接着搜索需要的库并添加。</p><h3 id="手动安装">2.3 手动安装：</h3><p>将 jieba 的整个目录放置于python的site-packages 目录中。</p><h2 id="在pycharm中配置pyqt5">3.在pycharm中配置pyqt5</h2><h3 id="pyqt5简介">3.1 PyQt5简介</h3><p>1.什么是<a href="http://www.zzvips.com/article/106394.html">GUI</a>：Graphical User Interface，图形用户界面，用于人机交互。</p><p>2.怎么设计GUI：Qt。</p><p>3.什么是Qt：Qt是一种基于C++的跨平台图形用户界面应用程序开发框架。</p><p>4.学习python的我们怎么用Qt：PyQt5模块。</p><p>5.什么是PyQt5:Qt的python接口，pyqt5对Qt进行完全封装，我们可以利用python代码设计想要的图形界面。</p><h3 id="安装pyqt5模块">3.2 安装PyQt5模块</h3><p>(包括pyqt5,pyqt5-tools,pyqt5designer）</p><p>依次点击 文件-设置-项目-解释器-“加号” 来添加。</p><h3 id="配置pyqt5设计器qt-designer及转换工具">3.3 配置PyQt5设计器（Qt Designer）及转换工具</h3><h4 id="qt-designer">(1)Qt Designer</h4><p>用途：方便我们打开设计器。</p><p>首先同样是在file里面打开settings：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046403193-6.png"></p><p>Name：我们自己给这个tool起的名字。</p><p>Program：填入designer.exe的路径，每个人路径不同，找到自己计算机上的 路径输进去。一般来说是在D:-packages.exe这里。</p><p>Working directory:填入$ProjectFileDir$，表示文件所在的项目路径。</p><h4 id="pyuic">(2)PyUIC</h4><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046402509-7.png"></p><p>Name:自己起的名字。</p><p>Program:python.exe所在的位置，一般在D:.exe这里。</p><p>Arguements:填入-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 是将.ui文件转化成.py文件的语句。</p><p>Working directory:$FileDir$,表示文件所在路径。</p><h2 id="pcv包的安装">4.PCV包的安装</h2><p>1.下载PCV包：https://codeload.github.com/Li-Shu14/PCV/zip/master；</p><p>2.打开Anaconda3的prompt窗口，切换到下载好的PCV包所在的路径下；</p><p>3.执行以下命令：</p><p><code>pip install PCV-master.zip</code></p><blockquote><p><strong>注：</strong> 压缩包不用解压，直接pip install即可。</p></blockquote><h2 id="vlfeat包安装">5.vlfeat包安装</h2><p>1.下载安装vlfeat包，版本0.9.20 官方下载连接：http://www.vlfeat.org/download/（注意要下载20版本，不然会出现找不到.sift文件）</p><p>2.下载完成过后，把vlfeat里win64里的vl.dll和sift.exe和vl.lib复制粘贴到项目目录下：这样子环境配置基本上已完成。</p><blockquote><p><strong>注：</strong>vlfeat0.9.21版本太高导致部分电脑提取特征为空，要用9.20版本。</p></blockquote><h2 id="pysqlite3库安装">6.pysqlite3库安装</h2><ul><li><p>访问 https://www.sqlite.org/download.html 页面，下载 Windows 版 SQLite 预编译二进制文件。</p><p>注意要下载与你 Python 版本和操作系统位数（32 位或 64 位）对应的版本。</p></li><li><p>解压缩下载的 SQLite 文件。</p><p>在解压后的文件夹中，你将看到一些静态库和工具，以及一个名为 sqlite3.dll 的共享库文件。这个文件是 <code>pysqlite3</code> 包所依赖的 SQLite 动态链接库。</p></li><li><p>访问 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pysqlite 页面，找到 <code>pysqlite3</code> 的适用于你的 Python 版本和操作系统位数的安装包并下载。</p><p>下载后的文件名一般是这样的：<code>pysqlite3-x.x.x-cpXX-cpXXm-win_amd64.whl</code>，其中 <code>x.x.x</code> 是版本号，<code>cpXX</code> 是 Python 主版本和次版本号，例如 <code>cp39</code> 代表 Python 3.9，<code>win_amd64</code> 表示 64 位 Windows 平台。</p></li><li><p>在命令提示符中使用 pip 安装刚才下载的 <code>pysqlite3</code> 安装包。</p><p>进入 <code>pysqlite3</code> 安装包所在的目录，然后运行以下命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">`Copy Codepip install pysqlite<span class="hljs-number">3</span>-<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>-cpXX-cpXXm-win_amd<span class="hljs-number">64</span>.whl`<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>如果你 Python 版本为 32 位，请下载适用于 32 位 Python 的安装包，并将含有 <code>win_amd64</code> 的部分替换为 <code>win32</code> 即可。</p><p>pysqlite3这个库下载比较麻烦，下载之后需要重新编译python，并且要注意pycharm中的编译环境最好设置为python所在的python.exe这个环境，否则之前安装的一些库会不在列表中。</p><p>也要注意python3版本使用的是sqlite3这个库，尽管编辑器报错的时候会提醒一个跟pysqlite2有关的错误，最后解决的方法是同时更换文件中和PCV中imagesearch.py的import，尝试更改那里即可成功。</p></blockquote><h1 id="二文本检索部分算法说明">二、文本检索部分算法说明</h1><h2 id="文本爬取">1.文本爬取</h2><p>我对https://www.8lrc.com/ 网站的经典歌词进行了爬取，并将爬取到的歌词，用’lyrics’+歌名+歌手的命名方式，以记事本的文件类型保存在了当前文件夹里。并将标题与歌词的对应关系进行了保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lyrics_urls</span>():<br>    titles = []  <span class="hljs-comment"># 用于保存标题</span><br>    urls = []  <span class="hljs-comment"># 用于保存每首歌的链接</span><br>    qianzhui = <span class="hljs-string">&#x27;https://www.8lrc.com/&#x27;</span>  <span class="hljs-comment"># 爬取网站</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):  <span class="hljs-comment"># 共49页</span><br>        link = <span class="hljs-string">&#x27;https://www.8lrc.com/jingdian/32/&#x27;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27;.htm&#x27;</span>  <span class="hljs-comment"># 每页链接</span><br>        req = requests.get(link)    <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取排行榜中的30首歌信息</span><br>        lrcList = soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&#x27;lrcList&#x27;</span>)<br>        lrcList = BeautifulSoup(<span class="hljs-built_in">str</span>(lrcList), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        r = lrcList.find_all(<span class="hljs-string">&#x27;li&#x27;</span>, class_=<span class="hljs-string">&#x27;clearfix&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r:     <span class="hljs-comment"># 对于每首歌</span><br>            lrc = BeautifulSoup(<span class="hljs-built_in">str</span>(i), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>            Singer = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGeshou&#x27;</span>).get_text()  <span class="hljs-comment"># 获取歌手名</span><br>            Song = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get_text().split(<span class="hljs-string">&#x27;[&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取歌名</span><br>            urls.append(qianzhui + lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get(<span class="hljs-string">&#x27;href&#x27;</span>))  <span class="hljs-comment"># 获取链接</span><br>            titles.append((Song + <span class="hljs-string">&#x27; &#x27;</span> + Singer).replace(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment"># 标题记为歌名+歌手名</span><br>    <span class="hljs-keyword">return</span> titles, urls<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">titles, urls</span>):<br>    lyrics_set = &#123;&#125;  <span class="hljs-comment"># 用于保存标题与歌词的对应关系</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(urls)):  <span class="hljs-comment"># 对于每页歌词链接</span><br>        req = requests.get(urls[i])     <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取内容</span><br>        <span class="hljs-keyword">if</span> soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:   <span class="hljs-comment"># 排除没有歌词或链接失效等情况</span><br>            lrc = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>).text    <span class="hljs-comment"># 获取歌词</span><br>            lrc = lrc.split(<span class="hljs-string">&#x27;编辑于&#x27;</span>)[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 去掉每首歌都包含的编辑信息</span><br>            lyrics_set[titles[i]] = lrc   <span class="hljs-comment"># 保存标题与歌词的对应冠词</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>((<span class="hljs-string">&#x27;lyrics&#x27;</span> + titles[i] + <span class="hljs-string">&#x27;.txt&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># 将歌词以txt的格式下载</span><br>                f.writelines(lrc)  <span class="hljs-comment"># 写入歌词</span><br>    <span class="hljs-keyword">return</span> lyrics_set<br>titles, urls = lyrics_urls()<br>lyrics_set = download(titles, urls)<br><br></code></pre></td></tr></table></figure><h2 id="jieba分词">2.jieba分词</h2><p>使用jieba分词对每首歌进行分词并统计所有词(每个词的长度大于1)记为一个集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">all_words = []  <span class="hljs-comment"># 用于统计所有词</span><br>    split_lyric = &#123;&#125;  <span class="hljs-comment"># 用于统计每首歌包含的词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        lyric = lyrics_set[j]  <span class="hljs-comment"># 获取歌词</span><br>        word = jieba.lcut(lyric)  <span class="hljs-comment"># 分词并返回list</span><br>        word = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i) &gt; <span class="hljs-number">1</span>]  <span class="hljs-comment"># 去掉单字</span><br><br>        split_lyric[j] = word<br>        all_words.extend(word)<br><br>    set_all_words = <span class="hljs-built_in">set</span>(all_words)<br>    <br></code></pre></td></tr></table></figure><h2 id="倒排索引">3.倒排索引</h2><p>每个歌词文本都可以用一系列关键词来表示，如果按关键词建立到文本的倒排索引便可以实现根据关键词快速地检索到相关文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">invert_index = &#123;&#125;  <span class="hljs-comment"># 倒排索引</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> set_all_words:  <span class="hljs-comment"># 对于每个词</span><br>        temp = []  <span class="hljs-comment"># 用于保存包含词的歌名</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> split_lyric[j]:  <span class="hljs-comment"># 若词在歌中</span><br>                temp.append(j)  <span class="hljs-comment"># 保存歌名</span><br>        invert_index[i] = tempvert_index[i] = temp<br>        <br></code></pre></td></tr></table></figure><h2 id="建立vsm模型">4.建立VSM模型</h2><p>向量空间模型(Vector Space Model, VSM)可以把提取文本内容中的关键词作为向量空间中的向量，并将向量间的相似度作为衡量文本相似度的标准。</p><p>关键词的提取使用TF-IDF算法<strong>（term frequency–inverse document frequency，词频-逆文档频率）</strong>。TF是词频，表示词在文本中出现的频率；IDF是逆文档频率，表示词的常见程度。将两者相乘得到TF-IDF值，其大小表示了词对文本的重要程度，因此可以选取TF-IDF值大的作为文本的关键词。</p><p>我们取TF-IDF值最大的10个作为关键词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">VSM</span>(<span class="hljs-params">invert_index, split_lyric</span>):<br><br>    IDF = &#123;&#125;  <span class="hljs-comment"># 统计每次词的逆文档频率</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> invert_index.keys():  <span class="hljs-comment"># 对于每个词</span><br>        IDF[j] = math.log(<span class="hljs-built_in">len</span>(split_lyric) / (<span class="hljs-built_in">len</span>(invert_index[j]) + <span class="hljs-number">1</span>))<br><br>    TF = &#123;&#125;  <span class="hljs-comment"># 统计词频</span><br>    TF_IDF = &#123;&#125;   <span class="hljs-comment"># 统计TF-IDF值</span><br>    key_word = &#123;&#125;   <span class="hljs-comment"># 统计每首歌的关键词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> split_lyric.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        count = <span class="hljs-built_in">dict</span>(Counter(split_lyric[j]))   <span class="hljs-comment"># 统计每个词在歌词中的出现次数</span><br>        temp_TF = &#123;&#125;<br>        temp_TI = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> count.keys():  <span class="hljs-comment"># 对于每次词</span><br>            temp_TF[i] = count[i] / <span class="hljs-built_in">max</span>(count.values())  <span class="hljs-comment"># 计算TF</span><br>            temp_TI[i] = temp_TF[i] * IDF[i]    <span class="hljs-comment"># 计算TF-IDF</span><br>        TF[j] = temp_TF<br>        TF_IDF[j] = temp_TI<br>        all_sorted = <span class="hljs-built_in">sorted</span>(TF_IDF[j].items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将每个词的TF-IDF值从大到小排序</span><br>        key_word[j] = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> all_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> all_sorted[:<span class="hljs-number">10</span>]]    <span class="hljs-comment"># 取其中前10个作为关键词</span><br>    <span class="hljs-keyword">return</span> TF, key_word<br><br></code></pre></td></tr></table></figure><h2 id="计算余弦相似度">5.计算余弦相似度</h2><p>首先我们要获取关键词出现在歌曲里的词频：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tf</span>(<span class="hljs-params">keyword, song</span>):<br>    kw_tf = np.zeros(<span class="hljs-built_in">len</span>(keyword))  <span class="hljs-comment"># 若歌词中不包含关键词则词频为0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> keyword:   <span class="hljs-comment"># 对于每个关键词</span><br>        <span class="hljs-keyword">if</span> song <span class="hljs-keyword">in</span> invert_index[i]:  <span class="hljs-comment"># 若歌词中包含关键词</span><br><br>            kw_tf[keyword.index(i)] = TF[song][i]   <span class="hljs-comment"># 获取关键词的词频</span><br><br>    <span class="hljs-keyword">return</span> kw_tf<br><br></code></pre></td></tr></table></figure><p>然后就可以计算余弦相似度： <span class="math display">\[cos(q,d_j)=\frac{\sum_{i=1}^{m}w_{ij}*w_{iq}}{\sqrt{\sum_{i=1}^{m}w_{ij}^2}*\sqrt{\sum_{i=1}^{m}w_{iq}^2}}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">song1, song2</span>):<br>    keyword = <span class="hljs-built_in">set</span>(key_word[song1] + key_word[song2]) <span class="hljs-comment"># 获取两首歌的关键词集合</span><br>    keyword = <span class="hljs-built_in">list</span>(keyword)<br><br>    tf1 = get_tf(keyword, song1)<br>    tf2 = get_tf(keyword, song2)<br><br><br>    result = dot(tf1, tf2) / (norm(tf1) * norm(tf2))    <span class="hljs-comment"># 计算其余弦相似度</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h2 id="检索和输入歌曲相似度最高的十首歌曲">6. 检索和输入歌曲相似度最高的十首歌曲</h2><p>首先用get_tf函数得到输入歌曲和每首歌曲的关键词的词频，然后计算输入歌曲和每首歌曲的余弦相似度。</p><p>最后比较余弦相似度，余弦相似度越高，则该歌曲与输入歌曲的歌词越相似，输出前十首余弦相似度最大的歌曲。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">song</span>):<br>    score = &#123;&#125;<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> TF.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        score[j] = compare(song, j)  <span class="hljs-comment"># 获取与指定歌曲比对所得的余弦相似度作为得分</span><br>    score_sorted = <span class="hljs-built_in">sorted</span>(score.items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将得分从大到小排序</span><br>    result = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> score_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> score_sorted[<span class="hljs-number">1</span>:<span class="hljs-number">11</span>]]<br><span class="hljs-comment"># 取其中得分最高的10个</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h1 id="三图像检索部分算法说明">三、图像检索部分算法说明</h1><h2 id="图片爬取">1.图片爬取</h2><p>我这里选择爬取百度图片，可以进行分类爬取，我这里爬取了30张猫的图片，30张花朵的图片，30张人脸图片，30张车的图片，30张轮船的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPages</span>():<span class="hljs-comment">#只能得到30张图片，想得到更多图片，需要变化params[&#x27;pn&#x27;]的值。</span><br>    headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77&quot;</span>&#125;<br>    url=<span class="hljs-string">&#x27;https://image.baidu.com/search/acjson&#x27;</span><br>    <span class="hljs-comment">#追加请求内容（负载）</span><br>    params=&#123;<br>        <span class="hljs-string">&#x27;tn&#x27;</span>:<span class="hljs-string">&#x27;resultjson_com&#x27;</span>,<br>        <span class="hljs-string">&#x27;logid&#x27;</span>:<span class="hljs-string">&#x27;5336511566462226640&#x27;</span>,<br>        <span class="hljs-string">&#x27;ipn&#x27;</span>:<span class="hljs-string">&#x27;rj&#x27;</span>,<br>        <span class="hljs-string">&#x27;ct&#x27;</span>:<span class="hljs-string">&#x27;201326592&#x27;</span>,<br>        <span class="hljs-string">&#x27;is&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;fp&#x27;</span>:<span class="hljs-string">&#x27;result&#x27;</span>,<br>        <span class="hljs-string">&#x27;fr&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;word&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cg&#x27;</span>:<span class="hljs-string">&#x27;girl&#x27;</span>,<br>        <span class="hljs-string">&#x27;queryWord&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cl&#x27;</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<br>        <span class="hljs-string">&#x27;lm&#x27;</span>:<span class="hljs-string">&#x27;-1&#x27;</span>,<br>        <span class="hljs-string">&#x27;ie&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;oe&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;adpicid&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;st&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;ic&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;hd&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;latest&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;copyright&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;se&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;tab&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;width&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;height&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;face&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;istype&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;qc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nc&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-string">&#x27;expermode&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nojc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;isAsync&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;pn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;rn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;gsm&#x27;</span>:<span class="hljs-string">&#x27;1e&#x27;</span>,<br>        <span class="hljs-string">&#x27;1660570401395&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span><br>        &#125;<br>    res=requests.get(url=url,headers=headers,params=params)<br>    <span class="hljs-comment"># print(res.json())</span><br>    data=res.json()[<span class="hljs-string">&#x27;data&#x27;</span>]<br>    <span class="hljs-comment"># print(data)</span><br>    <span class="hljs-comment">#得到所有图片地址</span><br>    urlPages=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> i.get(<span class="hljs-string">&#x27;thumbURL&#x27;</span>) !=<span class="hljs-literal">None</span>:<br>            urlPages.append(i[<span class="hljs-string">&#x27;thumbURL&#x27;</span>])<br>    <span class="hljs-comment"># print(urlPages)</span><br>    <span class="hljs-comment">#检测文件夹是否存在</span><br>    <span class="hljs-built_in">dir</span>=<span class="hljs-string">&#x27;D:\pycharm\picture&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-built_in">dir</span>):<br>        os.mkdir(<span class="hljs-built_in">dir</span>)<span class="hljs-comment">#创建目录方法</span><br>    <span class="hljs-comment">#向每个图片url发起请求</span><br>    x=<span class="hljs-number">70</span><br>    name1=<span class="hljs-string">&#x27;paris_invalides_00000&#x27;</span><br>    name2=<span class="hljs-string">&#x27;paris_invalides_0000&#x27;</span><br> <br>    <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> urlPages:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下载成功&#x27;</span>)<br>        res=requests.get(url=o,headers=headers)<br>        <span class="hljs-comment">#下载到dir文件夹</span><br>        <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">10</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name1&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">9</span>&lt;x&lt;<span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name2&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br> <br>        x+=<span class="hljs-number">1</span><br>getPages()<br></code></pre></td></tr></table></figure><h2 id="计算机视觉中的bag-of-words基础流程">2.计算机视觉中的Bag-of-words基础流程</h2><h3 id="特征提取-sift">2.1 特征提取 （SIFT）</h3><p>过分割、密集或随机采集、关键点或稳定区域、显著区域等方式使图像形成不同的图像块，并获得各图像块处的特征。</p><h3 id="学习-视觉词典visual-vocabulary-k-means">2.2 学习 “视觉词典（visual vocabulary）” （k-means）</h3><p>在上面提取完SIFT特征的步骤后,利用K-means聚类算法将提取的SIFT特征聚类生成视觉词典。</p><p>K-means算法是度量样本间相似性的一种方法，该算法设置参数为K，把N个对象分成K个簇，簇内之间的相似度较高，而簇间的相似度较低。聚类中心有K个，视觉词典为K。</p><h3 id="针对输入特征集根据视觉词典进行量化">2.3 针对输入特征集，根据视觉词典进行量化</h3><p>这一步骤通过对图像特征提取，然后将提取出来的特征点，根据第三步，转换为频率直方图。</p><p>这里在转换为频率直方图时候，有使用到TF-IDF，即词频(Term Frequency，TF)与逆文档频率(Inverse Document Frequency，IDF)乘积作为权值。引入这个权值的目的是为了降低一些重复特征所带来的影响。比如在BOW中，一些常用词汇譬如the，it，do等等词汇，不能体现文本内容特征，但是出现频率却很高，利用tf-idf可以降低这种不必要词汇的影响。同理，在BOF图像搜索中，图像之间也会有这样的无意义的特征出现，所以需要降低这类特征的权值。</p><h3 id="把输入图像转化成视觉单词visual-words的频率直方图">2.4 把输入图像转化成视觉单词（visual words）的频率直方图</h3><h3 id="构造特征到图像的倒排表通过倒排表快速索引相关图像">2.5 构造特征到图像的倒排表，通过倒排表快速索引相关图像</h3><p>倒排表是一种逆向的查找方式，在BOW中大体的思路是通过已经提取出来的词汇，反向查找出现过这个词汇的文章。</p><h3 id="根据索引结果进行直方图匹配">2.6 根据索引结果进行直方图匹配</h3><p>当我们做完上面的步骤，就需要对直方图进行匹配。直方图的匹配给出输入图像的频率直方图，在数据库中查找K个最近邻的图像，根据这K个近邻来投票图像的分类结果。</p><h2 id="特征提取">3.特征提取</h2><p>SIFT算法的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。</p><p>特征提取及描述主要是将一些<strong>具有代表性</strong>且<strong>区分性较强</strong>的<strong>全局或局部特征</strong>从图像中进行抽取，这些特征一般是类别之间差距比较<strong>明显的特征</strong>，可以将其与其他类别区分开，其次，这些特征还要求具有<strong>较好的稳定性</strong>，并对这些特征进行描述。</p><p>通常会使用SIFT算法从图片上提取出很多特征点，每个特征点都是128维的向量，因此，如果图片足够多的话,我们会提取出一个巨大的特征向量库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_image</span>(<span class="hljs-params">imagename, resultname, params=<span class="hljs-string">&quot;--edge-thresh 10 --peak-thresh 5&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Process an image and save the results in a file. &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> imagename[-<span class="hljs-number">3</span>:] != <span class="hljs-string">&#x27;pgm&#x27;</span>:<br>        <span class="hljs-comment"># create a pgm file</span><br>        im = Image.<span class="hljs-built_in">open</span>(imagename).convert(<span class="hljs-string">&#x27;L&#x27;</span>)  <span class="hljs-comment"># .convert(&#x27;L&#x27;) 将RGB图像转为灰度模式，灰度值范围[0,255]</span><br>        im.save(<span class="hljs-string">&#x27;tmp.pgm&#x27;</span>)  <span class="hljs-comment"># 将灰度值图像信息保存在.pgm文件中</span><br>        imagename = <span class="hljs-string">&#x27;tmp.pgm&#x27;</span><br><br>    cmmd = <span class="hljs-built_in">str</span>(<br>        <span class="hljs-string">&quot;D:\pycharm\picture\sift.exe &quot;</span> + imagename + <span class="hljs-string">&quot; --output=&quot;</span> + resultname +<br>        <span class="hljs-string">&quot; &quot;</span> + params)<br>    os.system(cmmd)  <span class="hljs-comment"># 执行sift可执行程序，生成resultname(test.sift)文件</span><br>    <span class="hljs-built_in">print</span><br>    <span class="hljs-string">&#x27;processed&#x27;</span>, imagename, <span class="hljs-string">&#x27;to&#x27;</span>, resultname<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_features_from_file</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Read feature properties and return in matrix form. &quot;&quot;&quot;</span><br><br>    f = loadtxt(filename)<br>    <span class="hljs-keyword">return</span> f[:, :<span class="hljs-number">4</span>], f[:, <span class="hljs-number">4</span>:]  <span class="hljs-comment"># feature locations, descriptors</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_features</span>(<span class="hljs-params">im, locs, circle=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Show image with features. input: im (image as array),</span><br><span class="hljs-string">        locs (row, col, scale, orientation of each feature). &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_circle</span>(<span class="hljs-params">c, r</span>):<br>        t = arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.01</span>, <span class="hljs-number">.01</span>) * <span class="hljs-number">2</span> * pi<br>        x = r * cos(t) + c[<span class="hljs-number">0</span>]<br>        y = r * sin(t) + c[<span class="hljs-number">1</span>]<br>        plot(x, y, <span class="hljs-string">&#x27;b&#x27;</span>, linewidth=<span class="hljs-number">2</span>)<br><br>    imshow(im)<br>    <span class="hljs-keyword">if</span> circle:<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> locs:<br>            draw_circle(p[:<span class="hljs-number">2</span>], p[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">else</span>:<br>        plot(locs[:, <span class="hljs-number">0</span>], locs[:, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;ob&#x27;</span>)<br>    axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="生成词汇">4.生成词汇</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> vocabulary<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br> <br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br> <br><span class="hljs-comment"># 提取文件夹下图像的sift特征</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images):<br>    im = array(Image.<span class="hljs-built_in">open</span>(imlist[i]).convert(<span class="hljs-string">&#x27;L&#x27;</span>))<br>    sift.process_image(imlist[i], featlist[i])<br> <br><span class="hljs-comment"># 生成词汇</span><br>voc = vocabulary.Vocabulary(<span class="hljs-string">&#x27; d:/pycharm/picture/paris_louvretest&#x27;</span>)<br>voc.train(featlist, <span class="hljs-number">500</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># 保存词汇</span><br><span class="hljs-comment"># saving vocabulary</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(voc, f)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;vocabulary is:&#x27;</span>, voc.name, voc.nbr_words)<br><br></code></pre></td></tr></table></figure><h2 id="图像索引创建数据库">5.图像索引（创建数据库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> imagesearch<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> sqlite3 <span class="hljs-keyword">import</span> dbapi2 <span class="hljs-keyword">as</span> sqlite<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br><span class="hljs-comment"># load vocabulary</span><br><span class="hljs-comment"># 载入词汇</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    voc = pickle.load(f)<br><span class="hljs-comment"># 创建索引</span><br>indx = imagesearch.Indexer(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>indx.create_tables()<br><span class="hljs-comment"># go through all images, project features on vocabulary and insert</span><br><span class="hljs-comment"># 遍历所有的图像，并将它们的特征投影到词汇上</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)[:<span class="hljs-number">1000</span>]:<br>    locs, descr = sift.read_features_from_file(featlist[i])<br>    indx.add_to_index(imlist[i], descr)<br><span class="hljs-comment"># commit to database</span><br><span class="hljs-comment"># 提交到数据库</span><br>indx.db_commit()<br><br>con = sqlite.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select count (filename) from imlist&#x27;</span>).fetchone())<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select * from imlist&#x27;</span>).fetchone())<br><br></code></pre></td></tr></table></figure><h2 id="图像检索">6.图像检索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">i</span>):<br>  <span class="hljs-comment"># 获取图像列表</span><br>  imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>  nbr_images = <span class="hljs-built_in">len</span>(imlist)<br>  <span class="hljs-comment"># 获取特征列表</span><br>  featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br>  <span class="hljs-comment"># 载入词汇</span><br>  f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>  voc = pickle.load(f)<br>  f.close()<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  locs, descr = sift.read_features_from_file(featlist[<span class="hljs-number">0</span>])<br>  iw = voc.project(descr)<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ask using a histogram...&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(src.candidates_from_histogram(iw)[:<span class="hljs-number">10</span>])<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try a query...&#x27;</span>)<br><br>  nbr_results = <span class="hljs-number">11</span><br>  res = [w[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> src.query(imlist[i-<span class="hljs-number">1</span>])[:nbr_results]]<br><br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算搜索结果得分:&quot;</span>)<br>  score=imagesearch.compute_ukbench_score(src, imlist[:<span class="hljs-number">10</span>])<br>  <span class="hljs-keyword">return</span> src, res, score<br><br></code></pre></td></tr></table></figure><h2 id="对数据库的操作">7.对数据库的操作</h2><p>我在最终运行的时候发现在图像检索时，有时会出现是个运行结果中有一两个显示不出来的问题，一开始我还以为是电脑卡顿的问题。然后我试着打印了res：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603231847152.png"></p><p>发现当运行结果中有一两个显示不出来时，res中有几个序号就大于我的图片总数，我知道了是我的数据库出现了问题，于是我用以下代码查看我的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>result = cursor.fetchall()<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(row)<br>    <br>conn.close()<br><br></code></pre></td></tr></table></figure><p>发现了下面的问题，我知道了是我之前在刚刚做图像检索时尝试代码，用了其他的命名方式给图片命名，这就导致了我后来的图片没有覆盖掉数据库中这些数据，其还占据着我的数据库，但图片和sift已经被我在文件夹中删掉了，如下图所示：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232019342.png"></p><p>而我之所以运行结果中有一两个显示不出来的问题，是因为它正好匹配到了那几个占据着我的数据库但不存在于我的图片库的序号。于是想着通过删除数据库的数据，来把数据库清空，再进行一次图像索引创建数据库，就可以删掉那几个多出的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br><span class="hljs-comment"># 1.创建数据库连接</span><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-comment"># 2.创建游标</span><br>cursor = conn.cursor()<br><br><span class="hljs-comment"># 删除数据库表记录</span><br><br>results = cursor.execute(<span class="hljs-string">&quot;DELETE  FROM imlist &quot;</span>)<br>conn.commit()  <span class="hljs-comment"># 更新数据库</span><br>results = cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>cursor.close()  <span class="hljs-comment"># 关闭cursor对象</span><br>conn.close()  <span class="hljs-comment"># 关闭数据库连接</span><br><br></code></pre></td></tr></table></figure><p>结果成功将那几个多余数据删除:</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232117000.png"></p><p>但当我很兴奋地去执行最后一步图像检索时，却出现了下面的报错：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232137227.png"></p><p>我尝试了各种办法，到处搜索，甚至还重新创建一个工程，用了一下午的时间，最终我突然想到，之所以会检索到有空的类型，是我之前删掉的那几个多余数据就变成了空的类型，我是150张图片，而数据库现在容量是153，3个位置是空的，于是我便又找了三张图片加入了进去，提取特征，生成词汇，再加入数据库，随后检索，果然成功，解决了这个问题。</p><p>最后，我一开始遇到的运行结果中有一两个显示不出来的问题也得到了解决。</p><blockquote><p>还有一个问题，导致如果匹配到前九张图片，就会显示不出来，原因是我的if语句用错了，应该是if,elif,else，而不是if,if,else。</p></blockquote><h1 id="三操作界面设计">三、操作界面设计</h1><p>利用了pyqt，点击工具中的QTdesigner，利用到了Push Button、Lable、Text Browser。</p><p>然后保存得到一个.ui文件，然后利用工具中的PyUIC，将.ui文件转换为.py文件。</p><p>将输入的歌曲和图像显示在界面上，然后输出前十个候选结果，且将余弦相似度和得分显示在界面上。</p><p>图像显示和文本显示用的方法是不同的，文本显示直接用setText即可将结果写入：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232530108.png"></p><p>图像显示首先使用QtGui模块中的QPixmap类创建一个名为jpg的Pixmap对象，该对象表示Name路径指定的图像文件；然后使用.scaled()方法将图像缩放到与label标签具有相同的宽度和高度。这是为了确保图像适应标签的大小；最后用setPixmap()方法将缩放后的图像设置为label标签的当前图像。这将在界面上显示图像。</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232558759.png" alt="image-20230603232558759"><figcaption aria-hidden="true">image-20230603232558759</figcaption></figure><p>代码中在显示图片的输出结果时我没有用循环，只是笨拙的罗列，所以我就不都放完整代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QFileDialog, QApplication<br><span class="hljs-keyword">from</span> gui <span class="hljs-keyword">import</span> Ui_MainWindow<br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtGui<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(QMainWindow, Ui_MainWindow):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>(MyWindow, self).__init__(parent)<br>        self.setupUi(self)<br>        self.pushButton.clicked.connect(self.<span class="hljs-built_in">open</span>)  <span class="hljs-comment"># 将点击按钮与函数open连接</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):<br>        Name, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择歌词&quot;</span>, <span class="hljs-string">&quot;./lyrics/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.txt)&quot;</span>)  <span class="hljs-comment"># 获取选择的歌曲名字</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(Name, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-comment"># 打开所选歌曲的歌词</span><br>            data = f.read()     <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser.setText(data)      <span class="hljs-comment"># 将歌词显示在textBrowser上</span><br>        Name = <span class="hljs-built_in">str</span>(Name).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉歌名的位置信息</span><br>        Name = Name[<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉歌名的后缀(.txt)</span><br><br>        self.label.setText(Name)    <span class="hljs-comment"># 将歌名显示在label上</span><br>        self.label_4.setText(get_keyword(Name)) <span class="hljs-comment">#将歌的关键词显示在label_4上</span><br>        result = search(Name)   <span class="hljs-comment"># 检索与所选歌歌词最相似的十首歌</span><br>        best = result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]     <span class="hljs-comment"># 最相似的一首歌</span><br>        result = <span class="hljs-string">&#x27;\n&#x27;</span>.join([<span class="hljs-built_in">str</span>(x[<span class="hljs-number">1</span>]) + <span class="hljs-number">8</span> * <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(x[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result])  <span class="hljs-comment"># 调整检索结果</span><br>        self.label_2.setText(result)  <span class="hljs-comment"># 将检索结果显示在label_2上</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;lyrics&#x27;</span> + best + <span class="hljs-string">&#x27;.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:   <span class="hljs-comment"># 打开相似效果最好的歌词</span><br>            data = f.read()  <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser_2.setText(data)  <span class="hljs-comment"># 将歌词显示在textBrowser_2上</span><br>        self.label_5.setText(get_keyword(best)) <span class="hljs-comment">#将歌的关键词显示在label_5上</span><br><br>        Name0, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择图片&quot;</span>, <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.jpg)&quot;</span>)  <span class="hljs-comment"># 获取选择的图片名字</span><br>        jpg = QtGui.QPixmap(Name0).scaled(self.label_8.width(), self.label_8.height())<br>        self.label_8.setPixmap(jpg)     <span class="hljs-comment"># 将输入图片显示在label_8上</span><br><br>        Name0 = <span class="hljs-built_in">str</span>(Name0).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉图片的位置信息</span><br>        Name0 = Name0[-<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉图片的后缀(.txt)</span><br>        i=<span class="hljs-built_in">int</span>(Name0)<br>        src, res, score=get(i)<br>        self.label_10.setText(<span class="hljs-built_in">str</span>(score))  <span class="hljs-comment"># 将搜索得分显示在label_10上</span><br>        <span class="hljs-comment">#将搜索到的10张图片显示</span><br>        <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">10</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_00000&quot;</span>+<span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>        <span class="hljs-keyword">else</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_0000&quot;</span> + <span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>……<br><br></code></pre></td></tr></table></figure><h1 id="四程序运行结果图">四、程序运行结果图</h1><h2 id="歌词爬取结果">1.歌词爬取结果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232945163.png" alt="所有歌词"><figcaption aria-hidden="true">所有歌词</figcaption></figure><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233009341.png" alt="单个歌词"><figcaption aria-hidden="true">单个歌词</figcaption></figure><h2 id="图片爬取结果">2.图片爬取结果</h2><p>猫：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233058696.png" alt="“猫”的爬取结果"><figcaption aria-hidden="true">“猫”的爬取结果</figcaption></figure><p>车：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233130164.png" alt="“车”的爬取结果"><figcaption aria-hidden="true">“车”的爬取结果</figcaption></figure><p>......</p><h2 id="最终效果">3.最终效果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233219873.png" alt="最终运行结果"><figcaption aria-hidden="true">最终运行结果</figcaption></figure><h2 id="总结与不足">4.总结与不足</h2><p>可以看出文本检索实现的很好，图像检索有八个正确结果，还算不错。</p><p>不足的地方一是在图像检索中，由于图像集数目不足，以及图片背景过于丰富，会导致特征采集不准确，有几个出现错误；</p><p>BOW的一个主要缺点是在用视觉单词表示图像时不包含图像特征的位置信息，而图像特征的位置信息在人脸识别图像时起到了很好的作用；</p><p>我觉得可以改进的地方，输入一张非图像库内的图像，然后再与图像库图像进行检索和匹配。且可以让文本检索和图像检索联系起来，输入文本可以既能得到相似文本，又能得到对应语义的图片，实现更强的功能。</p>]]></content>
    
    
    <categories>
      
      <category>进阶项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多媒体，专业课程，项目，计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SYSTEMVIEW通信原理实验</title>
    <link href="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一简单介绍">一、简单介绍</h1><h3 id="内容介绍">内容介绍</h3><ul><li>AM的调制与解调</li><li>SSB的调制与解调</li><li>FM的调制与解调</li><li>数字信号的基带传输</li><li>MASK的调制与解调</li><li>2FSK的调制与解调</li><li>2PSK的调制与解调</li><li>16QAM调制与解调</li><li>抽样定理</li></ul><h3 id="报告截图">报告截图</h3><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122412650.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122519556.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122608610.png"></p><h1 id="二报告和软件自行提取">二、报告和软件自行提取</h1><p>链接：https://pan.baidu.com/s/1o5ZZVY0MbFcnZWClfQXSPQ</p><p>提取码：k783</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程，实践课，systemview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研规划</title>
    <link href="/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/"/>
    <url>/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理(Ⅰ)</title>
    <link href="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/"/>
    <url>/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li>视频教程<a href="https://www.bilibili.com/video/BV11x411G79C/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ef3842945b0f7729a278874a86c98aa5">北邮 通信原理公开课 杨鸿文</a></li></ul><h1 id="一绪论">一、绪论</h1><h2 id="通信系统和通信网的构成">1.通信系统和通信网的构成</h2><h3 id="通信系统">1.1 通信系统</h3><p>通信系统：指点对点通信所需的全部设施</p><p>通信系统的香农模型:</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233002637.png"></p><p>信源：信息的发送者；信宿：信息的接收者。信源和信宿决定了通信系统的<strong>业务性质</strong>。例如电话系统传送语音信息，电报或数据通信系统传送代表某些信息的符号，电视系统传送活动图像的信息等。</p><p>编码：泛指把信源输出变换成适合信道传送的信号所需的设备。有信源编码、信道编码。</p><p>译码: 编码的反变换所需要的设备。</p><p>信道: 传送信息的通道。</p><p>以电信号为物理载体的通信系统（通信系统的另一种模型）：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233644437.png"></p><p>信源：</p><ul><li>模拟信源：各种传感器的输出，其存在形式一般是基带电信号；</li><li>数字信源：电脑、手机中存储的比特。</li></ul><p>信道：</p><ul><li>基带信道：一般可建模为低通型滤波器；</li><li>频带信道：一般可建模为带通型滤波器。</li></ul><p>故有这四种传输：</p><ul><li>模拟基带传输：最简单的传输</li><li>模拟频带传输：第四章</li><li>数字基带传输：第五章</li><li>数字频带传输：第六章</li></ul><h3 id="通信网">1.2 通信网</h3><p>通信网的构成：</p><ul><li><p>通信系统：终端设备（编码、译码）、传输设备（信道）；</p></li><li><p>交换设备：</p><ul><li><p>电路交换：如公共电话网，优点：实时、QoS(Quality of Service)高；缺点：信道利用率低。</p></li><li><p>分组交换：如Internet网，优点：信道利用率高；缺点：实时和QoS不易保证。</p></li></ul></li><li><p>信令和协议</p></li></ul><h3 id="信息消息信号">1.3 信息、消息、信号</h3><p>信息：要表示和传送的对象。</p><p><strong>消息</strong>：信息的表现形式，信息的数学表示形式。</p><p>信号：信号是与消息对应的某种物理量，信息的物理表示形式。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233053555.png" alt="信息、消息、信号"><figcaption aria-hidden="true">信息、消息、信号</figcaption></figure><p>香农信息论认为：信息的多少等于无知度的大小。人们已知的消息不是信息，而好像，大概，可能之类的不确切的内容包含着信息。 <span class="math display">\[离散消息的熵定义:H(X)=-\sum{p(x)\log_2p(x)}\]</span></p><p><span class="math display">\[连续消息的熵定义:H(X)=-\int_{a}^{b}{p(x)\log_2p(x)}dx\]</span></p><ul><li>连续消息的信息量是无限的.</li><li>连续消息有无穷个状态，因此根据香农熵的定义必然为无穷大。</li></ul><h3 id="通信系统的主要性能指标">1.4 通信系统的主要性能指标</h3><ul><li><p>有效性：是指在给定信道内传输的信息量的多少</p></li><li><p>代价：资源占用情况</p></li><li><p>带宽；传输速率、频带利用率</p></li><li><p>可靠性：是指接收信息的准确度</p><ul><li>质量：失真大小</li><li>输出信噪比、调制增益；误码率、误比特率</li></ul></li><li><p>码元传输速率（R<sub>S</sub> 或R<sub>B</sub>）：码元传输速率简称传码率，也称码元速率或符号速率。它被定义为单位时间（s<sup>-1</sup>）内传输码元的数目，单位为波特，记为Baud或B。</p></li><li><p>信息传输速率（R<sub>b</sub>）：信息传输速率简称传信率，又称信息速率。它被定义为单位时间（s<sup>-1</sup>）内传递的信息量（bit数），单位是比特/秒，也记为bit / s或bps。</p></li></ul><h1 id="二确定信号分析">二、确定信号分析</h1><h2 id="傅里叶变换">1.傅里叶变换</h2><h3 id="傅里叶变换与反变换">1.1 傅里叶变换与反变换</h3><p><span class="math display">\[傅里叶变换:F(f)=\int_{-\infty}^{+\infty}{f(t)e^{-j2\pi ft}}dt\]</span></p><p><span class="math display">\[傅里叶反变换:f(t)=\int_{-\infty}^{+\infty}{F(f)e^{j2\pi ft}}df\]</span></p><h3 id="典型信号的傅里叶变换">1.2 典型信号的傅里叶变换</h3><ul><li><p>矩形脉冲信号： <span class="math display">\[E\tau sinc(t\tau)\Leftrightarrow E[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p><p><span class="math display">\[也可表示为:E\tau sinc(t\tau)\Leftrightarrow Erect(\frac{f}{\tau})\]</span></p><p><span class="math display">\[E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]\Leftrightarrow E\tau sinc(f\tau)\]</span></p><p><span class="math display">\[sinc(x)=\frac{sin(\pi x)}{\pi x},Sa(x)=\frac{sin(x)}{x}\]</span></p><p><span class="math display">\[E\tau Sa(\pi t\tau)\Leftrightarrow E[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p></li></ul><p><span class="math display">\[拓展:Asinc^2(at)\Leftrightarrow\frac{A}{a}(1-\frac{|f|}{a})\]</span></p><ul><li><p>单边指数信号： <span class="math display">\[Ee^{-at}(t&gt;0,a&gt;0)\Leftrightarrow\frac{E}{a+j2\pi f}\]</span></p></li><li><p>直流信号：</p></li></ul><p><span class="math display">\[E\Leftrightarrow E\delta(f)\]</span></p><ul><li><p>单位冲激信号： <span class="math display">\[\delta(t)\Leftrightarrow 1\]</span></p></li><li><p>符号函数：</p></li></ul><p><span class="math display">\[f(t)=\begin{cases} +1，t&gt;0\\ -1， t&lt;0\end{cases},\quad F(w)=\frac{1}{j\pi f}\]</span></p><ul><li><p>阶跃函数： <span class="math display">\[  u(t)\Leftrightarrow\frac{1}{j2\pi f}+\frac{1}{2}\delta(f)  \]</span></p></li><li><p>正余弦函数： <span class="math display">\[cos(2\pi f_0)\Leftrightarrow\frac{1}{2}[\delta(f+f_0)+\delta(f-f_0)]\]</span></p><p><span class="math display">\[sin(2\pi f_0)\Leftrightarrow\frac{j}{2}[\delta(f+f_0)-\delta(f-f_0)]\]</span></p></li></ul><h3 id="傅里叶变换的性质">1.3 傅里叶变换的性质</h3><ul><li>尺度变换性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(at)\Leftrightarrow\frac{1}{|a|}F(\frac{w}{a})\]</span></p><ul><li>时移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t-t_0)\Leftrightarrow\ F(w)e^{-jwt_0}\]</span></p><blockquote><p>同号</p></blockquote><ul><li>对称性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则F(t)\Leftrightarrow 2\pi f(-w),或F(t)\Leftrightarrow f(-f)\]</span></p><p><span class="math display">\[若f(t)为偶函数,则F(t)\Leftrightarrow2\pi f(w)\]</span></p><ul><li>频移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t)e^{jw_0t}\Leftrightarrow\ F(w-w_0)\]</span></p><blockquote><p>异号</p></blockquote><ul><li>微分性质：</li></ul><p><span class="math display">\[f&#39;(t)\Leftrightarrow jwF(w),\quad f^{(n)}(t)\Leftrightarrow(jw)^{n}F(w)\]</span></p><p><span class="math display">\[tf(t)\Leftrightarrow jF&#39;(w),\quad t^{n}f(t)\Leftrightarrow j^{n}F^{(n)}(w)\]</span></p><ul><li>积分性质：</li></ul><p><span class="math display">\[F(0)=0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\frac{F(w)}{jw}\]</span></p><p><span class="math display">\[F(0)\neq0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\pi F(0)\delta(w)+\frac{F(w)}{jw}\]</span></p><h3 id="积化和差公式">1.4 积化和差公式</h3><p><span class="math display">\[cosacosβ=\frac{1}{2}[cos(a+β)+cos(a-β)]\]</span></p><p><span class="math display">\[sinasinβ=-\frac{1}{2}[cos(a+β)-cos(a-β)]\]</span></p><p><span class="math display">\[sinacosβ=\frac{1}{2}[sin(a+β)+sin(a-β)]\]</span></p><p><span class="math display">\[cosasinβ=\frac{1}{2}[sin(a+β)-sin(a-β)]\]</span></p><h2 id="能量谱密度与功率谱密度及相关函数">2.能量谱密度与功率谱密度及相关函数</h2><h3 id="能量信号与功率信号">2.1 能量信号与功率信号</h3><ul><li>能量信号：</li></ul><p><span class="math display">\[E_f=\int_{-\infty}^{\infty}{f^{2}(t)}dt&lt;\infty(能量有限)\]</span></p><ul><li>功率信号：</li></ul><p><span class="math display">\[P_f=\lim_{T\rightarrow+\infty}\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{f^{2}(t)}dt&lt;\infty(能量无限，功率有限)\]</span></p><h3 id="能量信号的相关函数">2.2 能量信号的相关函数</h3><ul><li>能量信号x(t)与y(t)的互相关函数</li></ul><p><span class="math display">\[R_{xy}(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt\]</span></p><p><span class="math display">\[R_{yx}(\tau)=\int_{-\infty}^{\infty}{y(t+\tau)x^{*}(t)}dt\]</span></p><ul><li>能量信号x(t)的自相关函数：</li></ul><p><span class="math display">\[R_x(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)x^{*}(t)}dt\]</span></p><blockquote><p>实信号不需要共轭</p></blockquote><ul><li>相关函数的性质：</li></ul><p><span class="math display">\[共轭对称性:R_{xy}(\tau)=R^{*}_{yx}(-\tau)\]</span></p><p><span class="math display">\[R_{x}(\tau)=R^{*}_{x}(-\tau)\]</span></p><p><span class="math display">\[x(t)的能量是自相关函数在\tau=0处的值\]</span></p><ul><li><p>许瓦兹不等式： <span class="math display">\[许瓦兹不等式:\vert \int_{-\infty}^{\infty}{s_1(t)s_2^{*}(t)}dt\vert\leq\sqrt{E_1E_2}\]</span></p><p><span class="math display">\[互相关函数满足:|R_{xy}(\tau)|=|\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt|\leq\sqrt{E_xE_y}\]</span></p><p><span class="math display">\[自相关函数在\tau=0时最大:R_x(\tau)\leq R_x(0)=E_x\]</span></p></li></ul><h3 id="能量谱密度">2.3 能量谱密度</h3><p><span class="math display">\[互能量谱密度:E_{xy}(f)=X(f)Y^*(f)\]</span></p><p><span class="math display">\[能量谱密度:E_{x}(f)=X(f)X^*(f)=|X(f)|^2\]</span></p><p><span class="math display">\[能量（帕塞瓦尔定理）:E_x=\int_{-\infty}^{\infty}{|x(t)|^2}dt=\int_{-\infty}^{\infty}{|X(f)|^2}df\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是能量谱密度:R_x(\tau)\Leftrightarrow|X(f)|^2\]</span></p><h3 id="功率信号的相关函数">2.4 功率信号的相关函数</h3><p><span class="math display">\[R_x(\tau)=\overline{[x(t+\tau)x^{*}(t)]}\]</span></p><p><span class="math display">\[自相关函数在\tau=0的值是功率:R_x(0)=\overline{[x(t)x^{*}(t)]}=P_x\]</span></p><blockquote><p>其他性质可类比能量信号</p></blockquote><h3 id="功率谱密度">2.5 功率谱密度</h3><p><span class="math display">\[功率:P_x=R_x(0)=\overline{|x(t)|^2}=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|X_T(f)|^2}df\bigg)=\int_{-\infty}^{\infty}{\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)}df\]</span></p><p><span class="math display">\[功率谱密度:P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是功率谱密度:R_x(\tau)\Leftrightarrow P_x(f)\]</span></p><h2 id="带宽">3.带宽</h2><h3 id="单边功率谱">3.1 单边功率谱</h3><p>从数学上来说，当我们对一个信号作傅里叶变换时，f的定义域是(-∞，+∞)，频率可正可负。</p><p>但在物理测量当中，负频率是没有意义的，f的定义域是[0，+∞)。实信号的功率谱密度或能量谱密度是对称的，故在工程中常用单边谱密度。 <span class="math display">\[P_x^单(f)=P_x(f)+P_x(-f)=2P_x(f)\qquad f\geq0\]</span></p><p><span class="math display">\[P_x=\int_{0}^{\infty}{P_x^单(f)}df\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/双边谱密度.png" alt="双边谱密度"><figcaption aria-hidden="true">双边谱密度</figcaption></figure><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/单边谱密度.png" alt="单边谱密度"><figcaption aria-hidden="true">单边谱密度</figcaption></figure><h3 id="基带信号与频带信号">3.2 基带信号与频带信号</h3><p>基带信号：信号的功率或能量主要集中在零频附近。</p><p>频带信号（带通信号）：信号的功率或能量集中在某个载频附近。</p><h3 id="带宽-1">3.3 带宽</h3><p>带宽：信号的带宽指单边谱密度的宽度。</p><ul><li><p>绝对带宽：频谱在某个区间之外为零，该区间的宽度就是绝对带宽。</p><blockquote><p>只是一种模型，一个信号若频域有限，则其时域无限，现实中的信号不可能时域无限。</p></blockquote></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/绝对带宽.png" alt="绝对带宽"><figcaption aria-hidden="true">绝对带宽</figcaption></figure><ul><li>主瓣带宽：有些信号频谱呈现出主瓣、旁瓣的特征，其带宽可采用主瓣宽度衡量。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/主瓣带宽.png" alt="主瓣带宽"><figcaption aria-hidden="true">主瓣带宽</figcaption></figure><ul><li>3dB带宽：功率谱密度从峰值下降一半（3dB)的宽度。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/3dB带宽.png" alt="3dB带宽"><figcaption aria-hidden="true">3dB带宽</figcaption></figure><ul><li><p>等效矩形带宽：功率谱同高同面积的矩形的宽度。</p></li><li><p>按能量占比定义的带宽</p></li></ul><blockquote><p>信号平方的带宽：x(t)的绝对带宽是W，x<sup>2</sup>(t)的绝对带宽是2W。</p><p>正弦调制的带宽：x(t)的绝对带宽是W，是s(t)=x(t)cos2πf<sub>c</sub>t的绝对带宽是2W。</p></blockquote><h2 id="线性时不变系统">4.线性时不变系统</h2><h3 id="线性时不变系统-1">4.1 线性时不变系统</h3><p>复单频信号通过滤波器后还是复单频信号： <span class="math display">\[x(t)=e^{j2\pi vt},\quad y(t)=e^{j2\pi vt}H(v)\]</span> 能量（功率）谱密度： <span class="math display">\[E_y(f)=|H(f)|^2E_x(f),\quad P_y(f)=|H(f)|^2P_x(f)\]</span></p><h3 id="希尔伯特变换与解析信号">4.2 希尔伯特变换与解析信号</h3><ul><li>希尔伯特变换： <span class="math display">\[实信号x(t)的希尔波特变换\widehat{x}(t)是将x(t)通过一个特定滤波器的输出。\]</span></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换.png" alt="希尔伯特变换"><figcaption aria-hidden="true">希尔伯特变换</figcaption></figure><p><span class="math display">\[H(f)=-j*sgn(f)=\begin{cases} -j，f&gt;0\\ j，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[h(t)=\frac{1}{\pi t}\]</span></p><p>​ 由于|H(f)|<sup>2</sup>=1，故希尔伯特变换不改变能量（功率）谱密度，不改变自相关函数。</p><p>​ 偶函数的希尔伯特变换是奇函数，奇函数的希尔伯特变换是偶函数。</p><p><span class="math display">\[x(t)与\widehat{x}(t)正交：\int_{-\infty}^{\infty} {\widehat{x}(t)x(t)}dt=0\]</span> ​ 常用希尔伯特变换对：</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换对.jpg" alt="希尔伯特变换对"><figcaption aria-hidden="true">希尔伯特变换对</figcaption></figure><ul><li><p>解析信号</p><p>实信号x(t)的解析信号z(t)定义为如下复信号：<span class="math display">\[z(t)=x(t)+j\widehat{x}(t)\]</span></p></li></ul><p><span class="math display">\[H(f)=1+j·[-j·sgn(f)]=1+sgn(f)=\begin{cases} 2，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[Z(f)=H(f)X(f)=\begin{cases} 2X(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p>​ 功率谱密度： <span class="math display">\[P_Z(f)=|1+sgn(f)|^2P_x(f)=\begin{cases} 4P_x(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><h2 id="带通信号">5.带通信号</h2><h3 id="带通信号的复包络">5.1 带通信号的复包络</h3><p>带通信号：频谱集中在某个载频f<sub>c</sub>附近，默认假设最高频率不超过2f<sub>c</sub></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通信号.png" alt="带通信号"><figcaption aria-hidden="true">带通信号</figcaption></figure><p>复包络： <span class="math display">\[实带通信号x(t)的复包络定义为:x_L(t)=z(t)e^{-j2\pi f_ct},其中z(t)=x(t)+j·\widehat{x}(t)\]</span></p><p><span class="math display">\[x_L(t)=[x(t)+j·\widehat{x}(t)]e^{-j2\pi f_ct}\]</span></p><ul><li>频谱关系</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/基带信号、解析信号、带通信号.png" alt="基带信号、解析信号、带通信号"><figcaption aria-hidden="true">基带信号、解析信号、带通信号</figcaption></figure><ul><li><p>功率谱密度关系 <span class="math display">\[解析信号的功率谱密度:P_Z(f)=\begin{cases} 4P_x(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[复包络的功率谱密度:P_L(f)=P_Z(f+f_c)=\begin{cases} 4P_x(f+f_c)，|f|&lt;f_c\\ 0，else\end{cases}\]</span></p></li></ul><h3 id="带通信号的三种表示方法">5.2 带通信号的三种表示方法</h3><ul><li><p><span class="math display">\[x(t)=Re\{x_L(t)e^{j2\pi fct}\}\]</span></p></li><li><p><span class="math display">\[x(t)=x_c(t)cos2\pi f_ct-x_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[x_c(t)=Re\{x_L(t)\}\quad同相分量\]</span></p><p><span class="math display">\[x_s(t)=Im\{x_L(t)\}\quad正交分量\]</span></p><p><span class="math display">\[x_L(t)=x_c(t)+j·x_s(t)\]</span></p></li><li><p><span class="math display">\[x(t)=A(t)cos[2\pi f_ct+\varphi(t)]\]</span></p><p><span class="math display">\[A(t)=|x_L(t)|\quad包络\]</span></p><p><span class="math display">\[\varphi(t)=\angle x_L(t)\quad相位\]</span></p><p><span class="math display">\[x_L(t)=A(t)e^{j\varphi(t)}\]</span></p></li></ul><h3 id="带通系统的等效基带分析">5.3 带通系统的等效基带分析</h3><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通系统的等效基带分析.png" alt="带通系统的等效基带分析"> <span class="math display">\[H_e(f)=\frac{1}{2}H_L(f)=H(f+f_c),\quad h_e(t)=\frac{1}{2}h_L(t)\]</span></p><blockquote><p>例题：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419234031223.png"></p></blockquote><h1 id="三随机过程">三、随机过程</h1><h2 id="随机过程">1.随机过程</h2><p>随机变量X：随机实验的结果是确定实数，X∈{x<sub>1</sub>,x<sub>2</sub>,…}</p><p>随机过程X(t)：随机实验的结果是确定的函数，X(t)∈{x<sub>1</sub>(t),x<sub>2</sub>(t),…}</p><p>随机过程X(t)是沿时间轴-∞&lt;t&lt;∞排列的无数个随机变量。</p><h3 id="随机过程的统计特性">1.1 随机过程的统计特性</h3><p>随机过程的数学期望： <span class="math display">\[E[X(t)]=m_X(t)\]</span> 任意随机过程可以看成是零均值随机过程与确定函数的和。</p><p>X(t)，Y(t)的互相关函数： <span class="math display">\[R_{XY}(t_1,t_2)=E[X(t_1)Y(t_2)]\]</span></p><blockquote><p>X(t)，Y(t)是两个随机过程，随便在两个过程上取两个时间，这样得到两个随机变量。</p><p>确定信号的互相关函数取平均是时间平均，随机信号的互相关函数取平均是统计平均。</p></blockquote><p>X(t)的自相关函数： <span class="math display">\[R_{X}(t_1,t_2)=E[X(t_1)X(t_2)]\]</span></p><p><span class="math display">\[\tau=t_1-t_2\]</span></p><p>平均自相关函数：对t做时间平均： <span class="math display">\[\overline{R}_X(\tau)=\overline{E[X(t+\tau)X(t)]}=E[\overline{X(t+\tau)X(t)}]\]</span></p><h3 id="随机过程的功率谱密度">1.2 随机过程的功率谱密度</h3><p>随机过程X(t)是从样本空间中随机抽出一个确定的样本函数x(t)。 <span class="math display">\[P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)\]</span> 每个样函数x(t)都有各自的功率谱密度。</p><p>随机抽出的不同样函数的功率谱密度可能不同。随机过程的功率谱密度定义为<strong>所有样本函数的功率谱密度的统计平均</strong>： <span class="math display">\[\overline{P}_x(f)=E[\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)]=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}E[|F[x_T(t)]|^2]\bigg)\]</span> 随机过程的功率谱密度是<strong>平均</strong>自相关函数的傅氏变换。</p><h2 id="平稳随机过程">2.平稳随机过程</h2><h3 id="狭义严平稳随机过程">2.1 狭义（严）平稳随机过程</h3><p>对于任意n和t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>以及τ有分布函数： <span class="math display">\[F_n(x_1,x_2,...,x_n;t_1.t_2,...,t_n)=F_n(x_1,x_2,...,x_n,t_1+\tau,t_2+\tau,...,t_n+\tau)\]</span> 称X(t)为狭义（严）平稳随机过程。</p><h3 id="广义宽平稳随机过程">2.2 广义（宽）平稳随机过程</h3><p><span class="math display">\[满足E[X(t)]=m_X,R_X(t+\tau,t)=R_X(\tau),称X(t)为宽平稳随机过程。\]</span></p><blockquote><p>均值和自相关满足遍历性的平稳过程叫做广义遍历过程。</p><p>遍历：每个样本函数的时间平均等于随机过程（所有样本函数）的统计平均。 <span class="math display">\[例如X(t)=cos(2\pi f_0t+\theta),X(t)就是随机过程，其中\theta可以取不同的值，求m_X也就是求X(t)的统计平均，一般是对\theta根据其所属分布求平均；而样本函数x(t)也就是确定了一个X(t)，\theta值固定，对其求时间平均就是对t求平均，\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{x_T(t)}dt\bigg)这样去求\]</span></p></blockquote><ul><li><p>功率谱密度 <span class="math display">\[随机过程的功率谱密度是平均自相关函数的傅氏变换。\]</span></p><p><span class="math display">\[因为平稳过程的自相关函数与t无关，故\overline{R}_X(\tau)=R_X(\tau)\]</span></p><p><span class="math display">\[P_X(f)=\int_{-\infty}^{\infty}{R_X(\tau)e^{-j2\pi f\tau}}d\tau\]</span></p></li></ul><h3 id="联合平稳">2.3 联合平稳</h3><p>X(t)、Y(t)联合平稳：除X(t)、Y(t)各自平稳外，还满足： <span class="math display">\[E[X(t+\tau)Y(t)]=R_{XY}(\tau)\]</span></p><blockquote><p>随机变量的不相关和独立： <span class="math display">\[不相关:E[XY]=E[X]E[Y]\]</span></p><p><span class="math display">\[独立:Pr\{A,B\}=Pr\{A\}Pr\{B\},f_{XY}(x,y)=f_X(x)f_Y(y)\]</span></p><p>若独立，则不相关。反之不一定。</p></blockquote><p>两个随机过程不相关：X(t<sub>1</sub>)，Y(t<sub>2</sub>) <span class="math display">\[E[X(t_1)Y(t_2)]=E[X(t_1)]E[Y(t_2)]\]</span></p><p><span class="math display">\[R_{XY}(t_1,t_2)=m_X(t_1)m_Y(t_2)\]</span></p><p>两个随机过程在同一时刻不相关： <span class="math display">\[t_1=t_2=t,E[X(t)Y(t)]=E[X(t)]E[Y(t)]\]</span></p><p><span class="math display">\[R_{XY}(t,t)=m_X(t)m_Y(t)\]</span></p><p>零均值平稳过程的相关系数：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/相关系数.png"></p><blockquote><p>看互相关函数，为零则不相关（因为是零均值平稳过程）</p></blockquote><h3 id="平稳过程通过线性系统">2.4 平稳过程通过线性系统</h3><p>平稳过程通过线性系统后还是平稳过程，且输入输出联合平稳。 <span class="math display">\[m_Y=m_XH(0)\quad P_Y(f)=|H(f)|^2P_X(f)\]</span> 零均值平稳过程X(t)的希尔伯特变换是零均值平稳过程。希尔伯特变换不改变功率谱密度、自相关函数。 <span class="math display">\[X(t)与\widehat{X}(t)在同一时刻不相关\]</span></p><h3 id="复平稳过程">2.5 复平稳过程</h3><ul><li><p>一种判断方法：Z(t)的实部X(t)、虚部Y(t)联合平稳。即X(t)、Y(t)各自平稳且互相关函数与t无关。</p></li><li><p>另一种判断方法：如果复过程的均值、自相关函数、共轭相关函数与t无关，则它是复平稳过程 <span class="math display">\[E[Z(t)]=m_Z\quad 均值与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z^*(t)]=R_Z(\tau)\quad 自相关函数与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z(t)]=R_{ZZ^*}(\tau)\quad 共轭相关函数与t无关\]</span></p></li></ul><h3 id="平稳带通过程的解析信号及复包络">2.6 平稳带通过程的解析信号及复包络</h3><p>零均值平稳过程X(t)的解析信号是零均值复平稳过程，且共轭不相关（共轭相关函数为0）。 <span class="math display">\[解析信号的自相关函数是R_X(\tau)的解析信号的2倍；功率谱密度是P_X(f)正频率部分的4倍。\]</span></p><p><span class="math display">\[R_Z(\tau)=2[R_X(\tau)+j·\widehat{R}_X(\tau)]\]</span></p><p>零均值平稳带通过程X(t)的复包络X<sub>L(</sub>t)=Z(t)e<sup>-j2πf_<sub>c</sub>t</sup>是零均值复平稳过程，且共轭不相关。</p><p>复包络的功率谱密度是P<sub>X</sub>(f)正频率部分的4倍向下搬移。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)是零均值联合平稳，且有相同的功率谱密度及自相关函数。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)在同一时刻不相关。</p><h3 id="平稳序列和循环平稳过程">2.7 平稳序列和循环平稳过程</h3><ul><li><p>随机序列：{X<sub>n</sub>}是无限个随机变量</p></li><li><p>广义平稳序列：{X<sub>n</sub>}的均值及自相关函数与绝对时间n无关 <span class="math display">\[E[X_n]=m_X(n)=m_X,\quad n=0,\pm1,\pm2,...\]</span></p><p><span class="math display">\[E[X_{n+m}X_n]=R_X(n+m,n)=R_X(m)\]</span></p></li><li><p>循环（周期）平稳过程：均值与自相关函数是t的周期函数 <span class="math display">\[E[X(t+T)]=E[X(t)]\]</span></p><p><span class="math display">\[E[X(t+T+\tau)X(t+T)]=E[X(t+\tau)X(t)]\]</span></p><p>循环平稳过程不是平稳过程。</p></li></ul><h2 id="高斯噪声">3.高斯噪声</h2><h3 id="高斯过程">3.1 高斯过程</h3><ul><li>高斯（正态）分布：</li></ul><p><span class="math display">\[高斯随机变量X\sim N(a,\sigma^2)的概率密度函数为p_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-a)^2}{2\sigma^2}}\]</span></p><ul><li>Q函数：</li></ul><p><span class="math display">\[定义：Q(x)=Pr\{X&gt;x\}=\frac{1}{\sqrt{2\pi}}\int_{x}^{\infty}{e^{-\frac{t^2}{2}}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1)大于x的概率\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/Q函数.png" alt="Q函数"><figcaption aria-hidden="true">Q函数</figcaption></figure><ul><li>erfc函数：</li></ul><p><span class="math display">\[定义：erfc(x)=\frac{2}{\sqrt{\pi}}\int_{x}^{\infty}{e^{-t^2}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1/2),|X|大于x的概率\]</span></p><p><span class="math display">\[erfc(x)=Pr\{|X|&gt;x\}=\int_{x}^{\infty}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\int_{-\infty}^{-x}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/erfc函数.png" alt="erfc函数"><figcaption aria-hidden="true">erfc函数</figcaption></figure><ul><li><p>联合高斯： <span class="math display">\[设Z_1,Z_2,...,Z_n是一组独立同分布的标准正态随机变量，Z_i\sim N(0,1)。若X_1,X_2,...,X_k中的每一个都是Z_1,Z_2,...,Z_n以及常数的线性组合，则称X_1,X_2,...,X_k服从联合高斯分布。\]</span></p><p><span class="math display">\[\begin{pmatrix}X_1  \\X_2  \\...  \\X_k  \\\end{pmatrix}=\begin{pmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}  \\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}  \\... &amp;...&amp;...&amp;... \\a_{k1}&amp;a_{k2}&amp;...&amp;a_{kn}  \\\end{pmatrix}\begin{pmatrix}Z_1  \\Z_2  \\...  \\Z_n  \\\end{pmatrix}+\begin{pmatrix}b_1  \\b_2  \\...  \\b_k  \\\end{pmatrix}\]</span> 若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，则X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>的各种线性组合也是联合高斯。</p><p>若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，m<sub>1</sub>,m<sub>2</sub>,...,m<sub>k</sub>是常数，则m<sub>1</sub>X<sub>1</sub>,m<sub>2</sub>X<sub>2</sub>,...,m<sub>k</sub>X<sub>k</sub>是联合高斯。</p></li><li><p>高斯过程：设X(t)是随机过程，若对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，X(t<sub>1</sub>),X(t<sub>2</sub>),...X(t<sub>n</sub>)联合高斯，则称X(t)为高斯过程。</p><blockquote><p>随机过程是沿时间排列的无数个随机变量。</p></blockquote><p>设X(t)是高斯过程，m(t)是确定信号，则Y(t)=m(t)X(t)是高斯过程。</p><p>对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，Y(t<sub>i</sub>)=m(t<sub>i</sub>)X(t<sub>i</sub>)。而m(t<sub>1</sub>),m(t<sub>2</sub>),...m(t<sub>n</sub>)是一组确定的系数，故Y(t<sub>1</sub>), Y(t<sub>2</sub>),...Y(t<sub>n</sub>)联合高斯。</p></li></ul><h3 id="高斯白噪声">3.2 高斯白噪声</h3><ul><li>理想限带高斯白噪声：带宽为B的理想限带高斯白噪声n<sub>B</sub>(t)是一种零均值平稳高斯过程。</li></ul><p><span class="math display">\[其功率谱密度为：P_{n_B}(f)=\begin{cases}\frac{N_0}{2}，f\leq B\\ 0，else\end{cases}\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度.png" alt="功率谱密度"> <span class="math display">\[其自相关函数为：R_{n_B}(\tau)=N_0B·sinc(2B\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数.png" alt="自相关函数"> <span class="math display">\[功率:P=R_{n_B}(0)=\int_{-\infty}^{\infty}{P_{n_B}(f)}df=N_0B\]</span></p><ul><li>高斯白噪声：高斯白噪声是理想限带高斯白噪声的极限：</li></ul><p><span class="math display">\[n_w(t)=\lim_{B\rightarrow+\infty}n_B(t)\]</span></p><p><span class="math display">\[P_{n_w}(f)=\frac{N_0}{2}\]</span></p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度1.png" alt="功率谱密度"> <span class="math display">\[R_{n_w}(\tau)=\frac{N_0}{2}\delta(\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数1.png" alt="自相关函数"></p><h3 id="高斯白噪声与确定信号的内积">3.3 高斯白噪声与确定信号的内积</h3><p>高斯白噪声与确定信号的内积是零均值高斯随机变量，方差为 <span class="math display">\[\frac{N_0}{2}E_g\]</span> 高斯白噪声在两个正交确定信号上的内积是两个独立的零均值高斯随机变量。</p><p>高斯白噪声在一组归一化正交函数上的投影是一组独立同分布的高斯随机变量，方差均为N<sub>0</sub>/2。</p><h3 id="窄带高斯噪声的解析信号及复包络">3.4 窄带高斯噪声的解析信号及复包络</h3><p>窄带高斯噪声：窄带高斯噪声n(t)就是高斯白噪声通过带通滤波器的输出。n(t)是带通型的零均值平稳高斯过程。 <span class="math display">\[解析信号:z(t)=n(t)+j·\widehat{n}(t)\]</span></p><p><span class="math display">\[复包络:n_L(t)=z(t)e^{-j2\pi f_ct}\]</span></p><p><span class="math display">\[同相分量:n_c(t)=Re\{n_L(t)\}\quad 正交分量:n_s(t)=Im\{n_L(t)\}\]</span></p><p><span class="math display">\[根据带通信号的表示方法:n(t)=n_c(t)cos2\pi f_ct-n_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[n(t)的功率谱密度为P_n(f)=\frac{N_0}{2}|H(f)|^2\]</span></p><p>n(t)的解析信号z(t)是零均值平稳复高斯过程，满足共轭不相关。 <span class="math display">\[z(t)的功率谱密度为P_Z(f)=\begin{cases} 4P_n(f),f&gt;0\\ 0， f&lt;0\end{cases}\]</span></p><h3 id="窄带高斯噪声的同相分量及正交分量">3.5 窄带高斯噪声的同相分量及正交分量</h3><p>n(t)的同相分量n<sub>c</sub>(t)、正交分量n<sub>s</sub>(t)是联合平稳的零均值高斯过程，二者有相同的自相关函数和功率谱密度，在同一时刻独立。</p><blockquote><p>对于高斯过程，不相关等于独立。</p></blockquote><p><span class="math display">\[三者有相同的功率:P_{n_c}=P_{n_s}=P_{n}\]</span></p><p>n<sub>c</sub>(t)与n<sub>s</sub>(t)有相同的功率谱密度： <span class="math display">\[P_c(f)=P_s(f)=P_n(f+f_c)+P_n(f-f_c)\]</span> n(t)的包络A(t)服从瑞利分布，相位φ(t)服从均匀分布。</p><h1 id="四模拟通信系统">四、模拟通信系统</h1><p>模拟信号m(t)是模仿物理量变化的电信号，m(t)一般的特征：时间连续、取值连续。</p><blockquote><p>默认m(t)不包含直流分量，频域就体现为频谱不含f=0处的冲击δ(f)</p></blockquote><p>模拟基带信号的传输：</p><ul><li><p>基带传输： <span class="math display">\[\xrightarrow{m(t)} \boxed{基带信道}\to\]</span></p></li><li><p>频带传输: <span class="math display">\[\xrightarrow{m(t)} \boxed{调制器}\xrightarrow{s(t)}\boxed{带通信号}\xrightarrow{}\boxed{解调器}\xrightarrow{}\]</span></p></li><li><p>数字化传输： <span class="math display">\[\xrightarrow{m(t)} \boxed{数字化}\xrightarrow{}\boxed{数字传输}\xrightarrow{}\boxed{还原}\xrightarrow{}\]</span></p></li></ul><p>本章假设理想无失真信道；无失真：波形不变，可以有延迟，可以有幅度变化；默认假设K=1、t<sub>0</sub>=0。 <span class="math display">\[s(t)\xrightarrow{}\boxed{信道}\xrightarrow{}K·s(t-t_0)\]</span> 系统模型：称m(t)为调制信号，称s(t)为已调信号。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/系统模型.png" alt="系统模型"><figcaption aria-hidden="true">系统模型</figcaption></figure><p>模拟调制的基本思路：</p><ul><li><p>目标：发送端：把基带信号m(t)变成带通信号s(t)；</p><p>​ 接收端：从带通信号s(t)中恢复出m(t)。</p></li><li><p>思路：发送端：让s(t)的复包络s<sub>L</sub>(t)携带m(t);</p><p>​ 接收端：先取复包络，再恢复m(t)。</p></li></ul><p>模拟调制的典型方法：</p><ul><li><p>幅度类调制：复包络就是m(t)—DSB-SC</p><p>​ 包络携带m(t)—AM</p><p>​ 复包络的实部是m(t)—SSB</p></li><li><p>角度类调制：复包络的相位φ(t)与mO(t)成比例—PM</p><p>​ φ(t)的斜率与m(t)成比例—FM</p></li></ul><p>关键性能指标：</p><ul><li><p>发送端：已调信号的带宽及频谱特征，涉及对频谱资源的耗费情况。</p></li><li><p>接收端：输出信噪比： <span class="math display">\[\Big(\frac{S}{N}\Big)_o=\frac{\overline{m^2(t)}}{E[n^2_o(t)]}\]</span> 涉及对功率资源的耗费情况。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
