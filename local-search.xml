<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图像与视频处理</title>
    <link href="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    <url>/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>2024/5/11 16:22 今天学习一下图像和视频处理的相关知识。</p><p>2024/5/16 11:17 到今天，已经把前三个实验任务完成了，今天准备开始做第四个实验。</p><h1 id="一pbm和pgm">一、PBM和PGM</h1><h2 id="pbm和pgm基本知识">1.PBM和PGM基本知识</h2><ul><li>PBM（Portable BitMap）支持单色图（1个像素位）。</li><li>PGM（Portable GreyMap）支持灰度图形，能够读PBM图形和PGM图形，输出PGM图形。</li><li>PPM（Portable PixMap）支持真彩色图形，可以读上面所有格式，输出PPM图形。</li></ul><p>这三种图像格式都通过头2个字节<strong>magic number</strong>（P1, P2, P3, P4, P5, P6）来表明图像的类型(PBM, PGM, PPM), 以及编码方式(ASCII 或 Binary)。</p><table><thead><tr class="header"><th style="text-align: left;">Magic Number</th><th style="text-align: left;">图像类型</th><th style="text-align: left;">编码方式</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">P1</td><td style="text-align: left;">Bitmap</td><td style="text-align: left;">ASCII</td></tr><tr class="even"><td style="text-align: left;">P2</td><td style="text-align: left;">Graymap</td><td style="text-align: left;">ASCII</td></tr><tr class="odd"><td style="text-align: left;">P3</td><td style="text-align: left;">Pixmap</td><td style="text-align: left;">ASCII</td></tr><tr class="even"><td style="text-align: left;">P4</td><td style="text-align: left;">Bitmap</td><td style="text-align: left;">Binary</td></tr><tr class="odd"><td style="text-align: left;">P5</td><td style="text-align: left;">Graymap</td><td style="text-align: left;">Binary</td></tr><tr class="even"><td style="text-align: left;">P6</td><td style="text-align: left;">Pixmap</td><td style="text-align: left;">Binary</td></tr></tbody></table><p>其实我们主要看的是图像文件的头信息, 且头信息都是ASCII格式的, 数据部分才分ASCII编码方式和Binary编码方式。</p><p>下面着重讲解ppm格式：</p><p>PPM图像格式分为两部分，分别为<strong>头部分</strong>和<strong>图像数据</strong>部分。</p><p>头部分：由3部分组成，通过换行或空格进行分割，一般PPM的标准是空格。</p><ul><li>第1部分：P3或P6，指明PPM的编码格式，</li><li>第2部分：图像的宽度和高度，通过ASCII表示，</li><li>第3部分：最大像素值，0-255字节表示。</li></ul><p>图像数据部分：</p><ul><li>ASCII格式：按RGB的顺序排列，RGB中间用空格隔开，图片每一行用回车隔开。</li><li>Binary格式：PPM用24bits代表每一个像素，红绿蓝分别占用8bits。</li></ul><h2 id="读取写入pgmppm图像">2.读取/写入PGM/PPM图像</h2><p>读取PGM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PGM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[image_data, width, height, max_val,P]</span> = <span class="hljs-title">readPGM</span><span class="hljs-params">(filename, format)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;r&#x27;</span>);<br>    P=fgetl(fid); <span class="hljs-comment">% 读取并忽略P5</span><br>    fgetl(fid); <span class="hljs-comment">% 读取并忽略注释</span><br>    dimensions = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">2</span>);<br>    width = dimensions(<span class="hljs-number">1</span>);<br>    height = dimensions(<span class="hljs-number">2</span>);<br>    max_val = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        image_data = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, [width, height]);<br>        image_data = image_data&#x27;;<br>    <span class="hljs-keyword">else</span><br>        image_data = fread(fid, [width, height], <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>        image_data = image_data&#x27;;<br>    <span class="hljs-keyword">end</span><br>    image_data=uint8(image_data);<br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>写入PGM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 写入PGM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writePGM</span><span class="hljs-params">(filename, image_data, width, height, max_val, format,P)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;w&#x27;</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P2</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d\n&#x27;</span>, max_val);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>            fprintf(fid, <span class="hljs-string">&#x27;%d &#x27;</span>, image_data(<span class="hljs-built_in">i</span>, :));<br>            fprintf(fid, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P5</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, max_val);<br>        image_data = image_data&#x27;;<br>        fwrite(fid, image_data, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>读取PPM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PPM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[image_data, width, height, max_val,P]</span> = <span class="hljs-title">readPPM</span><span class="hljs-params">(filename, format)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;r&#x27;</span>);<br>    P=fgetl(fid);<span class="hljs-comment">% 读取并忽略P6</span><br>    fgetl(fid); <span class="hljs-comment">% 读取并忽略注释</span><br>    dimensions = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">2</span>);<br>    width = dimensions(<span class="hljs-number">1</span>);<br>    height = dimensions(<span class="hljs-number">2</span>);<br>    max_val = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        image_data = fscanf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, [<span class="hljs-number">3</span>, width * height]);<br>        image_data = <span class="hljs-built_in">reshape</span>(image_data, [<span class="hljs-number">3</span>,width, height]);<br>        <br>    <span class="hljs-keyword">else</span><br>            image_data = fread(fid, [<span class="hljs-number">3</span>,width*height], <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>            image_data=double(<span class="hljs-built_in">reshape</span>(image_data,[<span class="hljs-number">3</span>,width,height]));<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>写入PPM图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 写入PPM图像</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writePPM</span><span class="hljs-params">(filename, image_data, width, height, max_val, format,P)</span></span><br>    fid = fopen(filename, <span class="hljs-string">&#x27;w&#x27;</span>);<br>    <span class="hljs-keyword">if</span> strcmp(format, <span class="hljs-string">&#x27;ASCII&#x27;</span>)<br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P3</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d\n&#x27;</span>, max_val);<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>            <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>                fprintf(fid, <span class="hljs-string">&#x27;%d %d %d &#x27;</span>, image_data(:, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>));<br>            <span class="hljs-keyword">end</span><br>            fprintf(fid, <span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%s\n&#x27;</span>,P); <span class="hljs-comment">% 写入P6</span><br>        fprintf(fid, <span class="hljs-string">&#x27;# image created by Sihan Rong\n&#x27;</span>); <span class="hljs-comment">% 添加注释</span><br>        fprintf(fid, <span class="hljs-string">&#x27;%d %d\n&#x27;</span>, width, height);<br>        fprintf(fid, <span class="hljs-string">&#x27;%d&#x27;</span>, max_val);<br>        fwrite(fid, image_data, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    fclose(fid);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取PPM图像并以其原始格式写入PPM图像</span><br><span class="hljs-comment">% input.ppm改成输入文件地址，output.ppm改成输出文件地址</span><br><span class="hljs-comment">% 注意在读取不同格式的图像数据时，要把函数后面的format换成相应的ASCII或Binary</span><br>[ppm_image_data, ppm_width, ppm_height, ppm_max_val] = readPPM(<span class="hljs-string">&#x27;input.ppm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>writePPM(<span class="hljs-string">&#x27;output.ppm&#x27;</span>, ppm_image_data, ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>, P);<br><br><br><br><span class="hljs-comment">% 读取PGM图像并以其原始格式写入PGM图像</span><br>[pgm_image_data, pgm_width, pgm_height, pgm_max_val] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, pgm_image_data, pgm_width, pgm_height, pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>, P);<br></code></pre></td></tr></table></figure><blockquote><p><code>fscanf</code> 函数用于从文件中按照指定的格式读取数据，并返回读取到的数据。但如果指定格式是矩阵的话，其读取后的数据填充方式是先填充列。故若源文件中数据矩阵式m×n大小，那就需要用<code>A=fscanf(fid, '%d', [n,m])</code>，再将A转置才是源文件中的矩阵。</p><p><code>fscanf</code> 用于读取格式化的<strong>文本数据</strong>，可以按照指定的格式读取不同类型的数据。</p><p><code>fread</code> 则用于读取<strong>二进制数据</strong>，它不关心数据的具体格式，只是按照字节来读取数据。</p><p><code>fgetl</code> 是MATLAB中用于从文本数据文件中读取一行文本的函数。</p><p>当你使用 <code>fopen</code> 打开文件时，该函数会返回一个文件标识符。你可以将这个标识符保存在一个变量中，并在后续的文件操作中使用它。一般情况下，当你完成文件操作后，应该使用 <code>fclose</code> 函数关闭文件，并释放该文件标识符。</p></blockquote><h1 id="二格式转换">二、格式转换</h1><h2 id="yuv图像格式">1.YUV图像格式</h2><p>YUV是一种图像颜色编码方式。相对于常见且直观的RGB颜色编码，YUV的产生自有其意义，它基于人眼对<strong>亮度</strong>比<strong>色彩</strong>的敏感度更高的特点，使用Y、U、V三个分量来表示颜色，并通过降低U、V分量的采样率，尽可能保证图像质量的情况下，做到如下3点：占用更低的存储空间、数据传输效率更高、兼容黑白与彩色显示。</p><h3 id="像素">1.1 像素</h3><p>想要深入了解YUV格式，必须得从Bit、Byte级别“看穿看透”它。</p><ul><li>Bit：位 —— 计算机硬件系统能识别的最基础单位。</li><li>Byte：字节 —— 计算机文件系统能识别的最基础单位。</li><li>像素：Pixel —— 显示图像的最基础单位。</li></ul><p>显示器上的一个像素点对应图像里的一个像素，不管哪种显示器，最终都是以像素为最小单位进行图像呈现。</p><p>不论技术怎么革新，有两点是始终不变的：</p><ul><li>显示的基础单元是<strong>像素</strong>。</li><li>每个像素的色彩由<strong>红、绿、蓝</strong>三原色混合实现。</li></ul><p>三原色是什么？显示器像素点的颜色数据是怎么排列存储的？带着问题先了解下RGB，为YUV的了解做个铺垫。</p><h3 id="rgb">1.2 RGB</h3><p>RGB：用R、G、B三个分量来表示像素点颜色，分别表示红、绿、蓝。这三种颜色就称为<strong>三原色</strong>，它们以不同比例混合能生成其他任意颜色。</p><p>RGB表示一帧图像：</p><ul><li>每个像素点背后都包含一组R、G、B分量，像素点的颜色就是它们的混合。</li><li>R、G、B每个分量分别占1个byte，也就是8个bit。</li></ul><p>例如，一张分辨率 1280 * 720 的RGB图片，占用 1280 * 720 * 3 / 1024 / 1024 = 2.63MB 空间。</p><h3 id="yuv表示图像">1.3 YUV表示图像</h3><p>YUV：用Y、U、V三个分量来表示像素颜色。</p><ul><li>Y 表示<strong>亮度</strong>（Luminance、缩写Luma），即为<strong>灰度值</strong>。</li><li>U 和 V 表示<strong>色度</strong>（Chrominance、缩写Chroma），即为<strong>色调和饱和度</strong>。</li></ul><p>默认Y、U、V每个分量占用存储空间1个byte，和RGB一样。前文概述中提到过，YUV是通过降低U、V分量的采样率来实现它占用空间小和传输效率高的优势。也就是图像每个像素的Y分量都被完整采样全部保存，但是U、V分量只做部分采样，让多个像素按照一些规则共用U、V分量。</p><h2 id="ppm图像和pgm图像之间的转换">2.PPM图像和PGM图像之间的转换</h2><p>PPM就是RGB图像，PGM就是灰度图像，也就是YUV中Y通道的图像。</p><p>给出YUV转换公式：</p><p>Y = 0.257 * R + 0.504 * G + 0.098 * B + 16</p><p>U = -0.148 * R - 0.291 * G + 0.439 * B + 128</p><p>V = 0.439 * R - 0.368 * G - 0.071 * B + 128</p><p>PPM转换为PGM：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[gray_image,YUV_image]</span> = <span class="hljs-title">BUPT_format_converter</span><span class="hljs-params">(color_image)</span></span><br>    [~,width, height] = <span class="hljs-built_in">size</span>(color_image);<br>    gray_image = <span class="hljs-built_in">zeros</span>(height, width);<br>    YUV_image = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>,width,height);<br><br><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>            R = color_image(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            G = color_image(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            B = color_image(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            <br>            Y = <span class="hljs-number">0.257</span> * R + <span class="hljs-number">0.504</span> * G + <span class="hljs-number">0.098</span> * B + <span class="hljs-number">16</span>;<br>            U = <span class="hljs-number">-0.148</span> * R - <span class="hljs-number">0.291</span> * G + <span class="hljs-number">0.439</span> * B + <span class="hljs-number">128</span>;<br>            V = <span class="hljs-number">0.439</span> * R - <span class="hljs-number">0.368</span> * G - <span class="hljs-number">0.071</span> * B + <span class="hljs-number">128</span>;<br>            <span class="hljs-comment">% 更改Y/U/V，选择得到哪个通道的灰度图</span><br>            gray_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = <span class="hljs-built_in">round</span>(Y);<br>            YUV_image(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = Y;<br>            YUV_image(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = U;<br>            YUV_image(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = V;<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>下面图(a)是PPM(RGB)图像，图(b)是PGM(灰度)图像，图(c)是U通道的图像，图(d)是V通道的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514095516604.png" alt="PPM转换为Y、U、V通道的图像"><figcaption aria-hidden="true">PPM转换为Y、U、V通道的图像</figcaption></figure><p>RGB 和灰度色彩空间之间的转换并不是线性的。这是因为转换涉及使用非线性系数对 RGB 分量进行加权平均，如YUV转换公式中所指定的那样。</p><p>U、V通道的图片产生了失真。这是因为YUV色彩空间将颜色信息（U和V通道）与亮度信息（Y通道）分开。当单独显示YUV通道作为灰度图像时，人眼可能会将颜色信息视为灰度变化，从而导致与原始RGB图像相比的失真外观。</p><p>换句话说，U和V通道代表色度信息，在单独显示为灰度图像时，并没有以原始的上下文展示。它们应该与亮度通道（Y）结合起来重建完整的彩色图像。因此，单独查看它们可能不能准确地呈现原始图像的颜色。</p><p>根据YUV转换公式我们倒推得到RGB的转换公式：</p><p><em>R</em>=<em>Y</em>+1.403⋅(<em>V</em>−128)</p><p><em>G</em>=<em>Y</em>−0.344⋅(<em>U</em>−128)−0.714⋅(<em>V</em>−128)</p><p><em>B</em>=<em>Y</em>+1.770⋅(<em>U</em>−128)</p><p>YUV图像数据向PPM（RGB）图像转换：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rgb_img</span> = <span class="hljs-title">yuv_to_rgb</span><span class="hljs-params">(YUV_img)</span></span><br>    <span class="hljs-comment">% 得到图片维度</span><br>    [~,width, height] = <span class="hljs-built_in">size</span>(YUV_img);<br>    <br>    <span class="hljs-comment">% 建立rgb图像数据</span><br>    rgb_img = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">3</span>,width,height);<br>    <br>    <span class="hljs-comment">% 转换YUV 为 RGB</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:width<br>            Y = YUV_img(<span class="hljs-number">1</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            U = YUV_img(<span class="hljs-number">2</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            V = YUV_img(<span class="hljs-number">3</span>, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>);<br>            <br>            R = Y + <span class="hljs-number">1.403</span> * (V - <span class="hljs-number">128</span>);<br>            G = Y - <span class="hljs-number">0.344</span> * (U - <span class="hljs-number">128</span>) - <span class="hljs-number">0.714</span> * (V - <span class="hljs-number">128</span>);<br>            B = Y + <span class="hljs-number">1.770</span> * (U - <span class="hljs-number">128</span>);<br>            <br><br>            rgb_img(:, <span class="hljs-built_in">j</span>, <span class="hljs-built_in">i</span>) = [<span class="hljs-built_in">round</span>(R), <span class="hljs-built_in">round</span>(G), <span class="hljs-built_in">round</span>(B)];<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[ppm_image_data, ppm_width, ppm_height, ppm_max_val,P] = readPPM(<span class="hljs-string">&#x27;input.ppm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>[pgm_image_data,YUV_image]=BUPT_format_converter(ppm_image_data);<br>ppm_image = yuv_to_rgb(YUV_image);<br><span class="hljs-comment">%将YUV数据重新复原为RGB图像</span><br>writePPM(<span class="hljs-string">&#x27;output_2.ppm&#x27;</span>, ppm_image , ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P3&#x27;</span>);<br><span class="hljs-comment">%得到Y、U、V的PGM图像</span><br>writePGM(<span class="hljs-string">&#x27;output_1.pgm&#x27;</span>, pgm_image_data, ppm_width, ppm_height, ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h1 id="三图像采样">三、图像采样</h1><h2 id="下采样sub-sampling的基本原理">1.下采样（Sub-sampling）的基本原理</h2><p>图像的下采样也就是缩小图像。下采样是一种信号处理技术，用于降低信号的采样率。在图像处理中，下采样指的是减少图像的像素数量，从而降低图像的分辨率。这通常通过在水平和垂直方向上以一定的间隔丢弃像素来实现。</p><p>下采样的原理是基于采样定理。根据奈奎斯特-香农采样定理，为了正确地表示一个信号（或图像），采样频率必须<strong>至少</strong>是信号最高频率的两倍。因此，如果降低采样率，即减少采样频率，就必须牺牲一些高频细节。下采样通过删除一些像素来实现这一点，从而降低了图像的分辨率，但同时也减少了文件大小和处理复杂度。</p><p>然而，需要注意的是，对图像进行下采样时，实际上是减少了从原始图像中取样的数量，降低了有效的采样频率，这意味着图像的空间频率内容相对于采样率变得更高。如果在下采样过程中不恰当地处理高频细节，可能会导致混叠问题，即产生意外的图案或失真。因此，在进行下采样时，通常会应用滤波器来平滑图像并移除高频信息，以减少混叠问题的发生。</p><p>当对图像进行下采样时，可能会产生混叠的明显例子是在图像中出现的摩尔纹（Moiré）图案。摩尔纹是一种常见的混叠现象，通常出现在对具有细微重复细节的图像进行采集时。这些细节可能包括纹理或图案。混叠是由于采样频率不足以准确捕捉场景中的高频细节而导致的，最终会在图像中产生不正确的表示和不需要的图案。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/512b616b27ca4d9c891cdf7b43e68b3c.jpeg" alt="混叠现象-摩尔纹"><figcaption aria-hidden="true">混叠现象-摩尔纹</figcaption></figure><h2 id="图像下采样">2.图像下采样</h2><p>实现一个函数，通过因子n对<strong>灰度图像</strong>进行下采样，其中n是2的倍数。 该函数应该能够在水平和垂直方向上独立地进行下采样，或者同时在两个方向上进行下采样。</p><blockquote><p>因子n表示在n个像素点中取1个，若水平n=2，则表示图像的水平宽度要变为原来的1/2。</p></blockquote><p>对图像Lena进行下采样：2水平，2垂直，2垂直和8水平，4垂直和4水平。</p><p>下采样函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 子采样函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub_sampled_image</span> = <span class="hljs-title">subSample</span><span class="hljs-params">(image, n_horizontal, n_vertical)</span></span><br>    <span class="hljs-comment">% 获取原始图像的大小</span><br>    [height, width] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 计算子采样后的大小</span><br>    new_height = height / n_vertical;<br>    new_width = width / n_horizontal;<br>    <br>    <span class="hljs-comment">% 初始化子采样后的图像</span><br>    sub_sampled_image = <span class="hljs-built_in">zeros</span>(new_height, new_width);<br>    <br>    <span class="hljs-comment">% 子采样</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:new_height<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:new_width<br>            sub_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = image((<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>)*n_vertical + <span class="hljs-number">1</span>, (<span class="hljs-built_in">j</span><span class="hljs-number">-1</span>)*n_horizontal + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 水平方向子采样因子为2</span><br>sub_sampled_horizontal_2 = subSample(lena_image, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>writePGM(<span class="hljs-string">&#x27;output_1.ppm&#x27;</span>, sub_sampled_horizontal_2, <span class="hljs-built_in">size</span>(sub_sampled_horizontal_2, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_horizontal_2, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 垂直方向子采样因子为2</span><br>sub_sampled_vertical_2 = subSample(lena_image, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>writePGM(<span class="hljs-string">&#x27;output_2.pgm&#x27;</span>, sub_sampled_vertical_2, <span class="hljs-built_in">size</span>(sub_sampled_vertical_2, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_vertical_2, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><br><span class="hljs-comment">% 水平方向子采样因子为8，垂直方向子采样因子为2</span><br>sub_sampled_horizontal_8 = subSample(lena_image, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>);<br>writePGM(<span class="hljs-string">&#x27;output_3.pgm&#x27;</span>, sub_sampled_horizontal_8, <span class="hljs-built_in">size</span>(sub_sampled_horizontal_8, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_horizontal_8, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><br><span class="hljs-comment">% 垂直方向子采样因子为4，水平方向子采样因子为4</span><br>sub_sampled_vertical_4 = subSample(lena_image, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);<br>writePGM(<span class="hljs-string">&#x27;output_4.pgm&#x27;</span>, sub_sampled_vertical_4, <span class="hljs-built_in">size</span>(sub_sampled_vertical_4, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(sub_sampled_vertical_4, <span class="hljs-number">1</span>), ppm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><p>下面图(a)是在垂直方向因子为1水平方向因子为2的图像，图(b)是在垂直方向因子为2水平方向因子为1的图像，图(c)是在垂直方向因子为2水平方向因子为8的图像，图(d)是在垂直方向因子为4水平方向因子为4的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514100217700.png" alt="图像下采样后的图像"><figcaption aria-hidden="true">图像下采样后的图像</figcaption></figure><h2 id="上采样up-sampling的基本原理">3.上采样（Up-sampling）的基本原理</h2><p>图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。</p><p>最简单的方式是重采样和插值：将输入图片 input image 进行 rescale 到一个想要的尺寸，而且计算每个点的像素点，使用如双线性插值 (Bilinear-Interpolation) 等插值方法对其余点进行插值。各种插值方法都有各自的优缺点。插值就是在不生成像素的情况下增加图像像素大小的一种方法，在周围像素色彩的基础上用数学公式计算丢失像素的色彩（也有的有些相机使用插值，人为地增加图像的分辨率）。所以在放大图像时，图像看上去会比较平滑、干净。但必须注意的是插值并不能增加图像信息。</p><h3 id="最邻近元法nearest-neighbour-interpolation">3.1 最邻近元法（Nearest Neighbour Interpolation）</h3><p>最邻近元法是最简单的一种插值方法，不需要计算，在待求像素的四邻像素中，将距离待求像素最近的像素素灰度赋给待求像素。设 i+u, j+v (i, j为正整数， u, v为大于零小于1的小数，下同)为待求像素坐标，则待求像素灰度的值 f(i+u, j+v)　如下图所示：</p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/1.png"></p><p>如果 (i+u, j+v) 落在A区，即 u&lt;0.5, v&lt;0.5，则将左上角像素的灰度值赋给待求像素，同理，落在B区则赋予右上角的像素灰度值，落在C区则赋予左下角像素的灰度值，落在D区则赋予右下角像素的灰度值。</p><p>最邻近元法计算量较小，但可能会造成插值生成的图像灰度上的不连续，在灰度变化的地方可能出现明显的锯齿状。当图片放大时，缺少的像素通过直接使用与之最接近的原有的像素的颜色生成，也就是说照搬旁边的像素，这样做的结果是产生了明显可见的<strong>锯齿</strong>。</p><h3 id="双线性内插法bilinear-interpolation">3.2 双线性内插法（Bilinear Interpolation）</h3><p>双线性插值是通过周边的四个点，计算权值，然后决定插入后的图像的像素值。新生成的图像中每个点都会计算一遍，是利用待求象素四个邻象素的灰度在两个方向上作线性内插，如下图所示：</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/2.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>(i+u,j+v)是目标位置（0&lt;u,v&lt;1)，需要进行插值的像素坐标，f(i+u,j+v)是该坐标下的像素值；(i,j)，(i+1,j)，(i,j+1)，(i+1,j+1)是原始图像中与目标位置最近的四个像素的坐标，分别表示左上、左下、右上和右下四个像素的位置。</p><p>根据双线性插值的原理，插值的结果 <code>interpolated_value</code> 是通过如下公式计算得到的： <span class="math display">\[interpolated\_value=\frac{f(i,j)·[(i+1)-(i+u)]·[(j+1)-(j+v)]+f(i+1,j)·(i+u-i)·[(j+1)-(j+v)]+f(i,j+1)·[(i+1)-(i+u)]·(j+v-j)+f(i+1,j+1)·(i+u-i)·(j+v-j)}{(i+1-i)(j+1-j)}\]</span> 双线性内插法的计算比最邻近点法复杂，计算量较大，但没有灰度不连续的缺点，结果基本令人满意。双线性插值算法（Bilinear Interpolation）输出的图像的每个像素都是原图中四个像素（2×2）运算的结果，这种算法极大地消除了锯齿现象。但它具有低通滤波性质，使高频分量受损，图像轮廓可能会有一点模糊。</p><h2 id="图像上采样">4.图像上采样</h2><p>最邻近元法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">up_sampled_image</span> = <span class="hljs-title">BUPT_up</span><span class="hljs-params">(image, factor, method)</span></span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% factor: 放大倍数</span><br>    <span class="hljs-comment">% method: 插值方法，&#x27;nearest&#x27; 或 &#x27;bilinear&#x27;</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% up_sampled_image: 放大后的图像</span><br>    <br><br>    <span class="hljs-comment">% 获取原始图像尺寸</span><br>    [rows, cols] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 计算放大后的尺寸</span><br>    new_rows = <span class="hljs-built_in">round</span>(rows * <span class="hljs-built_in">factor</span>);<br>    new_cols = <span class="hljs-built_in">round</span>(cols * <span class="hljs-built_in">factor</span>);<br>    <br>    <span class="hljs-comment">% 初始化放大后的图像</span><br>    up_sampled_image = <span class="hljs-built_in">zeros</span>(new_rows, new_cols);<br>    <br>    <span class="hljs-comment">% 遍历放大后的图像的每个像素位置</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:new_rows<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span> = <span class="hljs-number">1</span>:new_cols<br>            <span class="hljs-comment">% 计算对应原始图像的位置</span><br>            original_i = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">i</span> / <span class="hljs-built_in">factor</span>), rows));<br>            original_j = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">round</span>(<span class="hljs-built_in">j</span> / <span class="hljs-built_in">factor</span>), cols));<br>            <br>            <span class="hljs-comment">% 根据插值方法填充像素值</span><br>            <span class="hljs-keyword">if</span> strcmp(method, <span class="hljs-string">&#x27;nearest&#x27;</span>)<br>                <span class="hljs-comment">% 最近邻插值</span><br>                up_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = image(original_i, original_j);<br>            <span class="hljs-keyword">elseif</span> strcmp(method, <span class="hljs-string">&#x27;bilinear&#x27;</span>)<br>                <span class="hljs-comment">% 双线性插值</span><br>                up_sampled_image(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>) = bilinear_interpolation(image, <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">i</span> / <span class="hljs-built_in">factor</span>, rows)), <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">min</span>(<span class="hljs-built_in">j</span> / <span class="hljs-built_in">factor</span>, cols)));<br>            <span class="hljs-keyword">else</span><br>                error(<span class="hljs-string">&#x27;Unsupported interpolation method.&#x27;</span>);<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>双线性内插法：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">interpolated_value</span> = <span class="hljs-title">bilinear_interpolation</span><span class="hljs-params">(image, x, y)</span></span><br>    <span class="hljs-comment">% 双线性插值</span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% x, y: 插值位置</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% interpolated_value: 插值后的像素值</span><br><br>    <span class="hljs-comment">% 获取图像尺寸</span><br>    [rows, cols] = <span class="hljs-built_in">size</span>(image);<br>    <br>    <span class="hljs-comment">% 四个最近的整数坐标</span><br>    x1 = <span class="hljs-built_in">floor</span>(x);<br>    x2 = x1 + <span class="hljs-number">1</span>;<br>    y1 = <span class="hljs-built_in">floor</span>(y);<br>    y2 = y1 + <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">% 边界处理</span><br>    <span class="hljs-keyword">if</span> x2 &gt; rows<br>        x2 = rows;<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">if</span> y2 &gt; cols<br>        y2 = cols;<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 获取四个最近像素的值</span><br>    Q11 = image(x1, y1);<br>    Q12 = image(x1, y2);<br>    Q21 = image(x2, y1);<br>    Q22 = image(x2, y2);<br>    <br>    <span class="hljs-comment">% 计算双线性插值</span><br>    interpolated_value = <span class="hljs-built_in">round</span>((Q11 * (x2 - x) * (y2 - y) + Q21 * (x - x1) * (y2 - y) + Q12 * (x2 - x) * (y - y1) + Q22 * (x - x1) * (y - y1)) / ((x2 - x1) * (y2 - y1)));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取 Lena 图像</span><br>[lena, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input_1.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 最近邻插值放大 Lena 图像</span><br><span class="hljs-built_in">factor</span> = <span class="hljs-number">4.5</span>;<br>up_sampled_nearest = BUPT_up(lena, <span class="hljs-built_in">factor</span>, <span class="hljs-string">&#x27;nearest&#x27;</span>);<br><br>writePGM(<span class="hljs-string">&#x27;output_1.pgm&#x27;</span>, up_sampled_nearest, <span class="hljs-built_in">size</span>(up_sampled_nearest, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(up_sampled_nearest, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 读取 Baboon 图像</span><br>[baboon, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input_2.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 双线性插值放大 Baboon 图像</span><br><span class="hljs-built_in">factor</span> = <span class="hljs-number">3.6</span>;<br>up_sampled_bilinear = BUPT_up(baboon, <span class="hljs-built_in">factor</span>, <span class="hljs-string">&#x27;bilinear&#x27;</span>);<br><br>writePGM(<span class="hljs-string">&#x27;output_2.pgm&#x27;</span>, up_sampled_bilinear, <span class="hljs-built_in">size</span>(up_sampled_bilinear, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(up_sampled_bilinear, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240516224506826.png" alt="最邻近元法得到的锯齿状边缘" style="zoom:50%;"></p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240516224717094.png" alt="双线性内插法得到的图片进行放大" style="zoom: 50%;"></p><p>将两种方法得到的上采样图像经过放大后观察细节，最邻近元法产生了明显的锯齿状边缘；而双线性内插法得到图像表现较好，没有灰度不连续的地方。</p><p>在速度方面，Nearest Neighbour 插值通常比 Bilinear 插值更快。这是因为 Nearest Neighbour 插值只需要在目标位置附近找到最近的一个像素值，并将其作为插值结果，而不需要进行复杂的计算。相比之下，Bilinear 插值需要对目标位置周围的四个最近邻像素进行加权平均，计算量更大，因此更慢一些。</p><p>在准确性方面，Bilinear 插值通常比 Nearest Neighbour 插值更准确。这是因为 Bilinear 插值考虑了目标位置与最近邻像素之间的距离，以及像素值之间的线性关系，可以提供更加平滑和连续的插值结果。相比之下，Nearest Neighbour 插值仅仅是简单地将最近邻像素的值赋给目标位置，可能会导致插值结果的锯齿状边缘和块状伪影。</p><h1 id="四图像量化">四、图像量化</h1><h2 id="基本原理">1.基本原理</h2><p>图像通常是自然界景物的客观反映，并以照片形式或视频记录的介质连续保存，获取图像的目标是从感知的数据中产生数字图像，因此需要把连续的图像数据离散化，转换为数字化图像，其工作主要包括两方面——量化和采样。数字化幅度值称为量化，数字化坐标值称为采样。</p><p>所谓量化（Quantization），就是将图像像素点对应亮度的连续变化区间转换为单个特定值的过程，即将原始灰度图像的空间坐标幅度值离散化。量化等级越多，图像层次越丰富，灰度分辨率越高，图像的质量也越好；量化等级越少，图像层次欠丰富，灰度分辨率越低，会出现图像轮廓分层的现象，降低了图像的质量。下图是将图像的连续灰度值转换为0至255的灰度级的过程。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/v2-cf13cbb100995b17cb52c0e17eddf839_r.jpg" alt="图像量化"><figcaption aria-hidden="true">图像量化</figcaption></figure><p>如果量化等级为2，则将使用两种灰度级表示原始图片的像素（0-255），灰度值小于128的取0，大于等于128的取128；如果量化等级为4，则将使用四种灰度级表示原始图片的像素，新图像将分层为四种颜色，0-64区间取0，64-128区间取64，128-192区间取128，192-255区间取192；依次类推。</p><p>量化是一个不可逆过程。在量化过程中，连续值被近似为有限的一组离散值，这会导致信息丢失。这种损失称为量化误差。一旦细节被丢弃，就不能从量化值中完美恢复原始的细节。这个过程涉及数据精度的不可逆减少，因此不可能准确重建原始的连续值。</p><p>将量化后的图像文件大小将与原始图像文件进行比较。通常，量化后的文图像文件由于数据精度的降低会更小。量化通常应用于数据大小缩减非常关键的领域，如图像和视频压缩。它还用于数字信号处理，以简化信号的表示和传输。</p><h2 id="图像量化">2.图像量化</h2><p>实现一个函数来均匀量化灰度图像。该函数将允许通过给定的量化等级 n（2 的幂）来减少灰度值的数量。</p><p>量化函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quantized_image</span> = <span class="hljs-title">uniformQuantize</span><span class="hljs-params">(image, n)</span></span><br>    <span class="hljs-comment">% 确保n是2的幂</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">mod</span>(<span class="hljs-built_in">log2</span>(n), <span class="hljs-number">1</span>) ~= <span class="hljs-number">0</span><br>        error(<span class="hljs-string">&#x27;n必须是2的幂&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 将图像值转换为0到1之间</span><br>    image = double(image) / <span class="hljs-number">255</span>;<br>    <br>    <span class="hljs-comment">% 计算每个量化级别的步长</span><br>    step_size = <span class="hljs-number">1</span> / n;<br>    <br>    <span class="hljs-comment">% 对图像进行量化</span><br>    quantized_image = <span class="hljs-built_in">floor</span>(image / step_size) * step_size;<br>    <br>    <span class="hljs-comment">% 将量化后的图像重新映射到0到255之间</span><br>    quantized_image = uint8(quantized_image * <span class="hljs-number">255</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>floor</code> 函数用于对每个元素执行向下取整操作。</p><p><code>uint8()</code> 是一个函数，用于将数据转换为无符号 8 位整数类型。<code>uint8</code> 类型的值范围是 0 到 255，这使得它特别适合用于存储图像数据，因为灰度图像的像素值通常也是在这个范围内。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 设置量化因子，例如4</span><br>n = <span class="hljs-number">128</span>;<br><br><span class="hljs-comment">% 对图像进行均匀量化</span><br>quantized_image = uniformQuantize(lena_image, n);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, quantized_image, <span class="hljs-built_in">size</span>(quantized_image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(quantized_image, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(quantized_image);<br>title([<span class="hljs-string">&#x27;量化后的图像，因子为&#x27;</span>, num2str(n)]);<br></code></pre></td></tr></table></figure><p>下面是对比不同量化等级的“Lena”图。图(a)是量化等级为2时的图像，图(b)是是量化等级为8时的图像，图(c)是是量化等级为32时的图像，图(d)是是量化等级为128时的图像。</p><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514104729354.png" alt="量化后的图像"><figcaption aria-hidden="true">量化后的图像</figcaption></figure><h1 id="五灰度图像的直方图">五、灰度图像的直方图</h1><h2 id="灰度直方图的基本原理">1.灰度直方图的基本原理</h2><h3 id="定义">1.1 定义</h3><p>灰度直方图是关于灰度级分布的函数，是对图像中灰度级分布的统计。灰度直方图是将数字图像中的所有像素，按照灰度值的大小，统计其出现的频率。可表示为： <span class="math display">\[P(k)=\frac{n_k}{n},\quad k=0,1,\cdots,L-1\]</span> 且 <span class="math display">\[\displaystyle\sum_{k=0}^{L-1}P(k)=1\]</span> 式中，k为图像的第k级灰度值，<span class="math inline">\(n_k\)</span>则为图像中灰度值为k的像素个数，n为图像的总像素个数，L为灰度级数。不同的灰度分布对应着不同的图像质量。灰度直方图能反映图像的概貌和质量，也是图像增强处理的重要依据</p><h3 id="灰度直方图的性质">1.2 灰度直方图的性质</h3><ol type="1"><li>直方图的位置缺失性：灰度直方图仅仅反映了数字图像中各灰度级出现频数的分布，即取某灰度值的像素个数占图像总像素个数的比例，但对那些具有同一灰度值的像素在图像中的空间位置一无所知，即其具有位置缺失性。</li><li>直方图与图像的一对多特性：任一幅图像都能唯一地确定与其对应的一个直方图，但由于直方图的位置缺失性，对于不同的多幅图像来说，只要其灰度级出现频数的分布相同，则都具有相同的直方图，即直方图与图像是一对多的关系。</li><li>直方图的可叠加性：由于灰度直方图是各灰度级出现频数的统计值，若一图像分成几个子图，则该图像的直方图就等于各子图直方图的叠加。</li></ol><h2 id="获取灰度图像的直方图">2.获取灰度图像的直方图</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;D:\学习资料\大四下\思涵的实验\新建文件夹\6.img2024\Peppers512_ASCII2014.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>   <br><span class="hljs-comment">% 计算直方图</span><br>histogram_values = imhist(lena_image);<br><br><span class="hljs-comment">% 绘制直方图</span><br><span class="hljs-built_in">figure</span>;<br>bar(histogram_values);<br>title(<span class="hljs-string">&#x27;Peppers灰度图像直方图&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(histogram_values)]);<br></code></pre></td></tr></table></figure><blockquote><p><code>imhist</code> 是 MATLAB 中用于计算图像直方图的函数。它接受一个灰度图像作为输入，并返回一个表示直方图的向量。即返回一个向量，里面包含不同灰度级出现的频率。</p><p><code>bar</code> 是 MATLAB 中用于创建柱状图的函数。它可以用来可视化数据的分布或频率。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174050694.png" alt="Lena与它的灰度直方图"><figcaption aria-hidden="true">Lena与它的灰度直方图</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174125706.png" alt="Baboon与它的灰度直方图"><figcaption aria-hidden="true">Baboon与它的灰度直方图</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/image-20240514174208637.png" alt="Peppers与它的灰度直方图"><figcaption aria-hidden="true">Peppers与它的灰度直方图</figcaption></figure><h2 id="图像增强直方图均衡化">3.图像增强——直方图均衡化</h2><p>直方图均衡化是一种用于增强图像对比度的图像处理技术。它通过重新分配图像中的像素值，使得图像的像素值分布更加均匀，增强图像的对比度，从而改善图像的视觉效果。</p><p>直方图均衡化的过程如下：</p><ol type="1"><li><p>灰度转换：如果图像是彩色图像，则首先需要将其转换为灰度图像。这可以通过将彩色图像的RGB通道值平均或权重化来实现，得到一个表示亮度的灰度图像。</p></li><li><p>统计直方图：对于灰度图像，统计每个像素值的频数，生成原始图像的直方图。直方图表示了不同像素值的数量分布。</p></li><li><p>计算累积分布函数：通过计算原始图像的累积分布函数，可以得到每个像素值的累积概率分布，<strong>即小于等于该像素值的概率</strong>。可以通过对直方图进行归一化和累加操作得到。</p></li><li><p>映射像素值：根据每个像素值的累积概率分布映射出新的像素值，即将概率乘以255得到均衡化后的像素值。</p></li><li><p>像素重新映射：对于原始图像中的每个像素，根据映射将其像素值替换为均衡化后的像素值。</p></li><li><p>生成均衡化后的图像：根据重新映射的像素值，生成均衡化后的图像。均衡化后的图像在直方图上将有更平坦的分布，从而提高了图像的对比度。</p></li></ol><p>注意，经过直方图均衡化后，分布并不是完全均匀的。虽然直方图均衡化的目的是使像素强度的分布更加均匀，但结果的分布受到原始图像像素值及其在强度范围内的分布方式的影响。</p><p>经过直方图均衡化后，图像的直方图相比于原始图像会更加均匀地分布，但不会完全平坦。这是因为该过程是基于原始直方图的累积分布函数（CDF）重新分配像素值的，这意味着某些强度级别的像素数量仍然会因原始图像内容而有所不同。</p><p>例如，如果原始图像中有大量像素具有特定的强度值，那么在均衡化后，这些像素会分布到一系列的强度值中，但分布仍然可能显示出与原始强度值相对应的峰值和谷值。</p><h2 id="代码实现">4.代码实现</h2><p>直方图均衡化：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equalized_image</span> = <span class="hljs-title">histogramEqualization</span><span class="hljs-params">(image)</span></span><br>    <br>    <span class="hljs-comment">% 计算图像的直方图</span><br>    histogram_values = imhist(image);<br><br>    <span class="hljs-comment">% 计算累积分布函数（CDF）</span><br>    cdf = cumsum(histogram_values) / <span class="hljs-built_in">numel</span>(image);<br>    <br>    <span class="hljs-comment">% 创建一个查找表（Lookup Table），用于将原始灰度级映射到均衡化后的灰度级</span><br>    equalization_map = uint8(<span class="hljs-number">255</span> * cdf);<br><br>    <span class="hljs-comment">% 应用查找表，将原始图像转换为均衡化后的图像,将图像矩阵中的像素值作为查找表中的索引</span><br>    equalized_image = equalization_map(double(image) + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>cumsum</code> 可以对向量、矩阵或多维数组的元素进行累加，返回同尺寸的数组，其中每个元素表示该位置及之前所有元素的和。注意是在一行进行累加。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 主函数示例，读取PGM图像并应用直方图均衡化</span><br><span class="hljs-comment">% 读取PGM图像</span><br>[lena_image, pgm_width, pgm_height, pgm_max_val,P] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 调用直方图均衡化函数</span><br>equalized_image = histogramEqualization(lena_image);<br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, equalized_image, <span class="hljs-built_in">size</span>(equalized_image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(equalized_image, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 显示原始图像和均衡化后的图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(equalized_image);<br>title(<span class="hljs-string">&#x27;均衡化后的图像&#x27;</span>);<br><br><span class="hljs-comment">% 显示直方图</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>imhist(lena_image);<br>title(<span class="hljs-string">&#x27;原始图像直方图&#x27;</span>);<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(equalized_image);<br>title(<span class="hljs-string">&#x27;均衡化后的图像直方图&#x27;</span>);<br><br><span class="hljs-comment">% 显示均衡化后的图像直方图</span><br><span class="hljs-built_in">figure</span>;<br>histogram_values=imhist(equalized_image);<br>bar(histogram_values);<br>title(<span class="hljs-string">&#x27;Peppers均衡化后的图像直方图&#x27;</span>);<br>xlabel(<span class="hljs-string">&#x27;灰度级别&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;频率&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(histogram_values)]);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%9D%87%E8%A1%A1%E5%8C%96%E5%AF%B9%E6%AF%94_Lena.jpeg" alt="Lena经过均衡化的图像"><figcaption aria-hidden="true">Lena经过均衡化的图像</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%9D%87%E8%A1%A1%E5%8C%96%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%AF%B9%E6%AF%94_Lena.jpeg" alt="Lena经过均衡化的直方图"><figcaption aria-hidden="true">Lena经过均衡化的直方图</figcaption></figure><h2 id="直方图建模">5.直方图建模</h2><p>直方图建模技术是修改图像的动态范围和对比度的有效工具。与对比度拉伸不同，直方图建模运算符可以使用非线性和非单调的传递函数来映射输入和输出图像中的像素强度值。</p><h3 id="lena作为输入直方图">5.1 Lena作为输入直方图</h3><p>使用图像A(Lena)的直方图作为输入直方图，并根据输入对另一个图像B(Peppers)的直方图建模。</p><p>步骤：</p><ol type="1"><li>读取图像A和图像B，并计算它们的直方图。</li><li>计算图像A和图像B的累积分布函数（CDF）。</li><li>创建一个映射表，将图像B的像素值映射到具有图像A的直方图分布的像素值。</li><li>应用映射表，生成输出图像。</li></ol><p>直方图建模：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outputImage</span>  = <span class="hljs-title">Histogram_modelling</span><span class="hljs-params">(imageA,imageB)</span></span><br>    <br>    <span class="hljs-comment">% 计算图像A和图像B的直方图</span><br>    histA = imhist(imageA);<br>    histB = imhist(imageB);<br><br>    <span class="hljs-comment">% 计算累积分布函数（CDF）</span><br>    cdfA = cumsum(histA) / <span class="hljs-built_in">numel</span>(imageA);<br>    cdfB = cumsum(histB) / <span class="hljs-built_in">numel</span>(imageB);<br><br>    <span class="hljs-comment">% 根据图像B的CDF值找到最接近图像A的CDF值的索引，并构建映射表</span><br>    mapping = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br><br>    <span class="hljs-comment">% 生成映射表</span><br>    <span class="hljs-keyword">for</span> grayLevel = <span class="hljs-number">1</span>:<span class="hljs-number">256</span><br>        [~, idx] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(cdfB(grayLevel) - cdfA));<br>        mapping(grayLevel) = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">% MATLAB的索引从1开始，减去1得到灰度值</span><br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-comment">% 应用映射表到图像B</span><br>    outputImage = mapping(double(imageB) + <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>min</code> 函数有两个输出：</p><ol type="1"><li><strong>最小值</strong>：在数组中找到的最小值。</li><li><strong>索引</strong>：最小值所在的位置（索引）。</li></ol><p>例如，<code>[minValue, idx] = min(A)</code>。</p></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取灰度图像A和B</span><br>[imageA, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input_A.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br>[imageB, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input_B.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br>outputImage = Histogram_modelling(imageA,imageB);<br><br><span class="hljs-comment">% 显示原始图像和结果图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(imageB);<br>title(<span class="hljs-string">&#x27;图像B&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>imhist(imageA);<br>title(<span class="hljs-string">&#x27;图像A的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(imageB);<br>title(<span class="hljs-string">&#x27;图像B的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>imhist(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B的直方图&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, outputImage, <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1%E5%89%8D%E5%90%8EB%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="建模前后图像B的对比" style="zoom:80%;"></p><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1AB_%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="直方图对比" style="zoom:67%;"></p><h3 id="使用指数分布的近似值作为输入直方图">5.2 使用指数分布的近似值作为输入直方图</h3><p>使用指数分布的近似值作为输入直方图。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 生成指数分布直方图的近似</span><br>N = <span class="hljs-number">256</span>; <span class="hljs-comment">% 灰度级别数量</span><br>lambda = <span class="hljs-number">0.05</span>; <span class="hljs-comment">% 指数分布的参数</span><br><br><span class="hljs-comment">% 计算指数分布概率密度函数</span><br>x = <span class="hljs-number">0</span>:N<span class="hljs-number">-1</span>;<br>pdf_exp = lambda * <span class="hljs-built_in">exp</span>(-lambda * x);<br><br><span class="hljs-comment">% 标准化概率密度函数以得到直方图</span><br>pdf_exp = pdf_exp / sum(pdf_exp); <span class="hljs-comment">% 使概率密度函数的总和为1</span><br><br><span class="hljs-comment">% 使用指数分布近似作为输入直方图，模拟另一个图像的直方图</span><br>cdf_exp = cumsum(pdf_exp); <span class="hljs-comment">% 计算指数分布的累积分布函数</span><br><br><span class="hljs-comment">% 读取另一个图像，这里假设为灰度图像B</span><br>[imageB, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br><span class="hljs-comment">% 计算图像B的直方图</span><br>histB = imhist(imageB) / <span class="hljs-built_in">numel</span>(imageB); <span class="hljs-comment">% 将直方图标准化为概率</span><br><br><span class="hljs-comment">% 计算图像B的累积分布函数（CDF）</span><br>cdfB = cumsum(histB); <br><br><span class="hljs-comment">% 创建映射表</span><br>mapping = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">256</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;uint8&#x27;</span>);<br><br><span class="hljs-comment">% 对于每个灰度级别，找到与指数分布CDF最接近的灰度级别</span><br><span class="hljs-keyword">for</span> grayLevel = <span class="hljs-number">1</span>:<span class="hljs-number">256</span><br>    [~, idx] = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(cdfB(grayLevel) - cdf_exp));<br>    mapping(grayLevel) = idx - <span class="hljs-number">1</span>; <span class="hljs-comment">% MATLAB的索引从1开始，减去1得到灰度值</span><br><span class="hljs-keyword">end</span><br><br><span class="hljs-comment">% 应用映射表到图像B</span><br>outputImage = mapping(double(imageB) + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">% 显示原始图像和结果图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(imageB);<br>title(<span class="hljs-string">&#x27;图像B&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>bar(pdf_exp);<br>title(<span class="hljs-string">&#x27;指数分布直方图&#x27;</span>);<br>xlim([<span class="hljs-number">0</span>, <span class="hljs-number">256</span>]);<br>ylim([<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>(pdf_exp)]);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>imhist(imageB);<br>title(<span class="hljs-string">&#x27;图像B的直方图&#x27;</span>);<br><br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>imhist(outputImage);<br>title(<span class="hljs-string">&#x27;建模后的图像B的直方图&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, outputImage, <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(outputImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E5%BB%BA%E6%A8%A1%E5%89%8D%E5%90%8EB%E7%9A%84%E5%AF%B9%E6%AF%94.jpeg" alt="建模前后图像B的对比"><figcaption aria-hidden="true">建模前后图像B的对比</figcaption></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%BB%BA%E6%A8%A1%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83_%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="直方图对比" style="zoom: 67%;"></p><h1 id="六图像的基本操作">六、图像的基本操作</h1><h2 id="图像负片">1.图像负片</h2><p>图像的负片是指将图像的每个像素的灰度值取反，即将每个像素的灰度值从原来的值减去最大灰度级别，得到新的灰度值。这样做的结果是原来较亮的区域变得较暗，而原来较暗的区域变得较亮。因此，负片图像呈现出与原始图像完全相反的外观，亮度和对比度都会发生反转。</p><p>在实际应用中，图像的负片经常用于图像增强、特效处理和艺术创作等方面。负片可以改变图像的外观，使其更具有视觉冲击力和独特性。同时，负片还可以突出原始图像中的细节和特征，对图像进行突出和强调。因此，在数字图像处理中，生成图像的负片是一项常见且有用的操作。</p><p>得到图像负片：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">negativeImage</span> = <span class="hljs-title">generateNegative</span><span class="hljs-params">(image)</span></span><br>    <br>    <span class="hljs-comment">% 计算灰度级别的最大值</span><br>    maxIntensity = double(<span class="hljs-built_in">max</span>(image(:)));<br>    <br>    <span class="hljs-comment">% 生成负片</span><br>    negativeImage = maxIntensity - image;<br>    <br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 读取灰度图像</span><br>[image, ~, ~, pgm_max_val,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);<br><br>negativeImage = generateNegative(image);<br><br><span class="hljs-comment">% 显示原始图像和负片图像</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(image);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(negativeImage);<br>title(<span class="hljs-string">&#x27;负片图像&#x27;</span>);<br><br><span class="hljs-comment">% 保存结果图像</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, negativeImage, <span class="hljs-built_in">size</span>(negativeImage, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(negativeImage, <span class="hljs-number">1</span>), pgm_max_val, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%8E%9F%E5%A7%8B%E5%9B%BE%E5%83%8F%E5%92%8C%E8%B4%9F%E7%89%87%E5%9B%BE%E5%83%8F_Lena.jpeg" alt="Lena及其负片图像"><figcaption aria-hidden="true">Lena及其负片图像</figcaption></figure><h2 id="图像的旋转和倾斜">2、图像的旋转和倾斜</h2><h3 id="基本原理-1">2.1 基本原理</h3><p>图像倾斜的矩阵形式：</p><p>假设我们有一个二维向量(x,y)表示图像中的一个像素点。图像倾斜操作可以表示为以下矩阵乘法： <span class="math display">\[\begin{bmatrix}x&#39; \\y&#39;\end{bmatrix}= \begin{bmatrix}1 &amp; tan(\theta) &amp; 0\\0 &amp; 1 &amp; 0\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}\]</span> 在这里，θ 是倾斜的角度，(x',y')是经过倾斜操作后的像素点坐标。</p><p>图像旋转的矩阵形式：</p><p>图像旋转操作可以表示为以下矩阵乘法： <span class="math display">\[\begin{bmatrix}x&#39; \\y&#39;\end{bmatrix}= \begin{bmatrix}cos(\theta) &amp; -sin(\theta) \\sin(\theta) &amp; cos(\theta)\end{bmatrix}\begin{bmatrix}x\\y\end{bmatrix}\]</span> 在这里，θ是旋转的角度，(x',y')是经过旋转操作后的像素点坐标。</p><h3 id="代码实现-1">2.2 代码实现</h3><p>创建并在下面粘贴一张 PGM 图像，其中包含用 Arial 字体、72 点、大写字母书写的您的姓名。将创建的图像顺时针旋转 30 度、60 120 度和-50 度。将同一图像倾斜 10 度、40 度和 60 度。</p><p>旋转和倾斜函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[I_rotated,I_skewed]</span>=<span class="hljs-title">BUPT_transform</span><span class="hljs-params">(I, theta1, theta2)</span></span><br>   <br>    <span class="hljs-comment">% 旋转图像</span><br>    I_rotated = imrotate(I, theta1);<br><br>    <span class="hljs-comment">% 倾斜图像</span><br>    tform = affine2d([<span class="hljs-number">1</span>, <span class="hljs-built_in">tand</span>(theta2), <span class="hljs-number">0</span>; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]); <span class="hljs-comment">% 创建仿射变换对象</span><br>    I_skewed = imwarp(I, tform);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imrotate(I, theta1)</code> 是 MATLAB 中用于旋转图像的函数。它将图像 <code>I</code> 按照指定的角度 <code>theta1</code> 进行逆时针旋转。</p><p><code>affine2d</code> 是用于创建仿射变换对象的函数。仿射变换是一种线性变换，可以保持平行线的直线性质，但通常会改变对象的大小、形状和方向。</p><p><code>affine2d()</code> 的参数是一个矩阵。它可以通过矩阵来描，这个矩阵通常是一个 3×33×3 的矩阵，称为仿射变换矩阵。这个矩阵包含了对平移、旋转、缩放和剪切等操作的描述。</p><p>下面是这个仿射变换矩阵的一般形式： <span class="math display">\[\begin{bmatrix}a_{11} &amp; a_{12} &amp; t_x\\a_{21} &amp; a_{22} &amp; t_y\\0 &amp; 0 &amp; 1\end{bmatrix}\]</span> 其中：</p><ul><li><span class="math inline">\(a_{11}\)</span>和<span class="math inline">\(a_{22}\)</span>控制着水平和垂直方向上的缩放；</li><li><span class="math inline">\(a_{12}\)</span>和<span class="math inline">\(a_{21}\)</span>控制着水平和垂直方向上的剪切；</li><li><span class="math inline">\(t_x\)</span>和<span class="math inline">\(t_y\)</span>控制着水平和垂直方向上的平移。</li></ul><p><code>imwarp()</code> 用于对图像进行<strong>仿射变换</strong>或<strong>非线性变换</strong>。它可以将输入图像根据指定的变换应用到输出图像上。</p></blockquote><p>创建包含自己姓名的PGM 图像并实现上述操作：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义您的名字</span><br>name = <span class="hljs-string">&#x27;Your name&#x27;</span>;<br> <br><span class="hljs-comment">% 创建一个灰度图像，大小可以根据需要调整</span><br>image_size = [<span class="hljs-number">512</span>, <span class="hljs-number">512</span>];<br>image = uint8(<span class="hljs-built_in">zeros</span>(image_size) * <span class="hljs-number">255</span>); <span class="hljs-comment">% 初始化为全黑图像</span><br> <br><span class="hljs-comment">% 设置文本属性</span><br>text_position = [<span class="hljs-number">10</span>, <span class="hljs-number">25</span>]; <span class="hljs-comment">% 文本位置</span><br><br><span class="hljs-comment">% 在图像上绘制文本</span><br>image = insertText(image, text_position, name, <span class="hljs-string">&#x27;FontSize&#x27;</span>, <span class="hljs-number">72</span>, <span class="hljs-string">&#x27;Font&#x27;</span>, <span class="hljs-string">&#x27;Arial&#x27;</span>, <span class="hljs-string">&#x27;TextColor&#x27;</span>, <span class="hljs-string">&#x27;white&#x27;</span>);<br><br><span class="hljs-comment">% 保存图像为PGM格式</span><br>writePGM(<span class="hljs-string">&#x27;output.pgm&#x27;</span>, image, <span class="hljs-built_in">size</span>(image, <span class="hljs-number">2</span>), <span class="hljs-built_in">size</span>(image, <span class="hljs-number">1</span>), <span class="hljs-number">255</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>,<span class="hljs-string">&#x27;P2&#x27;</span>);<br><br><span class="hljs-comment">% 读取并显示创建的图像</span><br>originalImage = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>imshow(originalImage);<br>title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br><br>rotationAngles = [<span class="hljs-number">30</span>, <span class="hljs-number">60</span>, <span class="hljs-number">120</span>, <span class="hljs-number">-50</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(rotationAngles)<br>    [I_rotated,~]=BUPT_transform(originalImage, rotationAngles(<span class="hljs-built_in">i</span>), <span class="hljs-number">0</span>);<br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">1</span>);<br>    imshow(I_rotated);<br>    title([<span class="hljs-string">&#x27;旋转 &#x27;</span>, num2str(rotationAngles(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27; 度&#x27;</span>]);<br><span class="hljs-keyword">end</span><br>skewAngles = [<span class="hljs-number">10</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(skewAngles)<br>    [~,I_skewed]=BUPT_transform(originalImage, <span class="hljs-number">0</span>, skewAngles(<span class="hljs-built_in">i</span>));<br>    subplot(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-built_in">i</span>+<span class="hljs-number">5</span>);<br>    imshow(I_skewed);<br>    title([<span class="hljs-string">&#x27;倾斜 &#x27;</span>, num2str(skewAngles(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27; 度&#x27;</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>insertText()</code> 函数用于在图像上插入文本。它的基本用法：<code>insertText(I, position, text)</code></p><p>其中：</p><ul><li><code>I</code> 是输入图像。</li><li><code>position</code> 是文本的起始位置，可以是一个二元素的数组 <code>[x, y]</code>，表示文本左下角的坐标。</li><li><code>text</code> 是要插入的文本字符串。</li></ul><p>此外，<code>insertText()</code> 还支持很多参数来控制文本的样式和外观，比如字体大小、字体、颜色等。你可以通过提供参数值来设置这些选项。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E5%B9%B3%E7%A7%BB%E6%97%8B%E8%BD%AC-17157800682331.jpeg" alt="经过旋转、倾斜后的图像"><figcaption aria-hidden="true">经过旋转、倾斜后的图像</figcaption></figure><p>将旋转与倾斜结合：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-built_in">figure</span>;<br>[I_rotated,~]=BUPT_transform(originalImage, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>);<br>[~,I_skewed]=BUPT_transform(I_rotated, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(I_skewed);<br>title(<span class="hljs-string">&#x27;先旋转20°再倾斜50°&#x27;</span>);<br><br>[~,I_skewed]=BUPT_transform(originalImage, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>);<br>[I_rotated,~]=BUPT_transform(I_skewed, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(I_rotated);<br>title(<span class="hljs-string">&#x27;先倾斜50°再旋转20°&#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%97%8B%E8%BD%AC%E5%80%BE%E6%96%9C%E7%BB%93%E5%90%88.jpeg" style="zoom:67%;"></p><h1 id="七对图像噪声的处理">七、对图像噪声的处理</h1><h2 id="均方误差-mse-和峰值信噪比-psnr">1.均方误差 (MSE) 和峰值信噪比 (PSNR)</h2><p>均方误差（MSE）是衡量原始图像与失真图像之间平均平方差的一种度量，量化了原始图像和失真图像之间对应像素差异的平方的平均值。其公式如下： <span class="math display">\[\text{MSE} = \frac{1}{m \cdot n} \sum_{i=1}^{m} \sum_{j=1}^{n} [I(i,j) - K(i,j)]^2\]</span> 其中： - <span class="math inline">\(I\)</span>是原始图像。 - <span class="math inline">\(K\)</span>是失真图像。 - <span class="math inline">\(m\)</span>和<span class="math inline">\(n\)</span>是图像的维度（行数和列数）。 - <span class="math inline">\(I(i,j)\)</span>和<span class="math inline">\(K(i,j)\)</span>分别是原始图像和失真图像在位置<span class="math inline">\((i,j)\)</span>的像素值。</p><p>峰值信噪比是比较信号最大可能值与背景噪声水平的一种度量，通常以分贝 (dB) 表示。其公式如下： <span class="math display">\[ \text{PSNR} = 10 \cdot \log_{10} \left( \frac{\text{MAX}^2}{\text{MSE}} \right) \]</span> 其中： - <span class="math inline">\(MAX\)</span>是图像的最大可能像素值（对于8位图像，这个值是255）。 - <span class="math inline">\(MSE\)</span>是原始图像和失真图像之间的均方误差。</p><p>PSNR 通常是一个正值，因为<span class="math inline">\(MAX^2\)</span>的比值对实用和有用的图像来说总是大于1。如果 PSNR 为负，表明图像噪声极高，几乎无法使用。这种情况在实际应用中极为罕见。</p><p>通过向测试图像添加不同量的随机噪声，可以观察到 MSE 和 PSNR 的变化，这有助于理解图像质量随着噪声的恶化情况，以及这些度量如何量化这种恶化。</p><h2 id="获取加入噪声的图像">2.获取加入噪声的图像</h2><p>获取加入噪声的图像：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add_noise_and_evaluate</span><span class="hljs-params">(original_image)</span></span><br>    <br>    <span class="hljs-comment">% 添加盐和胡椒噪声,可以改变噪声的密度，表示图像中受噪声影响的像素比例。例如，0.05 表示5%的像素会被随机设为0或1（黑或白）</span><br>    sp_noisy_image = imnoise(original_image, <span class="hljs-string">&#x27;salt &amp; pepper&#x27;</span>, <span class="hljs-number">0.05</span>);<br>    <span class="hljs-comment">% 计算盐和胡椒噪声的MSE和PSNR</span><br>    [mse_sp, psnr_sp] = compute_mse_psnr(original_image, sp_noisy_image);<br>    <br>    <span class="hljs-comment">% 添加高斯噪声,在这里可以改变噪声的方差</span><br>    gauss_noisy_image_1 = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.0001</span>);<br>    <span class="hljs-comment">% 计算高斯噪声的MSE和PSNR</span><br>    [mse_gauss_1, psnr_gauss_1] = compute_mse_psnr(original_image, gauss_noisy_image_1);<br>    <br>    <span class="hljs-comment">% 添加高斯噪声,在这里可以改变噪声的方差</span><br>    gauss_noisy_image_2 = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.0025</span>);<br>    <span class="hljs-comment">% 计算高斯噪声的MSE和PSNR</span><br>    [mse_gauss_2, psnr_gauss_2] = compute_mse_psnr(original_image, gauss_noisy_image_2);<br>    <br>    <span class="hljs-comment">% 显示原始图像和添加噪声后的图像</span><br>    <span class="hljs-built_in">figure</span>;<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>), imshow(original_image), title(<span class="hljs-string">&#x27;原始图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>), imshow(sp_noisy_image), title(<span class="hljs-string">&#x27;盐和胡椒噪声图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), imshow(gauss_noisy_image_1), title(<span class="hljs-string">&#x27;\delta=0.01时的高斯噪声图像&#x27;</span>);<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>), imshow(gauss_noisy_image_2), title(<span class="hljs-string">&#x27;\delta=0.05高斯噪声图像&#x27;</span>);<br>    <br>    <span class="hljs-comment">% 显示计算结果</span><br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;盐和胡椒噪声 - MSE: &#x27;</span>, num2str(mse_sp), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_sp)]);<br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;标准差=0.01时的高斯噪声 - MSE: &#x27;</span>, num2str(mse_gauss_1), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_gauss_1)]);<br>    <span class="hljs-built_in">disp</span>([<span class="hljs-string">&#x27;标准差=0.05时的高斯噪声 - MSE: &#x27;</span>, num2str(mse_gauss_2), <span class="hljs-string">&#x27;, PSNR: &#x27;</span>, num2str(psnr_gauss_2)]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imnoise</code> 函数是 MATLAB 中用于向图像添加各种类型噪声的函数。</p></blockquote><p>计算MSE与PSNR：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[mse, psnr]</span> = <span class="hljs-title">compute_mse_psnr</span><span class="hljs-params">(original_image, noisy_image)</span></span><br>    <span class="hljs-comment">% 计算均方误差 (MSE)</span><br>    mse = immse(original_image, noisy_image);<br>    <br>    <span class="hljs-comment">% 计算峰值信噪比 (PSNR)</span><br>    max_pixel_value = <span class="hljs-number">255</span>; <span class="hljs-comment">% 对于8位图像</span><br>    psnr = <span class="hljs-number">10</span> * <span class="hljs-built_in">log10</span>(max_pixel_value^<span class="hljs-number">2</span> / mse);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br>add_noise_and_evaluate(original_image);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E5%8A%A0%E5%99%AA%E5%A3%B0-17159126666311.jpeg" alt="加入不同噪声后的Lena图"><figcaption aria-hidden="true">加入不同噪声后的Lena图</figcaption></figure><p>其中，盐和胡椒噪声的MSE: 935.1138, PSNR: 18.4222；标准差=0.01时的高斯噪声的MSE: 6.6053, PSNR: 39.9318；标准差=0.05时的高斯噪声的MSE: 162.7394, PSNR: 26.0159。可以看到，MSE越小，误差越小；PSNR越大，误差越小。</p><h2 id="低通滤波高斯滤波">3.低通滤波——高斯滤波</h2><h3 id="基本原理-2">3.1 基本原理</h3><p>低通滤波：图像滤波通过对原始图像像素执行某些操作生成处理后的图像。输出图像中的每个像素是作为原始图像中一个或多个像素（通常位于输出像素附近）的函数计算的。该过程通常通过将具有所需属性的卷积核与输入图像的像素进行卷积来实现。如果卷积核是高斯核，则滤波器的行为取决于高斯的方差。</p><p>使用的高斯核的公式：<span class="math inline">\(G(x,y)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{x^2+y^2}{2\sigma^2})\)</span></p><p>2D高斯核可以分解为两个1D高斯核。用于行和列的单独方程是：</p><p>对于行：<span class="math inline">\(G_r(x)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{x^2}{2\sigma^2})\)</span></p><p>对于列：<span class="math inline">\(G_c(y)=\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{y^2}{2\sigma^2})\)</span></p><p>使用可分离滤波器的优点：</p><ul><li><strong>效率:</strong> 可分离滤波器将计算复杂度从<span class="math inline">\(O(n^2)\)</span>降低到<span class="math inline">\(O(n)\)</span>，其中n是核的大小。这意味着卷积操作变得更快。</li><li><strong>内存使用:</strong> 它也减少了内存使用，因为使用两个较小的1D核代替一个大的2D核。</li></ul><p>σ与滤波器的截止频率之间的关系是截止频率与σ成反比。随着σ的增加，截止频率降低，导致图像更平滑和模糊。截止频率<span class="math inline">\(f_c\)</span>可以近似为：<span class="math inline">\(fc\approx\frac{1}{2\pi \sigma}\)</span></p><p>给定σ，选择卷积核大小的标准通常是确保卷积核捕获高斯函数的大部分显著值。一个常见的规则是使用大小为6σ或8σ的卷积核。这是因为高斯函数在离均值3σ或4σ以外的值非常接近零，可以忽略不计。使用此标准可以确保卷积核足够大以提供准确的滤波，同时不过分增大，避免不必要的计算成本。</p><h3 id="代码实现-2">3.2 代码实现</h3><p>将噪声功率为50 dBm的高斯噪声添加到图像Lena中，然后将噪声图像分别与σ = 0.5，1，2，4，7，10的高斯核卷积。</p><p>高斯滤波：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BUPT_lowpass</span><span class="hljs-params">(original_image)</span></span><br>    <br>    <span class="hljs-comment">% 添加高斯噪声，噪声功率为50 dBm</span><br>    <span class="hljs-comment">% 噪声方差是噪声功率除以255的平方</span><br>    noise_power = <span class="hljs-number">50</span>;<br>    noisy_image = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, noise_power / <span class="hljs-number">255</span>^<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">% 定义不同sigma值的高斯核</span><br>    sigmas = [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">10</span>];<br>    filtered_images = cell(<span class="hljs-number">1</span>, <span class="hljs-built_in">length</span>(sigmas));<br>    <br>    <span class="hljs-comment">% 对每个sigma值，进行高斯低通滤波</span><br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>        sigma = sigmas(k);<br>        <span class="hljs-comment">% 计算高斯核的尺寸。</span><br>        <span class="hljs-comment">% 这里我们使用了经验法则，即高斯核的大小一般取为6 * sigma左右，以确保包含足够的高斯分布信息</span><br>        <span class="hljs-comment">% 而且要是奇数，这样高斯核的中心元素可以对准图像的像素</span><br>        kernel_size = <span class="hljs-number">2</span> * <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3</span> * sigma) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">% 创建一个高斯核</span><br>        gaussian_kernel = fspecial(<span class="hljs-string">&#x27;gaussian&#x27;</span>, kernel_size, sigma);<br>        <span class="hljs-comment">% 对噪声图像进行高斯滤波</span><br>        filtered_images&#123;k&#125; = imfilter(noisy_image, gaussian_kernel, <span class="hljs-string">&#x27;same&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 显示原始图像、噪声图像以及不同sigma值的滤波结果</span><br>    <br>    <span class="hljs-built_in">figure</span>;<br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>    imshow(original_image);<br>    title(<span class="hljs-string">&#x27;Original Image&#x27;</span>);<br>    <br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>    imshow(noisy_image);<br>    title(<span class="hljs-string">&#x27;Noisy Image&#x27;</span>);<br>    <br>    <span class="hljs-keyword">for</span> k = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>        subplot(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, k + <span class="hljs-number">2</span>);<br>        imshow(filtered_images&#123;k&#125;);<br>        title([<span class="hljs-string">&#x27;\sigma = &#x27;</span>, num2str(sigmas(k))]);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>fspecial</code> 用于创建预定义的二维滤波器。它支持多种滤波器类型，例如高斯滤波器、均值滤波器、Laplacian滤波器等。</p><p><code>imfilter</code> 用于图像滤波。它通过卷积操作将指定的滤波器核应用于输入图像。这个函数非常适用于实现各种图像处理操作，例如模糊、锐化、边缘检测等。</p><p><code>'same'</code> 是 <code>imfilter</code> 函数的一个参数，用于指定输出图像的尺寸和位置与输入图像相同</p><p>卷积操作的几种不同模式：</p><ul><li><strong><code>'full'</code></strong>：输出图像包含卷积核在整个输入图像上的滑动结果，输出图像尺寸比输入图像大。</li><li><strong><code>'valid'</code></strong>：输出图像仅包含卷积核完全在输入图像内部滑动的结果，输出图像尺寸比输入图像小。</li><li><strong><code>'same'</code></strong>：输出图像尺寸与输入图像相同，卷积结果对齐到输入图像的中心位置。</li></ul></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br>BUPT_lowpass(original_image);<br></code></pre></td></tr></table></figure><p><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2.jpeg" alt="经过低通滤波的Lena图" style="zoom:150%;"></p><p>随着σ值的增加，滤波效果变得更加明显。具体来说：当σ较小，等于0.5时，图像保持了较多的细节，但噪声去除效果有限；当σ中等，等于1或2时，噪声被有效去除，图像变得更加平滑，但细节也开始丢失；当σ较大，等于4、7、10时，图像非常平滑，噪声几乎完全去除，但图像细节丢失严重，边缘变得模糊。</p><p>由此可以看出，选择适当的σ值是实现噪声去除与图像细节保留之间的平衡的关键。</p><h2 id="低通滤波矩形滤波">4.低通滤波——矩形滤波</h2><p>实现一个矩形滤波器。使用5 × 5和7 × 7内核对噪声图像Lena进行滤波。</p><p>矩形滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filtered_image</span> = <span class="hljs-title">BUPT_rect</span><span class="hljs-params">(image, kernel_size)</span></span><br>    <span class="hljs-comment">% 输入：</span><br>    <span class="hljs-comment">% image: 原始图像</span><br>    <span class="hljs-comment">% kernel_size: 滤波器大小，为正奇数</span><br>    <span class="hljs-comment">% 输出：</span><br>    <span class="hljs-comment">% filtered_image: 滤波后的图像</span><br><br>    <span class="hljs-comment">% 应用矩形滤波器</span><br>    kernel = <span class="hljs-built_in">ones</span>(kernel_size) / (kernel_size^<span class="hljs-number">2</span>);<br>    filtered_image = imfilter(image, kernel, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[original_image, ~, ~, ~,~] = readPGM(<span class="hljs-string">&#x27;input.pgm&#x27;</span>, <span class="hljs-string">&#x27;ASCII&#x27;</span>);    <br><br><span class="hljs-comment">% 添加高斯噪声</span><br>noisy_lena = imnoise(original_image, <span class="hljs-string">&#x27;gaussian&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">50</span>/<span class="hljs-number">255</span>^<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">% 使用矩形滤波器进行滤波</span><br>filtered_lena_5x5 = BUPT_rect(noisy_lena, <span class="hljs-number">5</span>);<br>filtered_lena_7x7 = BUPT_rect(noisy_lena, <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">% 显示结果</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>imshow(original_image);<br>title(<span class="hljs-string">&#x27;原始 Lena 图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>imshow(noisy_lena);<br>title(<span class="hljs-string">&#x27;添加高斯噪声后的 Lena 图像&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>imshow(filtered_lena_5x5);<br>title(<span class="hljs-string">&#x27;5x5 矩形滤波器&#x27;</span>);<br><br>subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);<br>imshow(filtered_lena_7x7);<br>title(<span class="hljs-string">&#x27;7x7 矩形滤波器&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Lena_%E7%9F%A9%E5%BD%A2%E6%BB%A4%E6%B3%A2.jpeg" alt="经过矩形滤波的Lena图"><figcaption aria-hidden="true">经过矩形滤波的Lena图</figcaption></figure><p>由于所有邻域内像素的权重相等，矩形滤波器容易产生明显的模糊效果，特别是大尺寸核的情况下，图像细节损失严重，边缘变得不清晰。通过加权平均的方式，高斯滤波器在噪声去除的同时，保留了更多的图像细节和边缘信息。随着σ值的增加，图像逐渐变得更平滑，但高斯滤波器整体上在保留图像细节方面优于矩形滤波器。</p><p>矩形滤波器适用于一些对计算要求较低的场景，或对图像细节和边缘不太敏感的场景。高斯滤波器适用于需要平滑图像并保留细节的场景，更适合在图像处理、计算机视觉等领域使用。</p><p>通过上述比较可以看出，高斯滤波器在视觉效果和细节保留上均优于矩形滤波器，尽管计算复杂度略高，但在大多数应用中是更好的选择。</p><h1 id="八边缘检测">八、边缘检测</h1><h2 id="一阶微分算子">1.一阶微分算子</h2><p>边缘检测是图像处理与计算机视觉中的重要技术之一。其目的是检测识别出图像中亮度变化剧烈的像素点构成的集合。图像边缘的正确检测对于分析图像中的内容、实现图像中物体的分割、定位等具有重要的作用。边缘检测大大减少了源图像的数据量，剔除了与目标不相干的信息，保留了图像重要的结构属性。</p><p>图像的边缘指的是图像中像素灰度值突然发生变化的区域，如果将图像的每一行像素和每一列像素都描述成一个关于灰度值的函数，那么图像的边缘对应在灰度值函数中是函数值突然变大的区域。函数值的变化趋势可以用函数的导数描述。当函数值突然变大时，导数也必然会变大，而函数值变化较为平缓区域，导数值也比较小，因此可以通过寻找导数值较大的区域去寻找函数中突然变化的区域，进而确定图像中的边缘位置。</p><p>一阶微分为基础的边缘检测，通过计算图像的梯度值来检测图像的边缘，如Roberts算子、Prewitt算子和Sobel算子等。</p><h3 id="roberts算子">1.1 Roberts算子</h3><p>Roberts算子是一种最简单的算子，它利用局部差分算子寻找边缘。采用对角线相邻两像素之差近似<strong>梯度幅值</strong>检测边缘，检测垂直边缘的效果比斜向边缘要好，定位精度高，但对噪声比较敏感，无法抑制噪声的影响。</p><p>Roberts算子是一个2x2的模板，采用的是对角方向相邻的两个像素之差，如下的2个卷积核形成了Roberts算子，图像中的每一个点都用这2个核做卷积。其中，<code>Gx</code> 用于计算水平方向（对角线方向）的梯度，<code>Gy</code> 用于计算垂直方向（对角线方向）的梯度： <span class="math display">\[G_x=\begin{bmatrix}1 &amp; 0\\0 &amp; -1\end{bmatrix},G_y=\begin{bmatrix}0 &amp; -1\\1 &amp; 0\end{bmatrix}\]</span> 对于每个像素，使用这两个卷积核分别计算其在两个对角方向上的梯度。假设图像的像素值矩阵为 <code>I</code>，那么在位置 <code>(i, j)</code> 处的梯度计算如下： <span class="math display">\[gradient_x = I(i, j) * G_x(1, 1) + I(i, j+1) * G_x(1, 2) + I(i+1, j) * G_x(2, 1) + I(i+1, j+1) * G_x(2, 2)\]</span></p><p><span class="math display">\[gradient_y = I(i, j) * G_y(1, 1) + I(i, j+1) * G_y(1, 2) + I(i+1, j) * G_y(2, 1) + I(i+1, j+1) * G_y(2, 2)\]</span></p><p><span class="math display">\[(梯度幅值)magnitude = \sqrt{gradient_x^2 + gradient_y^2)}\]</span></p><p>若对于输入图像I(x,y),使用Roberts算子后输出图像为g(x,y),则 <span class="math display">\[g(x,y)=\sqrt{(I(x,y)-I(x+1,y+1))^2+(I(x+1,y)-I(x,y+1))^2}\]</span> 在Matlab中，Roberts算子主要是通过imfilter()函数实现边缘提取。该函数主要是利用卷积核实现对图像的卷积运算。</p><h3 id="prewitt算子">1.2 Prewitt算子</h3><p>Prewitt是一种图像边缘检测的微分算子，其原理是利用特定区域内像素值产生的差分实现边缘检测。由于Prewitt算子采用3x3模板对区域内的像素值进行计算，而Roberts算子的模板为2x2，故Prewitt算子的边缘检测结果在水平和垂直方向均比Roberts算子更加明显。Prewitt算子适合用来识别噪声较多，灰度渐变的图像。Prewitt算子卷积核如下：</p><p><span class="math display">\[G_x=\begin{bmatrix}1 &amp; 1 &amp; 1\\0 &amp; 0 &amp; 0\\-1 &amp; -1 &amp; -1\end{bmatrix},G_y=\begin{bmatrix}-1 &amp; 0 &amp; 1\\-1 &amp; 0 &amp; 1\\-1 &amp; 0 &amp; 1\end{bmatrix}\]</span></p><h3 id="sobel算子">1.3 Sobel算子</h3><p>在边缘检测中，常用的一种模板是Sobel算子。Sobel算子有两个卷积核，一个是检测水平边缘的；另一个是检测垂直边缘的。与Prewitt算子相比，Sobel算子对于像素的位置的影响做了加权，可以降低边缘模糊程度，因此效果更好。</p><p>Sobel算子卷积核如下： <span class="math display">\[G_x=\begin{bmatrix}-1 &amp; 0 &amp; 1\\-2 &amp; 0 &amp; 2\\-1 &amp; 0 &amp; 1\end{bmatrix},G_y=\begin{bmatrix}1 &amp; 2 &amp; 1\\0 &amp; 0 &amp; 0\\-1 &amp; -2 &amp; -1\end{bmatrix}\]</span></p><h2 id="代码实现-3">2.代码实现</h2><p>边缘检测函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edge_image</span> = <span class="hljs-title">edge_detection</span><span class="hljs-params">(image, method)</span></span><br>    <span class="hljs-comment">% 初始化卷积核</span><br>    <span class="hljs-keyword">switch</span> method<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;sobel&#x27;</span><br>            gx = [<span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-2</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br>            gy = gx&#x27;;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;roberts&#x27;</span><br>            gx = [<span class="hljs-number">1</span> <span class="hljs-number">0</span>; <span class="hljs-number">0</span> <span class="hljs-number">-1</span>];<br>            gy = [<span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;prewitt&#x27;</span><br>            gx = [<span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>; <span class="hljs-number">-1</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span>];<br>            gy = gx&#x27;;<br>        <span class="hljs-keyword">otherwise</span><br>            error(<span class="hljs-string">&#x27;Unsupported edge detection method.&#x27;</span>);<br>    <span class="hljs-keyword">end</span><br>    <br>    <span class="hljs-comment">% 处理灰度图像</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">size</span>(image, <span class="hljs-number">3</span>) == <span class="hljs-number">1</span><br>        edge_image = apply_filter(image, gx, gy);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">% 处理RGB图像</span><br><br>        edge_image = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(image));<br>        <span class="hljs-keyword">for</span> c = <span class="hljs-number">1</span>:<span class="hljs-number">3</span><br>            edge_image(:,:,c) = apply_filter(image(:,:,c), gx, gy);<br>        <span class="hljs-keyword">end</span><br>        edge_image = uint8(edge_image);<br>    <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gradient_magnitude</span> = <span class="hljs-title">apply_filter</span><span class="hljs-params">(image, gx, gy)</span></span><br>    <span class="hljs-comment">% 应用卷积</span><br>    <span class="hljs-comment">% 得到在x方向的梯度</span><br>    gradient_x = imfilter(double(image), gx, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br>    <span class="hljs-comment">% 得到在y方向的梯度</span><br>    gradient_y = imfilter(double(image), gy, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br>    <br>    <span class="hljs-comment">% 计算梯度的绝对值</span><br>    gradient_magnitude = <span class="hljs-built_in">sqrt</span>(gradient_x.^<span class="hljs-number">2</span> + gradient_y.^<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-comment">% 正规化结果以便显示</span><br>    gradient_magnitude = uint8(<span class="hljs-number">255</span> * mat2gray(gradient_magnitude));<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imfilter</code> 函数用于对图像进行卷积操作，在这里用的是矩形滤波器。</p><p>使用 <code>'replicate'</code> 选项处理图像边缘，使边界外的像素值等于边界上的像素值，从而避免边缘处出现人为的卷积结果。</p><p>在图像卷积过程中，需要处理卷积核超过图像边界的情况。<code>imfilter</code> 提供了多种处理边界的方法，<code>replicate</code> 是其中一种。以下是几种常见的边界处理方法：</p><ul><li><strong><code>replicate</code></strong>： 边界外的像素值复制最近的边界内像素值。这种方法会使边缘部分的卷积结果较为平滑。</li><li><strong><code>circular</code></strong>： 边界外的像素值从图像的另一侧循环复制。例如，左边界外的像素值将从右边界复制。</li><li><strong><code>symmetric</code></strong>： 边界外的像素值对称于边界复制。例如，左边界外第一个像素值与左边界内第一个像素值对称。</li><li><strong><code>fill</code></strong>： 边界外的像素值填充为指定的常数值，默认值为 0。</li></ul></blockquote><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 加载灰度图像（PGM格式）</span><br>gray_image = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><span class="hljs-comment">% 加载RGB图像（PPM格式）</span><br>rgb_image = imread(<span class="hljs-string">&#x27;input.ppm&#x27;</span>);<br><br><span class="hljs-comment">% 对灰度图像进行边缘检测</span><br>gray_sobel = edge_detection(gray_image, <span class="hljs-string">&#x27;sobel&#x27;</span>);<br>gray_roberts = edge_detection(gray_image, <span class="hljs-string">&#x27;roberts&#x27;</span>);<br>gray_prewitt = edge_detection(gray_image, <span class="hljs-string">&#x27;prewitt&#x27;</span>);<br><br><span class="hljs-comment">% 对RGB图像进行边缘检测</span><br>rgb_sobel = edge_detection(rgb_image, <span class="hljs-string">&#x27;sobel&#x27;</span>);<br>rgb_roberts = edge_detection(rgb_image, <span class="hljs-string">&#x27;roberts&#x27;</span>);<br>rgb_prewitt = edge_detection(rgb_image, <span class="hljs-string">&#x27;prewitt&#x27;</span>);<br><br><span class="hljs-comment">% 显示结果</span><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); imshow(gray_sobel); title(<span class="hljs-string">&#x27;Gray Sobel&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); imshow(gray_roberts); title(<span class="hljs-string">&#x27;Gray Roberts&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); imshow(gray_prewitt); title(<span class="hljs-string">&#x27;Gray Prewitt&#x27;</span>);<br><br><span class="hljs-built_in">figure</span>;<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>); imshow(rgb_sobel); title(<span class="hljs-string">&#x27;RGB Sobel&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>); imshow(rgb_roberts); title(<span class="hljs-string">&#x27;RGB Roberts&#x27;</span>);<br>subplot(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); imshow(rgb_prewitt); title(<span class="hljs-string">&#x27;RGB Prewitt&#x27;</span>);<br></code></pre></td></tr></table></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Peppers_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_grey-17160136154963.jpeg" alt="经过边缘检测后的Peppers灰度图像"><figcaption aria-hidden="true">经过边缘检测后的Peppers灰度图像</figcaption></figure><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/Peppers_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_rgb.jpeg" alt="经过边缘检测后的Peppers的RGB图像"><figcaption aria-hidden="true">经过边缘检测后的Peppers的RGB图像</figcaption></figure><p>Roberts 算子边缘检测简单且计算效率高，但对噪声敏感。Sobel 算子在存在噪声时性能较好，并且能够检测到更平滑的边缘，但计算稍复杂。Prewitt 算子类似于 Sobel 算子，但略简单，效果也稍差。在具体应用中可以根据需求选择合适的边缘检测算法。</p><h2 id="二阶微分算子laplacian算子">3.二阶微分算子——Laplacian算子</h2><h3 id="基本原理-3">3.1 基本原理</h3><p>二阶微分为基础的边缘检测，通过寻求二阶导数中的过零点来检测边缘，如Laplacian算子等。</p><p>Laplacian算子是n维欧几里德空间中的一个二阶微分算子，常用于图像增强和边缘提取。它通过灰度差分计算邻域内的像素，基本流程是：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作。在算法实现过程中，Laplacian算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。 拉普拉斯滤波器是用于找到图像中的边缘的导数滤波器。由于导数滤波器对噪声非常敏感，因此在应用拉普拉斯之前通常会对图像进行平滑处理。例如，可以使用对图像进行平滑处理。将高斯低通滤波器和拉普拉斯滤波器组合的两步过程称为高斯拉普拉斯（LoG）算子。</p><h3 id="代码实现-4">3.2 代码实现</h3><p>LoG滤波器：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 定义LoG算子函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span> = <span class="hljs-title">LoG</span><span class="hljs-params">(image, sigma)</span></span><br>    <span class="hljs-comment">% 高斯滤波</span><br>    img_smoothed = BUPT_lowpass_1(image, sigma);<br>    <span class="hljs-comment">% 计算拉普拉斯算子</span><br>    laplacian_filter = fspecial(<span class="hljs-string">&#x27;laplacian&#x27;</span>);<br>    result = imfilter(img_smoothed, laplacian_filter,<span class="hljs-string">&#x27;conv&#x27;</span>, <span class="hljs-string">&#x27;replicate&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>高斯滤波器(BUPT_lowpass_1)：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">filtered_image</span> = <span class="hljs-title">BUPT_lowpass_1</span><span class="hljs-params">(image, sigma)</span></span><br>        kernel_size = <span class="hljs-number">2</span> * <span class="hljs-built_in">ceil</span>(<span class="hljs-number">3</span> * sigma) + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">% 创建一个高斯核</span><br>        gaussian_kernel = fspecial(<span class="hljs-string">&#x27;gaussian&#x27;</span>, kernel_size, sigma);<br>        <span class="hljs-comment">% 对噪声图像进行高斯滤波</span><br>        filtered_image = imfilter(image, gaussian_kernel,  <span class="hljs-string">&#x27;conv&#x27;</span>,<span class="hljs-string">&#x27;same&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab">img = imread(<span class="hljs-string">&#x27;input.pgm&#x27;</span>);<br><span class="hljs-comment">% 定义不同方差值</span><br>sigmas = [<span class="hljs-number">0.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">% 显示原始图像</span><br><span class="hljs-built_in">figure</span>;<br><br><span class="hljs-comment">% 对不同的方差值进行LoG滤波并显示结果</span><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(sigmas)<br>    <span class="hljs-comment">% 计算LoG结果</span><br>    log_result = LoG(img, sigmas(<span class="hljs-built_in">i</span>));<br>    <br>    <span class="hljs-comment">% 显示LoG结果</span><br>    subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-built_in">i</span>);<br>    imshow(log_result,[]);<br>    title([<span class="hljs-string">&#x27;LoG结果 (标准差=&#x27;</span>, num2str(sigmas(<span class="hljs-built_in">i</span>)), <span class="hljs-string">&#x27;)&#x27;</span>]);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><blockquote><p><code>imshow(log_result, [])</code> 中的 <code>[]</code> 参数是对图像进行缩放和映射的选项。当 <code>[]</code> 参数传递给 <code>imshow</code> 函数时，MATLAB 会自动选择适当的显示范围，使图像的最小值映射到0，最大值映射到255（对于uint8类型的图像）。这意味着函数会根据图像的最小值和最大值自动调整显示的亮度对比度，以使图像更清晰地显示在屏幕上。</p><p>如果不使用 <code>[]</code> 参数，<code>imshow(log_result)</code> 将默认使用图像的原始数据范围进行显示，这可能导致图像在显示时看起来很暗或者很亮。</p></blockquote><figure><img src="/2024/05/11/%E5%9B%BE%E5%83%8F%E4%B8%8E%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF_%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B_Peppers.jpeg" alt="经过边缘检测的Peppers图像"><figcaption aria-hidden="true">经过边缘检测的Peppers图像</figcaption></figure><p>增加高斯滤波器的标准差的一般效果是，随着标准差的增加，高斯滤波器的模糊程度增加，导致图像变得更加模糊。这可能会导致一些细节丢失，但也会减少噪声的影响。</p><p>当LoG滤波器的掩模大小（kernel size）对于所选择的高斯宽度（方差）来说太小时，输出的效果是LoG被截断，即只有部分边缘信息被检测到，而不是完整的边缘。这可能导致图像中的边缘检测不准确，因为边缘的某些部分被忽略了。为避免严重的截断，可以根据高斯的方差定义一个经验性规则来确定LoG掩模的大小。一般而言，LoG掩模的大小应至少为高斯滤波器的三倍，以确保边缘信息完整地包含在内。</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像与视频处理</tag>
      
      <tag>PBM</tag>
      
      <tag>PGM</tag>
      
      <tag>直方图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协作非正交多址接入</title>
    <link href="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/"/>
    <url>/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="一协作非正交多址接入方案">一、协作非正交多址接入方案</h1><h2 id="通过星座重排实现非正交多用户传输">1.通过星座重排实现非正交多用户传输</h2><p>本文提出了一种通过重新排列调制星座的新型非正交多址接入方案。每个用户的调制符号在叠加到不同的资源元素上之前，都要通过一个置换函数进行重映射。多用户系统的互信息被视为为每个用户找到最佳重映射的标准。采用模拟退火算法实现优化。根据误码率的数值结果，所提出的方案明显优于其他方案。</p><h3 id="引言">1.1引言</h3><p>非正交多址接入（NOMA）作为 5G 无线通信的几项关键技术之一，能有效提高频谱利用率和系统容量。近年来，人们提出了多种 NOMA 方案，包括功率域非正交多址接入（power domain non-orthogonal multiple access）、稀疏码多址接入（sparse code multiple access，SCMA）、多用户共享接入（multi-user sharing access，MUSA）、模式划分多址接入（pattern division multiple access，PDMA）等。一般来说，这些非正交多用户接入方案都是通过发送器的符号叠加和接收器的高级多用户检测来实现非正交多用户传输的。</p><blockquote><p>Pattern Division Multiple Access (PDMA) 是一种多址接入技术，旨在提高通信系统中多用户之间的频谱效率。它将时间-频率资源划分成一系列模式，每个模式用于单独的用户或用户组。通过精确的模式分配和调度，PDMA 允许多个用户同时使用同一频谱资源，从而提高了系统的容量和效率。</p></blockquote><p>现有的 NOMA 方案利用某些信号域的特性来区分用户，如发射功率、相位旋转、扩频序列等。目前的研究主要以系统容量或错误概率作为性能分析的标准。</p><p>大多数现有方案都利用了调制符号的振幅或者相位差。在传输过程中，振幅和相位不可避免地会受到信道衰落的影响。因此，尽管这些方案能够实现良好的性能，但它们在很大程度上依赖于信道状态信息（CSI）的正确性。一旦无法保证信道估计的准确性，性能下降就不可避免。因此，本文避免使用振幅和相位作为用户特征，而是提出了用于多用户叠加传输的星座重排（CoRe）。星座重排已在许多通信场景中实现，如中继信道、HARQ 系统等。通过重新排列不同链路调制中的比特-符号映射，可以得到最小欧氏距离更大的联合星座。对于多用户传输系统，我们在将每个用户的调制符号叠加到资源元素上之前，会根据一个置换函数对其进行重新映射。从一个用户的角度来看，联合星座因与资源元素的多重连接而具有更好的距离特性。从系统的角度来看，联合星座充分利用了多维空间，并获得了更多的非重叠点。我们以可实现速率为标准，通过置换函数对系统进行优化。我们采用模拟退火算法，以可接受的复杂度搜索最佳值。数值结果表明，与其他方案相比，我们提出的方案在传输速率和误码率 (BER) 方面都有显著提高。</p><p>本文的其余部分安排如下。第二节介绍了多用户叠加传输的系统模型和因子图表示法。第三节介绍了新提出的多用户传输星座重排方案，并介绍了优化准则和模拟退火算法。第四节提供了数值结果和性能讨论。第五节得出结论。</p><h3 id="多用户叠加传输的上行链路系统模型">1.2 多用户叠加传输的上行链路系统模型</h3><p>在不失一般性的前提下，我们考虑一个多用户叠加传输的上行链路系统，如图 1 所示，K 个用户将其数据映射到 N 个资源元素上。资源要素（RE）可以是时间、频率和/或空间维度的，其中一个 RE 与另一个 RE 正交。系统负载由<span class="math inline">\(\lambda=K/N\)</span>表示。如图 2 所示，叠加可以用因子图来表示。</p><p>我们定义<span class="math inline">\(X=[X_1,X_2,\cdots,X_K]^T\)</span>为 K 维用户符号向量，<span class="math inline">\(R=[R_1,R_2,\cdots,R_N]^T\)</span>为 N 维叠加信号向量。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309103321318.png" alt="图1：多用户叠加传输的上行链路系统模型"><figcaption aria-hidden="true">图1：多用户叠加传输的上行链路系统模型</figcaption></figure><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309103405901.png" alt="图2：多用户叠加传输因子图"><figcaption aria-hidden="true">图2：多用户叠加传输因子图</figcaption></figure><p>因子图的边连接可用叠加矩阵 H 来描述。矩阵 H 的大小为 N × K，元素为二进制。第 (n; k) 个元素用<span class="math inline">\(h_{nk}\)</span>表示。如果第 k 个用户的数据通过第 n 个资源元素传输，则<span class="math inline">\(h_{nk}=1\)</span>；否则，<span class="math inline">\(h_{nk}=0\)</span>。一个 RE 上的信号叠加是来自不同 UE 的调制符号的相加。那么我们有： <span class="math display">\[R=HX=\begin{bmatrix}\sum_{k=1}^Kh_{1k}X_k  \\ \sum_{k=1}^Kh_{2k}X_k  \\ \vdots \\\sum_{k=1}^Kh_{Nk}X_k    \end{bmatrix}\qquad (1)\]</span> 接收机接收到的信号为： <span class="math display">\[Y=R+Z\qquad (2)\]</span> 其中，<span class="math inline">\(Y=[Y_1,Y_2,\cdots,Y_N]^T\)</span>是 N 维接收信号向量，<span class="math inline">\(Z=[Z_1,Z_2,\cdots,Z_N]^T\)</span>表示 N 维噪声向量。</p><h3 id="星座重排的拟议方案">1.3 星座重排的拟议方案</h3><h4 id="拟议计划说明">1.3.1 拟议计划说明</h4><p>本文提出了多用户叠加传输的星座重排方法，如图3所示。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309105403057.png" alt="表I：4-PAM的π_nk(·)示例"><figcaption aria-hidden="true">表I：4-PAM的π_nk(·)示例</figcaption></figure><p>我们将用户传输的符号重新映射到每条边上，然后再叠加到 RE 上。第 k 个用户设备和第 n 个资源元素之间的重映射函数用<span class="math inline">\(\pi_{nk}(·)\)</span>表示。它是M进制调制符号的排列，显然重映射符号的数量仍然是 M。表Ⅰ显示了 4-PAM 的<span class="math inline">\(\pi_{nk}(·)\)</span>示例，其中 d 为归一化常数。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309110021598.png" alt="图3：重新排列星座的因子图"><figcaption aria-hidden="true">图3：重新排列星座的因子图</figcaption></figure><p>图4展示了使用星座重排的优势。我们以第二个用户的 4-PAM 调制符号<span class="math inline">\(X_2\)</span>及其相连的RE（即<span class="math inline">\(R_1\)</span>和<span class="math inline">\(R_N\)</span>）为例，假设比特到符号的映射为格雷映射。如图4(b)所示，第二条边上的符号被重新映射，导致联合星座的布局发生变化。与图4(a)相比，星座的最小欧氏距离变大，因为重新映射使二维星座平面得到充分利用。</p><p>对于给定的叠加矩阵 H，系统相应的 N × K CoRe矩阵可表示为： <span class="math display">\[G = \begin{bmatrix}h_{11}\pi_{11}(·) &amp; h_{12}\pi_{12}(·) &amp; \cdots &amp;h_{1K}\pi_{1K}(·) \\ h_{21}\pi_{21}(·) &amp; h_{22}\pi_{22}(·) &amp; \cdots &amp; h_{2K}\pi_{2K}(·) \\ \vdots &amp; \vdots &amp;\ddots &amp; \vdots\\h_{N1}\pi_{N1}(·) &amp; h_{N2}\pi_{N2}(·) &amp; \cdots &amp; h_{NK}\pi_{NK}(·)  \end{bmatrix}\qquad (3)\]</span> 回顾公式(1)，带有 CoRe 的 RE 上的叠加信号 R 可重写为： <span class="math display">\[R=\begin{bmatrix}\sum_{k=1}^Kh_{1k}\pi_{1k}(X_k)  \\ \sum_{k=1}^Kh_{2k}\pi_{2k}(X_k)  \\ \vdots \\\sum_{k=1}^Kh_{Nk}\pi_{Nk}(X_k)  \end{bmatrix}\qquad (4)\]</span> <img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240309112121965.png" alt="图4：不同重新映射下X2的联合星座"></p><p>举一个例子，<span class="math inline">\(K=3\)</span>，<span class="math inline">\(N=2\)</span>，并且 <span class="math display">\[H= \begin{bmatrix}1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1 \end{bmatrix}\qquad (5)\]</span> 则接收机接收到的信号为： <span class="math display">\[\begin{cases}Y_1=\pi_{11}(X_1)+\pi_{12}(X_2)+\pi_{13}(X_3)+Z_1\\Y_2=\pi_{21}(X_1)+\pi_{23}(X_3)+Z_2\\\end{cases}\qquad (6)\]</span> 在这个例子中，我们通过图5中的星座重排来展示其优势。我们假设所有用户的传输符号都是 BPSK 调制的。根据<span class="math inline">\(\pi^1(-1)=1\)</span>，<span class="math inline">\(\pi^1(1)=-1\)</span>对<span class="math inline">\(X_3\)</span>和<span class="math inline">\(R_1\)</span>之间边缘上的调制符号进行重新映射，联合星座的布局就会发生变化，如图5(b)所示。与图5(a)相比，星座的最小欧氏距离变大。更重要的是，图5(a)中重叠的星座点被分开了。图5(b)中区分的星座点数量达到了8个，这使得多用户系统的最大传输速率为1比特/用户。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240310012622259.png" alt="图5：不同重映射下K=3,N=2的联合星座"><figcaption aria-hidden="true">图5：不同重映射下K=3,N=2的联合星座</figcaption></figure><h4 id="使用-core-的可实现速率">1.3.2 使用 CoRe 的可实现速率</h4><p>可实现速率是多用户系统的一个重要性能指标，它由传输符号与接收信号之间的互信息来衡量。在 CoRe 设计中，通过选择适当的置换函数来最大化可实现率，从而实现系统优化。因此，在给定 H 的基础上，目标是寻找一个能使系统互信息最大化的 G，即 <span class="math display">\[G^*=arg\ max(I(X;Y))\qquad (7)\]</span></p><blockquote><p>数学在argmax g(t)中，表达的是定义域的一个子集，该子集中任一元素都可使函数g(t)取最大值。</p></blockquote><p>互信息的计算公式为： <span class="math display">\[I(X;Y)=h(Y)-h(Y|X)\qquad (8)\]</span> 假设每个用户的调制字母表都是有限的，并且服从均匀分布，则 h(Y) 的值为： <span class="math display">\[h(Y)=-\int p(y)\log_2(p(y))dy~\\=-\int\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}p(y|x)\log_2(\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{\hat x}p(y|\hat x))dy~\\=\log_2(\displaystyle\prod_{k=1}^KN_k)-\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}\int p(y|x)\log_2(\displaystyle\sum_{\hat x}p(y|\hat x))dy\qquad (9)\]</span> 其中，<span class="math inline">\(N_k\)</span>是第 k 个用户调制星座的基数。条件熵 h(Y|X) 可以表示为： <span class="math display">\[h(Y|X)=-\frac{1}{\prod_{k=1}^{K}N_k}\displaystyle\sum_{x}\int p(y|x)\log_2(p(y|x))dy\qquad (10)\]</span></p><blockquote><p><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/70.png" alt="条件熵的公式" style="zoom: 67%;"></p></blockquote><p>假设所有信道上的噪声都是高斯噪声，即<span class="math inline">\(Z_n\sim N(0,\sigma^2)\)</span>，我们有： <span class="math display">\[p(y|x)=\displaystyle\prod_{n=1}^N\frac{1}{\sqrt{2\pi\sigma^2}}exp(-\frac{(Y_n-R_n)^2}{2\sigma^2})\qquad (11)\]</span> 不难发现，多维星座中点的布局和出现概率决定了 p(y|x)。也就是说，可实现速率的优化就是找到最佳星座R。</p><h4 id="利用模拟退火算法进行优化">1.3.3 利用模拟退火算法进行优化</h4><p>我们假设每个用户使用 M 阶调制，系统需要重新映射 L 个边，即矩阵 G 中非零元素的个数。由于<span class="math inline">\(\pi_{nk}(X_k)\)</span>是用户调制字母表的排列组合，因此将有<span class="math inline">\((M!)^L\)</span>种可能的解决方案。显然，用穷举搜索来找到最优解是不可能的。因此，利用模拟退火算法寻求最优G。模拟退火算法在解空间中进行随机搜索。如果新的解决方案更好，它就接受新方案；反之，它以一定概率接受新方案，而这种概率会随着温度的下降而降低。虽然它不能确保获得的解决方案是全局最优的，但它有机会通过设置几个不同的初始化来接近全局最优解决方案。</p><h3 id="数值结果及讨论">1.4 数值结果及讨论</h3><p>在本节中，我们将提供可实现速率和误码率方面的数值结果。我们首先展示了 CoRe 对星座布局和互信息的影响。然后介绍误码率性能，以验证互信息的比较。</p><h4 id="联合星座和互信息">1.4.1 联合星座和互信息</h4><p>为了更好地说明星座重排带来的改进，我们首先研究 K = 3 和 N = 2 的小型结构。可能的边缘连接分别描述为<span class="math inline">\(H_1\)</span>、<span class="math inline">\(H_2\)</span>和<span class="math inline">\(H_3\)</span>，它们分别为： <span class="math display">\[H_1= \begin{bmatrix}1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1 \end{bmatrix}\qquad (12)\]</span></p><p><span class="math display">\[H_2= \begin{bmatrix}1 &amp; 1 &amp; 1 \\ 1 &amp; 0 &amp; 1  \end{bmatrix}\qquad (13)\]</span></p><p><span class="math display">\[H_3= \begin{bmatrix}1 &amp; 1 &amp; 1 \\ 1 &amp; 1 &amp; 1 \end{bmatrix}\qquad (14)\]</span></p><p>相应的因子图如图6所示。由于我们在图5中已经表明，对于<span class="math inline">\(H_2\)</span>，使用BPSK调制可以实现1比特/用户的最大传输速率，因此现在我们将其扩展到 4-PAM 调制的情况。</p><p>发射功率 p 被限制为1，即<span class="math inline">\(E(|X_k|^2)=1\)</span>，<span class="math inline">\(X_k\in [-3d,-d,d,3d]\)</span>，并且<span class="math inline">\(Z_n\sim N(0,\sigma^2)\)</span>。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311100527324.png" alt="图6：K = 3,N = 2的三个因子图"><figcaption aria-hidden="true">图6：K = 3,N = 2的三个因子图</figcaption></figure><p>图7显示了结构<span class="math inline">\(H_1\)</span>、<span class="math inline">\(H_2\)</span>和<span class="math inline">\(H_3\)</span>在最佳映射情况下每个用户的可实现速率。</p><p>我们可以看到，所有这些结构都明显得益于重映射。特别是结构<span class="math inline">\(H_3\)</span>，在没有重映射的情况下表现最差，但在进行了最佳重映射后表现最好。</p><p>现在我们研究结构<span class="math inline">\(H_3\)</span>，它是在不进行星座重排的情况下最差的结构。图8是通过模拟退火对 G 进行优化后得出的各用户平均互信息。我们可以发现，在不同的信噪比区域，最佳的 G 矩阵是不同的。也就是说，<span class="math inline">\(G_1\)</span>是低信噪比区域的最佳选择，<span class="math inline">\(G_2\)</span> 是中等信噪比区域的最佳选择，而<span class="math inline">\(G_3\)</span>则是高信噪比区域的最佳选择。当信道条件较好时，结构<span class="math inline">\(G_3\)</span>的性能明显优于其他结构；而当信道条件较差时，结构<span class="math inline">\(G_3\)</span>的性能与其他结构相当。也就是说，<span class="math inline">\(G_3\)</span>结构适用于所有信噪比区域。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311101804437.png" alt="图7：不同映射下 H1、H2 和 H3 的可实现速率"><figcaption aria-hidden="true">图7：不同映射下 H1、H2 和 H3 的可实现速率</figcaption></figure><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311101911374.png" alt="图8：采用不同重置方式 G1、G2 和 G3 时 H3的可实现速率"><figcaption aria-hidden="true">图8：采用不同重置方式 G1、G2 和 G3 时 H3的可实现速率</figcaption></figure><p>根据图8中的观察结果，我们可以对重置后的星座布局进行研究。图9使用二维平面来表示与符号向量 X 相关的所有可能的星座点。需要注意的是，用户符号叠加到 RE 上后可能存在重叠的星座点，这些重叠点可以借助信道编码加以区分。图9(a)显示了两个 RE 在没有重映射的情况下的联合星座图，而图9(b,c,d)则显示了在不同信噪比下的联合星座图和相应的最佳重映射。与图9(c,d)相比，图9(b)中的星座点较少。这是因为在低信噪比情况下，为了对抗噪声，相邻星座点之间的欧氏距离应尽可能大。随着信噪比的增加，非重叠星座点的数量增加。根据熵最大化定理，当星座点具有均匀概率分布时，熵达到最大值<span class="math inline">\(K\log_2M\)</span>。由于在这种情况下噪声可以忽略不计，因此点数越多的星座可实现的速率越高。</p><p>下面，我们将参数增加到 K = 6 和 N = 4。负载系数 λ 仍为 150%。我们将矩阵<span class="math inline">\(H_4\)</span>中的所有元素都设为 1，即所有用户和 RE 都完全连接。矩阵<span class="math inline">\(H_5\)</span>为 PDMA 系统优化的矩阵，矩阵<span class="math inline">\(H_6\)</span>取自其他方案。它们分别为： <span class="math display">\[H_5= \begin{bmatrix}1 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix}\qquad (15)\]</span></p><p><span class="math display">\[H_6= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\qquad (15)\]</span></p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311111948260.png" alt="图10：采用不同映射的 H5 和 H6 的实现速率，BPSK"><figcaption aria-hidden="true">图10：采用不同映射的 H5 和 H6 的实现速率，BPSK</figcaption></figure><p>首先，我们研究了文献中提出的 H5 和 H6 的可实现速率。采用 BPSK 调制。从图10中可以看出，通过星座重排，互信息明显增加。如图所示，这两种结构都能达到 BPSK 的最大传输速率。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311112631998.png" alt="图11：不同映射下 H4、H5 和 H6 的可实现速率，4PAM"><figcaption aria-hidden="true">图11：不同映射下 H4、H5 和 H6 的可实现速率，4PAM</figcaption></figure><p>图 11 显示了采用 4PAM 调制和最佳映射的<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的可实现速率。从图11中可以看出，采用<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的系统在应用最佳重映射后都获得了显著提高。采用<span class="math inline">\(H_4\)</span>的结构改进最大，在其他结构中表现最好。同时，根据图 7 和图 11 的观察结果，可实现速率从 K = 3 和 N = 2 时的 1.875 比特/用户提高到 K = 6 和 N = 4 时的 1.966 比特/用户。通过增加参数 K 和 N，同时保持 λ 不变，每个用户的可实现速率接近最大<span class="math inline">\(\log_2M\)</span>。</p><h4 id="误码率性能">1.4.2 误码率性能</h4><p>为了评估误码率性能，我们模拟了图 1 中的结构。信道编码是速率为1/2的Turbo 码，调制为 4-PAM。比特到符号的映射在调制中自然标出。经过星座重排后，符号在 AWGN 信道中传输。接收机采用联合最大似然检测。由于信道编码有助于区分重叠的星座点，因此要进行迭代检测和解码。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311114246988.png" alt="图12：H4、H5 和 H6 在 AWGN 信道中不同映射的误码率性能"><figcaption aria-hidden="true">图12：H4、H5 和 H6 在 AWGN 信道中不同映射的误码率性能</figcaption></figure><p>图 12 显示了 AWGN 信道中不同映射结构<span class="math inline">\(H_4\)</span>、<span class="math inline">\(H_5\)</span>和<span class="math inline">\(H_6\)</span>的平均误码率。在不进行星座重排的情况下，<span class="math inline">\(H_4\)</span>和<span class="math inline">\(H_5\)</span>结构不起作用，只有<span class="math inline">\(H_6\)</span>有机会恢复用户信息。在应用星座重排时，所有结构都通过使用最优重映射获得了显著改善。采用最佳映射的结构<span class="math inline">\(H_4\)</span>在误码率方面表现最佳，明显优于文献中优化的结构。图 12 中的误码率性能比较与图 11 中的互信息比较一致。</p><h3 id="结论">1.5 结论</h3><p>本文提出通过星座重排实现多用户叠加传输系统。我们基于互信息对多用户系统进行了优化，并使用模拟退火算法为每个用户找到了最佳重映射。数值结果表明，与文献中的方案相比，我们提出的方案在传输速率和误码率方面都有显著提高。</p><h2 id="通过双层因子图实现协同-noma">2.通过双层因子图实现协同 NOMA</h2><p>本文通过构建双层因子图提出了协作非正交多址接入。源端用户通过叠加一些资源元素来传输他们的符号。如果目的地的非正交多址传输不成功，中继器将协助解码和转发。两条链路上的叠加结构构建了一个双层因子图。来自中继站的信息有助于区分星座重叠并改善距离特性。利用遗传算法进行优化，以最大限度地提高传输总和速率。提供了传输速率和符号错误率方面的数值结果，说明了双层因子图在合作 NOMA 系统中的优越性。</p><h3 id="引言-1">2.1引言</h3><p>非正交多址接入（NOMA）被认为是一种有望提高 5G 无线通信频谱效率的技术。非正交多址方案的关键概念是将不同用户的符号叠加到同一资源要素（RE）上，RE 可以是时隙、频率信道、扩频码等。利用 NOMA 的协同传输，即使每个节点只配备一个天线，也能获得空间自由度。</p><p>用于 5G 无线通信的合作 NOMA 近来备受关注。在协作 NOMA 中，全双工和半双工模式都考虑了译码-前向（DF）中继和放大-前向（AF）中继。</p><p>关于协作 NOMA 的现有研究大多基于高斯源假设，并在功率域中实现。对于离散调制的情况，相关文献十分有限。同时，中继信道的拓扑结构与因子图自然相连。然而，基于因子图扩展的协作 NOMA 研究仍是空白。因此，本文提出了基于双层因子图的合作 NOMA 方案。从信源到目的地的 NOMA 传输被视为因子图的第一层。从中继站到目的地的传输构建了第二层，有助于区分星座重叠并改善距离特性。</p><p>有双层因子图在中继信道分布式信道编码中的应用，他采用了扩展和加长的因子图来实现编码合作。本文将双层因子图引入协作 NOMA 系统。源节点的用户在多个资源元素上进行非正交传输。如果目的地的 NOMA 传输不成功，中继器会对信息进行解码和转发，以协助传输。从目的地的角度来看，两条链路上的叠加结构构建了一个双层因子图。来自中继站的信息有助于区分源信息叠加中出现的星座重叠。此外，"-1 "元素也包含在二进制叠加矩阵中。因此，重叠的概率降低了，联合星座的距离特性也得到了改善。为了最大限度地提高传输总和率，我们使用遗传算法进行了优化。提供了总和速率和符号错误率（SER）方面的数值结果，说明了双层因子图在合作 NOMA 系统中的优越性。</p><p>本文的其余部分安排如下。首先，在第二节中使用因子图对一般的三节点中继信道进行建模。第三节提出了合作 NOMA 的双层因子图。第四节介绍了如何优化系统以实现最大传输速率。系统和速率和 SER 性能见第五节。最后，第六部分是本文的结论。</p><h3 id="系统模型">2.2 系统模型</h3><p>本文考虑的是一般的三节点中继信道。与经典的中继模式不同，源节点（S）由多个用户设备（UE）组成。UE 以非正交方式向共同接收器（即目的地 (D)）传输信息。中继节点（R）协助从源节点到目的地的传输。我们假设系统以半双工模式运行：在第一阶段，源端 UE 向中继站和目的地广播；在第二阶段，中继站将源端的信息转发给目的地，而源端保持沉默。源端 UE 发出的信息叠加到多个资源元素（RE）上。同样，中继器将叠加的符号传送到目的地。最后，目的地结合信源和中继的信道观测结果来恢复信息。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311162147994.png" alt="图1. 中继信道"><figcaption aria-hidden="true">图1. 中继信道</figcaption></figure><p>中继信道模型如图 1 所示。在不失一般性的前提下，我们假设有一个中继节点。扩展到多个中继节点的情况也很简单。在解码-转发协议中，中继节点对信息进行解码后再转发。我们假设源端有 K 个 UE，它们彼此独立。K 个 UE 的调制符号向量为<span class="math inline">\(x_S=[x_1,x_2,\cdots,x_K]^T\)</span>。这些符号根据叠加矩阵 <span class="math inline">\(H_S\)</span>映射到传输中的<span class="math inline">\(N_S\)</span>个资源元素上。目的地相应的接收信号矢量为<span class="math inline">\(y_{SD}=[y_1,y_2,\cdots,y_{N_S}]^T\)</span>。在中继节点，解码信息为<span class="math inline">\(x_R=[x_1&#39;,x_2&#39;,\cdots,x_K&#39;]^T\)</span>。中继根据叠加矩阵<span class="math inline">\(H_R\)</span>使用<span class="math inline">\(N_R\)</span>个RE 转发<span class="math inline">\(x_R\)</span>。目的地接收到的相应信号向量为<span class="math inline">\(y_{RD}=[y_{N_S+1},y_{N_S+2},\cdots,y_{N_S+N_R}]^T\)</span>。目的站根据<span class="math inline">\(y=[y_{SD}^T,y_{RD}^T]^T\)</span>进行多用户联合检测，以恢复源符号向量<span class="math inline">\(x_S\)</span>。我们假设所有资源元素的发射功率为 p，所有信道的噪声均为高斯噪声。那么，系统模型可以写成： <span class="math display">\[y_{SD}=H_Sx_S+z_S\qquad\quad~\\y_{RD}=H_Rx_R+z_R\qquad (1)\]</span> 噪声矢量<span class="math inline">\(z_S=[z_1,z_2,\cdots,z_{N_S}]^T\)</span>和<span class="math inline">\(z_R=[z_{N_S+1},z_{N_S+2},\cdots,z_{N_S+N_R}]^T\)</span>，其中<span class="math inline">\(s\in[1,N_S]\)</span>时，<span class="math inline">\(z_s\sim N(0,\sigma_S^2)\)</span>；<span class="math inline">\(r\in[N_S+1,N_S+N_R]\)</span>时，<span class="math inline">\(z_r\sim N(0,\sigma_R^2)\)</span>；我们定义<span class="math inline">\(N=N_S+N_R\)</span></p><p>叠加矩阵<span class="math inline">\(H_S\)</span>和<span class="math inline">\(H_R\)</span>描述了传输符号向量与资源元素之间的联系。矩阵<span class="math inline">\(H_S\)</span>有<span class="math inline">\(N_S\)</span>行和 K 列，矩阵 <span class="math inline">\(H_R\)</span>的大小为<span class="math inline">\(N_R×K\)</span>。以<span class="math inline">\(H_S\)</span>为例，元素<span class="math inline">\(h_{nk}\)</span>代表第 n 行和第 k 列的值。如果来自第 k 个 UE 的符号通过第 n 个 RE 传输，则<span class="math inline">\(h_{nk}≠0\)</span>否则<span class="math inline">\(h_{nk}=0\)</span>。每个叠加矩阵与因子图相关联。例如，图 2 表示有 5 个 UE 和 3 个 RE 的叠加传输。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311172428326.png" alt="图2. 5个 UE 和3个 RE 的叠加传输"><figcaption aria-hidden="true">图2. 5个 UE 和3个 RE 的叠加传输</figcaption></figure><h3 id="拟议计划">2.3 拟议计划</h3><h3 id="动机">2.3.1 动机</h3><p>我们首先来看看第一阶段的传输情况，在这一阶段中，源端 UE 致力于将其信息传送到目的地。假设我们使用的是二进制叠加矩阵，即<span class="math inline">\(h_{nk}\)</span>等于 0 或 1。我们以图 2 中的传输为例，其中： <span class="math display">\[H_S^{(3,5)}= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0  \\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1  \\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0   \end{bmatrix}\qquad (2)\]</span> 遗憾的是，这种叠加矩阵无法区分所有可能的传输符号向量。在 RE 上存在重叠的叠加符号。也就是说，不同的源符号向量可能会产生相同的叠加向量。如果目的地接收到这样的叠加向量，就无法分辨出传输的是哪个源符号向量。图 2 中的重叠叠加向量和相应的源符号向量列于表Ⅰ。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311173034851.png" alt="表Ⅰ.重叠的叠加向量"><figcaption aria-hidden="true">表Ⅰ.重叠的叠加向量</figcaption></figure><p>为了区分重叠的向量，目的地需要中继站提供额外的信息。通过观察表 1，我们可以发现关于<span class="math inline">\(x_4\)</span>或<span class="math inline">\(x_5\)</span>的知识可以简单地消除所有重叠。因此，在第二阶段，中继会向目的地转发一个符号。</p><p>上例说明了协作 NOMA 的动机和设计原理。信源和中继的两个传输阶段为协作 NOMA 构建了一个双层因子图。下面，我们将介绍拟议方案的细节。</p><h4 id="协作式-noma-的双层因子图">2.3.2 协作式 NOMA 的双层因子图</h4><p>考虑到一般系统模型，整个叠加矩阵可写成： <span class="math display">\[H= \begin{bmatrix}H_S  \\ H_R   \end{bmatrix}\qquad (3)\]</span> 信源-目的地链路的因子图与叠加矩阵<span class="math inline">\(H_S\)</span>相关联，中继-目的地链路的因子图与<span class="math inline">\(H_R\)</span>相关联。整个双层因子图对应于 N 行 K 列的矩阵 H。<span class="math inline">\(H_S\)</span>的设计目的是尽可能提高源-目的链路的传输速率，而<span class="math inline">\(H_R\)</span>所描述的传输有助于区分所有源符号向量。</p><p>事实上，并非所有二进制<span class="math inline">\(H_R\)</span>都能区分重叠的叠加向量。下面以 K = 6 和<span class="math inline">\(N_S=3\)</span>为例进行说明。叠加矩阵<span class="math inline">\(H_S\)</span>为： <span class="math display">\[H_S^{(3,6)}= \begin{bmatrix}1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp;0 \\ 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1 &amp;0 \\ 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp;1 \end{bmatrix}\qquad (4)\]</span> 共有 14 个重叠叠加向量。表 II 列出了最高概率—1/16的叠加矢量及其对应的源符号矢量。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311174840989.png" alt="表Ⅱ.重叠的叠加向量"><figcaption aria-hidden="true">表Ⅱ.重叠的叠加向量</figcaption></figure><p>在这个例子中，二进制<span class="math inline">\(H_R\)</span>只能减少重叠的可能性，但不能完全消除所有重叠。关键问题在于，当两个 UE 的符号之和为 "0 "时，不可能对 "+1 "和"-1 "做出判断。这可以通过在两个 UE 的其中一个连接中加入"-1 "来解决。因此，我们将<span class="math inline">\(H_R\)</span>中的值扩展为{-1,0,1}。如果来自第 k 个 UE 的符号通过第 n 个 RE 传输，则<span class="math inline">\(h_{nk}=1\)</span>；如果符号被翻转后再传输，则<span class="math inline">\(h_{nk}=-1\)</span>；否则，<span class="math inline">\(h_{nk}=0\)</span>。K = 6、<span class="math inline">\(N_S=3\)</span>和<span class="math inline">\(N_R=2\)</span>的映射示例由图 3 中的因子图表示。相应的叠加矩阵写为： <span class="math display">\[H_S^{(5,6)}= \begin{bmatrix}1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp;1 \\ 1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp;0 \\ 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp;1 \\ \hline0 &amp; 0 &amp; 1 &amp; 0 &amp; -1 &amp;0 \\0 &amp; 1 &amp; -1 &amp; 0 &amp; 0 &amp;1 \end{bmatrix}\qquad (5)\]</span> 其中，上部与第一层相对应，下部与第二层相关。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240311204849947.png" alt="图3. 双层因子图示例"><figcaption aria-hidden="true">图3. 双层因子图示例</figcaption></figure><h4 id="目的地联合解码">2.3.3 目的地联合解码</h4><p>目的地根据信源和中继的信道观测结果进行联合解码。在双层因子图上实现联合最大似然（ML）解码。解码向量的计算公式为： <span class="math display">\[\hat{x}= arg\ max\thinspace p(y_{SD}y_{RD}|x)\qquad (6)\]</span> 由于信源—中继链路存在噪声，可能会出现<span class="math inline">\(x_S≠x_R\)</span>的情况。第 k 个用户<span class="math inline">\(x_k\)</span>的信息位和它在中继站的估计<span class="math inline">\(x_k&#39;\)</span>的信息位不同的概率为<span class="math inline">\(p(x_k≠x_k&#39;)=\varepsilon_k\)</span>。那么 (6) 可以写成： <span class="math display">\[\hat{x}= arg\ max\thinspace p(y_{SD}|x)p(y_{RD}|x)~\\=arg\ max\thinspace p(y_{SD}|x)\displaystyle\sum_{x&#39;}p(y_{RD}|x&#39;)p(x&#39;|x)\qquad (7)\]</span> 其中<span class="math inline">\(p(x&#39;|x)=\prod_{k=1}^{K}p(x_k&#39;|x_k)\)</span>。</p><blockquote><ul><li>定义：（完备事件组/样本空间的划分）</li></ul><p>设B1，B2，…Bn是一组事件,若</p><ol type="1"><li><span class="math inline">\(\forall i≠j\in\{1,2,\cdots,n\},B_i\cap B_j=\varnothing\)</span></li><li>B1∪B2∪…∪Bn=Ω</li></ol><p>则称B1，B2，…Bn样本空间Ω的一个划分，或称为样本空间Ω 的一个完备事件组。</p><ul><li>定理（全概率公式）：</li></ul><p>设事件组<span class="math inline">\(\{B_i\}\)</span>是样本空间 Ω 的一个划分，且P(Bi)&gt;0(i=1，2，…n)</p><p>则对任一事件A，有：</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/b7e4dcaa31a2dec0a3701849ded5b1be.svg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><ul><li>定理（贝叶斯公式）：</li></ul><p>设B1，B2，…Bn…是一完备事件组，则对任一事件A，P（A）&gt;0，有</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/75e7f28a355ad71a021979ac4e46f161.svg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure></blockquote><p>在联合 ML 检测中，可以通过成对差错概率（PEP）计算出 SER 的上界。假设<span class="math inline">\(x_a,x_b\in\{x\}\)</span>，且第 k 个 UE 中<span class="math inline">\(x_b\)</span>与<span class="math inline">\(x_a\)</span>不同，则第 k 个 UE 的平均 SER 上界为： <span class="math display">\[p_k(e)\le \frac{1}{M^K}\displaystyle\sum_{x_a}(\displaystyle\sum_{x_b,x_b^k≠x_a^k}p\{x_a\to x_b\})\qquad(8)\]</span> 其中<span class="math inline">\(p\{x_a\to x_b\}\)</span>是 K 个 UE 的联合 PEP， <span class="math display">\[p\{x_a\to x_b\}=Q(\sqrt\frac{||Hx_a-Hx_b||^2}{4\sigma^2})\qquad(9)\]</span> 取所有 UE 的平均值即可得到 SER 的上限。</p><h3 id="系统优化">2.4 系统优化</h3><h4 id="和速率">2.4.1 和速率</h4><p>协作多用户传输的和速率被用作优化目标。对于一维调制，我们假设<span class="math inline">\(A_k\)</span>是星座字母表，星座大小为<span class="math inline">\(M_k\)</span>，<span class="math inline">\(k\in[1,K]\)</span>。我们将 J 定义为 K 个 UE 的所有码字数，则<span class="math inline">\(J=\prod_{k=1}^{K}M_k\)</span>。传输符号向量集和为<span class="math inline">\(x_j\)</span>，j = 1, 2,...,J。集合<span class="math inline">\(y=[y_1,y_2,\cdots,y_{N_S+N_R}]^T\)</span>是包含通过 AWGN 信道带有噪声矢量<span class="math inline">\(z=[z_1,z_2,\cdots,z_{N_S+N_R}]^T\)</span>的接收矢量。定义<span class="math inline">\(N=N_S+N_R\)</span>，我们计算和速率 I(X;Y)： <span class="math display">\[I(X;Y)=\displaystyle\sum_{j=1}^Jp(x_j)\int p(y|x_j)\log \frac{p(y|x_j)}{p(y)}dy\qquad(10)\]</span> 由于调制星座的等价性和独立性，我们可以得出： <span class="math display">\[I(X;Y)=\log J-\frac{1}{J}\displaystyle\sum_{j=1}^J\int\displaystyle\prod_{n=1}^Np(y_n|x_j)\log \displaystyle\sum_{i=1}^J\frac{\displaystyle\prod_{n=1}^Np(y_n|x_i)}{\displaystyle\prod_{n=1}^Np(y_n|x_j)}dy\qquad(11)\]</span> 考虑噪声源中继链路，对于<span class="math inline">\(n\in[N_S+1,N_S+N_R]\)</span>，<span class="math inline">\(p(y_n|x_i)=\sum_{x&#39;}p(y_n|x&#39;)p(x&#39;|x_i)\)</span>。<span class="math inline">\(p(x&#39;|x_i)\)</span>的计算已在第三节第三部分中描述，过渡概率为： <span class="math display">\[p(y_n|x&#39;)=\frac{1}{\sqrt{2\pi}\sigma_R}exp[-\frac{(y_n-h_nx&#39;)^2}{2\sigma_R^2}]\qquad (12)\]</span> 其中，<span class="math inline">\(h_n\)</span>是叠加矩阵 H 的第 n 行。</p><h4 id="两步优化">2.4.2 两步优化</h4><p>协作传输分两个阶段进行。相应地，优化也可分两步进行。第一步，优化从信源到目的地的传输，目的是尽可能提高该链路的传输速率。第二步，在第一阶段优化的结构基础上，最大限度地提高整体传输速率。</p><p>从因子图的角度来看，优化的第一步是为 S-D 链路选择最佳<span class="math inline">\(H_S\)</span>。在确定<span class="math inline">\(H_S\)</span>的基础上，第二步优化找出最佳<span class="math inline">\(H_R\)</span>。通过<span class="math inline">\(H_R\)</span>传输可区分重叠的星座并改善距离特性，从而有助于提高传输速率。</p><p>应用遗传算法（GA）可以实现优化。叠加矩阵被视为种群中的个体，相应的互信息就是个体的适应度。矩阵中的元素是基因，基因的排列构成染色体。通过个体选择、基因交叉和基因突变可以获得最优解。</p><p>对于 K = 5、<span class="math inline">\(N_S=3\)</span>和<span class="math inline">\(N_R=1\)</span>的系统，在高信噪比区域，GA 得到的最佳<span class="math inline">\(H_S\)</span>为（2）。如第三节第一部分所述，<span class="math inline">\(H_{R_1}^{(1,5)}=\begin{bmatrix} 0 &amp; 0&amp;0&amp;1&amp;0 \end{bmatrix}\)</span>或<span class="math inline">\(H_{R_1}^{(1,5)}=\begin{bmatrix} 0 &amp; 0&amp;0&amp;0&amp;1 \end{bmatrix}\)</span>能够消除重叠。然而，GA 得出的最佳<span class="math inline">\(H_R\)</span>是<span class="math inline">\(H_{R_2}^{(1,5)}=\begin{bmatrix} 0 &amp; 1&amp;0&amp;1&amp;1 \end{bmatrix}\)</span>，它提供了更好的距离特性。</p><h4 id="联合优化">2.4.3 联合优化</h4><p>上述两步优化涉及 S-D 链路和整个系统。第一阶段优化的目标是提高仅使用直接链路成功传输的概率。然而，由于第一次优化后结构已固定，第二次优化的搜索自由度受到限制。</p><p>在下面的联合优化中，我们直接优化双层叠加矩阵 H。矩阵<span class="math inline">\(H_S\)</span>取 H 的上<span class="math inline">\(N_S\)</span>行，<span class="math inline">\(H_R\)</span>等于 H 的下<span class="math inline">\(N_R\)</span>行。</p><p>下面以 K = 6 和 N = 4 为例进行说明。如果元素<span class="math inline">\(h_{nk}\)</span>从<span class="math inline">\(\{-1,0,1\}\)</span>中选择，则最优<span class="math inline">\(H^{(4,6)}\)</span>为： <span class="math display">\[H^{(4,6)}= \begin{bmatrix}1 &amp; -1 &amp; 0 &amp; 1 &amp; -1 &amp;1 \\ 1 &amp; 1 &amp; 1 &amp; -1 &amp; 0 &amp;1 \\ 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp;1 \\ \hline0 &amp; -1 &amp; 1 &amp; 1 &amp; 0 &amp;-1  \end{bmatrix}\qquad (13)\]</span> 就整体传输速率而言，由于搜索空间更大，联合优化优于两步优化。但是，如果我们只关注第一阶段，取 H 的上 <span class="math inline">\(N_S\)</span> 行的 S-D 链路传输速率可能会低于优化 <span class="math inline">\(H_S\)</span> 的传输速率。</p><h3 id="数值结果与讨论">2.5 数值结果与讨论</h3><h4 id="和速率-1">2.5.1 和速率</h4><p>在本节中，我们假定每个 UE 的信息都是 BPSK 调制的，S-D 和 R-D 链路的噪声都服从<span class="math inline">\(z \sim N(0,\sigma^2)\)</span>。对于两步优化，当中继节点的<span class="math inline">\(\varepsilon\)</span>不同时，我们比较了其传输速率。在所有用户的错误概率<span class="math inline">\(\varepsilon\)</span>相同的情况下，K = 6、 <span class="math inline">\(N_S\)</span> = 3 和 <span class="math inline">\(N_R\)</span> = 1 的传输速率如图 4 所示。最佳<span class="math inline">\(H_s^{(3,6)}\)</span>在第一步中获得，第三节第2部分对此进行了描述。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312162445084.png" alt="图4. 不同错误概率时的传输速率比较"><figcaption aria-hidden="true">图4. 不同错误概率时的传输速率比较</figcaption></figure><p>可以看出，在<span class="math inline">\(\varepsilon\)</span> = 0 时，使用 GA 搜索到的最优<span class="math inline">\(H_R^{(1,6)}=\begin{bmatrix} -1 &amp; 0&amp;1&amp;0&amp;0&amp;-1 \end{bmatrix}\)</span>可以使系统达到最大传输速率。即使<span class="math inline">\(\varepsilon\)</span>相对较大，传输速率仍比无中继时高得多。</p><p>下面我们将比较两种优化机制的传输速率。假设中继是无噪声的，K = 5、<span class="math inline">\(N_S\)</span> = 3 和 <span class="math inline">\(N_R\)</span> = 1 时的传输速率如图 5 所示。叠加矩阵 H 中的元素从<span class="math inline">\(\{-1,0,1\}\)</span>中选择。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312162940007.png" alt="图5. 不同优化机制的传输速率比较"><figcaption aria-hidden="true">图5. 不同优化机制的传输速率比较</figcaption></figure><p>我们可以看到，由于使用了中继，系统的可实现传输速率得到了显著提高。比较两条实心曲线，我们可以看到联合优化比两步优化实现了更高的整体传输速率。在高信噪比区域，合作 NOMA 在两种优化机制下都实现了系统的最大传输速率。另一方面，如果比较两条虚线，两步优化可确保 S-D 链路获得更好的性能。正如第四节所述，两步优化的目标是第一阶段尽可能高的速率，而联合优化的目标是整体传输。</p><h4 id="错误性能">2.5.2 错误性能</h4><p>在本节中，我们将评估协作式 NOMA 系统的误码性能。BPSK 调制符号从信源和中继站发射。在目的地，采用联合 ML 检测，并对 SER 进行数值模拟。</p><p>当中继无噪声时，图 6 显示了 (2) 中<span class="math inline">\(H_S^{(3,5)}\)</span>的系统平均 SER，但<span class="math inline">\(H_R^{(1,5)}\)</span>的实现方式不同。很明显，来自中继的传输一般有助于区分重叠并改善 SER 性能。<span class="math inline">\(H_R\)</span>的设计对 SER 性能有重要影响。如四节第二部分所述，由于<span class="math inline">\(H_{R_2}^{(1,5)}\)</span>具有更好的距离特性，因此其性能优于<span class="math inline">\(H_{R_1}^{(1,5)}\)</span>。矩阵<span class="math inline">\(H_{R_3}^{(1,5)}=\begin{bmatrix} 0 &amp; 1&amp;-1&amp;1&amp;1 \end{bmatrix}\)</span>的性能最好，因为它为优化提供了更大的自由度。为了验证模拟结果，我们还加入了 PEP 的上限。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312171713248.png" alt="图6. 针对 (2) 不同 HR 下的 HS 的 SER 比较"><figcaption aria-hidden="true">图6. 针对 (2) 不同 HR 下的 HS 的 SER 比较</figcaption></figure><p>将"-1 "引入叠加矩阵 H 的影响如图 7 所示。在 N 和 K 的每种设置下，与矩阵中没有"-1 "元素的系统相比，矩阵元素为<span class="math inline">\(\{-1,0,1\}\)</span>的系统获得了显著的增益。因子图的尺寸越大，增益就越高。这是因为因子图越大，可以探索的自由度就越高。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312172224867.png" alt="图7. 叠加矩阵中有&quot;-1 &quot;和没有&quot;-1 &quot;的 SER 比较"><figcaption aria-hidden="true">图7. 叠加矩阵中有"-1 "和没有"-1 "的 SER 比较</figcaption></figure><p>图 8 显示了<span class="math inline">\(H^{(4,6)}\)</span>不同<span class="math inline">\(\varepsilon\)</span>的 SER 比较，其和速率性能如图 4 所示。<span class="math inline">\(H^{(4,6)}_R\)</span>中的元素从<span class="math inline">\(\{-1,0,1\}\)</span>中选择，可以有效区分重叠，提高 SER 性能。中继站的误差在一定程度上是可以容忍的，但当<span class="math inline">\(\varepsilon\)</span>较大时，误差下限是不可避免的。</p><figure><img src="/2024/03/09/%E5%8D%8F%E4%BD%9C%E9%9D%9E%E6%AD%A3%E4%BA%A4%E5%A4%9A%E5%9D%80%E6%8E%A5%E5%85%A5/image-20240312172636255.png" alt="图 8. 不同错误率时的 SER 比较"><figcaption aria-hidden="true">图 8. 不同错误率时的 SER 比较</figcaption></figure><h3 id="结论-1">2.6 结论</h3><p>本文通过构建双层因子图，提出了合作式非正交多址接入。如果非正交多址传输在第一阶段没有成功，中继器会在第二阶段解码并转发信息。来自中继的信息有助于更好地区分叠加星座，并相应地提高整体传输速率。应用遗传算法进行了两种优化。提供了传输率和符号错误率方面的数值结果，验证了使用双层因子图的优势。</p><h1 id="二毕设协作非正交多址接入的研究与实现">二、毕设—协作非正交多址接入的研究与实现</h1><h2 id="对和速率的理论曲线进行仿真">1.对和速率的理论曲线进行仿真</h2><p>对和速率进行理论曲线的仿真，即用代码表示下面这个式子： <span class="math display">\[I(X;Y)=\log J-\frac{1}{J}\displaystyle\sum_{j=1}^J\int\displaystyle\prod_{n=1}^Np(y_n|x_j)\log \displaystyle\sum_{i=1}^J\frac{\displaystyle\prod_{n=1}^Np(y_n|x_i)}{\displaystyle\prod_{n=1}^Np(y_n|x_j)}dy\]</span> 我们假定每个 UE 的信息都是 BPSK 调制的，S-D 和 R-D 链路的噪声都服从<span class="math inline">\(z \sim N(0,\sigma^2)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协作非正交多址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>复试常见题汇总</title>
    <link href="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<p>2024/3/30 11:18 今天上午面试终于结束了，我感觉说的过去，不知道最后结果咋样。</p><h1 id="一通信原理">一、通信原理</h1><h2 id="高斯白噪声">1.高斯白噪声</h2><ul><li><u><strong>什么是白噪声，为什么叫白噪声？</strong></u></li></ul><p>噪声是一个随机过程，而随机过程有其功率谱密度函数，功率谱密度函数的形状则决定了噪声的“颜色”。</p><p>颜色为“白色”的噪声，即“白噪声”，其功率谱密度函数在整个实数范围内为常数。</p><p>有色噪声的功率谱密度函数则不为常数。</p><ul><li><strong><u>什么是白噪声，其功率谱和自相关函数有哪些特点？</u></strong></li></ul><p>白噪声是功率谱密度在整个频域范围为常数的噪声，其功率谱密度呈均匀分布，自相关函数是关于时间间隔<span class="math inline">\(\tau\)</span>的冲激函数。</p><ul><li><strong><u>高斯白噪声是什么，是功率信号还是能量信号？</u></strong></li></ul><p>白噪声是一种具有无限带宽的随机理想信号，功率谱为常数，功率分布与白光相似。高斯白噪声就是服从高斯分布的白噪声。</p><p>是功率信号。</p><h2 id="通信系统指标有效性可靠性">2.通信系统指标：有效性&amp;可靠性</h2><ul><li><u><strong>通信系统的指标是什么？</strong></u></li></ul><p>通信系统的主要性能指标是传输信息的有效性和可靠性。有效性是指在传输一定的信息量所消耗的信道资源的多少，信道资源包括信道的带宽和时间；而可靠性是指传输信息的准确程度。有效性和可靠性始终是相互矛盾的。在一定可靠性指标下，尽量提高信息的传输速率；或在一定有效性条件下，是消息的传输质量尽可能提高。根据香农公式，在信道容量一定时，可靠性和有效性之间可以彼此互换。</p><ul><li><u><strong>通信系统的指标是什么，怎么<mark>评价</mark>通信系统？</strong></u></li></ul><ol type="1"><li>有效性：传输频带（模拟通信系统），传输速率（又分波特率，比特率）（数字通信系统）；</li><li>可靠性：信噪比（模拟通信系统），差错概率（又分为误码率、误信率）（数字通信系统）；</li><li>标准性，经济性，可维护性。</li></ol><p>评价一个通信系统要从系统性能的可靠性和有效性同时考虑。可靠性的衡量指标包括误码率和各种增益等，有效性的衡量指标包括吞吐量，容量，传输速率，传输带宽等等。</p><ul><li><u><strong>模拟系统和数字系统的有效性和可靠性的衡量指标是什么？</strong></u></li></ul><p>模拟系统的有效性是通过有效带宽来衡量的，可靠性是信噪比来衡量的。</p><p>数字系统的有效性是通过频带利用率来衡量的，可靠性是误码率或者误信率。</p><p>其中有效带宽是指能够有效通过该信道信号的最大频带宽度；信噪比是信号功率和噪声功率的比值；频带利用率是单位频带内码元的传输速率；误码率是指码元在传输系统中被传错的概率，即错误码元数目在总传输码元中的比例。</p><p>补充：模拟系统的抗噪声指标为输出信噪比和制度增益。</p><ul><li><strong><u>通信系统两大关键指标及其关系？</u></strong></li></ul><p>有效性：在给定信道内，能传输多少信息。有效性一定要在相同的信道和信道带宽下衡量。</p><p>可靠性：接收信息的准确程度。</p><p><mark>度量</mark>：</p><p>模拟通信系统：</p><p>有效性：有效传输带宽越小，有效性越好。因为带宽资源是有限的。</p><p>可靠性：输出信噪比越大，可靠性越好。</p><p>数字通信系统：</p><p>有效性：频带利用率，即单位带宽所能实现的码速率或信息速率。越大越好。</p><p>可靠性：误码率。</p><p><mark>关系</mark>：</p><ol type="1"><li><p>相互矛盾。</p><p>以差错控制码为例，我们要引入冗余，对传输信息进行约束；通过在接收端检验这些约束，判断甚至更正发生的错误。显然，引入冗余就会减少有效信息的传输速率。</p><p>奈奎斯特第一准则也可以说明。如果码率增加，码元间隔减小，那么频域上的零点带宽就会增加，频带利用率下降。</p></li><li><p>通常可互换。</p><p>以调频通信系统为例，这是实现互换的最简单、最典型的系统。在大信噪比情况下，其信噪比增益与调频指数的三次方成正比。但是，由卡松公式，调频指数越高，其所占频带越宽，因此有效性越差。</p></li></ol><h2 id="数字模拟通信">3.数字/模拟通信</h2><ul><li><strong><u>简述数字通信与模拟通信的优缺点？</u></strong></li></ul><p>模拟通信优点：通过信道的信号频谱比较窄，因此信道的利用率高。</p><p>模拟通信缺点：（1）传输的信号是连续的，混入噪声干扰后不易清除，即抗干扰能力差。（2）不易保密。（3）设备不易大规模集成化。</p><p>数字通信优点：</p><p>（1）抗干扰能力强。</p><p>（2）可靠性高。</p><p>（3）由于数字信号传输采用二进制码，所以可以使用计算机对数字信号进行处理。</p><p>（4）数字通信系统可以传送各种信息，使通信系统灵活、通用，因而可以构成信号处理传送交换的现代数字通信网。</p><p>（5）数字信号易于加密处理，所以数字通信保密性强。</p><p>数字通信缺点：数字通信比模拟通信占用频带更宽。</p><ul><li><strong><u>什么是数字通信？描述数字通信系统的主要优缺点？</u></strong></li></ul><p>数字通信就是用数字信号传输信息的通信系统。数字通信系统的优点有差错可控，抗干扰能力强，易于存储，处理和交换，易于集成和加密，设备便于集成化和微机化，便于构成数字网。缺点是频带利用率不高，系统设备较为复杂。</p><ul><li><strong><u>什么是数字<mark>调制</mark>？它与模拟调制有哪些异同点？</u></strong></li></ul><p>由于数字基带信号的取值是有限的离散状态，数字调制是用载波信号的某些离散状态来表征传送的信息，在接收端对载波信号的离散调制参量估值。数字调制也有三种基本形式—调幅、调频、调相。数字调制的优点有：</p><ol type="1"><li>数字调制可以采用门限值检测；</li><li>数字脉冲在中继器中很容易再生；</li><li>通过压缩技术可以降低数字传输中所需要的带宽；</li><li>数字信号的信号质量通常优于模拟系统。</li></ol><ul><li><strong><u>数字通信的主要特点是什么？</u></strong></li></ul><ol type="1"><li>抗干扰能力强；</li><li>差错可控；</li><li>易于与各种数字终端接口，用现代计算机技术对信号进行处理、加工、变换、存储，从而形成智能网；</li><li>易于集成化，从而使通信设备微型化；</li><li>易于加密处理，且保密程度高。</li></ol><p>缺点：占用频带宽、系统设备复杂对同步要求高。</p><h2 id="调制">4.调制</h2><ul><li><strong><u>调制的目的、作用/意义？</u></strong></li></ul><p>调制的目的：是把要传输的模拟信号或数字信号变换成适合信道传输的信号，这就意味着把基带信号（信源）转变为一个相对基带频率而言频率非常高的带通信号，该信号称为已调信号，而基带信号称为调制信号。调制可以通过使高频载波随信号幅度的变化而改变载波的幅度、相位或者频率来实现。</p><p>调制的作用：</p><ol type="1"><li>调制搬移了基带信号的频谱，使已调波的频谱特性适宜信道的频谱特性。</li><li>调制将低频信号搬移到高频处，将调制信号转换成适合于信道传输的已调信号。</li><li>调制将多路基带信号搬移到不同的载波上，完成信号的频率分配，使多路信号互不干扰地在同一个信道上传输，从而实现频分复用，提高频率资源的利用率。</li><li>调制可以扩展信号带宽，提高系统抗干扰、抗衰路的能力。</li></ol><ul><li><strong><u>为什么要进行调制，即调制的目的和意义是什么？</u></strong></li></ul><ol type="1"><li>把调制信号转换成适合在信道中传输的已调信号；</li><li>实现信道的多路复用，提高信道利用率；</li><li>改善系统抗噪声性能。</li></ol><ul><li><strong><u>什么是线性调制？什么是非线性调制？</u></strong></li></ul><p>线性调制是频谱上的线性搬移。常见的线性调制有调幅，双边带调制，单边带调制和残留边带调制。非线性调制则不再是原调制信号的线性搬移，而是频谱的非线性变换，常见的有调频和调相。</p><p>线性调制是幅度调制，在波形上，幅度已调信号的幅度随基带信号的规律而成正比地变换；在频谱结构上，它的频谱完全是基带信号频谱在频域内的简单搬移，且这种搬移是线性的。但注意，“线性”并不意味着已调信号与调制信号之间符合线性变换关系。事实上，任何调制过程都是一种非线性的变换过程。</p><p>非线性调制是角度调制，已调信号频谱不再是原调制信号频谱的线性搬移，而是频谱的非线性变换，会产生与频谱搬移不同的新的频率成分，与线性调制相比，其优势是具有较高的抗噪声性能，缺点是占用更宽的带宽。</p><h2 id="基带频带传输">5.基带/频带传输</h2><ul><li><strong><u>什么是基带传输？什么是频带传输？</u></strong></li></ul><p>基带传输是按照数字信号以脉冲形式在信道上直接传输。此时的信道要有较宽的通频带。适用于小范围数据传输。</p><p>频带传输是通过对信号进行调制，使其成为具有一定频带的模拟信号。以适应在相应的信道中传输。</p><ul><li><strong><u>解释基带传输<mark>系统</mark>和频带传输系统？</u></strong></li></ul><p>基带传输系统：在某些具有低通特性的有线信道中，特别是在传输距离不太远的情况下，基带信号可以不经过载波调制而直接进行传输，这样的传输系统，成为数字基带传输系统。</p><p>频带传输系统：是用基带数字信号控制高频载波，把基带数字信号变换为频带数字信号的过程称为数字调制，已调信号通过信道传输到接收端，在接收端通过解调器把频带数字信号还原成基带数字信号，这种数字信号的反变换称为数字解调，把包含调制和解调过程的传输系统叫做数字信号的频带传输系统。</p><h2 id="模拟调制">6.模拟调制</h2><ul><li><strong><u>卡松公式是什么，它的意义是什么？</u></strong></li></ul><p>卡松公式指调频信号的带宽等于两倍的最大频偏加上调制信号的频率；说明了调频信号的带宽取决于最大频偏和调制信号的频率。</p><ul><li><strong><u>什么是过调幅失真？过调幅失真对调幅调制有哪些影响？</u></strong></li></ul><p>对于调幅信号<span class="math inline">\(s(t)=[A+m(t)]cosw_ct\)</span>，若<span class="math inline">\(A+m(t)\)</span>不能保证始终为正，则称为过调幅失真。过调幅失真将导致包络检波不能进行正确解调，此时只能使用相干解调的方式进行解调。</p><ul><li><strong><u>简述DSB与FM的优缺点？</u></strong></li></ul><p>DSB：</p><ol type="1"><li>频谱的上下边带含有相同的信息，与SSB相比有效性较差；</li><li><span class="math inline">\(\pm f_c\)</span>处没有载波分量，相干解调时需要提取载波；</li><li>信号带宽为基带带宽的两倍，与FM相比有效性较高；</li><li>FM牺牲了有效性换取了可靠性的提高，因此与FM相比可靠性较低。</li></ol><p>FM：</p><ol type="1"><li>频谱结构发生了很大变化（频率或相位随基带信号变化）；</li><li>属于非线性调制，分析较困难，只能进行近似分析；</li><li>占有较宽的信道带宽（已调信号带宽为调制信号带宽的许多倍）；</li><li>抗噪能力强，可靠性好（以牺牲带宽来换取高的抗噪能力）。</li></ol><h2 id="门限效应">7.门限效应</h2><ul><li><u><strong>什么是门限效应，什么是门限值，为什么相干解调不会出现门限效应，什么是最佳判决门限电平？</strong></u></li></ul><p>门限效应本质上是由包络检波器的非线性引起的，是当有用信号被噪声淹没，输入信噪比减小到一定程度导致输出信噪比急剧恶化的情况。开始出现门限效应的输入信噪比为门限值。使误码率最小的判决电平就是最佳门限电平。</p><p>由于相干解调信号和噪声可以分开解调，解调器的输出总是存在有效信号。</p><ul><li><strong><u>什么是门限效应，如何避免？</u></strong></li></ul><p>门限效应是由包络检波器的非线性解调导致的。相干解调中不存在门限效应，因为信号和噪声会分别进行解调。而非线性解调时，在小信噪比条件下，调制信号和噪声无法分开；并且随着输入信噪比的下降，包络检波器的输出信噪比会逐渐下降；在小于特定值（门限值）后，输出信噪比呈断崖式下降。</p><p>由于窄带调频信号可以使用相干解调，因此在功率较小的调频信号通信中，常用窄带调频，避免出现门限效应。</p><ul><li><strong><u>什么是门限效应，AM包络检波法为什么会产生门限效应，说明理由？</u></strong></li></ul><p>门限效应：输出信噪比不是按比例随着输入信噪比下降，而是急剧恶化，通常把这种现象称为解调器的门限效应。而开始出现门限效应的输入信噪比称为门限值。在大信噪比情况下，AM信号包络检波器的性能几乎与相干解调法相同。但当输入信噪比低于门限值时，将会出现门限效应，这时解调器的输出信噪比将急剧恶化，系统无法正常工作。</p><ul><li><strong><u>门限效应及其解决方法？</u></strong></li></ul><p>它是由包络检波器的非线性解调作用引起的。表现为当输入信噪比降到一定程度时，系统性能会急剧恶化。</p><p>用PLL（锁相环）进行解调，减小系统的等效带宽，从而降低输入噪声的功率，提高了输入信噪比。</p><h2 id="码间串扰">8.码间串扰</h2><ul><li><strong><u>匹配滤波器是什么，有什么作用？</u></strong></li></ul><p>匹配滤波器的频率响应是输入信号频率响应的共轭。在时域上是输入信号的反转平移。</p><p>匹配滤波器让信号尽可能大的通过，噪声尽可能小的通过，提高输出信噪比。</p><ul><li><u><strong>简述码间串扰和奈奎斯特准则？</strong></u></li></ul><p>码间串扰是前后码元对当前码元的接收产生的影响。</p><p>奈奎斯特准则是无码间串扰传输要满足的条件。</p><ul><li><strong><u>什么是码间串扰，它对通信质量有什么影响？</u></strong></li></ul><p>码间干扰是数字信号接收时，在抽样时刻接收信号中除当前码元以外的其他码元的取样值所产生的干扰。码间干扰是由于传输系统特性不理想而产生的，若系统特性不满足无码间干扰的条件，则会产生码间干扰。码间干扰会影响取样值的概率分布，使得误码率增大。</p><ul><li><u><strong>什么是码间串扰，怎样产生的，对通信质量有什么影响？</strong></u></li></ul><p>码间串扰是由于系统传输总特性不理想，导致前后码元的波形畸变、展宽，并使前面波形出现很长的拖尾，蔓延到当前码元的抽样时刻上，从而对当前码元的判决造成干扰。码间串扰严重时，会造成错误判决。</p><ul><li><u><strong>简述信道均衡？</strong></u></li></ul><p>频域均衡：从校正系统的频率特性出发，使得包括均衡器在内的基带系统的总的频率特性满足奈奎斯特准则。</p><p>时域均衡：利用均衡器产生的时间波形去直接校正发生了畸变的波形，使整个系统的冲激响应满足无码间串扰条件。</p><p>借助横向滤波器实现均衡是可能的，并且只要用无限长的横向滤波器，就能做到消除码间串扰的影响。横向滤波器可以将输入端在抽样时刻上有码间串扰的波形变换成在抽样时刻上没有码间串扰的波形，所以能实现时域均衡。</p><ul><li><strong><u>什么是时域均衡，什么是频域均衡？</u></strong></li></ul><p>时域均衡是利用均衡器产生的时间波形去直接校正已畸变的波形，使得包括均衡器在内的整个系统的冲击响应满足无码间串扰的条件。时域均衡能够根据信道特性的变化进行调整，有效地减少码间串扰。</p><p>频域均衡是指利用可调滤波器的频率特性来补偿基带系统的频率特性，使得包括均衡器在内的基带系统的总特性满足无失真传输的条件。</p><ul><li><u><strong>什么是时域均衡，为什么要时域均衡？</strong></u></li></ul><p>时域均衡是为了消除数据在传输过程中由于符号间干扰产生的影响。</p><p>时域均衡可以根据信道特性的变化进行调整，能够有效的减小码间串扰。</p><p>时域均衡是建立在消除取样点的码间干扰的基础上，并不要求传输波形的所有细节都与奈奎斯特准则所要求的理想波形一样，利用接受波形本身来进行补偿，消除取样点的码间干扰，提高判决的可靠性。</p><h2 id="数字调制">9.数字调制</h2><ul><li><strong><u>什么是多进制数字调制，有哪些优点？</u></strong></li></ul><p>采用多种基带波形的数字调制称为多进制数字调制。与二进制数字调制相比，<strong>多进制数字调制有以下几个特点</strong>：</p><ol type="1"><li>在码元速率（传码率）相同条件下，可以提高信息速率（传信率），使系统频带利用率增大。</li><li>在信息速率相同的条件下，可以降低码元速率，以提高传输的可靠性。</li></ol><blockquote><p>降低码元速率，会增加每个符号或码元的持续时间，从而减少传输过程中的信道噪声对每个符号的影响；可以增加每个符号之间的间隔，使得接收端更容易将信号与噪声分离开来。</p></blockquote><ul><li><strong><u>什么是正交幅度调制QAM？</u></strong></li></ul><p>正交幅度调制（QAM）是一种在两个正交载波上进行幅度调制的调制方式。这两个载波通常是相位差为90度的正弦波，因此被称作正交载波，QAM是一种振幅和相位联合键控，特别适用于频带资源有限的场合，QAM通过载波的某些参数的变化来传输信息，在QAM中，数据信号由相互正交的两个载波的幅度变化表示。</p><ul><li><strong><u>DPSK是如何消除相位模糊的？</u></strong></li></ul><p>DPSK—差分移相键控，用相邻码元的相位差表示基带信号，利用调制信号前后码元之间载波相对相位的变化来传递信息。</p><ul><li><u><strong>什么是GMSK？有什么优缺点？</strong></u></li></ul><p>GMSK的中文是高斯最小频移键控，是基带信号经过高斯低通滤波器的MSK。MSK的相位路径是不同斜率的直线组合成的折线，GMSK在其基础上，通过高斯滤波器使得相位路径变成了更光滑的曲线。优点：相对于MSK，具有更加集中的功率谱密度，对邻道干扰更小。缺点是有码间串扰。</p><ul><li><strong><u>OQPSK是如何减少信号包络起伏的？</u></strong></li></ul><p>OQPSK在QPSK的一个支路中加入一个延迟单元<span class="math inline">\(T_b\)</span>，使两个支路的基带的变换相差一个比特间隔，即每隔一个比特间隔只有一个支路发生相位变化，原来QPSK会出现<span class="math inline">\(\pi\)</span>相突变，OQPSK则为最大<span class="math inline">\(\frac{\pi}{2}\)</span>相突变。</p><ul><li><strong><u>什么是匹配滤波器，匹配滤波器的冲击响应是怎样的？</u></strong></li></ul><p>使滤波器的输出信噪比在某一特定时刻达到最大的滤波器就是匹配滤波器。匹配滤波器的单位冲击响应是输入信号的镜像函数。匹配滤波器的误码率仅和两种码元的波形之差的能量有关，而与波形本身无关。差别越大，误码率越小。</p><ul><li><strong><u>与单极性波相比，AMI码有什么优点？</u></strong></li></ul><ol type="1"><li>在“1”，“0”不等概率情况下，也无直流成分，并且在零附近频率的低频分量小，因此，对具有变压或其它交流耦合的传输信道来说，不受影响。</li><li>若码元极性与发端相反，收端也能正确接收。</li><li>编译码电路简单。</li></ol><ul><li><u><strong>什么是部分响应波形？什么是部分响应系统？</strong></u></li></ul><p>部分响应波形是指人为的有规律的在抽样时刻引入码间串扰，并在接收判决前再以约定的方式加以消除码间干扰，从而可以达到改善频谱的特性，压缩传输频带，还可以加速传输波形尾巴的衰落，使频带利用率提高到理论上的最大值。利用部分响应波形传输的基带系统就叫部分响应系统。由于升余弦滚降系统虽然有拖尾衰减快的优点，但是频带利用率不高，所以来设计一种部分响应系统同时满足两个优点。由于要恢复的信息码元只是接受信号中的一部分，所以叫做部分响应系统。部分响应系统是既能使频带利用率达到理论上的最大值又具有拖尾收敛快的优点的系统。</p><ul><li><strong><u>在基带传输部分响应系统中，采用预编码的意义何在？</u></strong></li></ul><p>部分响应系统的预编码是为了解决相关编码所引起的误码扩散的问题，经过预编码后，每一个输出值只跟当前输入值有关，不会出现误码扩散的现象。</p><ul><li><u><strong>数字基带传输系统的基本结构和各部分功能？</strong></u></li></ul><p>数字基带传输系统是由发送滤波器，信道，接收滤波器，抽样判决器及定时和同步系统构成。</p><p>信道信号发生器，用于把原始的基带信号转换成适合基带传输的信号；信道的作用是传输基带信号；接收滤波器的作用是接收信号并尽可能地滤除带外噪声和干扰，对信道均衡，形成有利于抽样判决的信号；抽样判决器是对接收滤波器的输出波形进行判决，恢复出基带信号；定时和同步系统的作用是为抽样判决器提供准确的抽样时钟。</p><ul><li><strong><u>数字通信系统的一般模型，并简述各个方框的功能？</u></strong></li></ul><p>信源——信源编码——加密——信道编码——调制——信道——解调——信道译码——解密——信源译码——信宿</p><p>信道编码和译码是为了压缩数据，减少冗余，提高传输的有效性。同时完成模数变换。</p><p>信道编码和译码是增加冗余，提高传输的可靠性，信道解码可以发现传输中的错误。</p><p>加密是为了保证信息的安全，人为地将传输的数字序列扰乱，只有能够对数据正确解密的人才能获取信息。</p><p>调制的目的是形成适合在信道上传输的信号，提高抗干扰能力，还可以用于实现多路复用，实现带宽和信噪比之间的转换。</p><h2 id="香农公式">10.香农公式</h2><ul><li><strong><u>香农公式是什么，怎么理解？</u></strong></li></ul><p>香农公式：<span class="math inline">\(C=B\log_2(1+S/N)\)</span>，其中C为信道容量，B为信道带宽。香农公式给出了理想情况下，<strong>理论上通信系统所能达到的极限信息传输速率</strong>。也就是说只要传输速率小于等于信道容量，则总可以找到一种信道编码技术，实现无差错传输信息。</p><p>香农定理的理解：三种增加信道容量的思路：①提高信号发射功率。②减少噪声功率。③增大信道带宽，但是用<strong>信道带宽来增加信道容量不是无限制的增大，因为信道带宽无限大时，噪声功率也无穷大</strong>。可以用带宽换取信噪比，<strong>如果给定信道容量C，则可以增大带宽来降低对信噪比要求；或者可以提高信噪比来换取较窄的频带，节约频谱资源</strong>。</p><ul><li><strong><u>香农公式有何意义？</u></strong></li></ul><p>给出了信息传输速率的上限和信道信噪比及带宽的关系。提高信噪比就能增加信道容量。当噪声功率为0的时候，信道容量无限大。增加带宽，并不能无限增加信道容量，有一个上限。</p><p>香农公式是一个被广泛公认的通信理论的基础和研究依据，也是近代信息论的基础，香农公式表明了系统的通信能力和抗干扰能力与传输信息所用带宽以及信噪比之间的关系。</p><ul><li><u><strong>香农三大定理？</strong></u></li></ul><p>香农第一定理是信源编码定理，通过信源编码，使码字尽量服从等概分布，每个码符号携带的信息量最大，可以使用尽量少的码符号传输信息。</p><p>香农第二定理是信道编码定理，指出了信息传输速率不能超出信道容量，信道容量<span class="math inline">\(C=B\log_2(1+S/N)\)</span>，如果超过信道容量，信息就不能可靠的传输。</p><p>香农第三定理是失真信源编码定理，指出了可以找到一种信源编码，编码后的传输速率略大于率失真函数，同时码字的平均失真度不大于给定的失真度。</p><blockquote><p>信息率失真函数：函数给出在满足一定失真情况下的最小信息传输速率。</p></blockquote><ul><li><strong><u>信道容量概念描述，它与什么有关？</u></strong></li></ul><ol type="1"><li>信道容量：信道中信息能够无差错传输的最大平均信息速率。</li><li>当<span class="math inline">\(S/n_0\)</span>一定时，无限增大带宽B，发现信道的容量并不会增大，此时的信道容量约为1.44<span class="math inline">\(S/n_0\)</span>。当想要以信道容量或接近信道容量的速率传递信息时，会发现为保障无差错传输的最低信噪比<span class="math inline">\(Eb/n_0\)</span>,，约为-1.6dB。</li></ol><ul><li><strong><u>什么是信道容量？</u></strong></li></ul><p>信道容量是信道的一个参数，反映了信道所能传输的最大信息量，其大小与信源无关。对不同的输入概率分布，互信息一定存在最大值。我们将这个最大值定义为信道容量，以不大于这个信道容量的速率进行传输，就能实现可靠传输。</p><h2 id="奈奎斯特采样定理">11.奈奎斯特采样定理</h2><ul><li><strong><u>描述采样定理/奈奎斯特采样定理？</u></strong></li></ul><p>采样定理最早是由奈奎斯特推导出来的，后来被香农明确说明并引用。这个定理表明如果信号的最高频率是<span class="math inline">\(f_m\)</span>，要想无失真地恢复出原信号需要的最低采样频率是2<span class="math inline">\(f_m\)</span>。因为在时域进行采样，等价于在频域进行频谱的周期搬移，搬移的周期只有大于2倍的信号最高频率才能避免频谱混叠，然后再加一个滤波器得到原始信号的频谱，再根据傅里叶变换的唯一性就可以无失真恢复出原信号。与之相关的还有频域采样定理，对序列进行N点DTFT变换，如果满足N≥M，可以无失真的恢复出原序列，如果不满足N≥M，会造成时域混叠现象。</p><blockquote><p>DTFT：离散时间傅里叶变换</p></blockquote><ul><li><u><strong>码间串扰？</strong></u></li></ul><p>由于实际信道都是有带宽的，因此在频域上与带通滤波器相乘，在时域上就是与无穷尽的Sa函数卷积，会导致时域信号无穷宽。因此在每一个码元间隔内，波形都被干扰了。</p><p>解决办法：让串扰只发生在采样点上。</p><p>我们把整个系统看作是LTI的，就得到了对级联信道的要求。这就是奈奎斯特第一准则。</p><ul><li><strong><u>奈奎斯特定律是什么？</u></strong></li></ul><p>奈奎斯特定律是一种信息速率，根据奈奎斯特定律，信道的极限速率（码元速率）等于信道带宽（低通信道）的两倍。</p><ul><li><u><strong>奈奎斯特第一准则？</strong></u></li></ul><p>只有当码速率不大于2倍信道带宽时，才有可能抽样值无失真。</p><ul><li><u><strong>什么是奈奎斯特速率和奈奎斯特<mark>间隔</mark>？</strong></u></li></ul><p>对于无失真恢复低通信号即不发生频谱混叠的所要求的最低采样速率为奈奎斯特速率。与此相对应的最小抽样间隔也即最低抽样速率的倒数为奈奎斯特间隔。</p><ul><li><strong><u>什么是奈奎斯特速率和奈奎斯特<mark>带宽</mark>，此时频带利用率有多大？</u></strong></li></ul><p>无码间串扰的情况下，系统能实现的最高传输速率就叫奈奎斯特速率，大小为<span class="math inline">\(1/T_s\)</span>；无码间串扰下，系统实现最高传输速率所需的最小传输带宽，大小为<span class="math inline">\(1/2T_s\)</span>；此时能提供的最高频带利用率为2Baud/Hz。</p><ul><li><strong><u>什么是码间干扰、产生原因、怎么解决？</u></strong></li></ul><p>什么是码间干扰（ISI）：由于信号的频带是有限的，这就造成时域是无限的，比如sinc函数，这就造成了采样时刻的抽样值可能会受到其他时刻的干扰。在一个抽样时刻，由于邻近码元的波形在该点的幅度值不为0，导致对当前码元抽样的干扰。也就是说，在抽样点得到的抽样值，不仅包含了当前码元的幅度值，还包含了临近码元的幅度值，这就是码间干扰。</p><p>产生原因：</p><ol type="1"><li>频带受限：这是在抽样判决之前，通过信道传输过来的信号需要经过一个滤波器，那么输入抽样判决器的信号，其频带宽度相比滤波之前的信号，频带受到了限制。</li><li>多径效应：同一码元波形的各个分量可能通过不同的路径传播，那么不同多径分量到达接收端的时间就不同，第一个多径分量到达的时刻和最后一个多径分量到达的时刻，这之间存在一个时间差，当这个时间差超过了一个码元的宽度之后，就意味着，上一个码元的一部分多径分量，在这个码元本应该传输完毕的时候，还没有到达接收点，而是混在了下一个码元的多径分量中到达的接收点，从而对下一个码元产生了干扰。</li></ol><p>解决办法：码间干扰的解决办法是采用均衡技术。关于码间干扰的准则有奈奎斯特准则。奈奎斯特第一准则表明信号的带宽是W，则最大无码间干扰的码元速率是2W。奈奎斯特第二准则表明，引入人为的码间干扰会提高频谱利用率，比如说部分响应系统就是引入人为的码间干扰，得到了最大的频带利用率2Baud/Hz。奈奎斯特第三准则表明如果抽样时刻的码元面积正比于脉冲的幅度，其他码元在该时刻面积为零，那么就没有码间干扰。</p><ul><li><strong><u>码间串扰，无码间串扰条件？</u></strong></li></ul><p>码间串扰是由于系统传输总特性（包括收、发滤波器和信道的特性）不理想，导致前后码元的波形畸变、展宽，并使前面波形出现很长的拖尾，蔓延到当前码元的抽样时刻上，从而对当前码元的判决造成干扰。码间串扰严重时会造成错误判决。</p><p>无码间干扰的时域条件：<span class="math inline">\(h(kT_b)= \begin{cases} 1 &amp;k=0\\ 0 &amp;k\text{为其他整数}\\ \end{cases}\)</span></p><p>无码间干扰的频域条件：<span class="math inline">\(\displaystyle\sum_{k=1}^{\infty}H(f+\frac{k}{T_s})=T_s\)</span></p><p>若对h(t)在时刻<span class="math inline">\(t=KT_s\)</span>抽样，h(t)的抽样值除了在t=0时不为零外，在其他所有抽样点上均为零，就不存在码间串扰。一个系统的频谱特性若能等效成一个理想（矩形）低通滤波器，则可以实现无码间串扰。</p><blockquote><p>注意区分码间干扰和码间串扰。</p></blockquote><h2 id="眼图">12.眼图</h2><ul><li><strong><u>眼图的获取方法？</u></strong></li></ul><p>眼图的获取方法是调整示波器的扫描周期为信息码元周期的整数倍，由于示波器的“余晖效应”，示波器将显示多个周期的接受波叠加的结果。</p><ul><li><strong><u>什么是眼图，眼图由什么作用？</u></strong></li></ul><p>眼图是指接收滤波器输出信号，示波器将多个周期的接收信号叠加起来的结果，用于观察码间串扰和噪声的影响，从而估计系统的性能。另外也可以用眼图对接收滤波器的特性加以调整，以减少码间串扰和改善系统的传输性能。</p><ul><li><strong><u>简单叙述眼图和系统性能之间的关系？</u></strong></li></ul><p>最佳抽样时刻对应眼睛张开最大时刻；对定时误差的灵敏度由眼图斜边的斜率决定；图的阴影区的垂直高度，表示信号幅度畸变范围；图中央横轴位置对应判决门限电平；抽样时刻上下阴影区的间隔距离之半为噪声容限。</p><h2 id="均衡技术">13.均衡技术</h2><ul><li><strong><u>均衡技术的作用？</u></strong></li></ul><p>均衡技术是一种起校正和补偿作用的可调滤波器，使用均衡技术可以减少码间干扰，主要实现的方式是<strong>通过训练一组序列调整滤波器的权值</strong>，保证尽可能地减少码间干扰。</p><ul><li><strong><u>简述时域均衡的目的及实现方法？</u></strong></li></ul><p>时域均衡的目的是消除残留的码间干扰，减少传输失真，降低接收端的误码率。时域均衡的方法是采用横向抽头滤波器，通过设计2N+1个抽头的抽头系数，可以实现前后N个抽样值无码间干扰。</p><ul><li><u><strong>什么是升余弦滚降传输特性，为什么要设计升余弦滚降？</strong></u></li></ul><p>由于理想低通系统在实际应用中难以实现，并且理想低通滤波器的冲击响应的拖尾很长，当定时存在误差时，可能出现很严重的码间串扰。故需要设计升余弦滚降系统，它的传输特性为具有关于奈奎斯特带宽呈奇对称的振幅特性。可以利用半周期的余弦信号作为低通滤波器的下降沿。升余弦滚降系统的优点是拖尾衰减快，定时抖动不敏感；缺点是频带利用率低。</p><h2 id="多径效应">14.多径效应</h2><ul><li><strong><u>描述多径效应？</u></strong></li></ul><p>多径效应是指信号经过不同的路径到达接收端，产生的时延不同，按各自相位的叠加产生了干扰。由于多径传播的影响，会使信号的包络产生起伏，即衰落；会使信号由单频率变成窄带信号，即频率弥散现象；还会使信号的某些频率成分消失，即频率选择性衰落。解决办法主要是通过减少码元速率，比如说OFDM将串行数据转换为并行数据。一般来说，多径效应会使通信质量下降。但是，MIMO系统专门利用不同的天线发送信号，接收端再将不同码片组合起来，可以改善通信质量。</p><ul><li><strong><u>多径传播会导致什么现象？</u></strong></li></ul><p>瑞利型衰落，频率弥散和频率选择性衰落；瑞利型衰落是多径传播使单一频率的正弦信号变成了包络和相位受调制的窄带信号；从频谱上看就是频率弥散，多径传播使得单一谱线变成了窄带谱线；频率选择性衰落表示对信号不同的频率成分，信道有着不同的衰减，当失真随时间随机变化时就形成频率选择性衰落。具体的判断方法是信号的频谱比相关带宽宽时，则将产生严重的频率选择性衰落。在传输数字信号时，频率选择性衰落还会引起严重的码间干扰。</p><ul><li><strong><u>什么是相干时间、相干带宽、频率选择性衰落？</u></strong></li></ul><p>相干时间：相干时间就是信道保持恒定的最大时间差范围，发射端的同一信号在相干时间之内到达接收端，信号的衰落特性完全相似，接收端认为是一个信号。如果该信号的自相关性不好，还可能引入干扰，类似照相照出重影让人眼花缭乱。</p><p>相干带宽：它表示为信道传输特性函数相邻两个零点之间的频率间隔。如果信号的频谱比相关带宽要宽的话，则将产生严重的频率选择性衰落。</p><p>频率选择性衰落：指在不同频段上衰落特性不一样。当信号频率超过相干带宽时发生频率选择性衰落。</p><h2 id="信源编码和信道编码">15.信源编码和信道编码</h2><ul><li><strong><u>信源编码和信道编码，它们各自的作用、区别、关系？</u></strong></li></ul><p>信源编码：主要是利用信源的统计特性，解决信源的相关性，去掉信源冗余信息，从而达到压缩信源输出的信息率，提高系统有效性的目的。第三代移动通信中的信源编码包括语音压缩编码、各类图像压缩编码及多媒体数据压缩编码。</p><p>信道编码：为了保证通信系统的传输可靠性，克服信道中的噪声和干扰。它根据一定的（监督）规律在待发送的信息码元中（人为的）加入一些必要的（监督）码元，在接收端利用这些监督码元与信息码元之间的监督规律，发现和纠正差错，以提高信息码元传输的可靠性。信道编码的目的是试图以最少的监督码元为代价，以换取最大程度的可靠性的提高。</p><p>联系与区别：信源编码经过信号调制之后转变为信道编码。信源编码的作用一是将模拟信号转化为数字信号，二是对数据进行压缩；信道编码则是通过添加一定的校验位，来提高码自身的纠错能力的手段。</p><p>概括来记：</p><ol type="1"><li>信源编码：提高信息的有效性，压缩信源中的信息冗余度。对于模拟信源，还要先进行模数转换。常见的信源编码：PCM，霍夫曼编码等。</li><li>信道编码：提高信息的可靠性，发端按照一定的规则加入保护码元，收端进行相应的译码，以纠正信息传输过程中的错误。常见信道编码：循环码，卷积码。</li></ol><ul><li><strong><u>说明线性分组码的最小码距与其检错和纠错能力之间的关系。</u></strong></li></ul><p>若要检出e位错，则要求d<sub>0</sub>≥e+1。若要纠正t位错，则要求d<sub>0</sub>≥2t+1，若要纠正t位错，同时检出e位错，则要求d<sub>0</sub>≥e+t+1，其中e&gt;t。</p><h2 id="差错控制">16.差错控制</h2><ul><li><strong><u>常见的差错控制方式有哪些？有什么优缺点？</u></strong></li></ul><p>有前向纠错，检错重发，混合纠错。</p><p>前向纠错不需要反馈信道，不需要重发导致的延误，但误码率相对较高；检错重发需要反馈信道，且传输实时性较差，但误码率较低，更加可靠；混合纠错结合了前两者的优点，当错码较少时自行纠正，但是错码较多时自动重发。</p><ul><li><strong><u>请简述差错控制的基本原理及其目的？</u></strong></li></ul><p>为了能判断发送的信息是否有误，可以在发送时增加必要的附加数据，又为了能纠正一定程度的错误，就需要增加更多的附加数据，这些附加数据在不发送误码的情况下，是完全多余的，但若发生误码，便可利用信息数据与附加数据之间特定的关系实现误码检知和误码纠正，这就是差错控制编码的基本原理。</p><h2 id="衰落">17.衰落</h2><ul><li><strong><u>什么是多普勒效应？</u></strong></li></ul><p>随着移动物体与基站距离的变化，接收频率会发生变化。由远到近时，频率变大。由近到远时，频率变小。相对移动速度越大，频偏越严重。</p><ul><li><strong><u>什么是大尺度衰落和小尺度衰落？对信号的影响？</u></strong></li></ul><p>信号从发射端经过无线信道到达接收端，功率会发生衰减，主要表现为：平均路径损耗、大尺度衰落、小尺度衰落。</p><p>什么是大尺度衰落：大尺度衰落是由移动通信信道路径上的固定障碍物（建筑物、山丘、树林等）的阴影一起的，衰减特性一般服从d''律，平均信号衰落和关于平均衰落的变化具有对数正态分布的特征。利用不同测试环境下的移动通信信道的衰落中值计算公式，可以计算移动通信系统的业务覆盖范围区域。从无线系统工程的角度看，传播的衰落主要影响到无线区的覆盖。</p><p>什么是小尺度衰落：小尺度衰落是指短期内的衰落，具体指当移动台移动一个较小距离时，接收信号在短期内的快速波动。小尺度衰落由诸多因素共同决定：多径传播，移动台速度，周围物体的速度，信号传输带宽。</p><p>大尺度衰落对信号的影响：大尺度衰落可忽略不计，而且平均路径损耗和阴影衰落主要影响到无线区域的覆盖，通过合理的设计可消除这种不利影响。</p><p>小尺度衰落对信号的影响：小尺度衰落导致信号的幅度快速衰落，以致大尺度衰落可忽略不计，而且平均路径损耗和阴影衰落主要影响到无线区域的覆盖，通过合理的设计可消除这种不利影响；而多径衰落严重影响信号传输质量，并且是不可避免的，只能采用抗衰落技术来减少其影响。</p><h2 id="交织"><strong>18.交织</strong></h2><ul><li><u><strong>交织？</strong></u></li></ul><p>在通信系统中，某些错误的出现是突发的，不可预见性的。这些错误对整个系统的影响有时候会特别严重，为了最大化的减少错误对通信带来的影响，我们使用交织技术，将突发错误分散开来，利用信道编码在矫正单个错误和不太长错误时有效的特点，将信道中的突发错误转变为随机错误，两者结合来形成抗突发错误的有效形式。</p><p>通俗的讲，一个问题，在你最漫不经心的时候出现，通常会带给你一些小小的震惊，你可能需要一些时间来缓一下，然后才会得到解决问题的方法。交织就是为了让你在遇到这些问题的时候，提前做好心理建设，有备无患。当然，交织技术并不完全是一个预防，它很大程度上是一个根上的防治。在陆地移动通信信道上，比特差错通常是成串发生的，而信道编码无法解决这么长串发生的错误，所以交织技术本质上是将信号不再采用成串传输，而是将其分成多个较短的小串，小串不再采用同一个信道方向传输，用两个信号相互交织的形式，例如正弦波和余弦波相互缠绕的方式，将突发差错离散成随机差错，再利用处理随机差错的编码（Fec）等信道编码技术消除差错。</p><ul><li><u><strong>交织码和Turbo码的区别？</strong></u></li></ul><p>交织码可以把传输中的突发错误分散开来，减少不可纠的概率；Turbo码是把两个同类编码器并联在一起。</p><h2 id="复用技术">19.复用技术</h2><ul><li><strong><u>什么是频分复用、时分复用？</u></strong></li></ul><p>频分复用：就是以频段分割的方法在一个信道内实现多路通信的传输体制；</p><p>时分复用：把传输信道按时间进行分割成不同的时间段，每部分时间段称为时隙，主要用于数字信号的传输和接入。</p><ul><li><u><strong>什么是频分复用？</strong></u></li></ul><p>频分复用是一种按频率来划分信道的复用方式。在FDM中信道的带宽被分成多个互不重叠的频段（子通道），每路信号占据其中一个子通道，并且各路之间必须留有未被分配的频带（防护频带）进行分割，以防止信号重叠。在接收端采用适当的带通滤波器将多路信号分开，从而恢复所需要的信号。</p><ul><li><strong><u>CDMA技术？</u></strong></li></ul><p>CDMA是码分多址的英文缩写（Code Division Multiple Access），它是在数字技术的分支——扩频通信技术上发展起来的一种崭新而成熟的无线通信技术。CDMA技术的原理是基于扩频技术，即将需传送的具有一定信号带宽的信息数据，用一个带宽远大于信号带宽的高速伪随机码进行调制，使原数据信号的带宽被扩展，再经载波调制并发送出去。接收端使用完全相同的伪随机码，与接收的带宽信号作相关处理，把宽带信号换成原信息数据的窄带信号即解扩，以实现信息通信。</p><ul><li><strong><u>简述OFDM调制的原理和特点？</u></strong></li></ul><p>OFDM技术：是一种多载波调制技术，具有较强的抗多径传播和抗频率选择性衰落的能力以及较高的频谱利用率。</p><p>基本思想：将宽带信道分解成许多并行的窄子信道，使每个子信道的带宽小于信道的相干带宽Bc，从而每个子信道所经历的衰落近似是平坦性衰落。</p><p>OFDM技术的特点：</p><ol type="1"><li>为了提高频带利用率和增大传输速率，各路子载波的已调信号频谱有部分重叠；</li><li>各路已调信号是严格正交的，以便接收端能完全地分离各路信号；</li><li>每路子载波的调制是多进制调制；</li><li>每路子载波的调制制度可以不同，根据各个子载波处信道特性的优劣不同采用不同的体质。</li></ol><p>采用OFDM的作用：传输更高比特速率，抗（多径）频率选择性衰落，降低由于信道不理想导致的码间串扰问题带来的信号影响。</p><h1 id="二信号与系统">二、信号与系统</h1><h2 id="信号性质">1.信号性质</h2><ul><li><strong><u>两个连续的周期信号之和什么情况下是周期信号？</u></strong></li></ul><p>两个周期信号相加后的周期都是两个信号周期的最小公倍数，若两个信号周期之比不是有理数，则相加后的信号不是周期信号。</p><ul><li><strong><u>请问信号经过希尔伯特变换后有什么变化，实现希尔伯特变换器的变换器又称为什么？</u></strong></li></ul><p>信号经希尔伯特变换后各频率分量的幅度不变，但相位将出现90°的相移，这就是说，将一个信号中原有的频率分量相移90°后，所得的时间函数就称为原信号的希尔伯特变换。因此把实现希尔伯特变换的变换器又称为90°移相器。</p><h2 id="系统">2.系统</h2><ul><li><strong><u>什么是线性系统？</u></strong></li></ul><p>线性系统是指同时满足叠加性与齐次性的系统。所谓叠加性是指当几个输入信号共同作用于系统时，总的输出等于每个输入单独作用时产生的输出之和；齐次性是指当输入信号增大若干倍时，输出也相应增大同样的倍数。</p><p>状态变量和输出变量对于所有可能的输入变量和初始状态都满足叠加原理的系统。一个由线性元部件所组成的系统必是线性系统。但是，相反的命题在某些情况下可能不成立。线性系统的状态变量与输入变量之间的因果关系可用一组线性微分方程或差分方程来描述，这种方程称为系统的数学模型。</p><ul><li><strong><u>什么是因果系统？</u></strong></li></ul><p>激励引起的响应不会出现在激励之前的系统，称为因果系统；也就是说，如果响应不依赖于将来的激励，那么系统就是因果的。</p><p>因果系统就是物理可实现系统。</p><ul><li><strong><u>什么是稳定系统？</u></strong></li></ul><p>一个系统，若对有界的激励所产生的响应也是有界的，则称该系统为有界输入有界输出稳定，简称稳定。该系统为稳定系统。</p><p>一个实际的系统一定是稳定系统，即有界的输入产生有界的输出。</p><p>对于频域来说，稳定系统是系统函数的收敛域要包含单位圆或者虚轴。</p><ul><li><strong><u>什么是时不变系统？</u></strong></li></ul><p>如果系统的参数不随时间而变化，则称此系统为时不变系统。即不管输入信号作用的时间先后，输出信号响应的形状均相同的系统。</p><p>时不变系统是满足时不变性质的系统，时不变性质：若系统满足输入延迟多少时间，其激励引起的响应也延迟多少时间。</p><ul><li><strong><u>请问系统无失真传输的条件是什么？</u></strong></li></ul><ol type="1"><li>系统的幅频特性是一个与频率无关的常数，对输入信号所有频率分量一视同仁，具有恒定的放大或缩小的功能。</li><li>系统的相频特性与频率成正比，对输入信号频率中的不同频率分量具有相同的延迟时间。</li></ol><ul><li><u><strong>振荡电路是否是稳定的，为什么？</strong></u></li></ul><p>不是稳定的，因为它的系统函数的极点不是全在左侧，而稳定的条件是系统函数的收敛域包括虚轴。</p><h2 id="卷积">3.卷积</h2><ul><li><strong><u>什么是卷积？</u></strong></li></ul><p>卷积的本质就是加权求和，它可以联系时域和频域。</p><p><strong>卷积的原理</strong>：任何一个信号都可以看成是一个个冲激信号的叠加，由于系统的线性时不变性，输出也可以看做是一个个冲激响应的叠加。将它们叠加起来就是卷积。</p><p><strong>卷积的物理意义</strong>：卷积是信号与系统中论述系统对输入信号的响应而提出的，卷积还可以作用于图像上对图像进行消除噪声、平滑滤波的作用。还有就是卷积定理，在时域上相乘就是在频域上卷积，时域卷积就是在频域上相乘。</p><p><strong>卷积的应用</strong>：(1)应用于图像处理；(2)卷积定理可以简化运算，比如FFT的使用。</p><p><strong>线性卷积</strong>：线性卷积是与循环卷积相区别的。线性卷积是两个非周期信号直接相卷积，而循环卷积则是两个非周期信号作周期延拓再取主值区间然后相卷积。</p><p>卷积的意义：当输入信号经过系统，其零状态响应可以等效为输入信号卷积系统的冲激函数。</p><h2 id="响应">4.响应</h2><ul><li><strong><u>什么是全响应？</u></strong></li></ul><p>全响应=齐次解（自由响应）+特解（强迫响应）。</p><p>齐次解：写出特征方程，求出特征根（自然频率或固有频率）；根据特征根的特点，齐次解有不同的形式；</p><p>特解：根据输入信号的形式有对应特解的形式，用待定系数法确定；在输入信号为直流和正弦信号时，特解就是稳态解。</p><p>用初始值确定积分常数，一般情况下，n阶方程有n个常数，可用n个初始值确定。</p><ul><li><strong><u>0-状态和0+状态是什么？</u></strong></li></ul><p>0-状态称为零输入时的初始状态，即初始值是由系统的储能产生的；0+状态称为加入输入后的初始状态，即初始值不仅有系统的储能，还受激励的影响。</p><p>从0-状态到0+状态的跃变：当系统已经用微分方程表示时，系统的初始值从0-状态到0+状态有没有跳变取决于微分方程右端自由项是否包含<span class="math inline">\(\delta(t)\)</span>及其各阶导数；如果包含有<span class="math inline">\(\delta(t)\)</span>及其各阶导数，说明响应的0-状态到0+状态发生了跳变。</p><p>0+状态的确定：已知0-状态求0+状态的值，可用冲激函数匹配法；求0+状态的值还可以用拉普拉斯变换中的初值定理求出。</p><ul><li><strong><u>怎么理解冲激响应？</u></strong></li></ul><p>冲激响应是系统在单位冲激信号的作用下而引起的零状态响应。一个信号可以分解为不同时延的冲激信号的叠加，这样，一个信号在经过一个系统处理之后就可以看做是很多不同时延的冲激信号经过了这个系统，这样可以大大简化我们对系统响应的计算。</p><ul><li><strong><u>什么是冲激响应和阶跃响应，它们的关系？</u></strong></li></ul><p>冲激响应：系统在单位冲激信号<span class="math inline">\(\delta(t)\)</span>作用下产生的零状态响应，称为单位冲激响应，简称冲激响应，一般用h(t)表示。</p><p>阶跃响应：系统在单位阶跃信号<span class="math inline">\(u(t)\)</span>作用下的零状态响应，称为单位阶跃响应，简称阶跃响应，一般用g(t)表示。</p><p>阶跃响应与冲激响应的关系：阶跃响应是冲激响应的积分。</p><ul><li><strong><u>冲激函数的特点？</u></strong></li></ul><p>高度无穷大，宽度无穷小，面积为1的对称窄脉冲。</p><h2 id="三大变换">5.三大变换</h2><ul><li><strong><u>傅里叶变换、拉普拉斯变换、Z变换的关系和区别？</u></strong></li></ul><p>傅里叶变换是最基本的变换，由傅里叶级数推导出。傅里叶级数只适用于周期信号，把非周期信号看成周期T趋于无穷的周期信号，就推导出傅里叶变换，能很好的处理非周期信号的频谱。但是傅里叶变换的弱点是原信号必须绝对可积，因此适用范围不广。</p><p>拉普拉斯变换是傅里叶变换的推广，傅里叶变换不适用于指数级增长的函数，而拉氏变换相当于是带有一个指数收敛因子的傅里叶变换，把频域推广到复频域，能分析的信号更广。然而缺点是从拉普拉斯变换的式子中，只能看到变量s，没有频率f的概念，要看幅频响应和相频响应，还得令<span class="math inline">\(s=j2\pi f\)</span>。</p><p>Z变换的本质是离散时间傅里叶变换（DTFT），<strong>如果说拉普拉斯变换专门分析模拟信号，那Z变换就是专门分析数字信号，Z变换可以把离散卷积变成多项式乘法，对离散数字系统能发挥很好的作用</strong>。Z变换看系统频率响应，就是令Z在复频域的单位圆上跑一圈，即<span class="math inline">\(Z=e^{j2\pi f}\)</span>，即可得到频率响应。由于傅里叶变换的特性“时域离散，则频域周期”，因此离散信号的频谱必定是周期的，就是以这个单位圆为周期，Z在单位圆上不停地绕圈，就是周期重复。单位圆0°位置是实际频率0HZ，单位圆180°的实际频率就是采样频率的一半，fs/2。</p><p>总结一下：拉普拉斯变换是傅里叶变换的扩展，傅里叶变换是拉普拉斯变换的特例，z变换是离散的傅里叶变换在复平面上的扩展。</p><h1 id="三计算机网络">三、计算机网络</h1><h2 id="三次握手">1.三次握手</h2><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70.png" alt="三次握手" style="zoom: 50%;"></p><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p><strong>第一次握手</strong>：客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；</p><p><strong>第二次握手</strong>：服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；</p><p><strong>第三次握手</strong>：客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手（SYN=1，ACK=y+1，seq=x+1）。</p><p>完成三次握手，客户端与服务器开始传送数据。</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP连接都将一直保持下去。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70-17108316236944.png" alt="三次握手" style="zoom:50%;"></p><h2 id="四次挥手">2.四次挥手</h2><p>断开一个TCP连接需要“四次握手”。</p><p><strong>第一次挥手</strong>：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（当然，在FIN包之前发送出去的数据，如果没有收到对应的ACK确认报文，主动关闭方依然会重发这些数据），但是，此时主动关闭方还可以接受数据。</p><p><strong>第二次挥手</strong>：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</p><p><strong>第三次挥手</strong>：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</p><p><strong>第四次挥手</strong>：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTA2OTIz,size_16,color_FFFFFF,t_70-17108315949982.png" alt="四次挥手" style="zoom:50%;"></p><h2 id="数据交换方式">3.数据交换方式</h2><ul><li><strong><u>数据交换方式都有哪些？</u></strong></li></ul><p>电路交换：经过建立连接、通信、释放连接三个步骤，整个报文直接从源点到目标点。</p><p>报文交换：通常我们把表示<strong>消息的整块数据</strong>成为一个<strong>报文</strong>。整个报文先传到附近的结点，全部储存下来再转发到下一个结点。</p><p>分组交换：在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由<strong>必要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。报文的一部分先传到附近的结点，再传到下一结点。</p><p>性能比较：</p><ol type="1"><li>若要传送大量数据，传送时间远大于连接建立时间，则电路交换的传送速度较快。</li><li>报文交换和分组交换不需要预先分配传送带宽，在传送突发数据时可提高整个网络的信道利用率。</li><li>分组交换比报文交换的时延小，同时也具有更好的灵活性。</li></ol><ul><li><strong><u>三种交换方式优缺点比较？</u></strong></li></ul><p>电路交换：</p><ul><li>优点：<ol type="1"><li>通信时延小</li><li>有序传输</li><li>没有冲突</li><li>适用范围广</li><li>实用性强</li><li>控制简单</li></ol></li><li>缺点：<ol type="1"><li>建立连接时间长</li><li>线路独占使用效率低</li><li>灵活性差</li><li>难以规格化</li></ol></li></ul><p>报文交换：</p><ul><li>优点：<ol type="1"><li>无需建立连接</li><li>动态分配线路</li><li>提高线路可靠性</li><li>提高线路的利用率</li><li>提供多目标服务</li></ol></li><li>缺点：<ol type="1"><li>引起了转发时延</li><li>需要较大的存储缓存空间</li><li>需要传输额外的信息量</li></ol></li></ul><p>分组交换：</p><ul><li><p>优点：</p><ol type="1"><li>无需建立连接</li><li>线路利用率高</li><li>简化了存储管理</li><li>加速传输</li><li>减少出错率和重发数据量</li></ol></li><li><p>缺点：</p><ol type="1"><li>引起了转发时延</li><li>需要传输额外的信息量</li><li>当分组交换采用数据报服务时，可能会出现失序、丢失或重复分组</li></ol></li></ul><h2 id="计算机网络体系结构分层">4.计算机网络体系结构分层</h2><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113588706576.webp" alt="OSI模型"><figcaption aria-hidden="true">OSI模型</figcaption></figure><p>TCP/IP分层：网络接口层、网际层、运输层、应用层。</p><p>五层协议：物理层、数据链路层、网络层、运输层、应用层。</p><p>物理层：负责<strong>将计算机连起来</strong>，在之间传送0和1这样的比特流。</p><p>数据链路层：工作在物理层之上，<strong>负责将数据包封装成帧</strong>，还要实现透明传输和差错检测。差错控制、流量控制、链路控制、mac寻址、区分数据和控制信息。</p><p>网络层：实现<strong>主机间</strong>的通信。选择合适的网间路由和交换结点。确保数据及时传送。</p><p>运输层：为应用层服务，实现<strong>进程间</strong>的通信。完成复用和分用的功能，实现差错控制和流量控制。</p><p>会话层：解决进程之间进行会话问题。</p><p>表示层：解决通信双方交换信息的表示问题。</p><p>应用层：通过应用进程之间的交互来实现特定网络应用。</p><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113588369094.webp" alt="协议数据单元"><figcaption aria-hidden="true">协议数据单元</figcaption></figure><h2 id="tcp和udp协议">5.TCP和UDP协议</h2><ul><li><strong><u>UDP协议的特点有哪些？</u></strong></li></ul><p>UDP协议全称是用户数据报协议，是一种无连接的协议。在OSI模型中，它在第四层-传输层，处于IP协议的上一层。</p><p>它有以下几个特点：</p><ol type="1"><li><p><strong>面向无连接</strong>：首先UDP是不需要和TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p></li><li><p><strong>有单播，多播，广播的功能</strong>：UDP不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说UDP提供了单播，多播，广播的功能。</p></li><li><p><strong>UDP是面向报文的</strong>：发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。</p></li><li><p><strong>不可靠性</strong>：首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p><p>再者网络环境时好时坏，但是UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包。</p></li></ol><ul><li><strong><u>TCP协议的特点有哪些？</u></strong></li></ul><p>TCP协议全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p><p>它有以下几个特点：</p><ol type="1"><li>面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</li><li>仅支持单播传输：每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li><li>面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</li><li>可靠传输：对于可靠传输，判断丢包、误码，靠的是TCP的段编号以及确认号。</li><li>提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网格注入数据的速率和数量，缓解拥塞。</li><li>TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段。</li></ol><ul><li><strong><u>TCP与UDP传输协议有哪些区别？</u></strong></li></ul><figure><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/webp-17113433199182.webp" alt="UDP和TCP的对比"><figcaption aria-hidden="true">UDP和TCP的对比</figcaption></figure><ol type="1"><li>TCP基于连接，而UDP基于无连接的；</li><li>对系统资源的要求：TCP较多（TCP首部最小20字节），UDP少（UDP首部仅8字节）；</li><li>UDP程序结构较简单；</li><li>TCP是字节流模式，而UDP是数据报文模式；</li><li>TCP保证数据正确性，安全可靠，并且保证数据顺序，而UDP可能丢包，而且UDP不保证数据顺序。</li></ol><ul><li><strong><u>为什么说TCP协议传输是可靠的？</u></strong></li></ul><p>TCP的可靠性表现在：它向应用层提供的数据是无差错的、有序的、无丢失的，简单的说就是：TCP最终递交给应用层的数据和发送者发送的数据是一摸一样的</p><p>TCP采用了流量控制、拥塞控制、连续ARQ等技术来保证它的可靠性。</p><h2 id="拥塞控制和流量控制">6.拥塞控制和流量控制</h2><p>流量控制：是端到端的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。</p><p>概念：流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。</p><p>拥塞控制：是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。</p><p>概念：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现锁死现象。拥塞控制是处理网络拥塞现象的一种机制。</p><ol type="1"><li>TCP发送方首先发送一个数据报，然后等待对方的回应；</li><li>得到回应后就把这个窗口的大小加倍，然后连续发送两个数据报；</li><li>直到出现超时错误，这样，发送端就了解到了通信双方的线路承载能力，也就确定了拥塞窗口的大小。</li></ol><h2 id="网络层">7.网络层</h2><ul><li><strong><u>IP是指什么？</u></strong></li></ul><p>网络之间互连的协议（IP）是 Internet Protocol 的外语缩写，在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。</p><ul><li><strong><u>MAC地址和IP的区别？</u></strong></li></ul><p>计算机网络分为七层，分别是物理层、数据链路层、网络层、运输层、会话层、表示层、应用层，MAC地址是硬件地址，用于物理层和数据链路层，IP地址是逻辑地址，用于网络层之上。交换机寻址用的是MAC地址，路由器寻找最佳路径用的是IP地址。</p><ul><li><strong><u>虚电路和数据报服务？</u></strong></li></ul><p>虚电路是发送方和接收方建立的一条逻辑电路，数据可以由发送方直接到达接收方，报文不需要带目的地址和序号，适合长时间通信的双方。数据报是通过不同的传输路径到达接收方，报文需要带目的地址和序号。但是可能会出现乱序重复丢失的现象。</p><p>虚电路和数据报都是分组交换技术，区别如下：</p><ol type="1"><li>数据报是无连接的数据交换，而虚电路是面向连接的数据交换；</li><li>数据报的分组都是通过独立的路由选择和转发，而同属于一条虚电路的分组按照同一路由转发；</li><li>数据报不保证数据的可靠交付，虚电路可靠性由网络保证；</li><li>数据报不保证分组的有序到达，虚电路保证分组的有序到达。</li></ol><h2 id="数据链路层">8.数据链路层</h2><ul><li><strong><u>交换机的概念？</u></strong></li></ul><p>交换机内部维护一张交换表（ARP表），它知道每个端口对应的MAC地址，下次传送帧的时候可以根据MAC地址直接发给对应的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p><ul><li><strong><u>简述交换机和路由器的作用？</u></strong></li></ul><p>交换机的作用可以简单的理解为将一些机器连接起来组成一个局域网。而路由器的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。</p><ul><li><strong><u>网桥的作用？</u></strong></li></ul><p>网桥是一个局域网与另一个局域网之间建立连接的桥梁。</p><p>优点：扩大物理范围、可以使用不同的物理层、互联不同的局域网、隔离碰撞域。</p><p>缺点：不能隔离广播域、没有流量控制。</p><h2 id="其他">9.其他</h2><ul><li><strong><u>计算机网络的传输媒质？</u></strong></li></ul><p>同轴电缆、双绞线、光纤。</p><ul><li><strong><u>计算机网络按照网络的拓扑结构分类？</u></strong></li></ul><p>总线型、星型、环型、树型、分布式网络。</p><ul><li><strong><u>HTTP与HTTPS有什么区别？</u></strong></li></ul><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。</p><p>两者区别：</p><ol type="1"><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者80，后者是443。</li><li>http的连接很简单，是无状态的；https协议是由ssl+http协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><ul><li><strong><u>CSMA/CD和CSMA/CA的基本思想以及主要区别？</u></strong></li></ul><p>CSMA/CA：发送数据时先广播告知其他节点，让其他节点在某段时间内不要发送数据，以免出现碰撞。</p><p>CSMA/CD：发送前侦听，边发送边侦听，一旦出现碰撞停止发送。</p><ul><li><strong><u>两台笔记本电脑连起来后ping不同，你觉得可能存在哪些问题？</u></strong></li></ul><ol type="1"><li>首先考虑是否是网络的问题。</li><li>局域网设置问题，电脑互联是要设置的。看是否安装了必要的网络协议，最重要的是IP地址是否设置正确。</li><li>网卡驱动未安装正确。</li><li>防火墙设置有问题。</li><li>是否有什么软件阻止了ping包。</li></ol><h1 id="四移动通信">四、移动通信</h1><h2 id="多址方式">1.多址方式</h2><ul><li><strong><u>请问频分多址具体是怎样划分信道的？为了保证信道不产生明显的干扰，采用什么措施？FDMA有何特点？</u></strong></li></ul><p>FDMA对给定的频率资源规划出多个载波，通常是等间隔划分频段方式实现，一个载频对应一个物理通道；为了保证相邻信道之间不产生明显干扰，在用户信道之间，一般要设保护频带以确保频道之间相互正交；FDMA技术特点如下：每个频道只传送一路电话，一旦给移动台分配了频道，移动台和基站同时连续不断发射；信道带宽较窄，即FDMA通常使用窄带系统；系统简单，但需要双工器，同时需要精确的射频带通滤波器来消除邻道干扰和基站的杂散辐射。</p><ul><li><strong><u>请问时分多址具体是怎样划分信道的？为了保证TDMA系统正常工作，有什么要求？TDMA有何特点？</u></strong></li></ul><p>在一个带宽的无线载波上，把时间分成周期性的帧，每一帧再分割为若干时隙，每一时隙就是一个信道，分配给一个用户；同步和定时是TDMA系统正常工作的前提，具体就是要求：位同步、时隙同步、帧同步、网同步；TDMA的技术特点如下：（1）多用户共享一个载波频率，数据分组发送，不连续发送，需开关；（2）由于速率较高，往往需要采用均衡器。</p><ul><li><strong><u>请问码分多址是怎样划分信道的？如何解调？</u></strong></li></ul><p>通过不同的码序列来划分物理信道，信道在时间和频率上重合，在码字上分离；在CDMA系统中，码不但可以区分信道，还可以区分基站或用户，区分基站或用户的码统称为扰码；CDMA系统为每个用户分配了各自特定的地址码，无论从频域还是时域来看，各用户的信号都是混杂在一起的，因为这些地址码具有准正交性，接收端唯有使用完全一致的本地地址码才能解调信号。</p><h1 id="五英语">五、英语</h1><h2 id="自我介绍">1.自我介绍</h2><p>Good morning, dear teachers! I am glad to be here for this interview. My name is QinMian. I like this name because it stands for diligence. I am from Beijing University of Posts and Telecommunications, and my major is Information Engineering.</p><p>I would like to choose the word diligence to describe myself. I spent more than eight hours on learning almost every day during my preparation of this exam, and that's why I am here. I don't believe luck, I don't believe talent, but I do believe diligence can take me there.</p><p>During my college years, I always take study seriously and did well in most of my specialized courses, and I got some precious learning experience. Accordingly, I was awarded the scholarship for three times. In my junior year, I successfully passed CET-6, and working hard on English equipped me with basic reading and writing abilities.</p><p>When I was a junior, I made the decision to take the postgraduate entrance examination because I hope I can get in-depth study in my major. In addition, I think to be a postgraduate can make myself more competitive in society. During the preparation for the preliminary exam, I collected a lot of major-related materials and had a better understanding of my major. It made me more convinced that I was interested in Communications Engineering, and it also strengthened my belief in attending graduate school.</p><p>Finally, I love our university. You know, it is selective and famous, especially in my field. What's more, our university is beautiful and famous for its academic atmosphere. If I won the chance to study here, I would try my best to be a good student and a pride of our university in the future.</p><p>Thank you for listening. This opportunity is so important to me that I hope you can give me a high score. Thank you!</p><h2 id="常见问题">2.常见问题</h2><p>听到问题先说，Thank you for your question.</p><p>Can you talk about your plans in the postgraduate period?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326202216213.png"></p><p>Can you tell me something about your family?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326202953128.png"></p><p>How do you usually deal with your pressure?</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240326205706105.png"></p><p>《Green Book》: Whatever you do, do it a hundred percent, when you work, work, when you laugh, laugh, when you eat, eat like it is your last meal.</p><p>I'm so sorry, teacher! I didn't hear the question clearly. Could you please repeat it？</p><ul><li><strong><u>What research direction you are interested in?</u></strong></li></ul><p>I want to research in the field of six generation mobile networks. Because it can bring faster transmission rates and lower latency. In the future, it will be applied in all aspects of our life. If I am admitted, I will continue to be strict with myself and work hard in my research direction.</p><ul><li><strong><u>Introduce your favorite course during your undergraduate studies.</u></strong></li></ul><p>My favourite course is Principles of Communication. It is the most important course in my major. I took the course seriously in my junior and did well in it, and I got some precious major-related knowledge. What's more, because I like this course, in the preliminary exam, I got a high score in the course. I will continue to be strict with myself and apply the knowledge of this course to future research.</p><h1 id="六项目提问">六、项目提问</h1><ul><li><strong><u>蒙特卡洛拒绝采样？</u></strong></li></ul><p>蒙特卡洛思想是指通过随机采样和统计模拟的方式来解决问题。它的基本思想是利用随机数生成器生成符合一定概率分布的随机数，并通过大量的重复实验来估计问题的解。其目标是根据给定的概率密度函数f(x),产生服从目标分布的样本X。</p><ul><li><strong><u>毕设？</u></strong></li></ul><p>我的毕设题目是协作非正交多址接入的研究与实现，在一个三节点中继信道上，源端由多个用户设备组成，还有目的地和中继节点。源端的多个用户以非正交的方式向目的地传输信息。如果目的地的NOMA传输不成功，中继节点会对信息进行解码和转发，以协助传输。假设系统以半双工模式运行：在第一阶段，源端向中继节点和目的地传输信息；第二阶段，中继站将源端的信息转发给目的地，而源端保持沉默。最后，目的地结合信源和中继的信道观测结果来恢复信息。</p><p>源端多个用户发出的信息通过一个叠加矩阵叠加到多个资源元素上再传到目的地，同样中继节点将来自源端的信息通过另一个叠加矩阵叠加到多个资源元素上再传到目的地。两个叠加矩阵就构成了双层因子图。</p><p>我用matlab对加入中继节点和不加入中继节点时的传输速率进行了仿真，发现加入中继节点后系统的传输速率得到了提高。</p><p>另外，中继点在对来自源端的信息进行解码时可能会产生错误，这个错误率会影响传输速率，我也对这种情况进行了仿真，发现即使存在一定的错误率，有中继节点时的传输速率，依然要大于无中继节点时的传输速率。</p><p>应用遗传算法（GA）可以实现优化。</p><p>遗传算法（Genetic Algorithm，GA）是模拟生物在自然环境中的遗传和进化的过程而形成的自适应全局优化搜索算法。</p><p>遗传算法借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种并行、高效、全局搜索的方法，它能在搜索过程中自动获取和积累有关搜索空间的知识，并自适应地控制搜索过程以求得最优解。</p><p>叠加矩阵被视为种群中的个体，相应的互信息就是个体的适应度。矩阵中的元素是基因，基因的排列构成染色体。通过个体选择、基因交叉和基因突变可以获得最优解。</p><ul><li><strong><u>基于文本和图像的多媒体检索系统？</u></strong></li></ul><p>使用jieba分词对每首歌进行分词并统计所有词。</p><p>关键词的提取使用TF-IDF算法<strong>（term frequency–inverse document frequency，词频-逆文档频率）</strong>。TF是词频，表示词在文本中出现的频率；IDF是逆文档频率，表示词的常见程度。将两者相乘得到TF-IDF值，其大小表示了词对文本的重要程度，因此可以选取TF-IDF值大的作为文本的关键词。</p><p>VSM模型即向量空间模型，把提取文本内容中的关键词作为向量空间中的向量，并将向量间的相似度作为衡量文本相似度的标准。所以便可以通过求余弦相似度，来表征文本相似度。</p><p>Bag-of-words基础流程：</p><p>特征提取：使图像形成不同的图像块，并获得各图像块处的特征。</p><p>用K-means聚类算法将提取的SIFT特征聚类生成视觉词典。</p><p>K-means算法是度量样本间相似性的一种方法，该算法设置参数为K，把N个对象分成K个簇，簇内之间的相似度较高，而簇间的相似度较低。聚类中心有K个，视觉词典为K。</p><p>针对输入特征集，根据视觉词典进行量化。</p><p>把输入图像转化成视觉单词（visual words）的频率直方图。</p><p>构造特征到图像的倒排表，通过倒排表快速索引相关图像。</p><p>根据索引结果进行直方图匹配。</p><p><img src="/2024/03/03/%E5%A4%8D%E8%AF%95%E5%B8%B8%E8%A7%81%E9%A2%98%E6%B1%87%E6%80%BB/image-20240328175547649.png" alt="话术" style="zoom: 67%;"></p>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>考研</tag>
      
      <tag>计算机网络</tag>
      
      <tag>信号与系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动通信</title>
    <link href="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/"/>
    <url>/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<ul><li>视频教程<a href="https://www.icourse163.org/learn/HDU-1464128174?tid=1471185461#/learn/content?type=detail&amp;id=1256070370&amp;cid=1288761743">杭州电子科技大学 移动通信公开课</a></li></ul><h1 id="一移动通信基础知识">一、移动通信基础知识</h1><h2 id="多址方式">1.多址方式</h2><p>多址方式就是用户间的资源分配。信号传输需要占用的资源包括频率、时间、空间、功率。</p><p>根据分配资源的不同，多址方式包含频分多址(FDMA)、时分多址(TDMA)、码分多址(CDMA)、空分多址(SDMA)、正交频分多址(OFDMA)、非正交多址(NOMA)这几类。</p><blockquote><p>NOMA在5G中采用</p></blockquote><p>FDMA的定义：在频域中一个相对窄带信道里，信号功率被集中起来传输，<strong>不同信号被分配到不同频率的信道</strong>，发往和来自邻近信道的干扰用带通滤波器限制，这样在规定的窄带里只能通过有用信号的能量，而任何其他频率的信号被排斥在外。</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218155752231.png"></p><ul><li>TDMA的定义：指一个信道由一连串周期性的时隙构成，<strong>不同信号被分配到不同的时隙里</strong>，利用定时选通来限制邻近信道的干扰，从而在规定时隙中只让有用的信号通过。</li></ul><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218160118592.png" alt="FDMA和TDMA相结合的多址方式"><figcaption aria-hidden="true">FDMA和TDMA相结合的多址方式</figcaption></figure><p>CDMA的定义：每一个信号被分配一个伪随机二进制序列进行扩频，<strong>不同信号的能量被分配到不同的伪随机序列里</strong>。</p><blockquote><p>不同用户所使用的码字是不同的，且是正交的。</p></blockquote><p>SDMA的定义：<strong>使得不同的用户信号占用不同的空间位置</strong>。不同用户信号的波束方向不同，避免了相互间的干扰。核心技术是智能天线，要求天线给每个用户分配一个点波束。</p><blockquote><p>处于不同位置的用户可以在同一时间使用同一频率和同一码型，而不会相互干扰。</p></blockquote><p>OFDMA的定义：</p><ul><li>是LTE系统中应用的多址方式，LTE是4G中采用的标准。</li><li>OFDM技术将带宽划分为多个重叠但正交的子载波。</li><li>而OFDMA将OFDM技术扩展到多用户，将不同的子载波分配给不同的用户。</li><li>实际上，LTE中采用的是OFDMA与TDMA结合的多址方式。</li></ul><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240218161407617.png"></p><p>NOMA的定义：是5G中提出的一种多址方式，该方式最大的特点是为<strong>不同信号分配的功率不同</strong>，通常要结合接收端信号处理技术来消除干扰。</p><p>为什么要引入NOMA？</p><ul><li>非正交多址技术（NOMA）的<strong>基本思想</strong>是在发送端采用非正交发送，主动引入干扰信息，在接收端通过串行干扰删除（SIC）接收机实现正确解调。虽然，采用SIC技术的接收机复杂度有一定的提高，但是可以<strong>很好地提高频谱效率</strong>。</li><li><strong>用提高接收机的复杂度来换取频谱效率，这就是NOMA技术的本质</strong>。</li><li>非正交多址接入(Non-Orthogonal Multiple Access, NOMA) 技术以<strong>不同功率</strong>将多个信息流在时域/频域/码域重叠的信道上传输，在相同无线资源上为多个用户同时提供无线业务。</li><li>在正交多址技术（OMA）中，只能为一个用户分配单一的无线资源，例如按频率分割或按时间分割，而NOMA方式可将一个资源分配给多个用户。在某些场景中，比如远近效应场景和广覆盖多节点接入的场景，特别是上行密集场景，采用功率复用的非正交接入多址方式较传统的正交接入有明显的性能优势，更适合未来系统的部署。目前已经有研究验证了在城市地区采用NOMA的效果，并已证实，采用该方法可使无线接入宏蜂窝的总吞吐量提高50%左右。非正交多址复用通过结合串行干扰消除或类最大似然解调才能取得容量极限，因此技术实现的难点在于是否能设计出低复杂度且有效的接收机算法。</li></ul><p><strong><mark>注意NOMA指的是非正交多址，而不是非正交频分，即NOMA的子信道传输依然采用正交频分复用（OFDM）技术，子信道之间是正交的</mark>，互不干扰，但是一个子信道上不再只分配给一个用户，而是多个用户共享，同一子信道上不同用户之间是非正交传输 <mark>（即非正交多址）</mark>，这样就会产生用户间干扰问题，这也就是在接收端要采用SIC技术进行多用户检测的目的。在发送端，对同一子信道上的不同用户采用功率复用技术进行发送，不同的用户的信号功率按照相关的算法进行分配，这样到达接收端每个用户的信号功率都不一样。SIC接收机再根据不同户用信号功率大小按照一定的顺序进行干扰消除，实现正确解调，同时也达到了区分用户的目的。</strong></p><blockquote><p>总之，记住一句话，NOMA就是多个用户共享一份资源，目的便是<strong>提升频谱效率</strong>。</p></blockquote><h3 id="协作非正交多址接入co-noma">1.1 协作非正交多址接入（Co-NOMA）</h3><p>协作非正交多址接入（Cooperative Non-Orthogonal Multiple Access，简称Co-NOMA）是一种新型的多用户接入技术，它结合了NOMA 和协作通信的思想。在 Co-NOMA 中，多个用户之间可以通过相互协作来提高系统性能和频谱效率。</p><p>Co-NOMA 的基本原理是，当一个用户的信号在到达接收器之前受到严重干扰时，其他用户可以通过协作来帮助该用户，以提高其信号的可靠性和质量。这种协作可以通过不同用户之间的合作传输、信号处理或者干扰抑制等方式实现。</p><p>Co-NOMA 技术可以应用于不同的通信场景，包括蜂窝通信系统、物联网（IoT）、车联网（V2X）等。通过协作，Co-NOMA 可以提高系统容量、覆盖范围和用户体验，同时有效地利用有限的频谱资源。</p><p>总的来说，Co-NOMA 是一种结合了 NOMA 和协作通信思想的新型多用户接入技术，可以提高系统性能和频谱效率，并在未来的通信系统中具有广泛的应用前景。</p><h2 id="分集技术及复用技术">2.分集技术及复用技术</h2><p>分集技术利用多条独立的通道传输相同的数据，而复用技术利用多条独立的通道传输不同的数据。</p><h3 id="分集技术">2.1 分集技术</h3><p>分集技术是一种<strong>补偿信道衰落的技术</strong>，用于改善无线通信链路的质量，而且不用改变通用空中接口或者增加发射功率或者带宽。</p><p>分集是指分散传输和集中接收。所谓分散传输是使接收端能获得多个统计独立的、携带<strong>同一信息</strong>的衰落信号。集中接收是接收机把收到的多个统计独立的衰落信号进行合并(选择与组合)以降低衰落的影响。</p><blockquote><p>核心思想即寻找无线传播环境中的独立（或高度不相关）路径，传输同一信号。</p></blockquote><p>常用分集：时间分集、频率分集、空间分集、极化分集</p><p>时间分集：以超过信道相干时间的时间间隔重复发送信号，以便让再次收到的信号具有独立的衰落环境，从而产生分集效果。重发的时间间隔要满足： <span class="math display">\[\Delta T \gg \frac{1}{2f_m}=\frac{1}{2(v/\lambda)}\]</span> 频率分集：在<strong>多于一个的载频</strong>上传送信号，其工作原理为，<strong>相隔超过信道相干带宽的两个信号是不相关的，并且不会出现相同的衰落</strong>。理论上，如果信道是不相关的，那么同时衰减的概率将是单独衰减概率的乘积。相干带宽的公式为： <span class="math display">\[B_c=\frac{1}{2\pi \Delta}(其中\Delta为时延扩展:最大传输时延和最小传输时延的差值)\]</span> 空间分集：从不同的天线上获得非相关的接收信号，要求天线间的间隔距离等于或大于半个波长。</p><blockquote><p>在市区，<span class="math inline">\(d\)</span>通常取0.5<span class="math inline">\(\lambda\)</span>，而在郊区，<span class="math inline">\(d\)</span>通常取0.8<span class="math inline">\(\lambda\)</span>。</p></blockquote><p>极化分集：利用了空中的水平极化和垂直极化路径不相关的特性。由于在传输中进行了多次反射，使得信号在不同的极化方向上是不相关的。将极化天线用于多径环境中，当传输路径中有障碍物时，极化分集可以极大地减少多径时延扩展，而不会明显地降低功率。</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240219103011167.png"></p><p>接收端分集合并：选择性合并、最大比值合并、等增益合并。</p><h4 id="最大比传输mrt">2.1.1 最大比传输（MRT）</h4><p>MRT可以被视为一种空间分集技术，是一种用于多天线系统（MIMO）中的传输技术。它的原理基于<strong>最大化接收信号功率</strong>，从而提高信号质量和系统性能。</p><p>MRT通常应用于具有多个发射天线和多个接收天线的系统中。这种系统称为多输入多输出（MIMO）系统。在MRT中，发送端利用多个天线发送相同的信号，但在每个天线上<strong>加权不同的系数</strong>。这些系数通常是为了最大化接收端的信号功率而计算得到的。MRT的主要目标是通过合理的<strong>天线加权</strong>，使得接收端接收到的信号功率最大化。这意味着在接收端的每个天线上收到的信号尽可能强，并且在信号与噪声的混合中，信号所占的比例最大。</p><p>在MRT中，除了<strong>幅度加权</strong>外，也需要对发送信号的<strong>相位</strong>进行调整，以确保在接收端接收到的信号相位最大程度地匹配，从而实现信号的合理叠加。在接收端，通过一定的信号处理技术（如最大比合并），将从各个天线接收到的信号合并起来，以最大程度地提高接收信号的质量。</p><p>总的来说，MRT的原理是通过合理的天线加权和相位调整，在传输端尽可能地增强信号功率，从而在接收端获得更高的信噪比，提高通信系统的性能和可靠性。</p><h3 id="复用技术">2.2 复用技术</h3><p>复用技术是对信道进行划分，一个信道划分为多个独立通道，传输多路<strong>不同信号</strong>。包括时分复用(TDM)、频分复用(FDM)、码分复用(CDM)、波分复用(WDM)。</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/image-20240219103435103.png" alt="几种资源分配技术的比较"><figcaption aria-hidden="true">几种资源分配技术的比较</figcaption></figure><h2 id="性能指标定义">3.性能指标定义</h2><h3 id="中继事件中继概率与分集增益">3.1 中继事件、中继概率与分集增益</h3><p>在通信系统中，中断事件、中断概率和分集增益是评估通信系统在衰落信道条件下稳定性和传输可靠性的重要指标。</p><p><strong>中断事件</strong>：在给定的通信方案下，由于信道衰落等因素导致无法达到所需的目标速率而发生的事件。</p><p><strong>中断概率</strong>：在通信过程中，中断事件发生的概率。对于固定的通信实现方案，该通信方案的可达容量为随机信道<span class="math inline">\(h\)</span>的函数<span class="math inline">\(I(h)\)</span>。如果<span class="math inline">\(I(h)&lt;R\)</span>，其中<span class="math inline">\(R\)</span>是目标速率，则发生中断事件。中断概率可以表示为<span class="math inline">\(Pr(I(h)&lt;R)\)</span>。</p><p><strong>分集增益</strong>：分集增益表示通过分集技术在高信噪比下提高信号质量的能力。在高信噪比条件下，分集系统可以通过收集多个独立接收的信号并将它们合并来提高信号质量。分集增益通常用<span class="math inline">\(G\)</span>表示，可以通过中断概率<span class="math inline">\(d\)</span>在高信噪比下的渐进行为来给出。 <span class="math display">\[d=Pr(I_h&lt;R_t)\infty \frac{1}{SNR},SNR\to+\infty\]</span> 方程式表明，在高信噪比条件下，中断事件发生的概率趋近于零，即随着信噪比的增加，中断事件的概率几乎为零。这是因为在高信噪比条件下，信号相对于噪声更容易被正确地接收，从而降低了中断事件的发生概率，提高了通信系统的可靠性。</p><h3 id="遍历速率复用增益">3.2 遍历速率、复用增益</h3><p>与中断性能代表的可靠性不同，遍历和速率、复用增益两项指标通常用来衡量通信系统最大可达速率。</p><p><strong>遍历速率<span class="math inline">\(R_E\)</span></strong>：遍历速率表示系统在所有可能的随机状态下的平均速率。具体地，如果即时可达速率<span class="math inline">\(R(h)\)</span>是随机信道<span class="math inline">\(h\)</span>的函数，则遍历速率<span class="math inline">\(R_E\)</span>可以表示为<span class="math inline">\(R_E=E[R(h)]\)</span>,其中<span class="math inline">\(E\)</span>表示期望运算。这意味着遍历速率是所有可能的随机状态下的即时可达速率的期望值。</p><p><strong>复用增益<span class="math inline">\(m\)</span></strong>：复用增益表示系统可以无干扰传输的独立信息流的数量。在高信噪比条件下，复用增益可以通过<span class="math inline">\(E\)</span>在高信噪比下的渐进行为来给出。具体地，复用增益<span class="math inline">\(m\)</span>可以表示为： <span class="math display">\[m=\lim\limits_{SNR \to \infty}\frac{R_E}{log_2(SNR)}\]</span></p><h2 id="多天线技术mimo">4. 多天线技术（MIMO）</h2><h3 id="基本概念">4.1 基本概念</h3><p><strong>MIMO技术</strong>属于多天线技术，利用<strong>空间分集/复用</strong>来提高吞吐量，多个<strong>独立的</strong>的数据流<strong>同时传输</strong>。</p><p>MIMO分为<strong>point-to-point MIMO</strong>和<strong>MU-MIMO</strong>两类，其中<strong>point-to-point MIMO</strong>即属于<strong>利用空间分集来提高吞吐量</strong>，虽然在point-to-point MIMO中，接收机和发射机都配备有多个天线，但是在每个时刻，只有一个用户可以被服务；<strong>MU-MIMO</strong>属于<strong>利用空间复用来提高吞吐量</strong>。</p><p><mark><strong>下面只关注使用空间复用的MIMO。</strong></mark></p><p>与<strong>SISO</strong>相比，<strong>MIMO</strong>：</p><ul><li>获得了吞吐量的增益</li><li>没有可靠性的增益</li></ul><h3 id="mimo的数学模型以22的mimo下行链路为例">4.2 MIMO的数学模型（以2×2的MIMO下行链路为例）</h3><p><strong>2个用户的MIMO下行场景</strong>：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-7eaddb44830608b37cb87b80274c6d2b_720w.webp" alt="2x2的MIMO的模型"><figcaption aria-hidden="true">2x2的MIMO的模型</figcaption></figure><p>其中，<span class="math inline">\(h_{11},h_{12},h_{21},h_{22}\)</span>为四条可能的传输路径，是<strong>系数</strong>，其大小表示<strong>从该路径传输的数据量的大小</strong>，数值越大，表示从该条路径传输的数据量越多。</p><blockquote><p><span class="math inline">\(h_{ij}\)</span>中的<span class="math inline">\(i\)</span>表示的是第<span class="math inline">\(i\)</span>个接收天线(<span class="math inline">\(R_x\)</span>)，<span class="math inline">\(j\)</span>表示第<span class="math inline">\(j\)</span>个发射天线(<span class="math inline">\(T_x\)</span>)。</p></blockquote><p>四个系数构成一个<strong>信道矩阵</strong>：<span class="math inline">\(H=\begin{bmatrix} h_{11} &amp; h_{12}\\ h_{21} &amp; h_{22} \end{bmatrix}\)</span>。</p><p>用矩阵表示MIMO的过程：<span class="math inline">\(y=Hx\)</span>。其中，<span class="math inline">\(y\)</span>为<strong>接收机接收到的数据构成的矩阵</strong>，维度为<span class="math inline">\(N_{R_x}×1\)</span>，<span class="math inline">\(y=\begin{bmatrix} y_1\\ y_2 \end{bmatrix}\)</span>；<span class="math inline">\(x\)</span>为<strong>发射机发送的数据构成的矩阵</strong>，维度为<span class="math inline">\(N_{T_x}×1\)</span>，<span class="math inline">\(x=\begin{bmatrix} x_1\\ x_2 \end{bmatrix}\)</span>。接收数据表示为发送数据经过<strong>信道矩阵</strong>变换后得到。</p><p><strong>传播矩阵</strong><span class="math inline">\(H\)</span>的维度是<span class="math inline">\(N_{R_x}×N_{T_x}\)</span>。</p><blockquote><p>信道矩阵的行数 = 接收天线的个数；信道矩阵的列数 = 发射天线的个数。</p></blockquote><p><strong>接收机的目的</strong>：从接收到的数据<span class="math inline">\(y\)</span>中提取得到原始数据<span class="math inline">\(x\)</span>。</p><p><strong>如何实现接收机的目的？</strong></p><p>概念上，可以直接通过对<strong>传播矩阵</strong>求逆得到，即<span class="math inline">\(\begin{bmatrix} x_1\\ x_2 \end{bmatrix}=\begin{bmatrix} h_{11} &amp; h_{12}\\ h_{21} &amp; h_{22} \end{bmatrix}^{-1}\begin{bmatrix} y_1\\ y_2 \end{bmatrix}\)</span>。</p><p>然而，<strong>存在如下的问题</strong>：</p><ol type="1"><li><strong>传播矩阵的逆不一定存在</strong>，只有在<strong>富杂散</strong>，即传播路径各不相干，各自独立，的环境中，<span class="math inline">\(H^{-1}\)</span>才存在；</li><li>即使<span class="math inline">\(H^{-1}\)</span>存在，求解矩阵的逆也是一个很复杂的事，是否存在一种方式可以<strong>预处理</strong>数据，使得<strong>UE</strong>（统一编码）可以在不对传播矩阵进行求逆的情况下，对数据进行译码。</li></ol><p><strong>解决方法</strong> -- 使用<strong>SVD，将对信道矩阵求逆化简为对对角矩阵求逆，引入Precoding（预编码）。</strong></p><blockquote><p>因此，引入预编码的目的视为让矩阵求逆变得简单。</p></blockquote><h4 id="用svd分析mimo">4.2.1 用SVD分析MIMO</h4><p>对<strong>信道矩阵</strong>进行SVD，即<span class="math inline">\(H=U\varSigma V^H\)</span>。</p><blockquote><p><span class="math inline">\(V^H\)</span>表示矩阵<span class="math inline">\(V\)</span>的共轭转置，实数域中共轭转置就等于转置，V和H都是正交矩阵。</p></blockquote><p>预编码矩阵<span class="math inline">\(V\)</span>的维度是<span class="math inline">\(N_{T_x}×N_{T_x}\)</span>。</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-66028592dd8732d512b75e78c1e901d9_r.jpg" alt="MIMO_SVD"><figcaption aria-hidden="true">MIMO_SVD</figcaption></figure><blockquote><p>在发射端和接收端分别加上<strong>预编码矩阵</strong><span class="math inline">\(V\)</span>和<strong>合并矩阵</strong><span class="math inline">\(U^H\)</span>，<strong>这两个都是信道矩阵分解后得到的酉矩阵</strong>，因此最后剩下的新的信道矩阵是一个对角矩阵。</p></blockquote><p>在这种情况下，<span class="math inline">\(y=U^H(U\varSigma V^H)Vx=\varSigma x\)</span>。</p><p>通过SVD，将<strong>信道矩阵</strong>可以简单表达为一个<strong>对角矩阵</strong>，<span class="math inline">\(\varSigma=\begin{bmatrix} \sigma_1 &amp; 0\\ 0 &amp; \sigma_2 \end{bmatrix}\)</span>，其中<span class="math inline">\(\sigma_i\)</span>为信道矩阵<span class="math inline">\(H\)</span>的<strong>奇异值</strong>，<span class="math inline">\(\sigma_i^2\)</span>为<span class="math inline">\(H^*H\)</span>的<strong>特征值</strong>。</p><p>此时，2×2的MIMO图示可以简化为：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-0295e95d931f1a1090c2ccb3108b37f1_720w.webp" alt="简化的MIMO"><figcaption aria-hidden="true">简化的MIMO</figcaption></figure><h3 id="发射机如何得到预编码矩阵v">4.3 发射机如何得到预编码矩阵<span class="math inline">\(V\)</span></h3><p><strong>思考过程：</strong>接收机(UE)可以基于发射机(eNB)发送的特定的参考信号进行<strong>信道估计</strong>，得到<strong>信道矩阵</strong>。然而，预编码矩阵是在发射机(eNB侧)被需要，那么，<strong>发射机如何知道预编码矩阵V呢</strong>？概念上，<strong>接收机(UE侧)告知发射机(eNB侧)预编码矩阵</strong>。但是，<strong>上述方法不可行</strong>，因为，<strong>将整个预编码矩阵发送给eNB是一个巨大的开销</strong>。</p><p>3GPP，对此给出的做法如下：在标准化过程中，对无线电信道进行了广泛的调查，预先定义了一组矩阵，UE侧和eNB侧均已知这组矩阵。之后，UE基于信道估计选择一个最合适的预编码矩阵，然后通知eNB所选的预编码矩阵在CodeBook中的下标。</p><p>上述的描述，即为TM4，即带有反馈的MIMO：</p><figure><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/v2-308da06fad3f4952b9b8df042112e95b_720w.webp" alt="带有反馈的MIMO"><figcaption aria-hidden="true">带有反馈的MIMO</figcaption></figure><p>UE侧在具体的时刻选择最适合信道的CodeBook的步骤：</p><ol type="1"><li>计算CodeBook中每个元素的<span class="math inline">\(\Omega=W(H^HH)W^H\)</span>，其中，<span class="math inline">\(W\)</span>为CodeBook中的每个元素(预编码矩阵)，<span class="math inline">\(H\)</span>为传播矩阵；</li><li>选择<span class="math inline">\(\Omega_{min}\)</span>对应的<span class="math inline">\(W\)</span>作为预编码矩阵</li><li>将选择的<span class="math inline">\(W\)</span>在CodeBook中的下标(PMI)告知发射机</li></ol><h3 id="rank-indicator">4.4 Rank Indicator</h3><p>Rank Indicator是UE侧一种特殊的测量，得到的是Rank Index。</p><p>从实际的角度来看，Rank Indicator表明了MIMO的工作质量，如：对于一个2×2的MIMO，如果<span class="math inline">\(RI=2\)</span>，表示数据块有2个传输通道，即表明它以真正的MIMO方式运行，但是，如果<span class="math inline">\(RI=1\)</span>，表明数据块只有1个传输通道，即表示它实际只是在单天线通信，即2×2MIMO没有发挥出最佳效率。</p><p>从<strong>奇异值矩阵</strong>Σ中，我们可以得到RI。以2×2MIMO为例：<span class="math inline">\(\varSigma=\begin{bmatrix} \sigma_1 &amp; 0\\ 0 &amp; \sigma_2 \end{bmatrix}\)</span>，<span class="math inline">\(RI\)</span>等于<span class="math inline">\(\varSigma\)</span>中对角元素非0的个数。</p><p><strong>RI的物理意义</strong>：表示独立通信的信道数目。</p><p>如果<span class="math inline">\(RI=2\)</span>，表示<span class="math inline">\(\sigma_1≠0\)</span>且<span class="math inline">\(\sigma_2≠0\)</span>，即有2条独立的信道；</p><p>如果<span class="math inline">\(RI=1\)</span>，表示<span class="math inline">\(\sigma_1=0\)</span><span class="math inline">\(或\sigma_2=0\)</span>，即虽然有2根天线，但只有一个数据流在工作，意味着其中一根天线的信号完全丢失或被埋在噪声中，无法decode。</p><h3 id="条件数----正确估计mimo信道的真实性能">4.5 条件数 -- 正确估计MIMO信道的真实性能</h3><p>Rank Indicator只关注了奇异值矩阵中的<strong>非零元素的数目</strong>，但其中<strong>非零元素的数值大小</strong>也同样重要。</p><p>如，<span class="math inline">\(\varSigma_1=\begin{bmatrix} 2 &amp; 0\\ 0 &amp; 1 \end{bmatrix}\)</span>，<span class="math inline">\(\varSigma_1=\begin{bmatrix} 2 &amp; 0\\ 0 &amp; 0.1 \end{bmatrix}\)</span>，虽然两个奇异值矩阵的RI是一样的，但是他们对应的MIMO的性能是完全不同的，用<strong>条件数</strong>来衡量。</p><p><strong>条件数的定义</strong>：<span class="math inline">\(K(H)=\frac{\lambda_{max}}{\lambda_{min}}\begin{cases} 当K(H)\approx 1时为空间复用的最佳方法\\当K(H)\gg 1时不是空间复用的最佳方法 \\ \end{cases}\)</span></p><h1 id="二noma和ofdma的性能对比">二、NOMA和OFDMA的性能对比</h1><h2 id="noma采用的关键技术">1.NOMA采用的关键技术</h2><h3 id="串行干扰删除sic">1.1 串行干扰删除（SIC）</h3><p>在发送端，类似于CDMA系统，引入干扰信息可以获得更高的频谱效率，但是同样也会遇到多址干扰（MAI）的问题。关于消除多址干扰的问题，在研究第三代移动通信系统的过程中已经取得很多成果，串行干扰删除（SIC）也是其中之一。NOMA在接收端采用SIC接收机来消除干扰，可以很好地提高接收机的性能。</p><p><strong>串行干扰消除技术的基本思想是采用逐级消除干扰策略，在接收信号中对用户逐个进行判决，进行幅度恢复后，将该用户信号产生的多址干扰从接收信号中减去，并对剩下的用户再次进行判决，如此循环操作，直至消除所有的多址干扰。</strong></p><p>例如：在一个由3个用户共享的子信道上，<strong>叠加后的信号为</strong><span class="math inline">\(x=x_1+x_2+x_3\)</span>。其中，<span class="math inline">\(x_i(i=1,2,3)\)</span>分别代表3个用户信号，其中，信号功率<span class="math inline">\(x_1&lt;x_2&lt;x_3\)</span>，为了简单起见。<strong>在接收端，接收信号<span class="math inline">\(y_i=h_i·x+w_i\)</span></strong>。</p><p>其中，<span class="math inline">\(h_i\)</span>是信道系数，<span class="math inline">\(w_i\)</span>是信道高斯白噪声和小区干扰。则SIC接收机解调3个用户过程为：</p><ul><li>在第一级检测之前，<strong>先要将接收信号按照信号功率大小进行排序</strong>，这里由于<span class="math inline">\(x_3\)</span>信号功率最强，先要对<span class="math inline">\(x_3\)</span>进行判决，输出<span class="math inline">\(x_3\)</span>。然后恢复出对<span class="math inline">\(x_3\)</span>的信号估计值，从接收信号中减去<span class="math inline">\(x_3\)</span>的估计值，得到<span class="math inline">\(x_1+x_2\)</span>，然后将<span class="math inline">\(y_2=h_2·(x_1+x_2)+w_2\)</span>作为下一级输入。按照功率顺序依次执行相同的操作，最后先后输出<span class="math inline">\(x_2\)</span>和<span class="math inline">\(x_1\)</span>，完成对所有的用户信号检测。</li><li><strong>在SIC信号检测过程中，很重要的一点是用户检测的顺序。这里进行排序是根据用户的信号功率来进行的。在NOMA中，发送端会采用功率复用技术对不同的用户进行功率分配</strong>。通常，信道增益高的用户会少分配一些功率资源，而信道增益低的用户会多分配一些功率资源。到达接收端后，每个用户的信号功率会不一样，SIC接收机根据用户的信号功率进行排序，依次对不同的进行解调，同时达到区分用户的目的。</li><li>虽然，SIC技术有很好的信号检测性能，但要在NOMA中采用，有3个问题。首先，相对于传统的SIC接收机，NOMA中采用的SIC接收机要更复杂，要求具备更强的信号处理能力；其次，从上述过程可知，根据信号功率排的用户顺序决定了最佳的接收效果，而在实际过程中，用户的功率是不断变化的，这就要求SIC接收机不断地对用户功率进行排序；再次，从SIC结构图中可以看出，每一级处理都会产生一定的时延，在现实多级处理过程中，产生的时延很大。前一个问题的解决有赖于未来芯片处理能力的提升，而后两个问题则需要对相关的处理算法进行进一步的研究。</li></ul><h3 id="功率复用">1.2 功率复用</h3><p>SIC在接收端消除多址干扰（MAI），需要在接收信号中对用户进行判决来排出消除干扰的用户的先后顺序，<strong>而判决的依据就是用户信号功率大小。基站在发送端会对不同的用户分配不同的信号功率，来获取系统<mark>最大的性能增益</mark>，同时达到<mark>区分用户</mark>的目的，这就是功率复用技术</strong>。功率复用技术在其他几种传统的多址方案没有被充分利用，其不同于简单的功率控制，而是由基站遵循相关的算法来进行功率分配。</p><h3 id="不依赖用户反馈csi">1.3 不依赖用户反馈CSI</h3><p>在现实的蜂窝网中，因为流动性、反馈处理延迟等一些原因，通常用户并不能根据网络环境的变化反馈出实时有效的网络状态信息。虽然在目前，有很多技术已经不再那么依赖用户反馈信息就可以获得稳定的性能增益，但是采用了SIC技术的NOMA方案可以更好地适应这种情况，从而NOMA技术可以在高速移动场景下获得更好的性能，并能组建更好的移动节点回程链路。</p><h2 id="与cdma3g和ofdma4g相比noma性能的优势">2.与CDMA（3G）和OFDMA（4G）相比，NOMA性能的优势</h2><p>从上面的描述中我们也可以看出，NOMA虽然是一种新的技术，但是也融合了一些3G和4G的技术和思想。例如，OFDM是在4G中用到的，而SIC最初是在3G中用到的。</p><p>3G的多址技术采用的是直序扩频码分多址（CDMA）技术，采用非正交发送，所有用户共享一个信道，在接收端采用RAKE接收机。<strong>非正交传输有一个很严重的问题，就是远近效应</strong>，在3G中，人们采用<strong>功率控制技术</strong>在发送端对距离小区中心比较近的用户进行功率限制，<strong>保证在到达接收端每个用户的功率相当。</strong></p><p><strong>4G的多址技术采用的是基于OFDM的正交频分多址（OFDMA）技术，不同用户之间采用正交传输，所以远近效应不是那么明显，功率控制也不再是必需的了</strong>。在链路自适应技术上，4G采用了自适应编码（AMC）技术，可以根据链路状态信息自动调整调制编码方式，从而给用户提供最佳的传输速度，但是在一定程度上要依赖用户反馈的链路状态信息。</p><p>跟CDMA和OFDMA相比，<strong>NOMA子信道之间采用正交传输</strong>，不会存在跟3G一样明显的远近效应问题，多址干扰（MAI）问题也没那么严重；由于可以不依赖用户反馈的CSI信息，在采用AMC和功率复用技术后，应对各种多变的链路状态更加自如，即使在高速移动的环境下，依然可以提供很好地速率表现；<strong>同一子信道上可以由多个用户共享</strong>，跟4G相比，在保证传输速度的同时，可以提高频谱效率，这也是最重要的一点。</p><h2 id="相关代码">3.相关代码</h2><h3 id="主函数">3.1 主函数</h3><h4 id="参数">3.1.1 参数</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 参数</span><br>order_psk = [<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">16</span>,<span class="hljs-number">64</span>];      <span class="hljs-comment">% PSK符号阶数，2表示BPSK，4表示4PSK，以此类推</span><br><span class="hljs-keyword">for</span> order = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(order_psk)<br>    sym_total = <span class="hljs-number">2.048e4</span>*<span class="hljs-number">52</span>; <span class="hljs-comment">% 总符号数</span><br>    len_turbo = <span class="hljs-number">1280</span>;   <span class="hljs-comment">% Turbo码长</span><br>    bit_total = sym_total * <span class="hljs-built_in">log2</span>(order_psk(order));<br>    N_ofdma_u1 = <span class="hljs-number">26</span>;    <span class="hljs-comment">% OFDMA用户1的子载波数</span><br>    N_ofdma_u2 = <span class="hljs-number">26</span>;    <span class="hljs-comment">% OFDMA用户2的子载波数</span><br>    p1 = <span class="hljs-number">0.1</span>;           <span class="hljs-comment">% NOMA用户1的功率</span><br>    p2 = <span class="hljs-number">0.9</span>;           <span class="hljs-comment">% NOMA用户2的功率</span><br><br>    N_ofdm = <span class="hljs-number">64</span>;        <span class="hljs-comment">% OFDM子载波数</span><br>    N_data = <span class="hljs-number">52</span>;        <span class="hljs-comment">% 数据载波数</span><br>    <span class="hljs-comment">% N_data 表示的是实际用于数据传输的子载波数量，而 N_ofdm 表示的是整个 OFDM 符号中的所有子载波的总数量。</span><br>    <span class="hljs-comment">% 通常情况下，N_data 是 N_ofdm 的一个子集。</span><br>    N_GB = [<span class="hljs-number">4</span>; <span class="hljs-number">3</span>];      <span class="hljs-comment">% 载波间隔参数</span><br>    N_P = [<span class="hljs-number">12</span>; <span class="hljs-number">26</span>; <span class="hljs-number">40</span>; <span class="hljs-number">54</span>]; <span class="hljs-comment">% 导频参数</span><br>    CP = <span class="hljs-number">1</span>/<span class="hljs-number">4</span>;           <span class="hljs-comment">% CP占比</span><br><br>    Ts = <span class="hljs-number">1</span>/<span class="hljs-number">10000</span>;<br>    FD = <span class="hljs-number">500</span>;           <span class="hljs-comment">% 瑞利信道参数</span><br>    SNR = <span class="hljs-number">25</span>:<span class="hljs-number">1</span>:<span class="hljs-number">60</span>;           <span class="hljs-comment">% 信噪比 </span><br></code></pre></td></tr></table></figure><h4 id="参数合理性判断">3.1.2 参数合理性判断</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 参数合理性判断</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mod</span>(bit_total, len_turbo)~=<span class="hljs-number">0</span>)<br>    error(<span class="hljs-string">&#x27;总比特数必须是Turbo编码长度的整数倍&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">mod</span>((<span class="hljs-number">3</span>*len_turbo+<span class="hljs-number">12</span>)*bit_total/len_turbo, N_data)~=<span class="hljs-number">0</span>)<br>    error(<span class="hljs-string">&#x27;总比特数必须保证OFDM符号完整&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (N_ofdma_u1+N_ofdma_u2~=N_data)<br>    error(<span class="hljs-string">&#x27;OFDMA中两用户的子载波数目之和必须等于数据载波总数&#x27;</span>);<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> (p1+p2~=<span class="hljs-number">1</span>)<br>    error(<span class="hljs-string">&#x27;功率系数p1与p2之和必须等于1&#x27;</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h4 id="生成两个用户的发射符号序列加入turbo编码">3.1.3 生成两个用户的发射符号序列，加入Turbo编码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% 生成两个用户的发射符号序列，加入Turbo编码</span><br>[sym_seq_u1, bit_seq_u1] = data_gen(bit_total, len_turbo, order_psk(order));<br>[sym_seq_u2, bit_seq_u2] = data_gen(bit_total, len_turbo, order_psk(order));<br></code></pre></td></tr></table></figure><h4 id="noma编码和ofdma编码">3.1.4 NOMA编码和OFDMA编码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% NOMA和OFDMA</span><br>sym_seq_noma = noma_enc(sym_seq_u1, sym_seq_u2, p1, p2);<br><span class="hljs-comment">% 对两用户数据进行NOMA编码</span><br>sym_seq_ofdma = ofdma_enc(sym_seq_u1, sym_seq_u2, N_ofdma_u1, N_ofdma_u2);<br><span class="hljs-comment">% 对两用户数据进行OFDMA编码</span><br></code></pre></td></tr></table></figure><h4 id="ofdm调制">3.1.5 OFDM调制</h4><p>创建OFDM调制器：</p><p><code>comm.OFDMModulator</code> 是 MATLAB 中用于创建 <strong>OFDM（正交频分多址）调制器</strong>对象的通信工具箱中的一个类。OFDM 调制器通常包括以下功能和属性（以第一个NOMA调制器为例）：</p><ul><li><code>'FFTLength',N_ofdm</code>：设置了 FFT（快速傅里叶变换）的长度为 <code>N_ofdm</code>。FFT长度决定了每个 OFDM 符号中使用的子载波数量。</li><li><code>'NumGuardBandCarriers',N_GB</code>：设置了保护带宽子载波数量为 <code>N_GB</code>。保护带宽是指在每个 OFDM 符号的两端分配的用于保护子载波的数量，通常用于减小符号之间的干扰。</li><li><code>'PilotInputPort',true</code>：启用了插入导频的功能。</li><li><code>'PilotCarrierIndices',N_P</code>：设置了导频（Pilot）子载波的索引。导频子载波用于信道估计和补偿，在信道估计过程中，将发送导频信号并通过接收到的信号与其进行比较以估计信道特性。</li><li><code>'NumSymbols',num_ofdmsym_noma</code>：设置了要生成的 OFDM 符号的数量，这里使用了之前计算得到的 <code>num_ofdmsym_noma</code>。</li><li><code>'CyclicPrefixLength',N_ofdm*CP</code>：设置了循环前缀（Cyclic Prefix）的长度为 <code>N_ofdm*CP</code>。循环前缀是在每个 OFDM 符号的头部插入的一段重复的信号，用于抵消多径传播引起的符号间的码间干扰。</li><li><code>'InsertDCNull',true</code>：启用了插入直流（DC）空子载波的功能。直流空子载波用于消除直流偏移，以提高系统的性能。</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs matlab">num_ofdmsym_noma = <span class="hljs-built_in">length</span>(sym_seq_noma)/N_data;<br>mod_ofdm_noma = comm.OFDMModulator(...<br><span class="hljs-string">&#x27;FFTLength&#x27;</span>,N_ofdm,...<br><span class="hljs-string">&#x27;NumGuardBandCarriers&#x27;</span>,N_GB,...<br><span class="hljs-string">&#x27;PilotInputPort&#x27;</span>,<span class="hljs-built_in">true</span>,...<br><span class="hljs-string">&#x27;PilotCarrierIndices&#x27;</span>,N_P,...<br><span class="hljs-string">&#x27;NumSymbols&#x27;</span>,num_ofdmsym_noma,...<br><span class="hljs-string">&#x27;CyclicPrefixLength&#x27;</span>,N_ofdm*CP,...<br><span class="hljs-string">&#x27;InsertDCNull&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 构造NOMA的OFDM调制器</span><br>num_ofdmsym_ofdma = <span class="hljs-built_in">length</span>(sym_seq_ofdma)/N_data;<br>mod_ofdm_ofdma = comm.OFDMModulator(...<br><span class="hljs-string">&#x27;FFTLength&#x27;</span>,N_ofdm,...<br><span class="hljs-string">&#x27;NumGuardBandCarriers&#x27;</span>,N_GB,...<br><span class="hljs-string">&#x27;PilotInputPort&#x27;</span>,<span class="hljs-built_in">true</span>,...<br><span class="hljs-string">&#x27;PilotCarrierIndices&#x27;</span>,N_P,...<br><span class="hljs-string">&#x27;NumSymbols&#x27;</span>,num_ofdmsym_ofdma,...<br><span class="hljs-string">&#x27;CyclicPrefixLength&#x27;</span>,N_ofdm*CP,...<br><span class="hljs-string">&#x27;InsertDCNull&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 构造OFDMA的OFDM调制器</span><br></code></pre></td></tr></table></figure><p>OFDM调制：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">tx_noma = ofdm_tx(sym_seq_noma, mod_ofdm_noma);<br>tx_ofdma = ofdm_tx(sym_seq_ofdma, mod_ofdm_ofdma);<br><span class="hljs-comment">% OFDM调制</span><br></code></pre></td></tr></table></figure><h4 id="高斯白噪声信道">3.1.6 高斯白噪声信道</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> snr = <span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(SNR)<br>    <span class="hljs-comment">%% 高斯白噪声信道</span><br>    cawgn = comm.AWGNChannel(<span class="hljs-string">&#x27;NoiseMethod&#x27;</span>, <span class="hljs-string">&#x27;Signal to noise ratio (SNR)&#x27;</span>);<br>    <span class="hljs-comment">% 创建了一个 AWGN（加性高斯白噪声）信道对象 cawgn，并将噪声的添加方式设置为基于信噪比（SNR）的方法。</span><br>    cawgn.SNR = SNR(snr);<br>    rx_noma = step(cawgn, tx_noma);<span class="hljs-comment">% 使用了 step 方法来模拟信道传输过程，其中 step 方法的参数是信道对象和发送信号，返回值是接收到的带有噪声的信号。</span><br>    rx_ofdma = step(cawgn, tx_ofdma);<br>    <span class="hljs-comment">% 接收信号经过加性高斯白噪声信道加入高斯噪声</span><br></code></pre></td></tr></table></figure><h4 id="ofdm解调">3.1.7 OFDM解调</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">%% OFDM解调</span><br>sym_seq_noma_mat = ofdm_rx(rx_noma, mod_ofdm_noma);<br>sym_seq_noma = <span class="hljs-built_in">reshape</span>(sym_seq_noma_mat, <span class="hljs-built_in">numel</span>(sym_seq_noma_mat), <span class="hljs-number">1</span>);<br><span class="hljs-comment">% 将解调后的数据符号序列矩阵重塑成列向量，以便后续的处理</span><br>sym_seq_ofdma_mat = ofdm_rx(rx_ofdma, mod_ofdm_ofdma);<br>sym_seq_ofdma = <span class="hljs-built_in">reshape</span>(sym_seq_ofdma_mat, <span class="hljs-built_in">numel</span>(sym_seq_ofdma_mat), <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h4 id="noma和ofdma解码及绘图">3.1.8 NOMA和OFDMA解码及绘图</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs matlab">        <span class="hljs-comment">%% NOMA和OFDMA解码</span><br>        <span class="hljs-keyword">if</span> (p1&gt;p2)<br>            [bit_u1, bit_u2] = noma_dec(sym_seq_noma, len_turbo, order_psk(order), p1, p2);<br>        <span class="hljs-keyword">else</span><br>            [bit_u2, bit_u1] = noma_dec(sym_seq_noma, len_turbo, order_psk(order), p2, p1);<br>        <span class="hljs-keyword">end</span><br><br>        [n1,r1(order, snr)] = biterr(bit_u1,bit_seq_u1);<br>        <span class="hljs-comment">% 解构赋值语法，将biterr函数的第一个返回值赋给变量n1，而将第二个返回值赋给矩阵r1中的特定位置，n1变量将包含比特误码数，而r1(order, snr)将包含比特误码率。</span><br>        [n2,r2(order, snr)] = biterr(bit_u2,bit_seq_u2);<br>        <span class="hljs-comment">% 按照功率顺序解码用户1和用户2的符号序列</span><br>        <br>        [bit_u11, bit_u22] = ofdma_dec(sym_seq_ofdma, len_turbo, order_psk(order), N_ofdma_u1, N_ofdma_u2);<br><br>        [n11,r11(order,snr)] = biterr(bit_u11,bit_seq_u1(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(bit_u11)));<br>        [n22,r22(order,snr)] = biterr(bit_u22,bit_seq_u2(<span class="hljs-number">1</span>:<span class="hljs-built_in">length</span>(bit_u22)));<br>        [r1(order,snr), r2(order,snr), r11(order,snr), r22(order,snr)]<br>    <span class="hljs-keyword">end</span><br>    <br><span class="hljs-keyword">end</span><br><span class="hljs-comment">% </span><br>save(<span class="hljs-string">&#x27;ber.mat&#x27;</span>,<span class="hljs-string">&#x27;r1&#x27;</span>,<span class="hljs-string">&#x27;r2&#x27;</span>,<span class="hljs-string">&#x27;r11&#x27;</span>,<span class="hljs-string">&#x27;r22&#x27;</span>);<br>plot_ber(order_psk, SNR, N_data, p1, p2, N_ofdma_u1, N_ofdma_u2);<br></code></pre></td></tr></table></figure><h3 id="生成两个用户的发射符号序列加入turbo编码-1">3.2 生成两个用户的发射符号序列，加入Turbo编码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ symbol_seq, bit_seq ]</span> = <span class="hljs-title">data_gen</span><span class="hljs-params">( bit_num, len_turbo, M )</span></span><br><span class="hljs-comment">% 输入总比特数、Turbo码长和PSK阶数，生成符号序列，同时返回原始比特序列。</span><br><span class="hljs-comment">% 输出一个包含两个元素的元组，其中第一个元素是经过 PSK 调制后的符号序列，第二个元素是原始的随机生成的二进制比特序列。</span><br>bit_seq = <span class="hljs-built_in">round</span>(<span class="hljs-built_in">rand</span>(bit_num, <span class="hljs-number">1</span>));<br><span class="hljs-comment">% 生成大小为 bit_num 的随机比特序列</span><br><br>[turbo_seq] = turbo_enc(bit_seq, len_turbo);<br><span class="hljs-comment">% Turbo编码，编码后长度为3*len+12</span><br><br>hModulator = comm.PSKModulator(M,<span class="hljs-string">&#x27;BitInput&#x27;</span>,<span class="hljs-built_in">true</span>);<br><span class="hljs-comment">% 创建了一个 PSK 调制器对象，用于将输入的二进制序列转换为 PSK 调制信号。</span><br><span class="hljs-comment">% PSK 调制器在数字通信中经常用于将数字数据转换为调制信号，用于传输到通信信道中。</span><br>hModulator.PhaseOffset = <span class="hljs-built_in">pi</span>/M;<br><span class="hljs-comment">% 将 PSK 调制器对象的相位偏移属性设置为 π/M，以确保调制信号的相位偏移符合预期，并与接收端的解调器相匹配。</span><br>symbol_seq = step(hModulator, turbo_seq);<br><span class="hljs-comment">% 进行PSK调制</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Turbo编码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ turbo_seq ]</span> = <span class="hljs-title">turbo_enc</span><span class="hljs-params">( bit_seq, len )</span></span><br><span class="hljs-comment">% 对输入比特序列进行Turbo编码</span><br><br>bit_mat = <span class="hljs-built_in">reshape</span>(bit_seq, len, <span class="hljs-built_in">numel</span>(bit_seq)/len);<br><span class="hljs-comment">% 将二进制序列bit_seq重新塑造</span><br>turbo_seq = [];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(bit_seq)/len<br>    turbo_seq0 = lteTurboEncode(bit_mat(:,<span class="hljs-built_in">i</span>));<br>    <span class="hljs-comment">% 对 bit_mat 中的第 i 列数据进行 Turbo 编码</span><br>    turbo_seq = [turbo_seq; turbo_seq0];<br>    <span class="hljs-comment">% 经过每次循环迭代将一个长度为 len 的子序列经过 Turbo 编码后的结果存储到 turbo_seq 中</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="noma编码">3.3 NOMA编码</h3><p>用户1的信号 <code>seq_u1</code> 被放大到功率水平 <code>p1</code>，用户2的信号 <code>seq_u2</code> 被放大到功率水平 <code>p2</code>，然后这两个信号相加得到 <code>seq_noma</code>，以便在 NOMA 系统中进行传输。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ seq_noma ]</span> = <span class="hljs-title">noma_enc</span><span class="hljs-params">( seq_u1, seq_u2, p1, p2 )</span></span><br><span class="hljs-comment">% 将用户1和用户2的数据序列按照p1和p2的功率分配合成NOMA序列</span><br><br>seq_noma = <span class="hljs-built_in">sqrt</span>(p1) * seq_u1 + <span class="hljs-built_in">sqrt</span>(p2) * seq_u2;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdma编码">3.4 OFDMA编码</h3><p>根据给定的子载波分配，将多个用户的数据合成为一个 OFDMA 序列，以便在 OFDMA 系统中进行传输。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ seq_ofdma ]</span> = <span class="hljs-title">ofdma_enc</span><span class="hljs-params">( seq_u1, seq_u2, N_u1, N_u2 )</span></span><br><span class="hljs-comment">% 将用户1和用户2的数据分别按照N_u1和N_u2的子载波数合成OFDMA序列，只保留部分序列。</span><br><br>sym_total = <span class="hljs-built_in">length</span>(seq_u1);<br>sym_u1 = sym_total * (N_u1/(N_u1+N_u2));<br>sym_u2 = sym_total * (N_u2/(N_u1+N_u2));<br>seq_u1_r = seq_u1(<span class="hljs-number">1</span>:sym_u1);<br>seq_u2_r = seq_u2(<span class="hljs-number">1</span>:sym_u2);<br><span class="hljs-comment">% 截取用户1和用户2的部分序列，保证序列总长度和NOMA的一致</span><br><br>mat_u1_r = <span class="hljs-built_in">reshape</span>(seq_u1_r, N_u1, <span class="hljs-built_in">numel</span>(seq_u1_r)/N_u1);<br>mat_u2_r = <span class="hljs-built_in">reshape</span>(seq_u2_r, N_u2, <span class="hljs-built_in">numel</span>(seq_u1_r)/N_u2);<br><br>mat_ofdma = [mat_u1_r; mat_u2_r];<br>seq_ofdma = <span class="hljs-built_in">reshape</span>(mat_ofdma, <span class="hljs-built_in">numel</span>(mat_ofdma), <span class="hljs-number">1</span>);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdm调制-1">3.5 OFDM调制</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ tx_data ]</span> = <span class="hljs-title">ofdm_tx</span><span class="hljs-params">( sym_seq, mod_ofdm )</span></span><br><br><span class="hljs-comment">% OFDM调制，mod为调制器</span><br><br>N_data = mod_ofdm.FFTLength - sum(mod_ofdm.NumGuardBandCarriers) - <span class="hljs-number">1</span> - <span class="hljs-built_in">length</span>(mod_ofdm.PilotCarrierIndices);<br><span class="hljs-comment">% 计算 OFDM 符号中用于传输数据的子载波数量</span><br>N_P = <span class="hljs-built_in">length</span>(mod_ofdm.PilotCarrierIndices);<br>num_ofdmsym = mod_ofdm.NumSymbols;<br><br>pilot_seq = <span class="hljs-built_in">complex</span>(<span class="hljs-built_in">rand</span>(N_P, num_ofdmsym),<span class="hljs-built_in">rand</span>(N_P, num_ofdmsym));<br><span class="hljs-comment">% 生成导频序列，每一列代表一个 OFDM 符号中的导频序列。</span><br>sym_mat = <span class="hljs-built_in">reshape</span>(sym_seq, N_data, num_ofdmsym);<br><span class="hljs-comment">% 重塑数据符号序列，每一列代表一个 OFDM 符号中的数据符号序列。</span><br><br>tx_data = step(mod_ofdm,sym_mat,pilot_seq);<br><span class="hljs-comment">% 调用了 mod_ofdm 对象的 step 方法。在调用过程中，OFDM 调制器将对每一列的数据符号序列和导频序列进行处理，并将它们合并成最终的 OFDM 符号序列 tx_data。</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdm解调-1">3.6 OFDM解调</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ sym_seq ]</span> = <span class="hljs-title">ofdm_rx</span><span class="hljs-params">( rx_data, mod)</span></span><br><span class="hljs-comment">% OFDM解调，mod为调制器</span><br><br>demod = comm.OFDMDemodulator(<span class="hljs-built_in">mod</span>);<br><span class="hljs-comment">% 创建了一个 OFDM 解调器对象 demod</span><br>[sym_seq, ~] = step(demod,rx_data);<br><span class="hljs-comment">% 解构赋值语法，[sym_seq, ~] 表示将 step 方法返回的第一个值赋给变量 sym_seq，而第二个值则被忽略（用 ~ 表示）</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="noma解码">3.7 NOMA解码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ bit_u1, bit_u2 ]</span> = <span class="hljs-title">noma_dec</span><span class="hljs-params">( sym_seq_noma, len, M, p1, p2 )</span></span><br><span class="hljs-comment">% 按信噪比依次解码用户1序列和用户2序列</span><br><br>sym_seq_u1 = sym_seq_noma/<span class="hljs-built_in">sqrt</span>(p1);<br><span class="hljs-comment">% 首先，将接收到的 NOMA 符号序列除以用户1的功率的平方根，以进行功率归一化</span><br>hDemod = comm.PSKDemodulator(M, <span class="hljs-string">&#x27;BitOutput&#x27;</span>, <span class="hljs-built_in">true</span>, <span class="hljs-string">&#x27;PhaseOffset&#x27;</span>,<span class="hljs-built_in">pi</span>/M);<br><span class="hljs-comment">% 创建了一个 PSK 解调器对象，用于将接收到的归一化后的符号序列解调为比特序列</span><br>pskdemod_u1 = step(hDemod, sym_seq_u1);<br><span class="hljs-comment">% 使用 PSK 解调器对归一化后的符号序列进行解调，得到用户1的比特序列</span><br><span class="hljs-comment">% 用户1PSK解调</span><br><br>bit_u1 = turbo_dec(pskdemod_u1, len);<br><span class="hljs-comment">% 用户1Turbo解码</span><br><br>turbo_seq_u1r = turbo_enc(bit_u1, len);<br>hMod_u1 = comm.PSKModulator(M,<span class="hljs-string">&#x27;BitInput&#x27;</span>,<span class="hljs-built_in">true</span>);<br>hMod_u1.PhaseOffset = <span class="hljs-built_in">pi</span>/M;<br>sym_seq_u1r = step(hMod_u1, turbo_seq_u1r);<br><span class="hljs-comment">% 用户1信号重构</span><br><br><br>sym_seq_u2 = (sym_seq_noma - sym_seq_u1r * <span class="hljs-built_in">sqrt</span>(p1))/<span class="hljs-built_in">sqrt</span>(p2);<br><span class="hljs-comment">% 用户2信号</span><br>pskdemod_u2 = step(hDemod, sym_seq_u2);<br><span class="hljs-comment">% 用户2PSK解调</span><br>bit_u2 = turbo_dec(pskdemod_u2, len);<br><span class="hljs-comment">% 用户2Turbo解码</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>Turbo解码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ data_seq ]</span> = <span class="hljs-title">turbo_dec</span><span class="hljs-params">( turbo_seq, len )</span></span><br><span class="hljs-comment">% Turbo解码</span><br><br>len_p = <span class="hljs-number">3</span>*len+<span class="hljs-number">12</span>;<br>turbo_mat = <span class="hljs-built_in">reshape</span>(turbo_seq, len_p, <span class="hljs-built_in">numel</span>(turbo_seq)/len_p);<br>data_seq = [];<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span> = <span class="hljs-number">1</span>:<span class="hljs-built_in">numel</span>(turbo_seq)/len_p<br>    data_seq0 = lteTurboDecode(turbo_mat(:,<span class="hljs-built_in">i</span>));<br>    data_seq = [data_seq; data_seq0];<br><span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="ofdma解码">3.8 OFDMA解码</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ bit_u1, bit_u2 ]</span> = <span class="hljs-title">ofdma_dec</span><span class="hljs-params">( sym_seq, len, M, N1, N2 )</span></span><br><span class="hljs-comment">% 根据用户1和用户2的子载波数进行OFDMA解码</span><br><br>sym_mat = <span class="hljs-built_in">reshape</span>(sym_seq, N1+N2, <span class="hljs-built_in">numel</span>(sym_seq)/(N1+N2));<br><span class="hljs-comment">% 首先，将接收到的OFDMA符号序列 sym_seq 重塑为一个矩阵 sym_mat,这个矩阵表示了每个OFDMA符号中的用户1和用户2的符号序列</span><br>sym_mat1 = sym_mat(<span class="hljs-number">1</span>:N1,:);<br><span class="hljs-comment">% 从重塑后的矩阵中提取出用户1的符号序列</span><br>sym_mat2 = sym_mat(N1+<span class="hljs-number">1</span>:<span class="hljs-keyword">end</span>,:);<br><br>sym_seq1 = <span class="hljs-built_in">reshape</span>(sym_mat1, <span class="hljs-built_in">numel</span>(sym_mat1), <span class="hljs-number">1</span>);<br><span class="hljs-comment">% 将用户1的符号序列重新展开为列向量</span><br>sym_seq2 = <span class="hljs-built_in">reshape</span>(sym_mat2, <span class="hljs-built_in">numel</span>(sym_mat2), <span class="hljs-number">1</span>);<br><br>hDemod = comm.PSKDemodulator(M, <span class="hljs-string">&#x27;BitOutput&#x27;</span>, <span class="hljs-built_in">true</span>, <span class="hljs-string">&#x27;PhaseOffset&#x27;</span>,<span class="hljs-built_in">pi</span>/M);<br>pskdemod_u1 = step(hDemod, sym_seq1);<br><span class="hljs-comment">% 使用PSK解调器对用户1的符号序列进行解调，得到用户1的比特序列</span><br>bit_u1 = turbo_dec(pskdemod_u1, len);<br><span class="hljs-comment">% 将用户1的比特序列输入到Turbo解码器中进行解码，得到最终的用户1比特序列</span><br>pskdemod_u2 = step(hDemod, sym_seq2);<br>bit_u2 = turbo_dec(pskdemod_u2, len);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="绘图">3.9 绘图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[ flag ]</span> = <span class="hljs-title">plot_ber</span><span class="hljs-params">( M, SNR, N_data, p1,p2,N1,N2 )</span></span><br><span class="hljs-comment">% 画BER的图</span><br><br>load(<span class="hljs-string">&#x27;ber.mat&#x27;</span>);<br>SNR_ad = SNR - <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(<span class="hljs-built_in">sqrt</span>(N_data));<br><span class="hljs-comment">% 计算了一个调整后的信噪比，这种调整通常用于匹配预先计算的数据与实际情况的场景</span><br><span class="hljs-comment">%% NOMA bpsk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">1</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">1</span>)));<br><span class="hljs-comment">% 分别计算 NOMA 系统中用户 1 和用户 2 的信噪比。这里使用了之前计算得到的调整后的 SNR（SNR_ad），并根据各自的功率分配（p1 和 p2）以及调制方案的比特数 M(1) 来计算</span><br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br><span class="hljs-comment">% 类似地，计算了 OFDMA 系统中用户 1 和用户 2 的信噪比，但使用的调制方案为 M(2)</span><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">1</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">1</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">2</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">2</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br><span class="hljs-comment">% semilogy 函数用于绘制双对数坐标系下的曲线。</span><br><span class="hljs-comment">% 它的前两个参数分别是 x 轴和 y 轴的值，即信噪比和比特误码率。</span><br><span class="hljs-comment">% -ob、-vb、-or 和 -vr 是曲线的样式，分别表示蓝色圆点、绿色圆点、红色圆点和紫色圆点。</span><br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-BPSK&#x27;</span>);<br>xlim([<span class="hljs-number">10</span> <span class="hljs-number">25</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-comment">%% NOMA-4psk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">2</span>)));<br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">4</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">4</span>)));<br><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">2</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">2</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">4</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">4</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-4PSK&#x27;</span>);<br>xlim([<span class="hljs-number">10</span> <span class="hljs-number">32</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-comment">%% NOMA 8psk</span><br><span class="hljs-built_in">figure</span>;<br><br>SNR_u1_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">3</span>)));<br>SNR_u2_noma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>(p2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">3</span>)));<br>SNR_u1_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N1/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">5</span>)));<br>SNR_u2_ofdma = SNR_ad + <span class="hljs-number">10</span>*<span class="hljs-built_in">log10</span>((N1+N2)/N2/<span class="hljs-built_in">log2</span>(M(<span class="hljs-number">5</span>)));<br><br>semilogy(SNR_u1_noma, r1(<span class="hljs-number">3</span>,:),<span class="hljs-string">&#x27;-ob&#x27;</span>);<br><span class="hljs-built_in">hold</span> on;<br>semilogy(SNR_u2_noma, r2(<span class="hljs-number">3</span>,:),<span class="hljs-string">&#x27;-vb&#x27;</span>);<br>semilogy(SNR_u1_ofdma, r11(<span class="hljs-number">5</span>,:), <span class="hljs-string">&#x27;-or&#x27;</span>);<br>semilogy(SNR_u2_ofdma, r22(<span class="hljs-number">5</span>,:), <span class="hljs-string">&#x27;-vr&#x27;</span>);<br>box on;<br>grid on;<br><br><span class="hljs-built_in">legend</span> (<span class="hljs-string">&#x27;NOMA用户1&#x27;</span>,<span class="hljs-string">&#x27;NOMA用户2&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户1&#x27;</span>,<span class="hljs-string">&#x27;OFDMA用户2&#x27;</span>,<span class="hljs-string">&#x27;Location&#x27;</span>,<span class="hljs-string">&#x27;southwest&#x27;</span>);<br>title(<span class="hljs-string">&#x27;NOMA-8PSK&#x27;</span>);<br>xlim([<span class="hljs-number">15</span> <span class="hljs-number">45</span>]);<br>ylim([<span class="hljs-number">1e-4</span> <span class="hljs-number">1</span>]);<br><br>xlabel(<span class="hljs-string">&#x27;Eb/N0&#x27;</span>);<br>ylabel(<span class="hljs-string">&#x27;BER&#x27;</span>);<br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h2 id="仿真结果">4.仿真结果</h2><p>BPSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-BPSK.jpeg" alt="BPSK时NOMA与OFDMA的误比特率对比" style="zoom: 80%;"></p><p>4PSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-4PSK.jpeg" alt="4PSK时NOMA与OFDMA的误比特率对比" style="zoom:80%;"></p><p>8PSK：</p><p><img src="/2024/02/18/%E7%A7%BB%E5%8A%A8%E9%80%9A%E4%BF%A1/NOMA-8PSK.png" alt="8PSK时NOMA与OFDMA的误比特率对比" style="zoom: 80%;"></p>]]></content>
    
    
    <categories>
      
      <category>毕业设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>移动通信</tag>
      
      <tag>非正交多址</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研数学</title>
    <link href="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>2024/1/12 13:40 这些知识点是真题中的易错点，是在我做完1998到2023年的数一真题，总结出我在真题中做错的题目所涉及的知识点，大多数是因为相应知识点记不熟或者理解不到位，如果能将下面的知识点记牢，对提升数学成绩有很大帮助。</p><p>2024/1/18 10:24 我的建议是在完成数学前两轮复习后，准备开始做真题前再开始看这份知识点整理。</p><h1 id="一高等数学">一、高等数学</h1><h2 id="数列极限">1.数列极限</h2><h3 id="数学归纳法">1.1 数学归纳法</h3><p>法一</p><ol type="1"><li>验证<span class="math inline">\(n=1\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>假设<span class="math inline">\(n=k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>证明<span class="math inline">\(n=k+1\)</span>时，命题<span class="math inline">\(f_n\)</span>正确。</li></ol><p>故命题正确</p><p>法二</p><ol type="1"><li>验证<span class="math inline">\(n=1\)</span>和<span class="math inline">\(n=2\)</span>时，命题<span class="math inline">\(f_n\)</span>都正确；</li><li>假设<span class="math inline">\(n&lt;k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确；</li><li>证明<span class="math inline">\(n=k\)</span>时，命题<span class="math inline">\(f_n\)</span>正确。</li></ol><p>故命题正确</p><h3 id="结论">1.2 结论</h3><p>单调不一定连续；收敛不一定单调。</p><h3 id="一些比较">1.3 一些比较</h3><p><span class="math inline">\((\ln n)^n\)</span>比<span class="math inline">\(n\)</span>要大；</p><p><span class="math inline">\((\ln n)^\alpha\)</span>比<span class="math inline">\(n\)</span>要小。</p><h2 id="一元函数微分学">2.一元函数微分学</h2><h3 id="极值点与拐点的重要结论">2.1 极值点与拐点的重要结论</h3><p>曲线的可导点不同时为极值点和拐点，不可导点可同时为极值点和拐点。</p><p>设<span class="math inline">\(f(x)=(x-a)^ng(x)(n&gt;1)\)</span>，且<span class="math inline">\(g(a)≠0\)</span>，当<span class="math inline">\(n\)</span>为偶数时，<span class="math inline">\(x=a\)</span>是<span class="math inline">\(f(x)\)</span>的极值点；当<span class="math inline">\(n\)</span>为奇数时，<span class="math inline">\((a,0)\)</span>是<span class="math inline">\(f(x)\)</span>的拐点。</p><p>设<span class="math inline">\(f(x)=(x-a_1)^{n_1}(x-a_2)^{n_2}\cdots(x-a_k)^{n_k}\)</span>，其中<span class="math inline">\(n_i\)</span>是正整数，<span class="math inline">\(a_i\)</span>是实数且<span class="math inline">\(a_i\)</span>两两不等。记<span class="math inline">\(k_1\)</span>为<span class="math inline">\(n_i=1\)</span>的个数，<span class="math inline">\(k_2\)</span>为<span class="math inline">\(n_i&gt;1\)</span>且<span class="math inline">\(n_i\)</span>为偶数的个数，<span class="math inline">\(k_3\)</span>为<span class="math inline">\(n_i&gt;1\)</span>且<span class="math inline">\(n_i\)</span>为奇数的个数。则<span class="math inline">\(f(x)\)</span>的极值点个数为<span class="math inline">\(k_1+2k_2+k_3-1\)</span>，拐点个数为<span class="math inline">\(k_1+2k_2+3k_3-2\)</span>。</p><h3 id="结论-1">2.2 结论</h3><p>不能以函数在一点的导数符号来确定函数在一个区间上的单调性。</p><h3 id="微分">2.3 微分</h3><p><span class="math inline">\(\Delta y=A\Delta x+o(\Delta x)\)</span>，其中<span class="math inline">\(A\)</span>与<span class="math inline">\(\Delta x\)</span>无关，则称<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x\)</span>处可微。</p><p><span class="math inline">\(A\Delta x\)</span>称为<span class="math inline">\(y=f(x)\)</span>在点<span class="math inline">\(x\)</span>处相应于<span class="math inline">\(\Delta x\)</span>的微分，记作<span class="math inline">\(dy\)</span>或<span class="math inline">\(d[f(x)]\)</span>，<span class="math inline">\(dy=A\Delta x=Adx\)</span>。 <span class="math display">\[A\Delta x=\begin{cases}dy \\d[f(x)]\\微分(\Delta x的微分)\\线性主部(\Delta y的线性主部)\end{cases}\]</span></p><h3 id="反函数的微分特点">2.4 反函数的微分特点</h3><p><span class="math inline">\(x_y&#39;=\frac{1}{y_x&#39;}\)</span></p><p><span class="math inline">\(y_x&#39;=\frac{dy}{dx}=\frac{1}{\frac{dx}{dy}}=\frac{1}{x_y&#39;}\)</span></p><p><span class="math inline">\(y_{xx}&#39;&#39;=\frac{d^2y}{dx^2}=\frac{d(\frac{dy}{dx})}{dx}=\frac{d(\frac{1}{x_y&#39;})}{dx}=\frac{d(\frac{1}{x_y&#39;})}{dy}·\frac{dy}{dx}=[-\frac{x_{yy}&#39;&#39;}{(x_y&#39;)^2}]·\frac{1}{x_y&#39;}=-\frac{x_{yy}&#39;&#39;}{(x_y&#39;)^3}\)</span></p><blockquote><p>不用背，可以自己推</p></blockquote><h2 id="一元函数积分学">3.一元函数积分学</h2><h3 id="一些常用不定积分">3.1 一些常用不定积分</h3><p><span class="math inline">\(\int\frac{dx}{cosx}=\int secxdx=ln|secx+tanx|+C\)</span></p><p><span class="math inline">\(\int\frac{dx}{sinx}=\int cscxdx=ln|cscx-cotx|+C\)</span></p><p><span class="math inline">\(\int\frac{1}{\sqrt{x^2+a^2}}dx=ln(x+\sqrt{x^2+a^2})+C\)</span></p><p><span class="math inline">\(\int\frac{1}{\sqrt{x^2-a^2}}dx=ln|x+\sqrt{x^2-a^2}|+C\)</span></p><h3 id="弧长公式">3.2 弧长公式</h3><p>直角坐标方程：<span class="math inline">\(S=\int_{a}^{b}\sqrt{1+[y&#39;(x)]^2}dx\)</span></p><p>参数方程：<span class="math inline">\(S=\int_{\alpha}^{\beta}\sqrt{[x&#39;(t)]^2+[y&#39;(t)]^2}dt\)</span></p><p>极坐标方程：<span class="math inline">\(S=\int_{\alpha}^{\beta}\sqrt{[r(\theta)]^2+[r&#39;(\theta)]^2}d\theta\)</span></p><h3 id="一个定积分">3.3 一个定积分</h3><p><span class="math inline">\(\int_{0}^{+\infty}x^2e^{-x^2}dx=\frac{\sqrt{\pi}}{4}\)</span></p><p><span class="math inline">\(\int x^2e^{-x^2}dx=\int x·x·e^{-x^2}dx=\int -\frac{x}{2}d(e^{-x^2})=e^{-x^2}·(-\frac{x}{2})+\frac{1}{2}\int e^{-x^2}dx\)</span></p><p><span class="math inline">\(\int_{0}^{+\infty} x^2e^{-x^2}dx=e^{-x^2}·(-\frac{x}{2})|_0^{+\infty}+\frac{1}{2}\int_{0}^{+\infty} e^{-x^2}dx=\frac{\sqrt{\pi}}{4}\)</span></p><h3 id="结论-2">3.4 结论</h3><p><span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上可积，则<span class="math inline">\(F(x)=\int_{a}^{x}f(t)dt\)</span>在<span class="math inline">\([a,b]\)</span>上连续；</p><p><span class="math inline">\(f(x)\)</span>在<span class="math inline">\([a,b]\)</span>上连续，则<span class="math inline">\(F(x)=\int_{a}^{x}f(t)dt\)</span>在<span class="math inline">\([a,b]\)</span>上可导。</p><h3 id="换元法">3.5 换元法</h3><p>令<span class="math inline">\(k=\begin{cases}x=rcos\theta \\y=rsin\theta\end{cases}\)</span></p><p>则<span class="math inline">\(\iint_{DXY}f(x,y)dxdy=\iint_{Dr\theta}f(rcos\theta,rsin\theta)\begin{Vmatrix} \frac{\partial x}{\partial r} &amp; \frac{\partial x}{\partial \theta}\\ \frac{\partial y}{\partial r} &amp; \frac{\partial y}{\partial \theta} \end{Vmatrix}drd\theta\)</span></p><blockquote><p>两条竖线分别是行列式和绝对值的意思</p></blockquote><h2 id="多元函数微分学">4.多元函数微分学</h2><h3 id="隐函数求导法">4.1 隐函数求导法</h3><p>设<span class="math inline">\(F(x,y,z)=0\)</span>，<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>满足<span class="math inline">\(F(P_0)=0\)</span>，<mark><span class="math inline">\(F&#39;_z(P_0)≠0\)</span></mark>，则在点<span class="math inline">\(P_0\)</span>的某邻域内可确定<span class="math inline">\(z=z(x,y)\)</span>，且有<span class="math inline">\(\frac{\partial z}{\partial x}=-\frac{F_x&#39;}{F_z&#39;}\)</span>，<span class="math inline">\(\frac{\partial z}{\partial y}=-\frac{F_y&#39;}{F_z&#39;}\)</span></p><h3 id="可微条件">4.2 可微条件</h3><p>若<span class="math inline">\(\lim\limits_{x \to 0,y \to 0}\frac{f(x,y)-f(0,0)-f_x&#39;(0,0)·x-f_y&#39;(0,0)·y}{\sqrt{x^2+y^2}}=0\)</span>，则<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\((0,0)\)</span>可微；</p><p>令<span class="math inline">\(f_x&#39;(x_0,y_0)=A,f_y&#39;(x_0,y_0)=B\)</span>，若<span class="math inline">\(\lim\limits_{\varDelta x \to 0,\varDelta y \to 0}\frac{f(x_0+\varDelta x,y_0+\varDelta y)-f(x_0,y_0)-A\varDelta x-B\varDelta y}{\sqrt{\varDelta x ^2+\varDelta y^2}}=0\)</span>，则<span class="math inline">\(f(x,y)\)</span>在<span class="math inline">\((x_0,y_0)\)</span>可微</p><h3 id="可微可导与连续的关系">4.3 可微、可导与连续的关系</h3><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117110110925.png"></p><h3 id="结论-3">4.4 结论</h3><p>二阶偏导数连续<span class="math inline">\(\to \frac{\partial^2 f}{\partial u\partial v}=\frac{\partial^2 f}{\partial v\partial u}\)</span></p><h2 id="微分方程">5.微分方程</h2><h3 id="伯努利方程">5.1 伯努利方程</h3><p>能写成<span class="math inline">\(y&#39;+p(x)y=q(x)y^n(n≠0，1)\)</span>：</p><ul><li>先变形为<span class="math inline">\(y^{-n}·y&#39;+p(x)y^{1-n}=q(x)\)</span>；</li><li>令<span class="math inline">\(z=y^{-n}\)</span>，得<span class="math inline">\(\frac{dz}{dx}=(1-n)y^{-n}\frac{dy}{dx}\)</span>，则<span class="math inline">\(\frac{1}{1-n}\frac{dz}{dx}+p(x)z=q(x)\)</span>；</li><li>解此一阶线性微分方程即可。</li></ul><h3 id="欧拉方程">5.2 欧拉方程</h3><p>能写成<span class="math inline">\(x^2y&#39;&#39;+pxy&#39;+qy=f(x)\)</span>：</p><ol type="1"><li><p>当<span class="math inline">\(x&gt;0\)</span>时，令<span class="math inline">\(x=e^t\)</span>，则<span class="math inline">\(t=lnx\)</span>，<span class="math inline">\(\frac{dt}{dx}=\frac{1}{x}\)</span>。</p><p>于是<span class="math inline">\(\frac{dy}{dx}=\frac{dy}{dt}·\frac{dt}{dx}=\frac{1}{x}·\frac{dy}{dt}\)</span>；</p><p><span class="math inline">\(\frac{d^2y}{dx^2}=\frac{d}{dx}·(\frac{1}{x}\frac{dy}{dt})=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x}·\frac{d}{dx}(\frac{dy}{dt})=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x}·\frac{d}{dt}(\frac{dy}{dt})·\frac{dt}{dx}=-\frac{1}{x^2}·\frac{dy}{dt}+\frac{1}{x^2}·\frac{d^2y}{dt^2}\)</span></p><p>方程化为<span class="math inline">\(\frac{d^2y}{dt^2}+(p-1)\frac{dy}{dt}+qy=f(e^t)\)</span>，即可求解。</p><blockquote><p>最后结果别忘了用<span class="math inline">\(t=lnx\)</span>回代成<span class="math inline">\(x\)</span>的函数</p></blockquote></li><li><p>当<span class="math inline">\(x&lt;0\)</span>时。令<span class="math inline">\(x=e^{-t}\)</span>，同理可得。</p></li></ol><h3 id="高阶常系数微分方程的通解与特解">5.3 高阶常系数微分方程的通解与特解</h3><p>通解：</p><ol type="1"><li><p><span class="math inline">\(\lambda_1≠\lambda_2\)</span>： <span class="math display">\[y=C_1e^{\lambda_1x}+C_2e^{\lambda_2x}\]</span></p></li><li><p><span class="math inline">\(\lambda_1=\lambda_2=\lambda\)</span>： <span class="math display">\[y=(C_1+C_2x)e^{\lambda x}\]</span></p></li><li><p><span class="math inline">\(\lambda=\alpha\pm i\beta\)</span>： <span class="math display">\[y=e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)\]</span></p></li></ol><p>特解：</p><ol type="1"><li><p>当自由项<span class="math inline">\(f(x)=P_n(x)e^{\alpha x}\)</span>时，特解要设为<span class="math inline">\(y^*=e^{\alpha x}Q_n(x)x^k\)</span>，其中： <span class="math display">\[\begin{cases}e^{\alpha x}照抄，\\ Q_n(x)为x的n次一般多项式，\\ k=\begin{cases}0，\alpha ≠\lambda_1, \alpha ≠\lambda_2 \\ 1，\alpha =\lambda_1或\alpha=\lambda_2,\lambda_1≠\lambda_2 \\2，\alpha =\lambda_1=\lambda_2\end{cases}  \end{cases}\]</span></p></li><li><p>当自由项<span class="math inline">\(f(x)=e^{\alpha x}[P_m(x)cos\beta x+P_n(x)sin\beta x]\)</span>时，特解要设为<span class="math inline">\(y^*=e^{\alpha x}[Q_l^{(1)}(x)cos\beta x+Q_l^{(2)}(x)sin\beta x]x^k\)</span>，其中： <span class="math display">\[\begin{cases}e^{\alpha x}照抄，\\ l=max\{m,n\},Q_l^{(1)}(x),Q_l^{(2)}(x)分别为x两个不同的l次一般多项式，\\ k=\begin{cases}0，\alpha \pm i\beta 不是特征根\\ 1，\alpha \pm i\beta 是特征根\end{cases}  \end{cases}\]</span></p></li></ol><h3 id="高阶微分方程的解">5.4 高阶微分方程的解</h3><p>若<span class="math inline">\(\lambda\)</span>为单实根，写<span class="math inline">\(Ce^{\lambda x}\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为<span class="math inline">\(k\)</span>重实根，写<span class="math inline">\((C_1+C_2x+C_3x^2+\cdots +C_kx^{k-1})e^{\lambda x}\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为单复根<span class="math inline">\(\alpha\pm i\beta\)</span>，写<span class="math inline">\(e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)\)</span></p><p>若<span class="math inline">\(\lambda\)</span>为二重复根<span class="math inline">\(\alpha\pm i\beta\)</span>，写<span class="math inline">\(e^{\alpha x}(C_1cos\beta x+C_2sin\beta x+C_3xcos\beta x+C_4xsin\beta x)\)</span></p><h2 id="无穷级数">6无穷级数</h2><h3 id="广义p级数">6.1 广义<span class="math inline">\(p\)</span>级数</h3><p><span class="math inline">\(\displaystyle\sum_{n=2}^\infty\frac{1}{n(\ln n)^p}\begin{cases}收敛，p&gt;1 \\ 发散，p≤1\end{cases}\)</span></p><h3 id="一些简单数项级数的和">6.2 一些简单数项级数的和</h3><p><span class="math inline">\(e^x=\displaystyle\sum_{n=0}^\infty\frac{x^n}{n!}\)</span></p><p><span class="math inline">\(\frac{e^x+e^{-x}}{2}=\displaystyle\sum_{n=0}^\infty\frac{x^{2n}}{(2n)!}\)</span></p><p><span class="math inline">\(cosx=\displaystyle\sum_{n=0}^\infty(-1)^n\frac{x^{2n}}{(2n)!}\)</span></p><p><span class="math inline">\(\frac{e^x-e^{-x}}{2}=\displaystyle\sum_{n=0}^\infty\frac{x^{2n+1}}{(2n+1)!}\)</span></p><p><span class="math inline">\(sinx=\displaystyle\sum_{n=0}^\infty(-1)^n\frac{x^{2n+1}}{(2n+1)!}\)</span></p><h3 id="傅里叶级数">6.3 傅里叶级数</h3><p>设函数<span class="math inline">\(f(x)\)</span>是周期为<span class="math inline">\(2l\)</span>的周期函数，且在<span class="math inline">\([-l,l]\)</span>上可积，则有 <span class="math display">\[a_n=\frac{1}{l}\int_{-l}^{l}f(x)cos\frac{n\pi}{l}xdx(n=0,1,2,\cdots)\]</span></p><p><span class="math display">\[b_n=\frac{1}{l}\int_{-l}^{l}f(x)sin\frac{n\pi}{l}xdx(n=1,2,3,\cdots)\]</span></p><p><span class="math display">\[f(x)\sim\frac{a_0}{2}+\displaystyle\sum_{n=1}^\infty(a_ncos\frac{n\pi}{l}x+b_nsin\frac{n\pi}{l}x)\]</span></p><h3 id="收敛区间和收敛域">6.4 收敛区间和收敛域</h3><p>收敛区间：不包含端点，是一个开区间；</p><p>收敛域：包含端点。</p><h2 id="多元函数积分学预备知识">7.多元函数积分学预备知识</h2><h3 id="曲线">7.1 曲线</h3><p>切向量：<span class="math inline">\(\tau=(A,B,C)\)</span></p><ul><li>已知<span class="math inline">\(\begin{cases} F(x,y,z)=0\\ G(x,y,z)=0 \end{cases}\)</span>，则<span class="math inline">\(\overrightarrow{\tau}=\begin{vmatrix} \overrightarrow{i} &amp; \overrightarrow{j} &amp; \overrightarrow{k}\\ \frac{\partial F}{\partial x} &amp; \frac{\partial F}{\partial y} &amp; \frac{\partial F}{\partial z}\\ \frac{\partial G}{\partial x} &amp; \frac{\partial G}{\partial y} &amp; \frac{\partial G}{\partial z} \end{vmatrix}\)</span></li></ul><p>切线：<span class="math inline">\(\frac{x-x_0}{A}=\frac{y-y_0}{B}=\frac{z-z_0}{C}\)</span></p><p>法平面：<span class="math inline">\(A(x-x_0)+B(y-y_0)+C(z-z_0)=0\)</span></p><h3 id="曲面">7.2 曲面</h3><p>法向量：<span class="math inline">\(n=(A,B,C)\)</span></p><p>法线：<span class="math inline">\(\frac{x-x_0}{A}=\frac{y-y_0}{B}=\frac{z-z_0}{C}\)</span></p><p>切平面：<span class="math inline">\(A(x-x_0)+B(y-y_0)+C(z-z_0)=0\)</span></p><h3 id="两点式求直线">7.3 两点式求直线</h3><p>直线过不同的两点：<span class="math inline">\((x_1,y_1,z_1),(x_2,y_2,z_2)\)</span>，则直线方程为<span class="math inline">\(\frac{x-x_1}{x_2-x_1}=\frac{y-y_1}{y_2-y_1}=\frac{z-z_1}{z_2-z_1}\)</span></p><h3 id="曲线绕一条定直线旋转一周所形成的曲面">7.4 曲线绕一条定直线旋转一周所形成的曲面</h3><p>曲线<span class="math inline">\(\begin{cases}F(x,y,z)=0\\ G(x,y,z)=0\end{cases}\)</span>绕直线<span class="math inline">\(L\)</span>，首先在直线<span class="math inline">\(L\)</span>上找一点<span class="math inline">\(M_0(x_0,y_0,z_0)\)</span>，方向向量为<span class="math inline">\(\overrightarrow{s}\)</span>，在曲线上任取一点<span class="math inline">\(M_1(x_1,y_1,z_1)\)</span>，过<span class="math inline">\(M_1\)</span>的纬圆上任取一点<span class="math inline">\(P(x,y,z)\)</span>，则可以得到： <span class="math display">\[\begin{cases}|\overrightarrow{M_0M_1}|=|\overrightarrow{M_0P}|\\ \overrightarrow{s}\bot\overrightarrow{M_1P}\\F(x_1,y_1,z_1)=0\\ G(x_1,y_1,z_1)=0\end{cases}\]</span></p><blockquote><p>四个方程三个未知数</p></blockquote><h3 id="点到面的距离">7.5 点到面的距离</h3><p><span class="math display">\[d=\frac{Ax_0+By_0+Cz_0+D}{\sqrt{A^2+B^2+C^2}}\]</span></p><h3 id="平面束方程">7.6 平面束方程</h3><p>过<span class="math inline">\(L:\begin{cases} A_1x+B_1y+C_1z+D_1=0\\ A_2x+B_2y+C_2z+D_2=0 \end{cases}\)</span>的平面束方程为<span class="math inline">\(A_1x+B_1y+C_1z+D_1+\lambda(A_2x+B_2y+C_2z+D_2)=0\)</span></p><h3 id="方向导数和梯度">7.7 方向导数和梯度</h3><p>求<span class="math inline">\(u=u(x,y,z)\)</span>在<span class="math inline">\(P_0\)</span>点沿<span class="math inline">\(l\)</span>方向的方向导数</p><p>定义法：<span class="math inline">\(\frac{\partial u}{\partial l}|_{P_0}=\lim\limits_{t \to 0^+}\frac{u(P)-u(P_0)}{t}=\lim\limits_{t \to 0^+}\frac{u(x_0+tcos\alpha,y_0+tcos\beta,z_0+tcos\gamma)-u(x_0,y_0,z_0)}{t}\)</span></p><blockquote><p>若三元函数<span class="math inline">\(u=u(x,y,z)\)</span>在点<span class="math inline">\(P_0(x_0,y_0,z_0)\)</span>处可微分，则可用公式法</p></blockquote><p>公式法：<span class="math inline">\(\frac{\partial u}{\partial l}|_{P_0}=u&#39;_x(P_0)cos\alpha+u&#39;_y(P_0)cos\beta+u&#39;_z(P_0)cos\gamma\)</span></p><p>求<span class="math inline">\(u=u(x,y,z)\)</span>在<span class="math inline">\(P_0\)</span>处的梯度：<span class="math inline">\(grad\thinspace u\thinspace |_{P_0}=(u&#39;_x(P_0),u&#39;_y(P_0),u&#39;_z(P_0))\)</span></p><blockquote><p>函数在某点处的梯度是一个向量，它的方向与取得最大方向导数的方向一致，而它的模为方向导数的最大值。</p></blockquote><h3 id="散度和旋度">7.8 散度和旋度</h3><p>散度：<span class="math inline">\(div\thinspace A=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\)</span></p><p>旋度：<span class="math inline">\(rot\thinspace A=\begin{vmatrix} i &amp; j &amp; k\\ \frac{\partial }{\partial x} &amp; \frac{\partial }{\partial y} &amp; \frac{\partial }{\partial z}\\ P &amp; Q &amp; R \end{vmatrix}\)</span></p><h2 id="多元函数积分学">8.多元函数积分学</h2><h3 id="球面坐标系">8.1 球面坐标系</h3><p><span class="math inline">\(\phi\)</span>的范围是从<span class="math inline">\(z\)</span>轴正向到负向<span class="math inline">\(0\to \pi\)</span>的</p><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117114157948.png" style="zoom: 20%;"></p><p><span class="math inline">\(\theta\)</span>的范围是<span class="math inline">\([0,2\pi]\)</span>，从<span class="math inline">\(x\)</span>轴正向开始逆时针转的</p><p><img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240117114800996.png" style="zoom: 20%;"></p><h3 id="斯托克斯公式">8.2 斯托克斯公式</h3><p><span class="math display">\[\oint Pdx+Qdy+Rdz=\iint_{\varSigma}\begin{vmatrix}cos\alpha &amp; cos\beta &amp;cos\gamma\\\frac{\partial}{\partial x} &amp; \frac{\partial}{\partial y} &amp; \frac{\partial}{\partial z}\\P &amp; Q &amp; R\end{vmatrix}dS\]</span></p><blockquote><p>二型线积分化为一型面积分</p></blockquote><h3 id="转换投影法">8.3 转换投影法</h3><p>对于二型面积分，若<span class="math inline">\(\varSigma\)</span>投影到<span class="math inline">\(xoy\)</span>平面上不是一条线，并且<span class="math inline">\(\varSigma\)</span>上任意两点到<span class="math inline">\(xoy\)</span>平面上的投影点不重合，则可将<span class="math inline">\(\varSigma\)</span>投影到<span class="math inline">\(xoy\)</span>平面。 <span class="math display">\[\iint P(x,y,z)dydz+Q(x,y,z)dzdx+R(x,y,z)dxdy=\pm\iint_{DXY}\{P[x,y,z(x,y)](-\frac{\partial z}{\partial x})+Q[x,y,z(x,y)](-\frac{\partial z}{\partial y})+R[x,y,z(x,y)]\}dxdy\]</span></p><blockquote><p>当<span class="math inline">\(\varSigma\)</span>为上侧时，取“+”；当<span class="math inline">\(\varSigma\)</span>为下侧时，取“-”</p></blockquote><h3 id="面线积分才能考虑代换">8.4 面线积分才能考虑代换</h3><p>例如<span class="math inline">\(\varSigma\)</span>是曲面<span class="math inline">\(x=\sqrt{1-3y^2-3z^2}\)</span>的前侧，<span class="math inline">\(\Omega\)</span>是<span class="math inline">\(\varSigma\)</span>围成的空间。三重积分是在一个空间内，<span class="math inline">\(x,y,z\)</span>不一直满足<span class="math inline">\(x=\sqrt{1-3y^2-3z^2}\)</span>的关系，无法代换，面线积分才能考虑代换。</p><h3 id="积分与路径无关">8.5 积分与路径无关</h3><h4 id="注意条件">8.5.1 注意条件</h4><p>积分与路径无关的条件是沿<span class="math inline">\(D\)</span>内任意光滑闭曲线都有<span class="math inline">\(\oint_LPdx+Qdy=0\)</span>；而<span class="math inline">\(\oint_LPdx+Qdy=A\)</span>不能推出积分与路径无关。</p><h4 id="积分与路径无关的6个等价条件">8.5.2 积分与路径无关的6个等价条件</h4><ol type="1"><li><p><span class="math inline">\(\int_{LAB}P(x,y)dx+Q(x,y)dy\)</span>与路径无关</p></li><li><p>沿<span class="math inline">\(D\)</span>内任意分段光滑闭曲线都有<span class="math inline">\(\oint_LPdx+Qdy=0\)</span></p></li><li><p><span class="math inline">\(Pdx+Qdy\)</span>为某二元函数<span class="math inline">\(u(x,y)\)</span>的全微分：</p><p>由1推3，<span class="math inline">\(\int_{LAB}Pdx+Qdy=\int_{LAB}du(x,y)=u(x,y)|^B_A\)</span>，故<span class="math inline">\(du(x,y)=\frac{\partial u}{\partial x}dx+\frac{\partial u}{\partial y}dy=Pdx+Qdy\)</span></p></li><li><p><span class="math inline">\(Pdx+Qdy=0\)</span>是全微分方程：</p><p>意思是上式可以被视为全微分方程，因为3说了<span class="math inline">\(Pdx+Qdy\)</span>为二元函数<span class="math inline">\(u(x,y)\)</span>的全微分；因为<span class="math inline">\(du=0\)</span>，故通解为<span class="math inline">\(u(x,y)=C\)</span></p><blockquote><p><span class="math inline">\(\frac{\partial P}{\partial y}\equiv\frac{\partial Q}{\partial x}\)</span>是判断是不是全微分方程的标准，理由在第六条给出</p></blockquote><p>例：求解<span class="math inline">\((x^4+3xy^2-y^3)dx+(3x^2y-3xy^2+y^2)dy=0\)</span></p><p>解：<span class="math inline">\(\because \frac{\partial P}{\partial y}\equiv\frac{\partial Q}{\partial x}=6xy-3y^2\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> 所求式为全微分方程</p><p>​ <span class="math inline">\(\therefore\)</span> 取路径<span class="math inline">\((0,0)\to (x,0)\to(x,y)\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(\int_{0}^{x}5x^4dx+\int_{0}^{y}(3x^2y-3xy^2+y^2)dy=C\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> <span class="math inline">\(x^5+\frac{3}{2}x^2y^2-xy^3+\frac{y^3}{3}=C\)</span></p><p>​ <span class="math inline">\(\therefore\)</span> 也可得<span class="math inline">\(u(x,y)=x^5+\frac{3}{2}x^2y^2-xy^3+\frac{y^3}{3}+C\)</span></p></li><li><p><span class="math inline">\(Pi+Qj\)</span>为某二元函数<span class="math inline">\(u(x,y)\)</span>的梯度</p></li><li><p><span class="math inline">\(\frac{\partial P}{\partial y}\equiv\frac{\partial Q}{\partial x}\)</span>在<span class="math inline">\(D\)</span>内处处成立：</p><p>由4推6，<span class="math inline">\(\because u&#39;&#39;_{xy}=u&#39;&#39;_{yx}\)</span>又<span class="math inline">\(\because \frac{\partial P}{\partial y}=u&#39;&#39;_{xy},\frac{\partial Q}{\partial x}=u&#39;&#39;_{yx}\)</span></p><p>​ <span class="math inline">\(\therefore \frac{\partial P}{\partial y}\equiv\frac{\partial Q}{\partial x}\)</span></p></li></ol><h1 id="二线性代数">二、线性代数</h1><h2 id="行列式">1.行列式</h2><h3 id="拉普拉斯展开式">1.1 拉普拉斯展开式</h3><p><span class="math display">\[\begin{vmatrix}A &amp; *\\O &amp; B\end{vmatrix}=\begin{vmatrix}A &amp; O\\* &amp; B\end{vmatrix}=|A|·|B|\]</span></p><p><span class="math display">\[\begin{vmatrix}O &amp; A\\B &amp; *\end{vmatrix}=\begin{vmatrix}* &amp; A\\B &amp; O\end{vmatrix}=(-1)^{mn}|A|·|B|\]</span></p><h3 id="克拉默法则">1.2 克拉默法则</h3><p>若<span class="math inline">\(n\)</span>个方程<span class="math inline">\(n\)</span>个未知数的线性方程组<span class="math inline">\(\begin{cases}a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n=b_1\\ a_{21}x_1+a_{22}x_2+\cdots+a_{2n}x_n=b_2 \\\cdots \\ a_{n1}x_1+a_{n2}x_2+\cdots+a_{nn}x_n=b_n \end{cases}\)</span></p><p>的系数行列式<span class="math inline">\(D=\begin{vmatrix} a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}\\ a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\ \vdots &amp; \vdots &amp;\ddots &amp; \vdots\\ a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}\end{vmatrix}≠0\)</span>，</p><p>则方程组有唯一解：<span class="math inline">\(x_1=\frac{D_1}{D},x_2=\frac{D_2}{D},\cdots,x_n=\frac{D_n}{D}\)</span></p><p>其中<span class="math inline">\(D_j=\begin{vmatrix} a_{11} &amp;\cdots &amp; a_{1,j-1}&amp; b_1 &amp; a_{1,j+1}&amp; \cdots &amp; a_{1n}\\ a_{21} &amp;\cdots &amp; a_{2,j-1}&amp; b_2 &amp; a_{2,j+1}&amp; \cdots &amp; a_{2n} \\ \vdots &amp; &amp; \vdots &amp; \vdots &amp; \vdots &amp; &amp;\vdots\\ a_{n1} &amp;\cdots &amp; a_{n,j-1}&amp; b_n &amp; a_{n,j+1}&amp; \cdots &amp; a_{nn}\end{vmatrix}\)</span></p><h3 id="代数余子式">1.3 代数余子式</h3><p><span class="math display">\[A_{ij}=(-1)^{i+j}M_{ij}\]</span></p><blockquote><p><span class="math inline">\(A_{ij}\)</span>是代数余子式，<span class="math inline">\(M_{ij}\)</span>是余子式</p></blockquote><h2 id="矩阵">2.矩阵</h2><h3 id="分块矩阵的初等行列变换">2.1 分块矩阵的初等行（列）变换</h3><p>交换分块矩阵中的某两个块行（列）；</p><p>用某个<mark><span class="math inline">\(可逆矩阵\)</span></mark>左（右）乘分块矩阵的某块行（列）；</p><p>用一个矩阵<mark><span class="math inline">\(左\)</span></mark>（右）乘某个块<mark><span class="math inline">\(行\)</span></mark>（列）之后加到另一个块<mark><span class="math inline">\(行\)</span></mark>（列）。</p><h3 id="伴随矩阵的秩">2.2 伴随矩阵的秩</h3><p><span class="math display">\[r(A^*)=\begin{cases}n, &amp;r(A)=n\\1, &amp;r(A)=n-1\\0, &amp;r(A)&lt;n-1\\\end{cases}\]</span></p><h3 id="初等矩阵的逆变换">2.3 初等矩阵的逆变换</h3><p><span class="math display">\[E_i^{-1}(k)=E_i(\frac{1}{k}),例:D = \begin{bmatrix}1 &amp; &amp;\\ &amp; 1&amp;\\&amp;&amp;2\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp; &amp;\\ &amp; 1&amp;\\&amp;&amp;\frac{1}{2}\end{bmatrix}\]</span></p><p><span class="math display">\[E_{ij}^{-1}(k)=E_{ij}(-k),例:D = \begin{bmatrix}1 &amp;0 &amp;0\\2 &amp; 1&amp;0\\0&amp;0&amp;1\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp;0 &amp;0\\-2 &amp; 1&amp;0\\0&amp;0&amp;1\end{bmatrix}\]</span></p><p><span class="math display">\[E_{ij}^{-1}=E_{ij},例:D = \begin{bmatrix}1 &amp;0 &amp;0\\0 &amp; 0&amp;1\\0&amp;1&amp;0\end{bmatrix}^{-1}=D = \begin{bmatrix}1 &amp;0 &amp;0\\0 &amp; 0&amp;1\\0&amp;1&amp;0\end{bmatrix}\]</span></p><h3 id="矩阵的秩">2.4 矩阵的秩</h3><ol type="1"><li><span class="math inline">\(r(A)=r(A^T)\)</span>，<span class="math inline">\(r(A^TA)=r(A)\)</span></li><li><span class="math inline">\(r(A+B)\le r(A)+r(B)\)</span></li><li><span class="math inline">\(r(AB)\le min\{r(A),r(B)\}\)</span>，若<span class="math inline">\(A\)</span>可逆，则<span class="math inline">\(r(AB)=r(B)\)</span>，<span class="math inline">\(r(BA)=r(B)\)</span></li><li>若<span class="math inline">\(A\)</span>是<span class="math inline">\(m\times n\)</span>矩阵，<span class="math inline">\(B\)</span>是<span class="math inline">\(n\times\)</span> s矩阵，<span class="math inline">\(AB=O\)</span>，则<span class="math inline">\(r(A)+r(B)\le n\)</span></li></ol><h2 id="n维向量">3.<span class="math inline">\(n\)</span>维向量</h2><h3 id="向量空间">3.1 向量空间</h3><h4 id="过渡矩阵">3.1.1 过渡矩阵</h4><p><span class="math display">\[\begin{bmatrix}\beta_1 &amp; \beta_2 &amp; \beta_3\end{bmatrix}=\begin{bmatrix}\alpha_1 &amp; \alpha_2 &amp; \alpha_3\end{bmatrix}C\]</span></p><p>称矩阵<span class="math inline">\(C\)</span>为由基<span class="math inline">\(\alpha_1\alpha_2\alpha_3\)</span>到<span class="math inline">\(\beta_1\beta_2\beta_3\)</span>的过渡矩阵。</p><h4 id="坐标变换公式">3.1.2 坐标变换公式</h4><p><span class="math display">\[\begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix}=C\begin{bmatrix}y_1 \\ y_2 \\ y_3\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(x\)</span>是<span class="math inline">\(\gamma\)</span>在基<span class="math inline">\(\alpha\)</span>的坐标，其中<span class="math inline">\(y\)</span>是<span class="math inline">\(\gamma\)</span>在基<span class="math inline">\(\beta\)</span>的坐标。</p><h2 id="特征值与特征向量">4.特征值与特征向量</h2><h3 id="注意">4.1 注意</h3><p>求特征向量时，结果前要乘k，表示全部的特征向量。</p><h3 id="注意-1">4.2 注意</h3><p>证明<span class="math inline">\(A,B\)</span>相似，首先要证明<span class="math inline">\(A,B\)</span>可相似对角化。</p><h3 id="特征值与特征向量的变化规律">4.3 特征值与特征向量的变化规律</h3><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(A\)</span></th><th style="text-align: center;"><span class="math inline">\(kA+E\)</span></th><th style="text-align: center;"><span class="math inline">\(A+kE\)</span></th><th style="text-align: center;"><span class="math inline">\(A^{-1}\)</span></th><th style="text-align: center;"><span class="math inline">\(A^*\)</span></th><th style="text-align: center;"><span class="math inline">\(A^n\)</span></th><th style="text-align: center;"><span class="math inline">\(P^{-1}AP\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(k\lambda+1\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda+k\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{|A|}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda^n\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"><span class="math inline">\(P^{-1}\alpha\)</span></td></tr></tbody></table><blockquote><p><span class="math inline">\(\lambda\)</span>变<span class="math inline">\(\alpha 不变\)</span>，<span class="math inline">\(\lambda\)</span>不变<span class="math inline">\(\alpha 变\)</span>。</p></blockquote><h3 id="特征多项式是lambda-e-a">4.4 特征多项式是<span class="math inline">\(|\lambda E-A|\)</span></h3><p>例：<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>是同阶方阵，如果<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>相似，试证<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>的特征多项式相等。</p><p>证：<span class="math inline">\(\because A,B\)</span>相似</p><p>​ <span class="math inline">\(\therefore P^{-1}AP=B\)</span></p><p>​ <span class="math inline">\(\therefore |\lambda E-B|=|\lambda E-P^{-1}AP|=|P^{-1}\lambda EP-P^{-1}AP|=|P^{-1}(\lambda E-A)P|=|\lambda E-A|\)</span></p><h2 id="二次型">5.二次型</h2><h3 id="二次型的矩阵表示">5.1 二次型的矩阵表示</h3><p><span class="math inline">\(f(x_1,x_2,\cdots,x_n)=\cdots\)</span>称为<span class="math inline">\(n\)</span>元二次型；二次型有矩阵表示： <span class="math display">\[f(x_1,x_2,\cdots,x_n)=x^TAx\]</span> 其中<span class="math inline">\(x\)</span>是<span class="math inline">\(n\)</span>维列向量，<span class="math inline">\(A\)</span>是实对称矩阵，称<span class="math inline">\(A\)</span>为二次型的矩阵，秩<span class="math inline">\(r(A)\)</span>称为二次型的秩。</p><h3 id="一些曲面">5.2 一些曲面</h3><p>单叶双曲面：<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=1\)</span></p><p>双叶双曲面：<span class="math inline">\(\frac{x^2}{a^2}+\frac{y^2}{b^2}-\frac{z^2}{c^2}=-1\)</span></p><h3 id="施密特正交化">5.3 施密特正交化</h3><p><span class="math inline">\(\beta_1=\alpha_1\)</span></p><p><span class="math inline">\(\beta_2=\alpha_2-\frac{(\alpha_2,\beta_1)}{(\beta_1,\beta_1)}·\beta_1\)</span></p><p><span class="math inline">\(\beta_3=\alpha_3-\frac{(\alpha_3,\beta_1)}{(\beta_1,\beta_1)}·\beta_1-\frac{(\alpha_3,\beta_2)}{(\beta_2,\beta_2)}·\beta_2\)</span></p><h3 id="合同变换和正定矩阵">5.4 合同变换和正定矩阵</h3><p>两个<span class="math inline">\(n\)</span>阶矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>，如果存在可逆矩阵<span class="math inline">\(C\)</span>，使得<span class="math inline">\(C^TAC=B\)</span>，就称矩阵<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>合同，记作<span class="math inline">\(A\simeq B\)</span>，称<span class="math inline">\(C\)</span>为合同变换的矩阵。</p><p>对二次型<span class="math inline">\(x^TAx\)</span>，如果对任何<span class="math inline">\(x≠0\)</span>，恒有<span class="math inline">\(x^TAx&gt;0\)</span>，则称二次型<span class="math inline">\(x^TAx\)</span>是正定二次型，并称实对称矩阵<span class="math inline">\(A\)</span>是正定矩阵。</p><p><span class="math inline">\(n\)</span>元二次型<span class="math inline">\(x^TAx\)</span>正定的充要条件有：</p><ol type="1"><li><span class="math inline">\(A\)</span>的正惯性指数是<span class="math inline">\(n\)</span>；</li><li><span class="math inline">\(A\)</span>与<span class="math inline">\(E\)</span>合同，即存在可逆矩阵<span class="math inline">\(C\)</span>，使<span class="math inline">\(C^TAC=E\)</span>；</li><li><span class="math inline">\(A\)</span>的所有特征值<span class="math inline">\(\lambda(i=1,2,\cdots,n)\)</span>均为正数；</li><li><span class="math inline">\(A\)</span>的各阶顺序主子式均大于零。</li></ol><p>例：设<span class="math inline">\(A\)</span>为<span class="math inline">\(m\)</span>阶实对称矩阵且正定，<span class="math inline">\(B\)</span>为<span class="math inline">\(m\times n\)</span>实矩阵，<span class="math inline">\(B^T\)</span>为<span class="math inline">\(B\)</span>的转置矩阵，试证：<span class="math inline">\(B^TAB\)</span>为正定矩阵的充分必要条件是<span class="math inline">\(r(B)=n\)</span>。</p><p>证：必要性：设<span class="math inline">\(B^TAB\)</span>为正定矩阵</p><p>​ <span class="math inline">\(\therefore\)</span>对任意<span class="math inline">\(n\)</span>维列向量<span class="math inline">\(x≠0\)</span>，有<span class="math inline">\(x^TB^TABx&gt;0\)</span>，即<span class="math inline">\((Bx)^TA(Bx)&gt;0\)</span></p><p>​ 又<span class="math inline">\(\because A\)</span>正定</p><p>​ <span class="math inline">\(\therefore Bx≠0\)</span>，因此<span class="math inline">\(Bx=0\)</span>只有零解</p><p>​ <span class="math inline">\(\therefore r(B)=n\)</span></p><p>​ 充分性：设<span class="math inline">\(r(B)=n\)</span></p><p>​ <span class="math inline">\(\because B^TAB=(B^TAB)^T=B^TAB\)</span></p><p>​ <span class="math inline">\(\therefore B^TAB\)</span>为实对称矩阵</p><p>​ <span class="math inline">\(\because r(B)=n\)</span></p><p>​ <span class="math inline">\(\therefore Bx=0\)</span>只有零解</p><p>​ <span class="math inline">\(\therefore\)</span>对任意<span class="math inline">\(n\)</span>维列向量<span class="math inline">\(x≠0\)</span>，都有<span class="math inline">\(Bx≠0\)</span></p><p>​ <span class="math inline">\(\because A\)</span>正定</p><p>​ <span class="math inline">\(\therefore (Bx)^TA(Bx)&gt;0\)</span>，即<span class="math inline">\(x^TB^TABx&gt;0\)</span></p><p>​ <span class="math inline">\(\therefore B^TAB\)</span>为正定矩阵</p><h1 id="三概率论与数理统计">三、概率论与数理统计</h1><h2 id="随机事件及其概率">1.随机事件及其概率</h2><h3 id="减法公式">1.1 减法公式</h3><p><span class="math inline">\(P(A\overline{B})=P(A-B)=P(A)-P(AB)\)</span></p><p><span class="math inline">\(P(\overline{A}B)=P(B-A)=P(B)-P(AB)\)</span></p><h2 id="一维随机变量及其分布">2.一维随机变量及其分布</h2><h3 id="泊松分布及指数分布">2.1 泊松分布及指数分布</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">概率密度</th><th style="text-align: center;">E(x)</th><th style="text-align: center;">D(x)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">泊松分布</td><td style="text-align: center;"><span class="math inline">\(P\{X=k\}=\frac{\lambda^k}{k!}e^{-\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td><td style="text-align: center;"><span class="math inline">\(\lambda\)</span></td></tr><tr class="even"><td style="text-align: center;">指数分布</td><td style="text-align: center;"><span class="math inline">\(f(x)=\begin{cases}\lambda e^{-\lambda x}，x\ge0\\ 0，x&lt;0\end{cases}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{1}{\lambda^2}\)</span></td></tr></tbody></table><h3 id="标准正态分布">2.2 标准正态分布</h3><p><span class="math inline">\(\Phi(\frac{X-4}{2})\)</span>是<span class="math inline">\(N(4,4)\)</span>的分布函数，<span class="math inline">\(Z=\frac{X-\mu}{\sigma}\sim N(0,1)\)</span>。</p><blockquote><p>正态分布图像特点：正态分布，方差越小，图像越高瘦。</p></blockquote><h2 id="二维随机变量及其分布">3.二维随机变量及其分布</h2><h3 id="判断xy是否独立">3.1 判断<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>是否独立</h3><p>看<span class="math inline">\(P\{X\le k,Y\le m\}\)</span>是否等于<span class="math inline">\(P\{X\le k\}·P\{Y\le m\}\)</span>，<span class="math inline">\(k\)</span>、<span class="math inline">\(m\)</span>为任取的值。</p><blockquote><p>证不独立时题中自己随便取即可。</p></blockquote><h3 id="f_zz直接求导求f_zz莱布尼兹公式">3.2 <span class="math inline">\(F_Z(z)\)</span>直接求导求<span class="math inline">\(f_Z(z)\)</span>（莱布尼兹公式）</h3><p>莱布尼兹公式： <span class="math display">\[\frac{d}{dz}\int_{\alpha(z)}^{\beta(z)}g(z,x)dx=\int_{\alpha(z)}^{\beta(z)}g_z&#39;(z,x)dx+\beta&#39;(z)·g(z,\beta(z))-\alpha&#39;(z)·g(z,\alpha(z))\]</span> 例：<span class="math inline">\(f(x,y)=\begin{cases}2-x-y,\quad0&lt;x&lt;1,0&lt;y&lt;1\\ 0,\quad其他\end{cases}\)</span>，求<span class="math inline">\(Z=X+Y\)</span>的概率密度<span class="math inline">\(f_Z(z)\)</span>。</p><p>解：<img src="/2023/12/25/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/image-20240128222426890.png" style="zoom: 20%;"></p><p><span class="math inline">\(0\le z&lt;1\)</span>时：<span class="math inline">\(F_Z(z)=P\{X+Y\le z\}=\int_{0}^{z}dx\int_{0}^{z-x}(2-x-y)dy\)</span></p><p>​ <span class="math inline">\(f_Z(z)=\frac{dF_Z(z)}{dz}=\int_{0}^{z}(2-z)dx+0-0=(2-z)·z\)</span></p><p><span class="math inline">\(1\le z&lt;2\)</span>时：<span class="math inline">\(F_Z(z)=1-\int_{z-1}^{1}dx\int_{z-x}^{1}(2-x-y)dy\)</span></p><p>​ <span class="math inline">\(f_Z(z)=\frac{dF_Z(z)}{dz}=-[\int_{z-1}^{1}(z-2)dx]=(z-2)^2\)</span></p><p><span class="math inline">\(\therefore f_Z(z)=\begin{cases}(2-z)·z,\quad0\le z&lt;1\\(z-2)^2,\quad1\le z&lt;2\\0,\quad其他\end{cases}\)</span></p><h2 id="数字特征">4.数字特征</h2><h3 id="方差的性质">4.1 方差的性质</h3><p><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>独立时：<span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\)</span></p><p><span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>不独立时：<span class="math inline">\(D(X\pm Y)=D(X)+D(Y)\pm2Cov(X,Y)\)</span></p><h3 id="协方差的性质">4.3 协方差的性质</h3><p><span class="math inline">\(Cov(X_1\pm X_2,Y)=Cov(X_1,Y)\pm Cov(X_2,Y)\)</span></p><p><span class="math inline">\(Cov(aX,bY)=abCov(X,Y)\)</span></p><p><span class="math inline">\(Cov(X_1-\overline{X},X_n-\overline{X})=Cov(X_1-\overline{X},X_n)-Cov(X_1-\overline{X},\overline{X})=Cov(X_1,X_n)-Cov(\overline{X},X_n)-Cov(X_1,\overline{X})+Cov(\overline{X},\overline{X})\)</span></p><h2 id="大数定律和中心极限定理">5.大数定律和中心极限定理</h2><h3 id="辛钦大数定律">5.1 辛钦大数定律</h3><p>设随机变量<span class="math inline">\(X_1,X_2,\cdots,X_n,\cdots\)</span>独立同分布，<span class="math inline">\(E(X_i)=\mu(i=1,2,\cdots)\)</span>，则对任意的<span class="math inline">\(\epsilon&gt;0\)</span>，有 <span class="math display">\[\lim\limits_{n \to \infty}P\{|\frac{1}{n}\displaystyle\sum_{i=1}^nX_i-\mu|&lt;\epsilon\}=1,即\frac{1}{n}\displaystyle\sum_{i=1}^nX_i\xrightarrow{P}\mu\]</span></p><h3 id="切比雪夫不等式">5.2 切比雪夫不等式</h3><p><span class="math display">\[P\{|X-E(X)|\ge\epsilon\}\le \frac{D(X)}{\epsilon^2}\]</span></p><h2 id="数理统计的基本概念">6.数理统计的基本概念</h2><h3 id="常见统计量">6.1 常见统计量</h3><ul><li><p><span class="math inline">\(\overline{X}=\frac{1}{n}\displaystyle\sum_{i=1}^nX_i\qquad E(\overline{X})=\mu\quad D(\overline{X})=\frac{\sigma^2}{n}\)</span></p></li><li><p><span class="math inline">\(S^2=\frac{1}{n-1}\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2\qquad E(S^2)=\sigma^2\)</span></p></li></ul><blockquote><p><span class="math inline">\(S^2\)</span>除以<span class="math inline">\(n-1\)</span>的原因也就是<span class="math inline">\(E(S^2)=\sigma^2\)</span>，即<span class="math inline">\(S^2\)</span>为<span class="math inline">\(\sigma^2\)</span>的无偏估计量。</p></blockquote><h3 id="chi2分布t分布和f分布">6.2 <span class="math inline">\(\chi^2\)</span>分布、<span class="math inline">\(t\)</span>分布和<span class="math inline">\(F\)</span>分布</h3><ol type="1"><li><p><span class="math inline">\(\chi^2\)</span>分布：总体<span class="math inline">\(X\sim N(0,1)\)</span>，<span class="math inline">\(\chi^2=X_1^2+X_2^2+\cdots+X_n^2\)</span>为服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(\chi^2\)</span>分布，记作<span class="math inline">\(\chi^2\sim \chi^2(n)\)</span>。</p><blockquote><p>设<span class="math inline">\(\chi^2\sim \chi^2(n)\)</span>，则<span class="math inline">\(E(\chi^2)=n\)</span>，<span class="math inline">\(D(\chi^2)=2n\)</span></p></blockquote></li><li><p><span class="math inline">\(t\)</span>分布：设总体<span class="math inline">\(X\sim N(0,1)\)</span>，<span class="math inline">\(Y\sim \chi^2(n)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，则<span class="math inline">\(T=\frac{X}{\sqrt{Y/n}}\)</span>为服从自由度为<span class="math inline">\(n\)</span>的<span class="math inline">\(t\)</span>分布，记作<span class="math inline">\(T\sim t(n)\)</span>。</p></li><li><p><span class="math inline">\(F\)</span>分布：设总体<span class="math inline">\(X\sim \chi^2(n_1)\)</span>，<span class="math inline">\(Y\sim \chi^2(n_2)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，则称<span class="math inline">\(F=\frac{X/n_1}{Y/n_2}\)</span>为服从第一自由度为<span class="math inline">\(n_1\)</span>，第二自由度为<span class="math inline">\(n_2\)</span>的<span class="math inline">\(F\)</span>分布，记作<span class="math inline">\(F\sim F(n_1,n_2)\)</span>。</p><blockquote><p>若<span class="math inline">\(T\sim t(n)\)</span>，则<span class="math inline">\(T^2\sim F(1,n_2)\)</span></p></blockquote></li></ol><h3 id="正态总体的抽样分布">6.3 正态总体的抽样分布</h3><p>单正态总体：设总体<span class="math inline">\(X\sim N(\mu,\sigma ^2)\)</span>，<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>为来自<span class="math inline">\(X\)</span>的简单随机样本。</p><ol type="1"><li><span class="math inline">\(\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}\sim N(0,1)\quad \frac{(\overline{X}-\overline{X})^2}{\sigma^2/n}\sim \chi^2(1)\)</span></li><li><span class="math inline">\(\overline{X}\)</span>与<span class="math inline">\(S^2\)</span><strong>相互独立</strong>，<span class="math inline">\(\frac{(n-1)S^2}{\sigma^2}=\frac{\displaystyle\sum_{i=1}^n(X_i-\overline{X})^2}{\sigma^2}\sim \chi^2(n-1)\)</span></li><li><span class="math inline">\(\frac{X_i-\mu}{\sigma}\sim N(0,1)\quad \frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\sigma^2}\sim \chi^2(n)\)</span></li><li><span class="math inline">\(\frac{\overline{X}-\mu}{S/\sqrt{n}}\sim t(n-1)\)</span></li></ol><p>双正态总体：设总体<span class="math inline">\(X\sim N(\mu_1,\sigma_1 ^2)\)</span>，<span class="math inline">\(Y\sim N(\mu_2,\sigma_2 ^2)\)</span>，且<span class="math inline">\(X\)</span>、<span class="math inline">\(Y\)</span>相互独立，<span class="math inline">\((X_1,X_2,\cdots,X_n)\)</span>、<span class="math inline">\((Y_1,Y_2,\cdots,Y_n)\)</span>为来自<span class="math inline">\(X\)</span>和<span class="math inline">\(Y\)</span>的简单随机样本。</p><ol type="1"><li><p><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1^2}+\frac{(n_2-1)S_2^2}{\sigma_2^2}\sim\chi^2(n_1+n_2-2)\)</span></p></li><li><p><span class="math inline">\(\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}\sim N(0,1)\)</span></p></li><li><p>当<span class="math inline">\(\sigma_1=\sigma_2=\sigma\)</span>时： <span class="math display">\[\frac{\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{\sigma\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}}{\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{\sigma^2(n_1+n_2-2)}}}=\frac{\overline{X}-\overline{Y}-(\mu_1-\mu_2)}{S_\omega\sqrt{\frac{1}{n_1}+\frac{1}{n_2}}}\sim t(n_1+n_2-2)\qquad S_\omega=\sqrt{\frac{(n_1-1)S_1^2+(n_2-1)S_2^2}{n_1+n_2-2}}\]</span></p></li><li><p><span class="math inline">\(\frac{(n_1-1)S_1^2}{\sigma_1^2}\sim\chi^2(n_1-1)\quad\frac{(n_2-1)S_2^2}{\sigma_2^2}\sim\chi^2(n_2-1)\)</span></p><p><span class="math inline">\(\frac{S_1^2}{S_2^2}·\frac{\sigma_2^2}{\sigma_1^2}\sim F(n_1-1,n_2-1)\)</span></p></li></ol><h2 id="参数估计与假设检验">7.参数估计与假设检验</h2><p>参数估计分为点估计和区间估计，点估计又分为矩估计和最大似然估计。</p><h3 id="估计量的无偏性">7.1 估计量的无偏性</h3><p>设<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的估计量，若<span class="math inline">\(E(\hat{\theta})=\theta\)</span>，就称<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的无偏估计，否则称为有偏估计。</p><p>若<span class="math inline">\(\lim\limits_{n \to \infty}E(\hat{\theta})=\theta\)</span>，就称<span class="math inline">\(\hat{\theta}\)</span>为<span class="math inline">\(\theta\)</span>的渐近无偏估计。</p><h3 id="离散总体的矩估计和最大似然估计">7.2 离散总体的矩估计和最大似然估计</h3><p>例：总体<span class="math inline">\(X\)</span>的概率分布为</p><table><thead><tr class="header"><th style="text-align: center;">X</th><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">P</td><td style="text-align: center;"><span class="math inline">\(\theta^2\)</span></td><td style="text-align: center;"><span class="math inline">\(2\theta(1-\theta)\)</span></td><td style="text-align: center;"><span class="math inline">\(\theta^2\)</span></td><td style="text-align: center;"><span class="math inline">\(1-2\theta\)</span></td></tr></tbody></table><p>其中<span class="math inline">\(\theta(0&lt;\theta&lt;\frac{1}{2})\)</span>是未知参数，利用总体<span class="math inline">\(X\)</span>的如下样本值$ 3,1,3,0,3,1,2,3<span class="math inline">\(，求\)</span>$的矩估计和最大似然估计值。</p><p>解：矩估计：<span class="math inline">\(E(X)=2\theta(1-\theta)+2\theta^2+3(1-2\theta)=3-4\theta=2\)</span></p><p>​ <span class="math inline">\(\therefore \hat{\theta}=\frac{1}{4}\)</span></p><p>​ 最大似然估计：<span class="math inline">\(L(\theta)=(1-2\theta)^4[2\theta(1-\theta)]^2(\theta^2)^2\)</span></p><p>​ <span class="math inline">\(\ln L(\theta)=4\ln (1-2\theta)+2\ln 2\theta(1-\theta)+4\ln \theta\)</span></p><p>​ <span class="math inline">\(\frac{d\ln L(\theta)}{d\theta}=\frac{8}{2\theta-1}+\frac{2-4\theta}{\theta(1-\theta)}+\frac{4}{\theta}=0\)</span></p><p>​ <span class="math inline">\(\therefore \hat{\theta}=\frac{7-\sqrt{13}}{12}\)</span></p><h3 id="区间估计的置信区间">7.3 区间估计的置信区间</h3><p>设总体<span class="math inline">\(X\)</span>的分布中含有未知函数<span class="math inline">\(\theta\)</span>，<span class="math inline">\(P\{\hat{\theta}_1&lt;\theta&lt;\hat{\theta}_2\}=1-\alpha\)</span>，则称随机区间<span class="math inline">\((\hat{\theta}_1,\hat{\theta}_2)\)</span>为未知参数<span class="math inline">\(\theta\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间。<span class="math inline">\(\hat{\theta}_1\)</span>和<span class="math inline">\(\hat{\theta}_2\)</span>分别称为置信下限和置信上限，<span class="math inline">\(1-\alpha\)</span>称为置信度或置信水平。</p><p>设总体<span class="math inline">\(X\sim N(\mu,\sigma^2)\)</span>，常见置信区间有：</p><ol type="1"><li><p>当<span class="math inline">\(\sigma^2\)</span>已知时，<span class="math inline">\(\mu\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{-U_{\frac{\alpha}{2}}&lt;\frac{\overline{X}-\mu}{\sigma/\sqrt{n}}&lt;U_{\frac{\alpha}{2}}\}=1-\alpha\]</span></p><p><span class="math display">\[P\{\overline{X}-U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}}&lt;\mu&lt;\overline{X}+U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}}\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\overline{X}-U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}},\overline{X}+U_{\frac{\alpha}{2}}\frac{\sigma}{\sqrt{n}})\]</span></p></li><li><p>当<span class="math inline">\(\sigma^2\)</span>未知时，<span class="math inline">\(\mu\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{-t_{\frac{\alpha}{2}}(n-1)&lt;\frac{\overline{X}-\mu}{S/\sqrt{n}}&lt;t_{\frac{\alpha}{2}}(n-1)\}=1-\alpha\]</span></p><p><span class="math display">\[P\{\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}}&lt;\mu&lt;\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}}\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\overline{X}-t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}},\overline{X}+t_{\frac{\alpha}{2}}(n-1)\frac{S}{\sqrt{n}})\]</span></p></li><li><p>当<span class="math inline">\(\mu\)</span>已知时，<span class="math inline">\(\sigma^2\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间： <span class="math display">\[P\{\chi^2_{1-\frac{\alpha}{2}}(n)&lt;\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\sigma^2}&lt;\chi^2_{\frac{\alpha}{2}}(n)\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\chi^2_{\frac{\alpha}{2}}(n)},\frac{\displaystyle\sum_{i=1}^n(X_i-\mu)^2}{\chi^2_{1-\frac{\alpha}{2}}(n)})\]</span></p></li><li><p>当<span class="math inline">\(\mu\)</span>未知时，<span class="math inline">\(\sigma^2\)</span>的置信度为<span class="math inline">\(1-\alpha\)</span>的置信区间：</p></li></ol><p><span class="math display">\[P\{\chi^2_{1-\frac{\alpha}{2}}(n-1)&lt;\frac{(n-1)·S^2}{\sigma^2}&lt;\chi^2_{\frac{\alpha}{2}}(n-1)\}=1-\alpha\]</span></p><p><span class="math display">\[\therefore(\frac{(n-1)·S^2}{\chi^2_{\frac{\alpha}{2}}(n-1)},\frac{(n-1)·S^2}{\chi^2_{1-\frac{\alpha}{2}}(n-1)})\]</span></p><h3 id="假设检验">7.4 假设检验</h3><p><span class="math inline">\(H_0\)</span>带等号，<span class="math inline">\(H_1\)</span>不带等号，其中<span class="math inline">\(H_1\)</span>对应于拒绝域。</p><p>第一类错误（弃真错误）：当原假设<span class="math inline">\(H_0\)</span>为真时，但检验结果为拒绝<span class="math inline">\(H_0\)</span>；</p><p>第二类错误（存伪错误）：当原假设<span class="math inline">\(H_0\)</span>不正确时，但检验结果为接受<span class="math inline">\(H_0\)</span>。</p><blockquote><p>不同的检验统计量对应的分布与置信区间那里一样。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
      <tag>高等数学</tag>
      
      <tag>线性代数</tag>
      
      <tag>概率论与数理统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信网性能分析</title>
    <link href="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    <url>/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>2023/6/15 10:53 今天开始网络理论基础课程的复习及知识整理。</p><p>2023/6/21 23:14 今天下午总算考完这门课，我也在今天晚上完成了通信网性能分析这门课知识的总结。另外说一句，今晚一边整理，一边发现今天下午考试时写错的，这种感觉真是苦不堪言啊......ps：明天开始高数的知识点梳理。</p><h1 id="一通信信源模型">一、通信信源模型</h1><h2 id="泊松过程">1.泊松过程</h2><p>对于Poisson呼叫流，长度为t的时间内到达k个呼叫的概率<span class="math inline">\(P_k(t)\)</span>服从Poisson分布，即 <span class="math display">\[p_k(t)=\frac{(\lambda t)^k}{k!}e^{-\lambda t}\qquad k=0,1,2,......\]</span> Poisson分布的均值：<span class="math inline">\(E[N(t)]=\lambda t\)</span></p><p>Poisson分布的方差：<span class="math inline">\(Var[N(t)]=\lambda t\)</span></p><p>m个Poisson流的参数分别为<span class="math inline">\(\lambda_1,\lambda_2,......,\lambda_m,\)</span>并且它们是相互<strong>独立</strong>的，合并流仍然为Poisson流，且参数为<span class="math inline">\(\lambda=\lambda_1+\lambda_2+...+\lambda_m\)</span>。</p><p>一个随机过程是参数 λ 的Poisson过程的充分必要条件为呼叫到达间隔<span class="math inline">\(X_i,i=1,2...\)</span>相互独立，且服从相同参数 λ 的负指数分布。</p><h2 id="负指数分布">2.负指数分布</h2><p>随机变量X满足<span class="math inline">\(P\{X\ge t\}=e^{-\lambda t}\)</span>，或分布函数为：<span class="math inline">\(P\{X&lt;t\}=1-e^{-\lambda t},t\ge0\)</span>，则这个分布被称之为参数为λ的<strong>负指数分布</strong>。</p><p>这个分布的概率密度函数为：<span class="math inline">\(f_x(t)=\lambda e^{-\lambda t},t\ge0\)</span></p><p>负指数分布的均值：<span class="math inline">\(E[X]=\frac{1}{\lambda}\)</span></p><p>负指数分布的均值：<span class="math inline">\(Var[X]=\frac{1}{\lambda^2}\)</span></p><p>负指数分布具有无记忆特性：<span class="math inline">\(P\{X\ge t+s|X\ge t\}=P\{X\ge s\}\)</span></p><p>假设<span class="math inline">\(T_1,T_2\)</span>为<strong>相互独立的</strong>两个负指数分布，参数分别为<span class="math inline">\(\lambda_1,\lambda_2\)</span>，令<span class="math inline">\(T=min(T_1,T_2)\)</span>则：</p><ol type="1"><li><p>T 是一个以<span class="math inline">\(\lambda_1+\lambda_2\)</span>为参数的负指数分布；</p></li><li><p>T 的分布和<span class="math inline">\(T_i\)</span>谁是较小数无关；</p></li><li><p><span class="math inline">\(P\{T_1&lt;T_2|T=t\}=\frac{\lambda_1}{\lambda_1+\lambda_2}\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621204746403.png" style="zoom:80%;"></p></li></ol><h2 id="mm1排队系统">3.M/M/1排队系统</h2><h3 id="排队系统性能指标">3.1 排队系统性能指标</h3><p><em>λ</em>：排队系统到达率</p><p><span class="math inline">\(\mu\)</span>：服务率（离去率）</p><p>k：队长（系统中的顾客数）</p><p><span class="math inline">\(\omega\)</span>：等待时间</p><p><span class="math inline">\(\tau\)</span>：服务时间</p><p>s=<span class="math inline">\(\omega+\tau\)</span>：系统时间</p><p>η：系统效率</p><p><span class="math inline">\(\rho=\frac{\lambda}{\mu}\)</span></p><h3 id="mm1">3.2 M/M/1</h3><p>根据生灭过程的性质：<span class="math inline">\(p_k=\rho^kp_0\)</span></p><p>在<span class="math inline">\(\rho&lt;1\)</span>时，两边求和得到： <span class="math display">\[p_0=\frac{1}{1+\sum_{k=1}^{\infty}\rho^k}=1-\rho\]</span> M/M/1的队长分布：<span class="math inline">\(p_k=\rho^k(1-\rho)\qquad k=0,1,2,...\)</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200225503.png" alt="M/M/1的状态转移图" style="zoom: 80%;"></p><p>N：系统中的平均顾客数</p><p>T：顾客在系统中的平均时间 <span class="math display">\[平均队长:E[N]=\frac{\rho}{1-\rho}\]</span></p><p><span class="math display">\[Var[N]=\frac{\rho}{(1-\rho)^2}\]</span></p><p><span class="math display">\[在系统中的平均停留时间:E[s]=\frac{\frac{\rho}{1-\rho}}{\lambda}=\frac{1}{\mu-\lambda}\]</span></p><p><span class="math display">\[平均排队时间:E[\omega]=E[s]-\frac{1}{\mu}=\frac{\rho}{1-\rho}\frac{1}{\mu}\]</span></p><p><span class="math display">\[平均等待队长:E[N_w]=\lambda E[\omega]=\frac{\rho}{1-\rho}\frac{\lambda}{\mu}\]</span></p><p>M/M/1排队系统在稳态时，系统时间 s 服从参数为<span class="math inline">\(\mu-\lambda\)</span>的负指数分布。</p><h1 id="二erlang拒绝和等待系统">二、Erlang拒绝和等待系统</h1><p>呼叫量=业务量/观察时间</p><p>呼叫量的单位为erl，这是一个无量纲的单位。</p><p>实际上，在一段时间T内通过的呼叫量就是该时段内被占用的平均中继线数目。</p><h2 id="erlang即使拒绝系统mmss">1.Erlang即使拒绝系统——M/M/s(s)</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615200329406.png" alt="M/M/s(s)的状态转移图" style="zoom: 67%;"></p><p>令<span class="math inline">\(a=\frac{\lambda}{\mu}\)</span>，则<span class="math inline">\(p_k=\frac{a^k}{k!}p_0\qquad k=1,2,...,s\)</span></p><p>两边求和解得： <span class="math display">\[p_0=\frac{1}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 稳态分布为： <span class="math display">\[p_k=\frac{\frac{a^k}{k!}}{\sum_{r=0}^{s}\frac{a^r}{r!}}\qquad k=0,1,2,...,s\]</span> 特别，当k＝s 时，p<sub>s</sub>表达了中继线全忙的概率，这个概率为系统的时间阻塞率，记为 <span class="math display">\[p_s=B(s,a)=\frac{a^s/s!}{\sum_{r=0}^{s}\frac{a^r}{r!}}\]</span> 通过的呼叫量：<span class="math inline">\(a&#39;=a[1-B(s,a)]\)</span></p><h2 id="erlang等待制系统mms">2.Erlang等待制系统—M/M/S</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615210209146.png" alt="M/M/S状态转移图" style="zoom: 80%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620225521649.png" alt="等待制系统分析" style="zoom: 67%;"></p><p><span class="math display">\[p_0=\frac{1}{\sum_{k=0}^{s-1}\frac{a^k}{k!}+\frac{a^s}{s!}\frac{1}{1-a/s}}\]</span> 一个呼叫需要等待的概率： <span class="math display">\[C(s,a)=\frac{a^s}{s!}\frac{p_0}{1-a/s}\]</span> 在a&lt;s的条件下：</p><p>通过的呼叫量：<span class="math inline">\(a&#39;=a\)</span></p><p>系统中的平均呼叫数：<span class="math inline">\(E[N]=\frac{\rho}{1-\rho}C(s,a)+a\qquad \rho=a/s\)</span></p><p>系统中的平均呼叫数为a，等待队列中的平均呼叫数为<span class="math inline">\(\frac{\rho}{1-\rho}C(s,a)\)</span></p><p>平均等待时间：<span class="math inline">\(E[\omega]=[\frac{\rho}{1-\rho}C(s,a)]/\lambda=\frac{C(s,a)}{s\mu(1-\rho)}\)</span></p><p>等待时间的分布：<span class="math inline">\(p\{\omega&gt;t\}=C(s,a)e^{-(s\mu-\lambda)t}\)</span></p><h2 id="一般混合制的mmsn系统">3.一般混合制的M/M/S(n)系统</h2><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230620231245977.png" alt="M/M/S(n)系统分析" style="zoom:67%;"></p><h1 id="三通信网络性能分析">三、通信网络性能分析</h1><h2 id="wilkinson定理算溢出呼叫流的统计特征">1.Wilkinson定理算溢出呼叫流的统计特征</h2><p><span class="math display">\[\alpha=aB(s,a)\qquad v=\alpha(1-\alpha+\frac{a}{s+1+\alpha-a})\]</span></p><blockquote><p>上面是溢出呼叫流和溢出呼叫流的方差</p></blockquote><p><span class="math display">\[峰值因子:z=\frac{v}{\alpha}\]</span></p><h2 id="呼损的近似计算方法rapp">2.呼损的近似计算方法Rapp</h2><ol type="1"><li><p>计算<span class="math inline">\(z=\frac{v}{\alpha}\)</span></p></li><li><p>令<span class="math inline">\(a=v+3z(z-1)\)</span> <span class="math display">\[然后,s=\frac{a(\alpha+z)}{\alpha+z-1}-\alpha-1\]</span> 但s一般不为整数，向下取整，记为[s]</p></li><li><p>重新计算： <span class="math display">\[a=\frac{([s]+\alpha+1)(\alpha+z-1)}{\alpha+z}\]</span></p></li><li><p>计算等效系统的呼损和拒绝的呼叫量<span class="math inline">\(B(s+c,a)\)</span>和<span class="math inline">\(aB(s+c,a)\)</span></p></li></ol><h1 id="四网络拓扑结构分析">四、网络拓扑结构分析</h1><h2 id="图论基础">1.图论基础</h2><h3 id="图的定义和基本概念">1.1 图的定义和基本概念</h3><p>图：所谓一个图G，是指给了一个端点集合V，以及边的集合或V中元素的序对集合E，图一般用G=(V,E)来表示。</p><p>端的度数：</p><ul><li>对无向图的端<span class="math inline">\(v_i\)</span>，与该端关联边的数目为该端的度数，记为：<span class="math inline">\(d(v_i)\)</span>。</li><li>对有向图的端<span class="math inline">\(v_i\)</span>，<span class="math inline">\(d^+(v_i)\)</span>表示离开<span class="math inline">\(v_i\)</span>的边数，<span class="math inline">\(d^-(v_i)\)</span>表示进入<span class="math inline">\(v_i\)</span>的边数。</li></ul><p>给定图G=(V,E)，若<span class="math inline">\(V_1\subseteq V,E_1=\{(u,v)\in E|u,v\in V_1\}\)</span>称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(V_1\)</span>生成的<strong>子图</strong>，记<span class="math inline">\(G[V_1]\)</span>。</p><p>特别，若子图的端点集合为V，这个图被称为图G的<strong>支撑子图</strong>。</p><p>若<span class="math inline">\(E_1\subseteq E,V_1=\{V\in V|v是E_1中某边的端点\}\)</span>， 称图<span class="math inline">\(G_1=(V_1,E_1)\)</span>是G中由<span class="math inline">\(E_1\)</span>生成的子图，记为<span class="math inline">\(G[E_1]\)</span>。</p><p>考虑边的一个序列，相邻两边有公共端，如(v1，v2)， (v2，v3)， (v3，v4)，…… (vi ，vi+1)，这个边序列称为<strong>链</strong>，链简单说就是一个连续轨迹。</p><p>没有重复边的链称为简单链；没有重复端的链称为初等链或<strong>道路</strong>。</p><p>若链的起点与终点重合，称之为<strong>圈</strong>；若道路的起点与终点重合,称之为<strong>初等圈</strong>。</p><p>任何两端间至少存在一条链的图，为<strong>连通图</strong>。否则，就是非连通图。</p><h3 id="树">1.2 树</h3><p>树的定义：</p><ul><li>任何二端有且只有一条道路的图称为树。</li><li>无圈的连通图称为树。</li></ul><p>如果树T是连通图G的子图，<span class="math inline">\(T\subseteq G\)</span>，且T包含G的所有端，称T是G的<strong>支撑树或主树</strong>。</p><p>树边，连枝：如果在一个连通图中确定了一个支撑树，图的边集合被分为两类，属于树的边称为树边；不属于树的边称为连枝。</p><h3 id="割集">1.3 割集</h3><p><strong>割集</strong>指的是某些端集或边子集，对连通图，去掉此类子集，图变为不连通（即图变成一个点）。</p><p>设v是图G的一个端，去掉<mark>v和其关联边</mark>后，G的部分数增加（或图变成一个点），则称v是图G的<strong>割端</strong>。</p><p>去掉一个端集合后，G的部分数增加，这个端的集合称为<strong>割端集</strong>。</p><p>对于连通图, 在众多的割端集中至少存在一个端数最少的割端集，称为<strong>最小割端集</strong>。</p><p>最小割端集的端数目，称为图的<strong>点连通度或连通度</strong>，连通度用a 表示。</p><p>设e是图G的一条边，去掉 e 后，G的部分数增加，则称e是图G的<strong>割边</strong>。去掉一个边集合后，G的部分数增加，这个边的集合称为<strong>割边集</strong>。</p><p>割边集中边数最少的割边集，称为<strong>最小割边集</strong>。最小割边集的边数目，称为<strong>线连通度</strong>，线连通度用β 表示。</p><p>确定了连通图的一个支撑树后，每条树边可以决定一个基本割集。</p><p>对于支撑树，去掉<strong>树</strong>上任何一条边，<strong>树</strong>便分为两个连通分支，从而将原图的<strong>端</strong>分为两个集合，这两个集合之间的所有<strong>边</strong>形成一个极小边割集，这个边割集称为<strong>基本割集</strong>。</p><blockquote><p>基本割集数等于树支数。</p></blockquote><p>对于任何一个连通图G，设T为G的一个支撑树，每一条连枝决定的圈是<strong>基本圈</strong>。</p><blockquote><p>基本圈的个数等于连枝数。</p></blockquote><p>反圈：给定图G=(V,E)，<span class="math inline">\(S,T\subseteq V\)</span>，记<span class="math inline">\([S,T]_G=\{(u,v)\in E|u\in S,v\in T \}\)</span>；特别，当T=V，将<span class="math inline">\([S,T]_G\)</span>记为<span class="math inline">\(\Phi_G(S)\)</span>或<span class="math inline">\(\Phi(S)\)</span>。设X是V的非空真子集，若<span class="math inline">\(\Phi_G(X)\not=\phi\)</span>，称<span class="math inline">\(\Phi_G(X)\)</span>为由X确定的反圈。</p><blockquote><p>反圈是一种特殊的边割集。</p></blockquote><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="最小支撑树">2.1 最小支撑树</h3><h4 id="prim算法反圈法">2.1.1 Prim算法－反圈法</h4><ol type="1"><li>任取一点作为初始的<span class="math inline">\(X^{(0)}\)</span>；</li><li>在反圈<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选边的原则是：<ul><li>从<span class="math inline">\(\Phi[X^{(k)}]\)</span>中选一条权最小的边（如果有多条权最小的边，则任选一条）；</li><li>将选出边的邻端并入<span class="math inline">\(X^{(k)}\)</span>形成<span class="math inline">\(X^{(k+1)}\)</span>；</li></ul></li><li>若在某一步，<span class="math inline">\(\Phi[X^{(k)}]=\phi\)</span>，则G不含支撑树；若在某一步，<span class="math inline">\(X^{(k)}=V\)</span>，则由所有被选边生成的树是最小支撑树。</li></ol><h4 id="kruskal算法避圈法">2.1.2 Kruskal算法－避圈法</h4><p>将所有边排序，然后由小到大选边，保持所选的边不生成圈，如果选了n－1条边，则生成了一个最小支撑树。</p><h4 id="破圈法">2.1.3 破圈法</h4><p>从连通图中先寻找圈，然后在圈中删去权最大的边，最后剩下的无圈连通图为最小支撑树。</p><h3 id="端间最短距离和路由">2.2 端间最短距离和路由</h3><h4 id="dijkstra算法">2.2.1 Dijkstra算法</h4><p>在下图中求<span class="math inline">\(v_1\)</span>到其余端点的最短距离和路由：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230618194227852.png" alt style="zoom:50%;"></p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(v_1\)</span></th><th style="text-align: center;"><span class="math inline">\(v_5\)</span></th><th style="text-align: center;"><span class="math inline">\(v_2\)</span></th><th style="text-align: center;"><span class="math inline">\(v_3\)</span></th><th style="text-align: center;"><span class="math inline">\(v_4\)</span></th><th style="text-align: center;">置定端<span class="math inline">\(l_0\)</span></th><th style="text-align: center;">距离<span class="math inline">\(\lambda_{l_0}\)</span></th><th style="text-align: center;">路由<span class="math inline">\(i_0\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">6</td><td style="text-align: center;">V3</td><td style="text-align: center;">2</td><td style="text-align: center;">V1</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">3</td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V2</td><td style="text-align: center;">3</td><td style="text-align: center;">V3</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">V4</td><td style="text-align: center;">5</td><td style="text-align: center;">V3</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">V5</td><td style="text-align: center;">6</td><td style="text-align: center;">V2</td></tr></tbody></table><h4 id="floyd算法">2.2.1 Floyd算法</h4><ul><li><p>给定图G及其边(i,j)的权<span class="math inline">\(w_{i,j}\)</span></p></li><li><p><span class="math inline">\(F_0\)</span>：初始化距离矩阵<span class="math inline">\(W^{(0)}\)</span>和路由矩阵<span class="math inline">\(R^{(0)}\)</span></p><ul><li><p><span class="math display">\[w_{ij}^{(0)}=\begin{cases}w_{ij} &amp;\text{若 $e_{ij}\in E$}\\\infty &amp;\text{若 $e_{ij}\not\in E$}\\0 &amp;\text{若 $i=j$}\\\end{cases}\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(0)}=\begin{cases}j &amp;\text{若 $w_{ij}^{(0)}\not=\infty,0$}\\0 &amp;\text{其它}\\\end{cases}\]</span></p></li></ul></li><li><p>迭代</p><ul><li><p><span class="math display">\[w_{i,j}^{(k)}=min(w_{i,j}^{(k-1)},w_{i,k}^{(k-1)}+w_{k,j}^{(k-1)})\]</span></p></li><li><p><span class="math display">\[r_{ij}^{(k)}=\begin{cases}r_{i,k}^{(k-1)}&amp;\text{若 $w_{i,j}^{(k)}&lt;w_{i,j}^{(k-1)}$}\\r_{i,j}^{(k-1)} &amp;\text{若$w_{i,j}^{(k)}=w_{i,j}^{(k-1)}$}\\\end{cases}\]</span></p></li></ul></li><li><p>根据<span class="math inline">\(R^{(n)}\)</span>进行路由查找。</p></li><li><p>根据<span class="math inline">\(W^{(n)}\)</span>求图的中心与中点</p><ul><li>中心：先找每行最大值，再找里面最小的；</li><li>中点：先每行求和，再找里面最小的。</li></ul></li></ul><p>例：利用F算法求v2到 v4的最短距离和正向路由，并求网的中心和中点。</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621213119808.png" alt="例题解答"><figcaption aria-hidden="true">例题解答</figcaption></figure><p><span class="math inline">\(v_2\)</span>到<span class="math inline">\(v_4\)</span>的最短距离为4，正向路由为<span class="math inline">\(v_2\to v_1\to v_4\)</span>。</p><h2 id="网络流量问题">3.网络流量问题</h2><p>可行流的两个限制条件：</p><ol type="1"><li><p>非负有界性：对任意边<span class="math inline">\(e_{i,j}\)</span>有，<span class="math inline">\(0\le f_{i,j}\le c_{i,j}\)</span></p></li><li><p>连续性：对任意端<span class="math inline">\(v_t\)</span>有， <span class="math display">\[\sum_{(i,j)\in E}^{}f_{ij}-\sum_{(j,i)\in E}^{}f_{ji}=\begin{cases}F &amp;\text{$v_i$为源端$v_s$}\\-F &amp;\text{$v_i$为源端$v_t$}\\0 &amp;\text{其他}\\\end{cases}\]</span></p></li></ol><p>割量<span class="math inline">\(C(X,X^c)\)</span>定义为这个割集中所有边容量的和。</p><p>对于某条流，若在某条路中，前向边均不饱和（<span class="math inline">\(f_{i,j}&lt;c_{i,j}\)</span>），反向边均有非0流量（<span class="math inline">\(f_{j,j}\not=0\)</span>），称这条路为<strong>可增流路</strong>。</p><h3 id="最大流问题m算法">3.1 最大流问题—M算法</h3><p>例：利用M算法计算下图的最大流结果</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621215552636.png" alt="题目所给网络" style="zoom:80%;"></p><p>①标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_A(+,S,5)\)</span>，标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_A\)</span>：标<span class="math inline">\(V_C(+,A,5)\)</span>，<span class="math inline">\(V_A\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,5)\)</span></p><p>增流：<span class="math inline">\(f_{SA}=5,f_{AC}=5,f_{CT}=5\)</span></p><p>②重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,4)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,4)\)</span>，标<span class="math inline">\(V_D(+,B,4)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,C,3)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3,f_{BC}=3,f_{CT}=3\)</span></p><p>③重标<span class="math inline">\(V_S(+,S,\infty)\)</span></p><p>查<span class="math inline">\(V_S\)</span>：标<span class="math inline">\(V_B(+,S,1)\)</span>，<span class="math inline">\(V_S\)</span>已查</p><p>查<span class="math inline">\(V_B\)</span>：标<span class="math inline">\(V_C(+,B,1)\)</span>，标<span class="math inline">\(V_D(+,B,1)\)</span>，<span class="math inline">\(V_B\)</span>已查</p><p>查<span class="math inline">\(V_C\)</span>：标<span class="math inline">\(V_T(+,D,1)\)</span></p><p>增流：<span class="math inline">\(f_{SB}=3+1,f_{BD}=1,f_{DT}=1\)</span></p><p>故最大可行流为5+3+1=9。</p><h3 id="最小费用流问题负价环法算法">3.2 最小费用流问题—负价环法算法</h3><p>例：图(a)为该通信网，一个可行流安排如图(b)，求最小费用流的流量安排。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222102785.png" alt="图(a)" style="zoom: 67%;"></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621222213322.png" alt="图(b)" style="zoom:67%;"></p><ol type="1"><li><p>图(b)的总费用为54，其补图为图(c)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120016583.png" alt="图(c)" style="zoom:67%;"></p><p>找到负圈(B,C,T,D)，沿其增流2单位，总费用减2×(-1)=-2</p><p>可行流为图(d)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621223124406.png" alt="图(d)" style="zoom:67%;"></p></li><li><p>图(d)的补图为图(e)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120102209.png" alt="图(e)" style="zoom:67%;"></p><p>找到负圈(A,C,B,S)，沿其增流1单位，总费用减1×(-1)=-1。</p><p>可行流为图(f)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120152137.png" alt="图(f)" style="zoom:67%;"></p></li><li><p>图(f)的补图为图(g)：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230622120218809.png" alt="图(g)" style="zoom:67%;"></p><p>已找不到负圈，最小费用为51。</p></li></ol><h1 id="五网络可靠性分析">五、网络可靠性分析</h1><h2 id="可靠性理论基础">1.可靠性理论基础</h2><h3 id="寿命分布和失效率函数">1.1 寿命分布和失效率函数</h3><h3 id="寿命分布和可靠度">1.1.1 寿命分布和可靠度</h3><p>首先，考虑子系统的可靠性特点，然后考虑子系统依照不同方法构成的大系统的可靠性。</p><p>对于简单系统，假设它仅包含两个状态：正常和故障。如果用一个非负随机变量X来描述系统的寿命，X相应的分布函数为：</p><p><span class="math display">\[F(t)=P\{X \le t \}\]</span> 有了寿命分布，就知道了在时刻t以前都正常的概率： <span class="math display">\[R(t)=P\{X &gt; t \}=1-F(t)\]</span> 而R(t)表示系统的可靠度函数或可靠度。</p><p>平均寿命为： <span class="math display">\[E(X)=\int_{0}^{\infty}R(t)dt\]</span></p><h4 id="失效率函数">1.1.2 失效率函数</h4><p>设系统的寿命为非负连续型随机变量，其分布函数为F(t)，密度函数为f(t)，定义失效率函数如下： <span class="math display">\[对任意t,F(t)&lt;1, 失效率函数（简称失效率）:r(t)=\frac{f(t)}{1-F(t)}\]</span> 因系统在t时刻正常，在(t,t+△t]中失效的概率为： <span class="math display">\[P\{X \le t+\varDelta t|X&gt;t\}\frac{F(t+\varDelta t)-F(t)}{1-F(t)} \sim\frac{f(t)\varDelta t}{1-F(t)}=r(t)\varDelta t\]</span> 当△t很小时，r(t)△t表示在(t,t+△t]中失效的概率。</p><p>下图中表示了典型的失效率函数，也被称之为浴盆曲线：</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615113134324.png" alt="浴盆曲线" style="zoom: 67%;"></p><h3 id="不可修复系统和可修复系统">1.2 不可修复系统和可修复系统</h3><p>如果一个子系统在故障后，不再修复，这个子系统称之为不可修复系统。</p><p>如果一个子系统在故障后，经历一段时间，修复又重新使用，如此循环往复，这种系统称之为可修复系统。</p><p>可修复系统和不可修复系统的区分并不是绝对的，在一定条件下它们可以相互转换。</p><h4 id="不可修复系统">1.2.1 不可修复系统</h4><p>对于不可修复系统，可靠性的重要指标为其寿命分布X和可靠度函数R(t)。若失效率函数为常数α，X服从负指数分布，则 <span class="math display">\[R(t)=P\{X&gt;t\}=e^{-\alpha t}\]</span> 不可修复系统的平均寿命记为MTTF， <span class="math display">\[MTTF=\frac{1}{\alpha}\]</span> 一般地，系统的失效率函数不为常数，设为r(t)，则可靠度： <span class="math display">\[R(t)=e^{-\int_{0}^{t}r(x)dx}\]</span></p><h4 id="可修复系统">1.2.2 可修复系统</h4><p>对于可修复系统，系统处于故障、正常的循环交替中。系统的可靠度有时也被称为<strong>可用度</strong>，它表示在总时间中有多少比例的时间系统处于正常状态，其可靠度R应与时间t无关， <span class="math display">\[R=\frac{正常时间}{总时间}\]</span></p><h4 id="平均故障间隔时间mtbf和平均修复时间mttr">1.2.3 平均故障间隔时间MTBF和平均修复时间MTTR</h4><p>可修复系统在故障之后，其修复时间的分布有多种类型。</p><p>下面假设系统的修复时间为参数β的负指数分布，系统正常工作时间为参数α的负指数分布，若R(t)为可靠度函数，则 <span class="math display">\[R(t)=\frac{\beta}{\alpha+\beta}+\frac{\alpha}{\alpha+\beta}e^{-(\alpha+\beta)t}\]</span></p><p><span class="math display">\[在t\rightarrow\infty时,R(t)=R=\frac{\beta}{\alpha+\beta}或\frac{\frac{1}{\alpha}}{\frac{1}{\alpha}+\frac{1}{\beta}}\]</span></p><p>1/α为平均故障间隔时间，一般记为MTBF；</p><p>1/β为平均修复时间，一般记为MTTR。</p><p>同时β也被称为修复率。</p><p>对于可修复系统可以利用实测数据来估计它的可用度；而对于不可修复系统，容易根据实测数据获得可靠度的估计值，从而得到寿命分布函数。</p><h3 id="复杂系统的可靠度">1.3 复杂系统的可靠度</h3><p>子系统可以依照不同的方法构成大系统，最简单的如串接、并接。在下图中分别表示了串接、并接系统。</p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230615143534212.png" alt="串接、并接系统" style="zoom: 67%;"></p><p>如果n个子系统只要有一个子系统故障，整个系统就故障，n个子系统就构成一个串接系统。</p><p>如果n个子系统只要有一个子系统正常，整个系统就正常，n个子系统就构成一个并接系统。</p><h5 id="独立系统可靠度计算">独立系统可靠度计算:</h5><p>当各个子系统独立时，串、并接系统的可靠度分别计算如下： <span class="math display">\[R_串=\prod_{i=1}^{n}R_i\]</span></p><p><span class="math display">\[R_并=1-\prod_{i=1}^{n}(1-R_i)\]</span></p><p>已知各子系统的可靠度R<sub>i</sub>总是小于1的，则串接系统的可靠度必小于任一子系统的可靠度。串接子系统愈多，可靠度也将愈小。</p><p>并接系统中的子系统愈多，系统的可靠度愈高。实际上这是采用备用系统的结果。备用系统愈多，当然愈不会失效。</p><h5 id="不可修复子系统的串接">不可修复子系统的串接：</h5><p>例如一个系统是由n个不可修复的子系统组成的串接系统，各子系统均相同，失效率均为α，或平均寿命均为1/α，则此系统的可靠度将为：<span class="math inline">\(R(t)=e^{-nat}\)</span> 其平均寿命将为1/nα，即缩短到1/n。</p><p>当各不可修复的子系统有不同失效率α<sub>r</sub>时，可得全系统的可靠度为：<span class="math inline">\(R(t)=e^{-t\sum_{r=1}^{n}\alpha_r}\)</span></p><p>平均寿命为： <span class="math display">\[T=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 等效失效率为：<span class="math inline">\(\alpha=1/T\)</span></p><h5 id="非独立系统可靠度">非独立系统可靠度：</h5><p>n个子系统串接形成一个系统，每个子系统为可修复系统，其可靠度为<span class="math inline">\(\frac{\beta_i}{\alpha_i+\beta_i}\)</span>，但当某个子系统故障时，别的子系统停顿，等故障子系统修复后，其它子系统继续一起工作，求系统可靠度R。</p><p>若第r个子系统失效，平均修复时间为：<span class="math inline">\(1/\beta_r\)</span></p><p>各子系统的失效概率应与它的失效率α<sub>r</sub>成正比，第r个系统失效的概率为： <span class="math display">\[p_r=\frac{\alpha_r}{\sum_{k=1}^{n}\alpha_k}\]</span> 全系统的平均修复时间为： <span class="math display">\[MTTR=\sum_{r=1}^{n}\frac{p_r}{\beta_r}=\frac{\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}{\sum_{r=1}^{n}\alpha_r}\]</span> 平均故障间隔时间为： <span class="math display">\[MTBF=\frac{1}{\sum_{r=1}^{n}\alpha_r}\]</span> 全系统的可靠度为： <span class="math display">\[R&#39;=\frac{MTBF}{MTBF+MTTR}=\frac{1}{1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}}\]</span> 各子系统独立时的可靠度： <span class="math display">\[R=\prod_{r=1}^{n}\frac{\beta_r}{\alpha_r+\beta_r}=\frac{1}{\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})}\]</span> 许多子系统停止了不必要的运行：R'&gt;R <span class="math display">\[\prod_{r=1}^{n}(1+\frac{\alpha_r}{\beta_r})&gt;1+\sum_{r=1}^{n}\frac{\alpha_r}{\beta_r}\]</span></p><h5 id="不可修复子系统的并接">不可修复子系统的并接：</h5><p>若各子系统都是不可修复的，全系统的可靠度为： <span class="math display">\[R(t)=1-\prod_{i=1}^{n}[1-R_r(t)]=1-\prod_{i=1}^{n}(1-e^{-\alpha_rt})=\sum_{r=1}^{n}e^{-\alpha_rt}-\sum_{r_1\not=r_2}^{}e^{-(\alpha_{r1}+\alpha_{r2})t}+\sum_{r_1\not=r_2\not=r_3}^{}e^{-(\alpha_{r1}+\alpha_{r2}+\alpha_{r3})t}-...\]</span> 平均寿命为：<span class="math inline">\(T=\sum_{r=1}^{n}\frac{1}{\alpha_r}-\sum_{r_1\not=r_2}^{}\frac{1}{\alpha_{r1}+\alpha_{r2}}+...\)</span></p><p>若各子系统的失效率均为α，则平均寿命为：<span class="math inline">\(T=\frac{n}{\alpha}-\frac{1}{2\alpha}C_n^2+\frac{1}{3\alpha}C_n^3-...+(-1)^n\frac{1}{n\alpha}\)</span></p><h2 id="网络可靠度的计算">2.网络可靠度的计算</h2><p>若考虑连通无向图G=(V,E)，<strong>点连通度α</strong>与<strong>线连通度β</strong>反映了图的可靠性大小，下面再定义一个混合连通度γ，其定义如下</p><p><span class="math inline">\(γ=min|X|\)</span>，其中X为混合割集。则<span class="math inline">\(\alpha=\gamma\le \beta\le \delta\le \frac{2m}{n}\)</span></p><p>为了更加细致地描述图的可靠性，引入三个辅助指标。它们的定义如下：</p><ul><li>C<sub>α</sub> = 最小割端集的数目；</li><li>B<sub>β</sub> = 最小割边集的数目；</li><li>A<sub>γ</sub> = 最小混合割集的数目；</li></ul><p>例题：<img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230044115.png" alt="题目" style="zoom:80%;"></p><p>解：</p><figure><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230104150.png" alt="端和边的个数"><figcaption aria-hidden="true">端和边的个数</figcaption></figure><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230218619.png" alt="混合割集" style="zoom:80%;"> <span class="math display">\[\alpha=3,\beta=3,\gamma=3\]</span></p><p><span class="math display">\[C_\alpha=60,B_\beta=60,A_\gamma=60+60+60*3+90*2=480\]</span></p><p><img src="/2023/06/15/%E9%80%9A%E4%BF%A1%E7%BD%91%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/image-20230621230502255.png" alt="近似可靠度" style="zoom: 50%;"></p><h2 id="网络综合可靠度">3.网络综合可靠度</h2><p><strong>通信网的各种连通度以及一些辅助指标</strong>，这些指标仅仅依赖于拓扑结构，是对可靠性的<strong>确定性度量</strong>。</p><p>为了<strong>进一步</strong>分析网络的可靠度，需要考虑<strong>网络承载的业务</strong>。</p><p>考虑<strong>故障因素</strong>的电话网络平均呼损也可被称之为<strong>综合不可靠度</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信网</tag>
      
      <tag>泊松分布</tag>
      
      <tag>数学建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生物信息学</title>
    <link href="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/"/>
    <url>/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>2023/6/14 12:15 昨天结束了生物信息基础的期末考试，而在今天终于把生物信息学的知识整理完毕，历时一个星期，收工！</p><h1 id="一序列分析">一、序列分析</h1><h2 id="序列的相似性">1.序列的相似性</h2><h3 id="序列比较">1.1 序列比较</h3><p>序列比较是生物信息学中最基本、最重要的操作。通过序列比较可以发现生物序列中的结构、功能和进化的信息。找出具有生物学意义的相似性或差异，研究序列的同源性。</p><ul><li>同源（homology）: 两个序列有共同的祖先。</li><li>垂直同源序列：来自于不同种属的的同源序列，也叫直系同源</li><li>横向同源序列：来自于同一种属的序列，由进化过程中的序列复制而产生，也叫旁系同源。</li></ul><p>同源序列一般是相似的，相似序列不一定是同源的。</p><p>序列比较的基本任务：</p><ul><li>计算序列之间的<strong>相似性</strong></li><li>找出序列之间的<strong>共同区域</strong></li><li>辨别序列之间的<strong>差异</strong></li></ul><h3 id="子序列和字串">1.2 子序列和字串</h3><p>子序列的描述</p><ul><li>子序列 <sub>0</sub>:s:<sub>i</sub> 称为前缀，即prefix(s,i)</li><li>子序列 <sub>i</sub>:s:<sub>|s|</sub>称为后缀，即suffix(s, |s|-i)</li><li><sub>i</sub>:s: <sub>i</sub> — 为空序列</li><li><sub>j-1</sub>:s:<sub>j</sub> —表示s 中的第j 个字符，简记为s<sub>j</sub></li></ul><p>子序列：选取s中的某些字符或删除s中的某些字符而形成s的一部分。</p><p>子串： 由s中相继的字符所组成</p><blockquote><p>子串是子序列，子序列不一定是字串</p></blockquote><h3 id="序列相似性比较">1.3 序列相似性比较</h3><p>相似程度的刻画：</p><ol type="1"><li>两个序列的相似度: 它是两个序列的函数，其值越大，表示两个序列越相似</li><li>两个序列的距离：距离越大，则两个序列的相似度就越小。</li></ol><blockquote><p>汉明(Hamming)距离：对于两条长度相等的序列，汉明距离等于对应位点 上字符不同的数目</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608114003804.png"></p></blockquote><p>序列比对(Alignment)是序列比较的基本操作。是关于序列相似性的定性描述。</p><p>两个序列的比对是指这两个序列中各个字符的一种一一对应关系(或各个字符的对比排列)。反映出两条序列在什么部位相同，什么部位存在差异。</p><blockquote><p>两个序列可以有多种不同的比对方式。</p></blockquote><h3 id="编辑距离">1.4 编辑距离</h3><p>度量两个字符串之间的距离的主要困难？</p><ul><li>两个字符串之间可能具有不同的长度，各自位置上的字符并不一定是真正的对应关系，直接计算汉明距离未必适当。</li></ul><p>如何合理度量？</p><ul><li>通过字符的插入、删除和替换等<strong>编辑操作</strong>把一个字符串变为另一个字符串</li></ul><ol type="1"><li>Match (a，a)：字符匹配</li><li>Delete (a，-) ：从第一条序列删除字符a (或在第二条序列相应的位置插入空位字符)</li><li>Insert (-，b)：在第一条序列插入空位字符(或删除第二条序列中的对应字符b)</li><li>Replace (a，b)：以第二条序列中的字符b替换第一条序列中的字符a，且a和b不相同</li></ol><p>编辑距离的定义：两个字符串之间，由一个字符串转换成另一个字符串所需要进行的<strong>最少</strong>编辑操作次数；其中的编辑操作包括把一个字符替换成另一个字符、插入一个字符和删除一个字符。</p><blockquote><p>编辑距离是所有可能的把s转换为t的<strong>编辑总代价的最小值</strong>。</p></blockquote><h3 id="序列比对的量化评价">1.5 序列比对的量化评价</h3><h4 id="代价函数法">1.5.1 代价函数法</h4><ul><li>首先定义一个<strong>代价函数</strong></li><li>然后定义序列比对的<strong>总代价</strong>等于各列的代价之和</li><li>其中，每一列考虑3种情况，其代价定义如下：<ul><li>匹配：0</li><li>替换：1</li><li>空位：1</li></ul></li></ul><h4 id="打分函数法">1.5.2 打分函数法</h4><ul><li>首先定义一个<strong>打分函数</strong></li><li>然后定义<strong>序列比对的打分值</strong>等于各列的打分之和</li><li>其中，每一列考虑3种情况，其打分定义如下：<ul><li>匹配：+1</li><li>替换：-1</li><li>空位：-1</li></ul></li></ul><blockquote><p>对于核酸序列或蛋白质序列的比对，打分函数 的定义需要考虑其生物学意义。</p></blockquote><h4 id="序列比对与最优序列比对">1.5.3 序列比对与最优序列比对</h4><p>序列比对：通过字符匹配、替换、插入或删除，使两个序列的长度相等；但不能出现两者全为空位的列，且每一列只能出现匹配、失配和出现1个空位这3种可能情形之一。</p><p>两条序列比对的得分：将序列s转化为序列t所用的所有编辑操作的得分总和。</p><p>最优序列比对：在所有可能比对中得分最高或者编辑代价最小的比对。</p><p>如何寻找最优比对？</p><ul><li>寻找得分最高或代价最小的比对<ul><li>需要设计算法，求解组合优化问题</li></ul></li></ul><h3 id="编辑距离的应用">1.6 编辑距离的应用</h3><ul><li>自然语言处理</li><li>机器翻译的自动评测</li><li>识别平行网页对</li><li>字符串核函数 (String Kernel)</li><li>歌曲的哼唱检索 (Query by Humming: QbH）</li></ul><h3 id="矩阵作图法">1.7 矩阵作图法</h3><p>矩阵作图法（对角线作图法）基本步骤：</p><ol type="1"><li>将两条待比较的序列分别放在坐标系的两个轴上：s序列放在Y轴上，自下而上；t序列放在X轴上，从左到右。</li><li>当对应的行与列的序列字符匹配时，则在矩阵对应的位置作出“点”标记。</li><li>逐个比较所有字符对，最终形成点矩阵。</li></ol><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180444466.png"></p><p>把点矩阵中非重叠的与对角线平行的斜线组合起来，可以形成两条序列的一种比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180557387.png"></p><p>矩阵作图法找最佳比对:寻找对应位点的相同字符最多的比对——相当于在点矩阵中找<strong>非重叠的最长的平行斜线的组合</strong>。</p><p>除非已知待比较序列非常相似，一般先用矩阵作图法进行比较。</p><p>矩阵作图法的缺陷：当两条序列中存在很多匹配的位点对时，点矩阵中会形成很多点标记。当比较长的序列进行比较时，这样的点阵图会变得非常复杂和模糊。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608180956992.png"></p><p>改进策略：滑动窗口技术</p><p>使用滑动窗口之间的比较去代替单个位点之间的比较。</p><ul><li>比如设窗口大小(window size)为10，相似度阈值为8，则每次比较取10个连续的字符，若相同字符数超过8个，则进行标记为窗口相似。</li></ul><p>优点：基于滑动窗口的点矩阵方法可以明显地降低点阵图的噪声，且明确无误的指示出两条序列具有显著相似性的区域。</p><p>滑动窗口法的效果比较：</p><ul><li>下图的(b)为人类(Homosapiens)与黑猩猩(Pongo pygmaeus)的β球蛋白基因序列进行比较的完整点阵图。</li><li>(c)为利用滑动窗口对以上的两种球蛋白基因序列进行比较的点阵图，其中窗口大小为10个核苷酸，相似度阈值(threshold)为8。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608181834815.png"></p><h2 id="两条序列的比较">2.两条序列的比较</h2><h3 id="序列比对打分矩阵">2.1 序列比对打分矩阵</h3><p>两条序列 s 和 t 的比对得分等于将 s 转化为 t 所用的所有编辑操作的得分总和。</p><p>详细列出各种字符替换的得分，并排列成表格(或矩阵)，即为打分矩阵。</p><blockquote><p>定义打分矩阵是进行序列比较的基础。</p></blockquote><p>选择不同的打分矩阵将得到不同的比较结果。</p><p>打分矩阵的定义需要依据其实际应用中生物学意义。</p><p>打分矩阵分为：</p><ul><li>核酸打分矩阵： 单位矩阵, BLAST矩阵, 转移矩阵<ul><li>单位矩阵 ：相同的核苷酸匹配得分为1，不同核苷酸替换为0。</li><li>BLAST矩阵 ：相同匹配得分为+5，反之为-4。</li><li>转移矩阵（transition）：相同匹配得分为+1，反之为-5。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608182752593.png"></p><ul><li>蛋白质打分矩阵：单位矩阵, 氨基酸突变代价矩阵GCM, 疏水矩阵…</li></ul><h3 id="最优序列比对">2.2 最优序列比对</h3><p>最优比对：在所有可能的比对中，得分最高(或编辑代价最小)的比对，把最优比对的得分值称为s和t的相似度，记作sim(s,t)。</p><ul><li>最高得分(相似度)是唯一的，但最佳比对方式不一定唯一。</li></ul><p>寻找最优比对：</p><ul><li>寻找得分最高(或代价最小)的比对</li><li>需要设计有效的最优化算法</li></ul><p>穷举法：穷举所有可能比对，选取最高得分者。</p><ul><li>穷举所有可能比对</li><li>分别计分</li><li>选取最高得分者</li></ul><p>两条序列可能的比对数目是<strong>序列长度的指数函数</strong>；随着序列长度的增长，计算量呈指数增长。穷举法不可行！ <span class="math display">\[比对数目=\sum_{k=0}^{min(m,n)}\frac{(m+n-k)!}{(n-k)!(m-k)!k!}\]</span></p><h3 id="动态规划dynamic-programming全局序列比对">2.3 动态规划（Dynamic Programming）—全局序列比对</h3><h4 id="认识动态规划算法">2.3.1 认识动态规划算法</h4><p>动态规划算法是寻找最优比对的一个方法。</p><p>利用同一问题已计算出的局部解求解<strong>全局解</strong>。</p><ul><li>一般是通过把一个问题分解成计算量合理的子问题，并使用这些子问题的结果来计算最终解。</li></ul><p>应用场景举例：用于在一个复杂空间中寻找一条最优路径。</p><ul><li>如果该问题可以描述为一个对应的图论问题，且问题的解对应于图中从起点到终点的最短距离，那么就可以通过动态规划算法解决这个问题。</li></ul><p>动态规划是<strong>求解最优化问题的一种途径或框架</strong>：</p><ul><li>并不是某一个特殊算法。</li><li>不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。</li><li>动态规划算法往往是针对某一种特定最优化问题设计。</li><li>不存在一种可以解决各类最优化问题万能的动态规划算法。</li></ul><p>动态规划的<strong>基本思想</strong>：将待求解问题分解成若干个子问题，先求解子问题，再从子问题的解得到原问题的解。</p><ul><li>经分解得到子问题往往不是互相独立的。</li><li><strong>保存已解决的子问题的答案</strong>，而在需要时再找出已求得的答案，以避免大量的重复计算。<ul><li>在穷举法中存在大量重复计算</li></ul></li><li>用一个表来记录所有已解的子问题的答案<ul><li>具体的动态规划算法多种多样，但它们具有相同的填表格式。</li></ul></li></ul><h4 id="动态规划算法基本步骤">2.3.2 动态规划算法基本步骤</h4><p>设计动态规划算法的五个<strong>基本步骤</strong>：</p><ol type="1"><li>确定问题的决策对象</li><li>对决策过程划分阶段</li><li>对各阶段确定状态变量</li><li>根据状态变量确定代价函数和总的目标函数</li><li>建立各阶段状态变量的转移过程，确定状态转移方程</li></ol><p>利用<strong>动态规划算法寻找最优序列比对的基本建模步骤</strong>：</p><ol type="1"><li>确定问题的决策对象：<ul><li>确定各个位点上应采用何种编辑操作: 匹配/失配/空位</li></ul></li><li>对决策过程划分阶段：<ul><li>一个位点对应一个阶段</li></ul></li><li>对各阶段确定状态变量：<ul><li>序列前缀串的比对结果和当前位置的编辑操作是当前阶段的状态变量</li></ul></li><li>根据状态变量确定得分函数和总的目标函数：<ul><li>序列前缀串的得分作为各阶段的得分函数，完整 序列的得分函数即构成总的目标函数</li></ul></li><li>建立各阶段状态变量的转移过程，确定状态转移方程：<ul><li>顺推方式：使用状态S<sub>k-1</sub>推导状态S<sub>k</sub> 的得分</li></ul></li></ol><h4 id="动态规划辅助矩阵">2.3.3 动态规划辅助矩阵</h4><p>在开始算法之前，我们还要理解一个概念是<strong>动态规划辅助矩阵</strong>：考虑两个序列s与t</p><ul><li><p>设 m = |s|, n= |t|, 则s共有m + 1个前缀串, t共有n + 1个前缀(包括空串)</p></li><li><p>动态规划辅助矩阵A为：(m + 1) × (n + 1)</p></li><li><p>矩阵A的(i,j)元素为前缀的最优比对得分: <span class="math display">\[A(i,j)=sim(prefix(s,j),prefix(t,j))或A(i,j)=sim(s[0..i],t[0..j])\]</span></p></li><li><p><strong>算法的核心步骤</strong>：通过状态转移方程，维护一个动态规划辅助矩阵A用以存放这些得分。</p><ul><li>算法从最短的前缀开始，递推地得到更长的前缀串的相似度，并不直接计算 sim(s,t)</li></ul></li><li><p>全局序列比对也称为Needleman-Wunsch(NW)算法。</p></li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure><p><strong>计算A(i,j)的方法</strong>：</p><ul><li><p>已知序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的前缀最优比对，即是已知3种子序列的最优比对</p><ul><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li><li><sub>0</sub>:s:<sub>(i-1)</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对</li><li><sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>(j-1)</sub>的最优比对</li></ul></li><li><p>则序列<sub>0</sub>:s:<sub>i</sub>和<sub>0</sub>:t:<sub>j</sub>的最优比对必是上述3种情况之一的扩展，即</p><ul><li><p>替换或匹配(s<sub>i</sub> ,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195505891.png" style="zoom: 50%;"></p></li><li><p>删除(s<sub>i</sub> ,-)</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195559054.png" style="zoom: 50%;"></p></li><li><p>插入(-,t<sub>j</sub> )</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608195946697.png" style="zoom: 50%;"></p></li></ul></li><li><p>状态转移方程： <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span></p></li></ul><h4 id="辅助矩阵的初始化">2.3.4 辅助矩阵的初始化</h4><ul><li>假设给定打分函数：<ul><li>匹配：1</li><li>失配：-1</li><li>空位：-2</li></ul></li><li>初始化辅助矩阵A：<ul><li>矩阵的纵轴方向自上而下对应于第1条序列(s)，横轴方向自左向右对应于第2条序列(t)</li><li>矩阵横向的移动表示在纵轴序列中加入一个空位</li><li>纵向的移动表示在横轴序列中加入了一个空位</li><li>而斜对角向的移动表示两序列各自相应的字符进行比对</li></ul></li></ul><blockquote><p>注意：各轴第一个元素的索引下标为0, 且初始化A(0,0)=0。</p></blockquote><h4 id="动态规划辅助矩阵的维护过程">2.3.5 动态规划辅助矩阵的维护过程</h4><p>计算顺序：</p><ol type="1"><li>计算过程从A(0,0)开始，到A(m, n)结束。</li><li>计算A(i,j)时，只要已知A(i-1,j), A(i-1,j-1), A(i,j-1)即可使用递推公式计算。<ul><li>可按行计算——每行从左到右，也可按列计算—— 每列从上到下。</li><li>第一行第一列可以单纯的-2来计算，因为矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位。</li></ul></li><li>在计算A(i,j)后，需要<strong>保存</strong>A(i,j)是从(i − 1,j), (i − 1,j − 1), (i,j − 1) 中的哪一个位置推进的。<ul><li>保存计算路径，以便于后续处理</li></ul></li></ol><h4 id="用序列比对的动态规划求解问题的实例">2.3.6 用序列比对的动态规划求解问题的实例</h4><p>给定序列s和t，打分函数定义如下。请使用NW算法找出最优比对：s=AAAC，t=AGC</p><p>打分函数：<img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608202753737.png"></p><p><strong>基本求解步骤：</strong></p><ul><li><p>建立动态规划辅助矩阵</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608194456553.png" alt="动态规划辅助矩阵A"><figcaption aria-hidden="true">动态规划辅助矩阵A</figcaption></figure></li><li><p>初始化动态规划辅助矩阵</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203000442.png" style="zoom: 50%;"></p></li><li><p>根据状态转移方程不断维护辅助矩阵A</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203043267.png" style="zoom:50%;"></p><ul><li>最终得到的A(m,n)即为s与t的最佳比对得分(相似度)为-1。</li></ul></li><li><p>回溯计算的路径，以找到最优比对</p><ul><li><p>从A(m,n)开始，反推</p></li><li><p>假设在反推到达A(i,j)时，根据保存的计算路径判断A(i,j)究竟是利用A(i-1,j), A(i-1,j-1), A(i,j-1)中的哪一个计算而得到的</p></li><li><p>找到这个点后，由从此点出发，一直到A(0,0)为止</p></li><li><p>矩阵横向的移动表示在纵轴序列中加入一个空位，纵向的移动表示在横轴序列中加入了一个空位；而斜对角向的移动表示两序列各自相应的字符进行比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608203832883.png"></p></li><li><p>图中路径对应的最佳比对（有多种最佳比对方式）为：</p><ul><li>AAAC与AG-C</li><li>AAAC与A-GC</li><li>AAAC与-AGC</li></ul></li></ul></li></ul><h3 id="最优局部比对子序列与完整序列的比对">2.4 最优局部比对—子序列与完整序列的比对</h3><h4 id="认识最优局部比对">2.4.1 认识最优局部比对</h4><p>最优全局比对：两条长度相近的序列进行比对。</p><p>最优局部比对：</p><ul><li><p>子序列与完整序列的比对；</p></li><li><p>寻找最大的相似子序列。</p></li></ul><p>基于动态规划的最优全局序列比对可以找出两条序列的最佳比对，但未必总是具有生物学意义。</p><ul><li>有些同源序列虽然全序列的相似性很小，但是存在高度相似的局部区域。</li><li>如果在进行比对时，注重序列的局部相似性，则可能会发现重要的比对。</li><li>Smith和Waterman在Needleman-Wunsch算法的基础上提出了序列最优局部比对算法。</li><li>最优局部比对算法叫做Smith-Waterman算法。</li></ul><p>把一个较短的序列与一个较长的完整序列进行比对，试图找出<strong>最优的局部匹配</strong>。</p><ul><li>给定两条序列 <sub>0</sub>:s:<sub>m</sub>和<sub>0</sub>:t:<sub>n</sub> ，<strong>从<sub>0</sub>:t:<sub>n</sub>中寻找一个子序列</strong>，使得两条序列 sim(s, <sub>i</sub>:t:<sub>j</sub>)最大</li></ul><h4 id="最优局部序列比对的实现">2.4.2 最优局部序列比对的实现</h4><p>寻找最优的局部比对时，需要避免对序列一端或者两端出现的空位进行罚分。</p><p>由于不计删除序列t前缀的得分，因此在对动态规划辅助矩阵初始化时，按照下述方式处理： <span class="math display">\[A(_0:s:_0,_0:t:_j)=0\]</span> 局部比对也不计删除序列t后缀的得分，因此: <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\end{cases}\]</span> 动态规划辅助矩阵最后一行的更新公式: <span class="math display">\[A(m,j)=max\begin{cases} A(m,j-1)+0\\ A(m-1,j-1)+p(s[m],t[j])\\A(m-1,j)+p(s[m],-)\end{cases}\]</span> 局部最优序列比对路径：</p><ul><li>从最后一行(第m行)中寻找最大值，反推最优路径到达第一行<ul><li>由位置(m, j) 出发，反推最优比对路径，最终通过<strong>斜线</strong>(非空位)到达(1, i)，其中 j 是第 m 行中取得最大分值的最小列下标。</li></ul></li></ul><h3 id="最优局部比对寻找最大的相似子序列">2.5 最优局部比对——寻找最大的相似子序列</h3><p>对两条序列都进行部分比对，以寻找最大的相似子串。</p><ul><li>初始化<ul><li>由于不计删除或插入序列前缀的得分，因此边界条件(即初始化)修改为：A(0,j)=0，A(i,0)=</li><li>即动态规划辅助矩阵A的第0行和第0列初始化为0</li></ul></li></ul><blockquote><p>相当于忽略前缀</p></blockquote><ul><li><p>状态转移方程 <span class="math display">\[A(i,j)=max\begin{cases} A(i,j-1)+p(-,t[j])\\ A(i-1,j-1)+p(s[i],t[j])\\A(i-1,j)+p(s[i],-)\\0\end{cases}\]</span></p><ul><li>对于每个A(i,j)，一定存在一个得分为“0”的空后缀比对，因此矩阵A中的所有元素大于或等于“0”</li><li>阈值为0意味着矩阵中的0元素分布区域对应于不相似的子序列，而正数区域则是局部相似的区域。</li></ul></li><li><p>在矩阵A中寻找最大值</p><ul><li>该值是最优局部比对得分</li><li>该值对应的位置为序列局部比对的末点</li><li>反向推演前面的最优路径，直到局部比对的起点——局部比对的起点取值为0</li><li>矩阵A中元素的含义与基本算法有所不同：A(i,j)中每个元素的值代表序列<sub>0</sub>:s:<sub>i</sub> 某个后缀和序列<sub>0</sub>:t:<sub>j</sub> 某个后缀的最佳比对</li></ul></li></ul><h3 id="准全局比对">2.6 准全局比对</h3><p>准全局序列比对的四种常见情况对应于两个序列终端空位的四种可能：</p><ul><li>子序列与完整序列的比对</li><li>寻找最大的相似子序列</li><li>判断一条序列的前缀与另一条序列的后缀相似</li><li>判断一条序列的后缀与另一条序列的前缀相似</li></ul><p>准全局序列比对：在评价序列比对时，不计算序列终端出现“空位”情况的罚分。</p><p>所谓的序列终端空位包括：</p><ul><li>出现在序列第一个字符之前的空位</li><li>出现在序列最后一个字符之后的空位</li></ul><p>不计前端空位:</p><ul><li>不计s的前端空位：第0行初始值为“0”</li><li>不计t的前端空位：第0列初始值为“0”</li></ul><p>不计末端空位:：</p><ul><li>不计s的末端空位：在最后一行中寻找最大值</li><li>不计t的末端空位：在最后一列中寻找最大值</li></ul><p><strong>以上4条可任意组合</strong></p><h3 id="总结">2.7 总结</h3><p>全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221708590.png"></p><p>局部序列比对—子序列与完整序列的比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221811317.png"></p><p>局部序列比对——寻找最大的相似子序列：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221842345.png"></p><p>准全局序列比对：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230608221912089.png"></p><h2 id="多序列比对">3.多序列比对</h2><h3 id="多条序列比对的提出">3.1 多条序列比对的提出</h3><p>序列序列两两比对主要用于建立两条序列的同源关系和推测它们的结构、功能。</p><p>多条序列比对对于研究分子结构、功能及进化关系更为有用。</p><ul><li>在实际蛋白质研究中，并不是仅仅分析单个蛋白质，而是更着重于研究蛋白质之间的关系，研究一个家族中的相关蛋白质及序列中与结构域或功能相关的保守区域，进而分析蛋白质的结构和功能。<ul><li>序列两两比对不能满足这样的需要，难以发现多个序列的共性。</li><li>要得到一个序列家族的序列特征，需要同时比对多条同源序列。</li><li>当给定一个新序列时，根据序列特征，可以判断这个序列是否属于该家族。</li></ul></li></ul><p>多序列比对定义：有k ( &gt; 2 ) 个序列s<sub>1</sub> , s<sub>2</sub> , ... ,s<sub>k</sub>，每个序列由同一个字母表中的字符组成。通过插入字符操作，使得各序列达到一样的长度，从而形成这些序列的多重比对。</p><p>目标：</p><p>发现多个序列的共性</p><p>发现与结构和功能相关的保守序列片段</p><p>推测各个序列的进化历史</p><h4 id="打分函数">3.1.1 打分函数</h4><p>具有k个变量, 可用一个k维数组来表示。</p><p>所期望的打分函数：</p><ul><li>函数在形式上应该简单，具有统一的形式。</li><li>不随序列的个数而发生形式变化。</li><li>函数值应独立于各参数的顺序，与比较的序列先后次序无关。</li><li>对相同或相似字符的比对，得分值高。</li></ul><h5 id="spsum-of-pairs模型">SP(Sum-of-Pairs)模型</h5><p>SP模型的思路：按照每个比对的列进行打分，然后求和。</p><p>SP打分函数： <span class="math display">\[SP(c_1,c_2,...,c_k)=\sum_{i=1}^{k-1}\sum_{j=i+1}^{k}p(c_i,c_j)\]</span></p><ul><li><p>其中c<sub>1</sub> ,c<sub>2</sub> ,…,c<sub>k</sub>是一列中的k个字符，p(. , . )是关于一对字符相似性的打分函数。</p><p>总得分基于字符两两比较得分。</p><p>把一个多重比对所有列的得分全部加起来，其和即为该多重序列比对的得分。</p></li></ul><p>多重序列比对的空位：</p><ul><li>进行多重序列比对时，可能<strong>会出现两个空位字符的比对</strong>，因此我们扩充打分函数p的定义域。<ul><li>即增加p(-,-)=0</li><li>在分析这两条序列时，可以同时去掉这些空位。这个结果称之为多重序列比对在两条特定序列上的投影(projection)。</li></ul></li></ul><p>基于SP打分函数的逐对比对：</p><ul><li><p>引入打分函数的定义域扩充p(−,−) = 0后,则可以先对每一对序列进行两两比对，再求和： <span class="math display">\[SP(s_1,s_2,...,s_k)=\sum_{i&lt;j}^{k}sim(s_i,s_j)\]</span></p><ul><li>等价于对多重序列的每一列进行计算，然后将每一列的得分值相加。</li></ul></li></ul><p>穷举出所有可能的比对，取得分最高者！</p><h3 id="多条序列比对的方法">3.2 多条序列比对的方法</h3><p>精确比对：多重比对的动态规划算法</p><p>渐进比对：星形比对、树形比对</p><h4 id="多重序列比对的动态规划算法">3.2.1 多重序列比对的动态规划算法</h4><p>对于3条序列，每1种可能的比对可以用3维晶格中的1条路径来表示，每1维对应于1条序列。</p><ul><li>路径的起点为晶格的<strong>左上后角</strong>，终点为晶格的<strong>右下前角</strong>。</li><li>对于多条序列，则形成超晶格(hyper-lattice)。</li><li>对于两条序列比对，其得分矩阵相当于2维晶格(平面)。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609103503859.png" alt="三条序列比对"><figcaption aria-hidden="true">三条序列比对</figcaption></figure><h5 id="多重比对的动态规划的基本原理">（1）多重比对的动态规划的<strong>基本原理</strong>：</h5><ul><li>在超晶格中，序列比对的计算是从左上后角坐标点(0,0,…,0)开始，按<strong>节点之间的依赖关系</strong>向右下前方推进，直至计算完最后一个节点。<ul><li>实际计算时可按先低维再高维(对应于先行后列)。</li><li>二重序列比对时，可将动态规划算法的计算过程看成是在二维平面上按照一定顺序访问每个节点，每个节点的得分代表两个序列前缀的最优比对的得分。</li></ul></li><li>当前位点的得分计算取决于与它相邻的(2k – 1)条边，分别对应于匹配、替换或引入空位等3种编辑操作。</li><li>计算各操作的得分时，选择一个得分最大的操作，将得分和存放于该节点。</li></ul><h5 id="状态转移方程">（2）状态转移方程：</h5><p><span class="math display">\[s_{i,j,k}=max\begin{cases} s_{i-1,j,k} \enspace +\delta(\upsilon_i,-,-) \\ s_{i,j-1,k} \enspace +\delta(-,\omega_j,-)\\s_{i,j,k-1} \enspace +\delta(-,-,\mu_k)\\s_{i-1,j-1,k}  +\delta(\upsilon_i,\omega_j,-)\\s_{i-1,j,k-1}  +\delta(\upsilon_i,-,\mu_k)\\s_{i,j-1,k-1}  +\delta(-,\omega_j,\mu_k)\\s_{i-1,j-1,k-1}  +\delta(\upsilon_i,\omega_j,\mu_k)\end{cases}\]</span></p><h5 id="dp算法的计算过程">（3）DP算法的计算过程：</h5><p>动态规划的计算过程是一个递推更新动态规划辅助矩阵的过程。</p><ul><li>在计算每个节点得分时，将其<strong>各前趋节点</strong>的值分别加上从前趋节点到当前点的SP得分，取最大值作为当前节点的值。<ul><li>一般在3维(k=3)情况下，考虑7个前趋节点。</li><li>在k维情况下，前趋节点的个数等于2k –1。</li></ul></li></ul><p>多重比对的DP算法的计算复杂度：</p><ul><li>对于k条序列，动态算法需要处理k维空间的每个节点，计算量与节点数成正比（与各序列长度的乘积的乘积）。<ul><li>注意到前趋节点的个数为2<sup>k</sup> – 1，因此动态规划算法复杂度为O(2<sup>k</sup> N<sup>k</sup>)。</li><li>随着待比对的序列数目k的增加，动态规划的计算量和所要求的计算空间呈<strong>指数</strong>形式猛增。</li></ul></li></ul><p>多重比对的动态规划的空间复杂度：</p><ul><li>动态规划辅助矩阵的大小 = N<sup>k</sup> 个元素<ul><li>N为序列长度</li><li>k为序列条数</li></ul></li><li>每个元素需要处理2<sup>k</sup> – 1个相邻元素<ul><li>时间复杂度: O(2<sup>k</sup> N<sup>k</sup>)</li></ul></li></ul><p>如果采用标准的动态规划算法计算最优的多重序列比对，k较大时所需要的时间和空间复杂度均是难以满足的。</p><h4 id="渐进方法星形比对">3.2.2 渐进方法—星形比对</h4><p><strong>渐进法</strong>的基本过程：</p><ul><li>把多重序列比对转化为两两序列比对。</li><li>再将两两比对聚合起来，最终形成完整的多序列比对。</li></ul><p><strong>渐进法</strong>的特点：</p><ul><li>属于启发式近似方法，能够大大减少所需的计算时间。</li><li>虽然无法保证最终得到最优解，但在大多数情况下，其计算结果接近最优结果。</li></ul><h5 id="星形比对的基本思路">（1）星形比对的基本思路：</h5><ol type="1"><li>在给定若干序列中，首先选出一个<strong>核心序列</strong>。</li><li>把该序列与其它序列进行两两比对。</li><li>最后聚合形成所有序列的多重比对。<ul><li>使得该多重比对在核心序列和任何一个其它序列方向的投影均为最优的两两比对。</li></ul></li></ol><blockquote><p>基本过程：</p></blockquote><ul><li>假设k条待比对的序列中核心序列是s<sub>c</sub>，那么：<ul><li>先利用标准的动态规划方法求出所有s<sub>i</sub>和s<sub>c</sub>的最优两两比对。</li><li>把得到的两两比对按一定规则<strong>聚合</strong>起来。</li></ul></li></ul><p>时间复杂度为 O(k N<sup>2</sup>)</p><h5 id="如何选择核心序列">（2）如何选择核心序列？</h5><ul><li><p>第一种方法是尝试将每一个序列分别作为核心序列，进行星形多重序列比对，取比对结果最好的一个。</p></li><li><p>另一种方法是计算所有的两两比对，取下式值最大的一个： <span class="math display">\[sim(s_j,s_c)\]</span></p></li></ul><h5 id="星形比对的基本过程">（3）星形比对的基本过程：</h5><ol type="1"><li>选定一个核心序列。</li><li>把多重比对转化为k个两两比对。</li><li>聚合过程：从某一个两两比对开始，比如sc和s1，然后逐步加上其他的两两比对。<ul><li>对于空位采用”一次加入空白，次次保留空白”原则: 逐增加 s<sub>c</sub>中的空位字符，以适应其他的比对，但不删除s<sub>c</sub>中已经存在的空位字符。</li></ul></li></ol><h4 id="渐进方法树形比对">3.2.3 渐进方法—树形比对</h4><p>树形比对一般过程：</p><ol type="1"><li>先将多个序列进行两两比对，基于这些比对得到相似性矩阵。<ul><li>该矩阵反映逐对序列之间的关系。</li></ul></li><li>利用该相似性矩阵，构建一棵“<strong>指导树(guide tree)</strong>”。</li><li>从<strong>最接近的一对序列出发</strong>，根据指导树逐步填加序列，聚合成多重比对；直到所有序列处理完毕为止。</li></ol><h2 id="在数据库中进行序列同源搜索">4.在数据库中进行序列同源搜索</h2><h3 id="问题的提出">4.1 问题的提出</h3><p>在数据库中搜索相似的序列：</p><ul><li>查询序列（待查询的序列）</li><li>目标序列（数据库中的每条被搜索的序列）</li></ul><p>直接用两序列比对进行数据库搜索存在的问题：</p><ul><li>目标序列太长、数量巨大，穷举式搜索耗时过长。</li><li>解决办法：索引技术、启发式方法。</li><li>实用的数据库搜索算法：“最佳”→“较佳”。</li></ul><p>两大主要搜索算法：</p><ul><li>BLAST及其相关算法</li><li>FASTA及其相关算法</li></ul><h3 id="常用的搜索方法blast搜索算法">4.2 常用的搜索方法—BLAST搜索算法</h3><p>主要特征：原始的BLAST算法是<strong>不带空位的局部比对方法</strong>。</p><p>给定一个查询序列，BLAST返回所有查询序列与数据库序列得分<strong>超过某个阈值S</strong>的片段对。</p><blockquote><p>阈值S可以由用户设置，但程序有一个默认的推荐值。</p></blockquote><ul><li><p>选择S的<strong>基本原则</strong>是：一条随机序列与查询序列比较的得分不会超过S。</p></li><li><p>由于在序列比对过程中不考虑空位的操作(没有插入和删除)，则对于二维平面上各点的计算问题可转化为一维点的计算问题，计算速度得以大幅提高。</p></li></ul><p>通过搜索序列数据库来找出<strong>最优的无空位局部比对</strong>。</p><ul><li>从数据库中找出与<strong>查询序列的某些子序列</strong>相似的子序列。</li><li>在进行数据库查询时，BLAST返回一个<strong>高得分的相似片段对列表</strong>，每个片段对包括查找序列的一个片段和数据库中待比较序列的一个片段。</li></ul><blockquote><p>BLAST算法把数据库搜索建立在严格的统计学基础上。</p></blockquote><h5 id="基本步骤">基本步骤：</h5><ol type="1"><li><p>利用<strong>滑动窗口</strong>将查询序列分解为定长的“单词”串(默认长度为4)。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164801077.png" style="zoom:67%;"></p></li><li><p>舍弃那些由最常见的残基组成的“单词”串，在数据库中精确匹配剩余“单词”串。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609164946161.png" style="zoom:67%;"></p></li><li><p>对匹配上的单词串，逐步向两端延伸该匹配，直到得分低于某个阈值为止。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609165100296.png" style="zoom:67%;"></p></li></ol><h3 id="常用的搜索方法fasta搜索算法">4.3 常用的搜索方法—FASTA搜索算法</h3><p>FASTA是另一种常用的序列比对及搜索工具：</p><ul><li>能够进行<strong>带空位的局部比对</strong>。</li><li>由于FASTA搜索时会将<strong>查询序列与数据库中每条序列进行细致比较</strong>，故通常比BLAST搜索要慢些。</li></ul><h5 id="基本步骤-1">基本步骤：</h5><ol type="1"><li><p>用滑动窗口将查询序列分隔成“单词”串：</p><ul><li>对于核苷酸序列， “单词”串长为4~6</li><li>对于氨基酸序列， “单词”串长为1~2</li></ul></li><li><p>为查询序列建立一个表格，记录下各个“单词”串在序列中出现的位置。</p><p>例：“单词”长度为1的序列如下：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609170226299.png" alt="查询序列" style="zoom:67%;"></p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171158162.png" alt="查询序列表格"><figcaption aria-hidden="true">查询序列表格</figcaption></figure></li><li><p>对目标序列建立另一个表格，用于比较目标序列与查询序列中各残基的位置之差。</p><p>查询序列：<strong>FAMLGFIKYLPGCM</strong></p><p>目标序列：<strong>TGFIKYLPGACT</strong></p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609171928801.png"></p></li><li><p>从第二个表中发现有很多距离为3的位置，这表明：如果对目标序列<strong>偏移3个位置</strong>，则可得到一个较好的比对。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609172302785.png"></p></li></ol><p>通过比较两条序列的<strong>偏移表</strong>，可以很快地发现相同的区域，并将这些区域连接起来形成更长的序列，然后利用Smith-Waterman算法比对。</p><blockquote><p>由于FASTA是对已知区域进行比对，较原始算法(即用动态规划算法进行查询序列与所有目标序列间的比对)要快得多。</p></blockquote><h3 id="数据库搜索结果得分及统计显著性">4.4 数据库搜索结果得分及统计显著性</h3><p>提出原因：</p><ul><li>数据库搜索总会产生结果，<strong>但找到的序列未必真与查询序列相关</strong>。</li><li>比对得分可以说明搜索的结果与查询序列之间的相似程度，但由于数据库搜索算法不同、比对打分标准不统一 ，因此<strong>比对得分值</strong>本身并不能充分指明两序列间的关系。</li></ul><p>设某个数据库搜索结果的比对得分为S，我们可以提出一个<strong>基本问题</strong>：</p><ul><li>若有一组与查询序列不相关的序列(<strong>如随机序列</strong>)，则在这些序列中随机找到一个得分同样为S的比对的概率有多大？</li></ul><p>为回答这个基本问题，数据库搜索引擎通常会为每个搜索结果提供P得分与E得分。</p><p>P得分：对于随机找出的一条或多条序列，其比对得分大于等于S的<strong>可能性</strong>(概率)。</p><p>E得分：随机找出的、与查询序列进行比对的<strong>得分大于等于S的目标序列的期望数目</strong>。</p><ul><li>如果E得分与P得分均<strong>较低</strong>，则说明搜索结果与查询序列<strong>具有进化上的关系</strong>，并不是由于<strong>随机因素</strong>得到的结果。</li></ul><blockquote><p>当E值&lt; 10<sup>-3</sup>时，通常认为搜索结果具有统计上的显著性；</p><p>–搜索得到的匹配序列在E值上可以低到<strong>10<sup>-50</sup></strong> ，表明查询序列与搜索结果间<strong>具有进化关系的可能性极大</strong>。</p></blockquote><h2 id="dna片段组装">5.DNA片段组装</h2><h3 id="问题提出与定义">5.1 问题提出与定义</h3><p>问题描述：给定一组取自特定字母表的字符串集合F，寻找一个最短的字符串s，使得F中的每一个字符串均为s的一个连续子串。</p><ul><li>其中，集合F中的字符串是待组装的序列片段，s 是序列片段组装的结果。</li></ul><p>DNA片段组装任务的提出：大规模基因组测序时，得到待测序列的<strong>一系列片段</strong>，这些序列片段<strong>覆盖待测序列</strong>，且序列片段之间存在相互覆盖或重叠；根据这些存在相互覆盖或重叠的序列片段，<strong>重建</strong>目标DNA序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609192717156.png"></p><h5 id="序列片段组装的基本原理">序列片段组装的基本原理：</h5><p>将输入的序列片段进行<strong>两两比对</strong>；</p><ul><li>与基本的序列两两比对算法不同，此时需要寻找一个序列的后缀与另一个序列的前缀相同或相似的部分。</li><li>通过准全局序列比对(忽略某一端的空白字符)，相当于各个片段之间进行相对定位；</li><li>由各个片段之间的相对定位，逐步确定目标序列。</li></ul><p>指导片段组装的因素是<strong>片段之间的覆盖</strong>。</p><ul><li>通过各个片段之间的覆盖，对片段实现<strong>相对定位</strong>，进而把所有片段连接起来。<ul><li>也可以看成是序列片段的特定多重比对。</li></ul></li><li>对于每一列，提取<strong>出现频率最大</strong>的一个字符。</li></ul><h3 id="dna片断组装的主要困难">5.2 DNA片断组装的主要困难</h3><h4 id="碱基标识错误">5.2.1 碱基标识错误</h4><p>在序列片段中存在碱基替换、插入和删除。</p><p>解决方案:</p><ul><li>考虑到序列的检测误差，序列片段组装的一个更准确定义为：给定一组取自特定字母表的字符串集合F，其中的字符串具有一定的误差，寻找一个<strong>最短的字符串s</strong>，使得在s中观察到F的可能性最大。</li></ul><blockquote><p>最大似然 (Maximum Likelihood)准则：以可能性最高为判断标准。</p></blockquote><h4 id="未知片段方向">5.2.2 未知片段方向</h4><p>如果一个片段是一条链的子串， 根据互补原则，该片段的反向互补片段是另一条链的子串。</p><p>对于一条输入的片段，在进行组装时，既可以用其本身，也可以用其<strong>反向互补片段</strong>。</p><p>解决方案：按两个方向分别尝试。</p><h4 id="存在重复区域">5.2.3 存在重复区域</h4><p>重复区域是目标序列中多次出现的子序列。有的重复区域太长，超过片段的边界，造成无法给出确切相对定位，使片段组装变得不确定。</p><h4 id="缺少覆盖">5.2.4 缺少覆盖</h4><p>覆盖强度：定义为目标序列上某个位点上覆盖此位点的片段个数。</p><blockquote><p>平均覆盖强度: 计算求所有覆盖片段的长度和，再除以目标序列长度的估计值。</p></blockquote><p>如果对于目标序列上的某个位点，覆盖该点的序列片段个数为零，则没有相关的序列信息来重建该点附近的目标序列。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609194833195.png"></p><h3 id="dna片段组装的基本过程与组装模型">5.3 DNA片段组装的基本过程与组装模型</h3><h4 id="dna片段组装的基本过程">5.3.1 DNA片段组装的基本过程</h4><ol type="1"><li>首先进行序列片段的两两比对，确定可能的片段之间的覆盖（或者重叠）。</li><li>确定所有片段统一的覆盖模式，即确定各个序列片段的相对位置（最关键一步）。</li><li>最后确定片段组装结果，即确定目标序列。</li></ol><h4 id="最短公共超串模型">5.3.2 最短公共超串模型</h4><p>给定一个字符串集合F，求出一个<strong>最短</strong>的字符串S，使得对于所有属于F 的字符串<em>f</em>，S是<em>f</em>的超串(或者<em>f</em>是S的子串)。</p><p>设F={ACT,CTA,AGT}，则S=ACTAGT是F的超串。</p><p>其中，S要求是各片段的严格超串，不允许片段中存在实验误差，而且<strong>各片段的方向必须已知</strong>。</p><h4 id="重建模型">5.3.3 重建模型</h4><h5 id="近似子串">（1）近似子串</h5><p>考虑到片段的误差和未知方向的问题，对于判别子串的序列比较不需要完全匹配，而是根据相似程度进行处理，需要引入“近似子串”的概念。</p><p>假设 <em>f</em>, <em>g</em>是代表两条序列的字符串，<em>f</em>作为<em>g</em>近似子串的代价为： <span class="math display">\[d_s(f,g)=\min_{s\in S(g)}d(f,s)\]</span></p><ul><li>其中，S(<em>g</em>)代表<em>g</em>的所有子串的集合，<em>d</em>(⋅ , ⋅)为一般编辑距离。</li></ul><p>设0 &lt; ε &lt; 1，如果<em>d<sub>s</sub>(f,g)</em> ≤ ε|<em>f</em>| , 则称字符串 <em>f</em>是误差 ε 下 <em>S</em> 的近似子串。</p><h5 id="重建模型的定义">（2）重建模型的定义</h5><p>给定一个字符串集合<em>F</em>，求一个最短的字符串<em>S</em>，使得对于所有字符串<em>f∈F</em>，有: <span class="math display">\[d_s(f,S)\le \epsilon|f|\]</span> 或者 <span class="math display">\[d_s(f^{&#39;},S)\le \epsilon|f|\]</span> 其中 <em>f′</em> 是 <em>f</em> 的反向互补串。</p><p>主要思路: 寻找一个尽可能短的字符串<em>S</em>，使得每一个<em>f</em>或其反向 互补串<em>f′</em>成为<em>S</em>的近似子串。</p><p>该模型可同时处理序列误差、未知序列方向的问题，但不能处理目标序列中的重复区域和缺少覆盖问题。</p><h4 id="多重连续区模型">5.3.4 多重连续区模型</h4><p>t-contig：在多重序列比对中，如果其<strong>最弱连接的交叠长度至少为t</strong>，则称为一个t-contig。</p><p><em>F</em> 允许一个t-contig：在多重序列比对中，如果能够根据序列片段集合<em>F</em>构造一个t-contig，则称<em>F</em>允许1个t-contig。</p><p>多重连续区模型：</p><ul><li>通过构造t-contig来定义具体不同覆盖强度的序列组装结果。</li><li>给定一个片段集合<em>F</em>和一个整数 t ≥ 0, 将<em>F</em>分割为最小数目的片段子集C<sub>i</sub>，其中1 ≤ i ≤ k，且 每个C<sub>i</sub>允许一个t-contig。</li></ul><blockquote><p>把F分割为k个子集C<sub>i</sub>，根据序列片段子集C<sub>i</sub>构造出一个t-contig，进而完成最小覆盖强度为t的组装结果。</p></blockquote><h1 id="二基因组学与基因识别">二、基因组学与基因识别</h1><h2 id="基因与基因组">1.基因与基因组</h2><p>基因(Gene) ：编码一条多肽链或功能RNA所必需的全部核苷酸序列。</p><blockquote><p>DNA分子链上的特定区域。</p></blockquote><p>基因组(Genome)：一个细胞或者生物体所携带的一套完整的染色体单倍体序列。</p><blockquote><p>包括编码序列和非编码序列在内的全部DNA分子，包含全套基因序列和间隔序列。</p></blockquote><p>基因表达：利用存储在DNA中的遗传信息合成RNA分子，然后再合成相应蛋白质的过程，称为基因表达。</p><blockquote><p>基因表达包括转录与翻译两个子过程。</p></blockquote><h3 id="生物分子中的信息传递">1.1 生物分子中的信息传递</h3><p>在生物生长发育过程中，生物信息传递有两种方式：</p><ol type="1"><li>自我复制——在繁衍过程中传递遗传信息。</li><li>基因通过转录和翻译，使遗传信息在生物个体 中表达，使后代表现出与亲代相似的生物性状。<ul><li>DNA→RNA→蛋白质</li><li>基因控制着蛋白质的合成，基因的DNA序列到蛋白质序列存在着一种明确的对应关系——遗传密码。</li></ul></li></ol><blockquote><p>遗传密码又称三联体密码，即DNA序列3个连续的碱基对应编码1个蛋白质的氨基酸，且对应关系具有通用性。</p><p>自然界中天然存在20种氨基酸(标准氨基酸)→21种或22种。</p><p>第21: 硒代半胱氨酸(Sec, U), 由终止密码子UGA有义编码Sec；</p><p>第22：吡咯赖氨酸(Pyl, O), 由终止密码子UAG的有义编码Pyl。</p></blockquote><h3 id="人类基因组">1.2 人类基因组</h3><p>人类基因组计划（Human Genome Project / HGP）：测定组成人类染色体（指单倍体）中所包含的30亿个碱基对组成的核苷酸序列，绘制人类基因组图谱， 辨识其载有的基因及其序列，破译人类遗传信息。</p><blockquote><p>截止到2005年，人类基因组计划的测序工作已经完成。</p></blockquote><p>人类基因组：科学家研究的第一个脊椎动物染色体基因组，已成为其他脊椎动物中的代表。</p><blockquote><p>人类基因组约有3万多个基因，分布在染色体的DNA序列中。</p><p>目前已明确定位的基因仅占3万多个基因的一部分。</p></blockquote><p>基因识别：从序列中找到基因及其表达调控信息。</p><blockquote><p>通过识别特殊的序列功能位点、分析序列的组成特征来识别基因，发现与基因表达调控相关的信息。</p></blockquote><h4 id="人类基因组图谱">1.2.1 人类基因组图谱</h4><p>序列图谱：通过测序得到基因组的序列图谱。</p><p>遗传图谱（genetic map）：也叫连锁图谱(linkage map)，它是以具有遗传多态性的遗传标记为“路标” ，以遗传学距离为图距的基因组图。</p><p>物理图谱（physical map）：是指有关构成基因组的全部基因的排列和间距的信息，通过对构成基因组的DNA分子进行测定而绘制。</p><ul><li>DNA物理图谱是指DNA链的限制性酶切片段的排列顺序，即酶切片段在DNA链上的定位。</li><li>目的是把有关基因的遗传信息及其在每条染色体上的相对位置线性而系统地排列出来。</li></ul><p>基因图谱：在识别基因组所包含的蛋白质编码序列的基础上所绘制的、结合有关基因序列、位置及表达模式等信息的图谱；其任务是在人类基因组中鉴别出占2%~5%的全部基因的位置、结构与功能。</p><blockquote><p>最主要的方法是通过基因表达产物mRNA反向追溯到染色体位置</p></blockquote><h4 id="人类基因组中的编码规律">1.2.2 人类基因组中的编码规律</h4><p>编码区域在人类基因组所占比例不超过3%。</p><p>97%是非编码序列：主要包括启动子、增强子、内含子、简单重复序列、移动元件及其遗留物、伪基因等。</p><p>对于非编码序列，目前了解得比较少，尚不完全清楚其含义或功能。</p><ul><li>从生物进化的观点来看，这部分序列具有重要的生物学功能；目前普遍认为: 它们与基因在四维时空的表达调控有关。</li></ul><h4 id="遗传语言">1.2.3 遗传语言</h4><p>科学家认为：基因组DNA序列并非是一种简单的生物分子序列，而是一种<strong>遗传语言</strong>, 用于描述遗传信息、控制生物体的性状、甚至规定生物体的生老病死。</p><ul><li>科学家们开始测序人类及其他模式生物基因组，希望解读和破译遗传信息。</li><li>迄今为止，用于理解DNA翻译成蛋白质的编码规律的<strong>遗传密码</strong>是人们对于生物体遗传语言了解最多的部分。</li></ul><p>把基因组DNA序列当作遗传语言，那么可用语言学的方法进行研究，以发现遗传语言的规律。</p><p>自然语言 vs. 程序语言 vs. 遗传语言：</p><ul><li>人类自然语言，用于人类之间描述、记录和交流思想，可以被转换成二进制序列，存放在数字图书馆中。</li><li>计算机高级程序语言经编译被转换成二进制机器指令，形成可执行程序。</li><li>遗传语言的代码实际上就是DNA序列，是由A/C/G/T(U) 4种字符组成的一种四进制代码。</li></ul><h3 id="生物体的信息加工">1.3 生物体的信息加工</h3><p>从信息工程的角度来看：</p><p>蛋白质编码区域所包含的信息相当于待加工的“数据” ，经加工处理后产生对应的氨基酸序列；非编码区域相当于“程序” ，确定如何对数据进行处理，控制基因的表达和蛋白质的合成。</p><p>计算机中数据与程序是相对分立；在染色体上，数据与程序相互嵌套，染色体上的基因经过调控程序的转录和翻译，产生蛋白质的氨基酸序列，从而发挥生物学功能。</p><blockquote><p>一维线性的DNA分子在特定环境下，通过复杂而准确的信息程序处理，拓展为一个四维时空生命体。</p></blockquote><h2 id="原核生物基因组">2. 原核生物基因组</h2><p>原核生物基因组的许多信息仅是为维持细胞最基本的功能。</p><ul><li>构造和复制DNA(至多需要32种基因)。</li><li>产生蛋白质(需要100-150个基因)。</li><li>获得和存储能量(至少需要30个基因)。</li></ul><p>原核生物基因组中的基因密度高：一些非常简单的原核生物，如流感嗜血杆菌，其基因组仅包含由256-300个基因组成的最小集合。</p><ul><li>完全测序的细菌基因组数据表明：其中85%～88%的核酸序列与基因的编码直接相关。</li></ul><h3 id="原核基因的典型结构">2.1 原核基因的典型结构</h3><p>原核基因结构非常简单</p><ul><li><p>完整的基因结构从基因的5’ -端启动子区域开始，到3’ -端终止区结束。</p></li><li><p>基因的转录开始位置由转录起始位点确定，转录过程直至遇到转录终止位点。</p></li><li><p>转录的内容包括5’-端不翻译区（UTR）、开放阅读框及3’-端不翻译区。</p></li><li><p>基因翻译的准确起止位置由起始密码子和终止密码子决定，翻译的对象即为介于这两者之间的开放阅读框。</p></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230609231106118.png"></p><p>原核基因作为连续基因，其编码区是一个完整的DNA片段。</p><ul><li>负责基因表达的蛋白质可以识别各种调控信号。</li><li>调控信号是一些相对较短的核苷酸序列, 这些信号的微妙差别可以影响到: 基因表达与否、基因的表达水平。</li></ul><p>启动子位点：长度为<strong>13个</strong>核苷酸的特定序列</p><ul><li>1个为转录起始位点(+1)</li><li>6个位于转录起始位点上游10个碱基处(-10)</li><li>6个位于转录起始位点上游35个碱基处(-35)</li></ul><p>这13个位点的核苷酸作为一个整体，称为启动子序列；它们之间的相对位置固定。</p><h3 id="开放阅读框orf">2.2 开放阅读框/ORF</h3><p>对于任何给定的核酸序列(单链DNA或mRNA)，根据密码子的起始位置，可以按照3种方式将其翻译成氨基酸肽链。</p><ul><li><p>例如：序列ATTCGATAACAA</p><p>—ATT CGA TAA CAA</p><p>—(A)TTC GAT AAC AA</p><p>—(AT)TCG ATA ACA A</p></li><li><p>这3种阅读顺序称为阅读框(reading frames)</p></li><li><p>不含终止密码子且有比较多的三联密码子的长序列被称为开放阅读框(Open Reading Frame: ORF)</p></li></ul><blockquote><p>存在ORF表明该区域可能对应于一个原核生物基因的编码序列。</p></blockquote><h3 id="原核基因组中的gc含量">2.3 原核基因组中的GC含量</h3><p>GC含量：GC含量是在DNA4种碱基中，鸟嘌呤和胞嘧啶所占的比率称为GC含量。</p><blockquote><p>在双链DNA中，腺嘌呤与胸腺嘧啶（A/T）之比，以及鸟嘌呤与胞嘧啶（G/C）之比都是1。但是，（A+T）/（G+C）之比则随DNA的种类不同而异。GC含量愈高，DNA的密度也愈高，同时热及碱不易使之变性，因此利用这一特性便可进行DNA的分离或测定。</p></blockquote><p>不同的原核生物中，GC含量在25%到75%之间变化。</p><ul><li>许多细菌基因组表现为具有不同GC含量区域的组合，这些区域反映了细菌的进化历史。</li><li>在原核生物中，双链DNA组成的基因组的GC含量是区分不同物种的特征之一。<ul><li>基于这种事实，测量基因组的GC含量被证明是一种识别细菌种类的有效方法。</li></ul></li></ul><h3 id="总结原核生物基因的特征">2.4 总结：原核生物基因的特征</h3><p>编码区是连续的，具有较长的开放阅读框。</p><ul><li>60+个密码子。</li></ul><p>较简单的启动子序列。</p><ul><li>+1/-10/-35处一共13个位点。</li></ul><p>转录终止信号。</p><ul><li>转录终止位点。</li></ul><p>原核生物基因组密度高，很少有空间浪费。</p><ul><li>随机选择一段原核生物基因组核苷酸序列，其中包含重要基因的编码序列或启动子的概率很大。</li></ul><h2 id="真核生物基因组">3.真核生物基因组</h2><h3 id="真核生物基因组的挑战">3.1 真核生物基因组的挑战</h3><p>真核生物的<strong>复杂性与灵活性</strong>：</p><ul><li>细胞的内部膜系统允许在细胞内维持各种变化较大的化学环境。</li><li>几乎全为多细胞生物，虽然每个细胞有相同的遗传“指令” ，但其表达方式与表达水平可以有显著差异。</li><li>存在有大量的不表达区域（也被称为junk DNA区域）。</li></ul><blockquote><p>复杂性与灵活性导致对真核基因组的分析与注释成为目前极具挑战性的难题之一。</p></blockquote><p>基因组规模较大，真核生物基因组序列测定比原核生物更为困难：</p><ul><li>细胞核中一般包含多条线性染色体，且通常包含每条染色体的双拷贝。</li></ul><blockquote><p>比如：人类22条常染色体的双拷贝+2条性染色体，最短的为5500万个bp,最长有2.5亿个bp；全基因组长约32亿个bp。</p></blockquote><ul><li>真核生物基因数量不容易准确估计。</li></ul><p>真核生物基因编码区域是<strong>不连续</strong>的：</p><ul><li>能够编码蛋白质的序列被不能够编码蛋白质的序列分隔开来，成为一种不连续的形式。<ul><li>能够编码蛋白质的序列叫做外显子，不能够编码蛋白质的序列叫做内含子。</li></ul></li><li>在编码区域插入了不编码的内含子，大量内含子的存在，使得真核生物不存在像原核基因那样具有显著长度的ORF标志。</li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093206887.png" alt="内含子和外显子" style="zoom: 33%;"></p><h3 id="真核生物基因的结构特征">3.2 真核生物基因的结构特征</h3><p>完整的真核生物基因一般包含以下部分：</p><ol type="1"><li>转录起始区：含有对DNA序列转录起调控作用的启动子(Promoter)以及增强子(enhancer)等。</li><li>转录起始位点(TSS)</li><li>5‘- 非翻译区</li><li>翻译起始位点(TLSS)</li><li>外显子(exon), E-I剪切位点(doner),内含子(intron),I-E剪切位(acceptor),外显子, …</li><li>翻译终止位点TLSTOP</li><li>3 ‘- 非翻译区</li><li>转录终止位点</li></ol><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230610093843123.png" alt="真核生物基因的结构"><figcaption aria-hidden="true">真核生物基因的结构</figcaption></figure><blockquote><p>各部分的序列形态和长度并不确定，不同物种间的基因差别很大。</p></blockquote><h3 id="复杂的基因转录调控方式">3.3 复杂的基因转录调控方式</h3><p>真核生物基因的<strong>调控机制</strong>比原核生物复杂：</p><ul><li>真核基因的启动子序列更加分散，且距起始密码子较远；</li><li>启动子区域的信息提取比较困难；</li><li>在真核生物DNA序列中寻找基因相当于大海捞针。</li></ul><p>真核生物的细胞具有<strong>复杂的转录起始调控机制</strong>：</p><ul><li>真核生物的基因表达涉及多种RNA聚合酶。</li><li>真核生物至少使用由8～12个蛋白组成的3种不同类型的RNA聚合酶。<ul><li>原核生物只用一种由多个蛋白聚合而成的RNA聚合酶。</li></ul></li><li>每个真核生物的基因有自己的启动子。<ul><li>原核生物中多个基因共享一个启动子。</li></ul></li></ul><h3 id="剪切加工的方式">3.4 剪切加工的方式</h3><p>在把RNA聚合酶的转录产物运出细胞核之前，需要进行大量剪切加工过程。</p><ul><li>加工前的RNA聚合酶II转录物称为hnRNA。</li><li>加帽(capping)：在hnRNA的5’端发生的化学改变。</li><li>剪切(splicing)：切除其中的<strong>内含子</strong>片段。</li><li>多聚腺苷酸化(Poly-A): 在3’端连接多个(约250个)A。</li></ul><blockquote><p>这些加工过程，特别是剪切加工，具有组织特异性，这给基因识别带来了巨大挑战。</p></blockquote><h3 id="真核基因组gc含量">3.5 真核基因组GC含量</h3><p>真核生物基因组的GC含量差别没有原核生物明显，但GC含量对于识别真核基因仍有重要作用。</p><p>真核生物的ORF更难以识别。</p><p>真核基因组中GC含量的显著性变化是基因与上游启动子区域、密码子选择、基因长度以及基因密度之间相关性的基础。</p><h3 id="cpg岛">3.6 CpG岛</h3><p>CpG岛（CpG island）：</p><ul><li>CpG双核苷酸在人类基因组中的分布很不均匀，在基因组的某些区段，CpG保持或高于正常概率，这些区段被称作<strong>CpG岛</strong>。</li><li>CpG：胞嘧啶C—磷酸p—鸟嘌呤G</li><li>CG出现的频率远低于随机出现的概率, 但也有部分例外：</li><li>在许多基因的-1500~+500区域上往往形成<strong>CpG岛，其CG频率达到随机出现的水平</strong>。</li><li>人类基因组中大约有45000个CpG岛。</li></ul><p>CpG岛多与管家基因有关联，也与组织特异性基因的启动子有关。</p><ul><li>CpG岛很少出现在非基因区域或发生多次突变的基因中。<ul><li>管家基因：在所有组织和在发育的所有阶段都具有高水平表达的基因。</li></ul></li></ul><h3 id="遗传密码的使用偏性">3.7 遗传密码的使用偏性</h3><p>遗传密码的使用具有一定的统计规律，并不是完全随机的。</p><ul><li>如果密码子的第一、第二位碱基分别是A和U，则第三位尽可能使用G或C。</li><li>基因对同义密码子的使用也存在偏爱。<ul><li>不同种属所偏爱的密码子不同：<ul><li>人类基因组中，密码子第三位取A、U的情况占90%。</li><li>酵母基因组中的精氨酸：密码子AGA占48%，其它密码子CGT, CGC, CGA, CGG和AGG各约占10%。</li><li>果蝇基因组中的精氨酸CGC约占33%。</li></ul></li></ul></li></ul><h3 id="真核生物的基因识别">3.8 真核生物的基因识别</h3><p>真核生物基因识别主要考虑：</p><ul><li>已知的启动子元件(即TATA盒和CAAT盒)。</li><li>CpG岛</li><li>与内含子相关的剪接信号。</li><li>具有特定密码子使用偏好的开放阅读框。</li><li>与其它生物体EST或基因序列的相似程度。</li></ul><p>真核生物基因识别的解决方案: 通过寻找已经注释的序列数据集的统计特性，来预测相关、但未经注释的序列数据的特性。</p><h2 id="基因组序列分析基因识别">4. 基因组序列分析—基因识别</h2><p>基因识别：也被称为基因组注释(genome annotation)。</p><ul><li>从基因组序列之中找到基因及其表达调控信息， 包括识别基因编码区域(即外显子所在区域)和功能位点。</li></ul><blockquote><p>功能位点：存放基因表达调控信息的DNA片段，比如基因的启动子、剪切位点等。</p></blockquote><p>基因识别问题：对给定的DNA序列，确定出所有<strong>编码区域</strong>和<strong>基因结构</strong>。</p><ul><li>包含两个问题：<ul><li>确定出可能的编码区域</li><li>确定出编码和非编码区域的分界点</li></ul></li></ul><h4 id="基因识别与定位的方法">基因识别与定位的方法</h4><p>方法一：通过分子生物学实验确定基因的位置和序列。</p><p>方法二：通过信息分析寻找基因。</p><blockquote><p>方法二基本依据：</p><ul><li>在基因的前后两端存在一些特殊信号。</li><li>基因的蛋白质编码区域与非编码区域在序列的统计特征上有明显的差异。</li><li>可以使用模式识别方法识别DNA序列上与基因相关的信息，区分统计特性，从而识别基因。</li></ul></blockquote><p>根据是否利用同源序列的信息，把基因识别方法分为两类：</p><ul><li>基于同源序列比较的方法<ul><li>利用数据库中现有与基因有关的信息(如EST序列、cDNA、蛋白质序列)，借助同源序列比对去识别可能的基因序列。</li></ul></li><li>基于统计信息的方法<ul><li>从编码蛋白质基因的一般统计规律出发，利用基因序列和非基因序列以及外显子与内含子的统计信息差异性去识别可能的基因序列。</li></ul></li></ul><h4 id="基因编码区识别">基因编码区识别</h4><p>基因的编码区：一般是指预测DNA序列中编码蛋白质的部分(即基因的外显子部分)。</p><blockquote><p>预测编码区域是基因识别中的一个关键问题。</p></blockquote><p>基本依据：真核生物基因外显子(编码区域)具有特别的序列信号，根据这些特征信号可确定外显子的边界，从而识别编码区域。</p><blockquote><p>缺点: 特征信号强度弱，缺乏统计显著性，无法单独使用。</p></blockquote><p>对编码区域进行统计特性分析，可以确定编码区的粗略位置。</p><blockquote><p>DNA中密码子的使用频率不是平均分布的，使得编码区的序列呈现出一定的统计特异性(即密码子偏好性)。</p></blockquote><h3 id="模式识别问题">4.1 模式识别问题</h3><p>模式：观测数据中的某种规则性(regularities)，称为模式(patterns)。</p><p>模式识别：把给定观测数据中的某种规则性(regularities)识别出来(或确认出来)，并应用到新的观测数据上。</p><blockquote><p>给定的观测数据：训练数据集。</p><p>新的观测数据：测试数据集。</p></blockquote><h4 id="一个典型的模式识别问题分成下面4个步骤">4.1.1 一个典型的模式识别问题分成下面4个步骤：</h4><ol type="1"><li>收集待解决问题的观测数据，进行特征抽取。<ul><li>把数据分成训练集和测试集两部分。</li></ul></li><li>选定或设计一个用于解决分类问题的数学模型。<ul><li>称为分类器设计；从数学上，即构造一个从数据到类别的映射。</li></ul></li><li>基于给定训练数据，确定分类模型中的参数。<ul><li>称为模型训练，或参数学习。</li></ul></li><li>在测试数据集上进行性能评价。</li></ol><h4 id="影响模式识别性能的因素">4.1.2 影响模式识别性能的因素：</h4><ul><li>特征表达或特征抽取方式<ul><li>对于一个特定模式分类问题，选定好的特征表达或抽取方式至关重要。</li></ul></li><li>分类器模型复杂度<ul><li>模型过于简单或过于复杂都不能获得好的性能。</li></ul></li><li>模型中参数的学习方法<ul><li>最大似然估计 /最大后验概率估计 /贝叶斯估计。</li></ul></li><li>训练样本数量<ul><li>在不考虑计算成本的情况下, 希望样本尽量多。</li></ul></li><li>训练样本的分布<ul><li>期望训练样本的分布体现数据的真实分布。</li></ul></li></ul><h4 id="模式识别问题举例">4.1.3 模式识别问题举例</h4><p>医生对患者进行疾病诊断的过程是一个典型的模式识别过程。</p><ul><li>医生的诊断过程是通过观察病人表现出的症状和各种化验检测数据来推断病情。</li><li>诊断过程是一个分类过程。<ul><li>医生就好比一个分类器</li><li>医生诊断的准确率与下列因素有密切关系：<ul><li>诊断方式(中医/西医)</li><li>病人的症状是否突出(待分类数据的特性)</li><li>诊断专长(训练样本的分布)</li><li>诊断经验(训练样本数量)</li></ul></li></ul></li></ul><h3 id="推理与决策">4.2 推理与决策</h3><p>推理的基本定义：</p><ul><li>从已知前提(或假设是正确的前提)出发，得出符合逻辑的结论的过程。</li><li>通过事实的模式的观测，间接地看到用于理解的某种新意义或上下文联系。</li></ul><p>对于模式分类来说，推理就是基于给定的数据，确定联合分布密度或者后验分布密度的过程。 <span class="math display">\[D=\{(x_i,t_i)\}\to p(x,t)或p(t|x)\]</span> 决策：给定输入数据 x, 确定最优的输出 t。</p><p>贝叶斯决策：根据平均错误率最小的准则进行决策。</p><ul><li>贝叶斯决策是一种理想的判别规则，需要借助<mark>先验概率</mark>和<mark>似然度</mark>。</li><li>贝叶斯错误率是理论上可获得的最小错误率。</li></ul><p><span class="math display">\[P(mistake)=P(x\in R_1,C_2)+P(x\in R_2,C_1)=\int_{R_1}^{}p(x,C_2)dx+\int_{R_2}^{}p(x,C_1)dx\]</span></p><p>贝叶斯公式：贝叶斯公式用于把先验概率转化为后验概率。 <span class="math display">\[P(M|D)=\frac{P(D|M)P(M)}{P(D)}\qquad 后验概率=\frac{似然度×先验概率}{边缘概率}\]</span> 贝叶斯公式的意义：通过贝叶斯公式，我们把先验概率和从观测数据上得到的似然度相结合，从而得到后验概率。</p><blockquote><p>先验概率: 在获得观测数据之前对判别结果的认识。</p><p>后验概率: 基于观测数据而对判别结果的更新认识。</p></blockquote><p>计算后验概率的过程，也被称为推理；基于所计算的后验概率，可以进行决策。</p><h3 id="朴素贝叶斯方法">4.3 朴素贝叶斯方法</h3><p>在基因编码区，三联密码子出现的频率具有一定统计规律。</p><ul><li>在随机序列中 ，三联密码子出现的频率是相同的——可认为每个密码子出现的频率均为1/64。</li><li>在基因编码区域 ，三联密码子出现的频率并不是均匀的。</li></ul><p>根据这个差异，可以计算不同的阅读框属于基因编码序列的概率，并由此判断是否为基因编码区域。</p><h4 id="基于密码子的出现频率区分编码区">4.3.1 基于密码子的出现频率区分编码区</h4><ul><li><p>基本原理：在DNA序列的编码区和非编码区，三联密码子出现的频率不同；因此基于三联密码子出现频率的差异，可以建立概率模型完成区分。</p></li><li><p>基本步骤：</p><ol type="1"><li><p>对基因编码区和非编码区域分别估计三联密码子的出现概率。</p><p>用C<sub>1</sub>表示非编码区， C<sub>2</sub>表示编码。</p></li><li><p><mark>建立概率模型</mark>，根据后验概率判别该序列否属于基因编码区域。</p></li></ol></li></ul><h4 id="朴素贝叶斯方法-1">4.3.2 朴素贝叶斯方法</h4><p>基本思路：假设各个特征相互条件独立，我们把联合分布或联合概率转化为各个边缘分布或边缘概率的乘积。 <span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}\xrightarrow{S=s_1s_2...s_m} P(C_j|S)=\frac{P(C_j)\prod_{i=1}^{m}P(s_i|C_j)}{P(S)}\]</span> 判别规则：基于最大后验概率准则确定出序列S所属于的类别k <span class="math display">\[k=arg\thinspace \max_{j}\{P(C_j|S,j=1,...K\},其中C_j为类别j\]</span></p><ul><li>设计分类器，即构造一个从给定的数据S到各个类别的映射规则。</li></ul><h4 id="基于序列s建立概率模型">4.3.3 基于序列S建立概率模型</h4><p>考虑2个类别C<sub>1</sub> 和 C<sub>2</sub>：其中用C<sub>1</sub>表示非编码区，C<sub>2</sub>表示编码区。</p><p>对于给定序列S，要判断S属于编码区还是非编码区，可以计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)。</p><ul><li>根据贝叶斯公式： <span class="math display">\[  P(C_1|S)=\frac{P(C_1,S)}{P(S)}∝P(S|C_1)P(C_1)\\\\P(C_2|S)=\frac{P(C_2,S)}{P(S)}∝P(S|C_2)P(C_2)  \]</span></li></ul><p>对于给定序列S，把S表示成 A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>（A<sub>i</sub>为三联密码子），则序列S的出现概率为：P(S) =P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>)。</p><p>假设序列中的3联密码子相互独立(且忽略3联密码子的顺序)，则序列S的出现概率可以转化为：P(S) = P(A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>) = P(A<sub>1</sub>)P(A<sub>2</sub> )…P(A<sub>L</sub>）</p><blockquote><p>若要计算P(S)，则需要估计出P(A<sub>1</sub>)，P(A<sub>2</sub>), …, P(A<sub>L</sub>）</p></blockquote><p>计算条件概率P(S|C<sub>2</sub>)：</p><p>在编码区(C<sub>2</sub>)观测到序列S的概率，把S表示成三联密码子序列 A<sub>1</sub> A<sub>2</sub> …A<sub>L</sub>，则 P(S|C<sub>2</sub>)表达为: <span class="math display">\[P(S|C_2)=P(A_1A_2...A_L|C_2)=P(A_1|C_2)P(A_2|C_2)...P(A_L|C_2)\]</span></p><blockquote><p>这里假设了编码区的序列中的3联密码子相互独立(且忽略3联密码子的顺序)。</p></blockquote><p>则计算P(S|C<sub>2</sub>)需要估计出P(A<sub>1</sub>|C<sub>2</sub>) , P(A<sub>2</sub>|C<sub>2</sub>) , …, P(A<sub>L</sub>|C<sub>2</sub>) 。</p><blockquote><p>也就是基于编码区的序列去估计各个三联密码子的出现概率。</p></blockquote><p>计算条件概率P(S|C<sub>1</sub>)方法同理。</p><p>最后，利用贝叶斯公式： <span class="math display">\[P(C_j|S)=\frac{P(S|C_j)P(C_j)}{P(S)}∝P(S|C_j)P(C_j)\]</span> <mark>分类规则：</mark></p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><h4 id="基于朴素贝叶斯方法识别编码区与非编码区4.3.3的总结">4.3.4 基于朴素贝叶斯方法识别编码区与非编码区（4.3.3的总结）</h4><p>具体步骤：</p><ol type="1"><li><p>基于训练数据集, 估计各个三联密码子的出现概率 <span class="math display">\[P(C_j|S)∝P(C_j)P(A_1A_2...A_L|C_j)=P(C_j)P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span> 其中, P(A<sub>i</sub>|C<sub>j</sub>)为类别C<sub>j</sub>中3联密码子A<sub>i</sub>的出现概率，需要基于给定的训练样本序列去估计。</p><ul><li>计算每个三联体密码子出现的频率f<sub>AAA,</sub> f<sub>AAC</sub>, f<sub>AAG</sub>…, 用频率去估计三联密码子在当前序列中的出现概率。</li></ul></li><li><p>利用三联密码子出现频率，对于基因序列样本集中的每条序列S，计算S的出现概率 P(S|C<sub>1</sub>)和P(S|C<sub>2</sub>）。 <span class="math display">\[P(S|C_j)=P(A_1A_2...A_L|C_j)=P(A_1|C_j)P(A_2|C_j)...P(A_L|C_j)\]</span></p></li><li><p>估计非编码区和编码区的先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)，计算后验概率P(S|C<sub>1</sub>)P(C<sub>1</sub>)和P(S|C<sub>2</sub>)P(C<sub>2</sub>)。</p><ul><li>先验概率P(C<sub>1</sub>)和P(C<sub>2</sub>)可根据训练集里两种类型的序列的比例去估计。</li></ul></li></ol><p>测试阶段：</p><p>给定序列S，计算P(C<sub>1</sub>|S)和P(C<sub>2</sub>|S)</p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>编码区</mark>。</li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于<mark>非编码区</mark>。</li></ul><p>该方法优点：模型简便，易于实现。</p><p>该方法缺点：识别率较低。</p><p>改进的方向：</p><ul><li>考虑相邻密码子之间依存关系，建立一阶或高阶马尔科夫模型。</li><li>考虑描述序列的高维向量。</li></ul><h3 id="马尔科夫链markov-chain">4.4 马尔科夫链(Markov Chain）</h3><p>考虑一个具有多个状态的系统S，令O<sub>1</sub>, O<sub>2</sub>, ⋯, O<sub>n</sub>为系统在各个时刻的状态变量，即<mark>状态链</mark>。</p><p>无后效性：</p><ul><li><p>1阶马氏链: 系统在时间步 t 处于哪个状态, 仅与时间t-1时系统所处的状态有关。 <span class="math display">\[P(O_1O_2O_3...O_n)=P(O_1)P(O_2|O_1)P(O_3|O_2)...P(O_n|O_n-1)\]</span></p><ul><li>系统未来的状态仅依赖于当前状态。</li><li>一条马尔可夫链完全决定于初始分布和状态转换概率。</li></ul></li><li><p>k阶马氏链：时间步t的状态仅与时间t-1, t-2, … , t-k时刻的历史状态有关。</p></li></ul><h4 id="考虑三联密码子的1阶马尔科夫性">考虑三联密码子的1阶马尔科夫性：</h4><ul><li><p>给定DNA序列片段S =A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub> ，其中A<sub>i</sub>为3联密码子。</p></li><li><p>在计算P(A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub>)时，我们<mark>引入1阶马尔可夫模型</mark>，把P(A<sub>1</sub>A<sub>2</sub> …A<sub>n</sub>)转化为: <span class="math display">\[P(A_1A_2...A_n)=P(A_1)P(A_2|A_1)...P(A_n|A_{n-1})\]</span></p><ul><li>需要估计出三联密码子之间的转移概率P(A<sub>j</sub>|A<sub>j-1</sub>)和P(A<sub>1</sub>)</li></ul></li></ul><p>状态转移概率P(A<sub>j</sub>|A<sub>i</sub>)的估计:</p><ul><li><p>以编码区为例:A<sub>i</sub>到A<sub>j</sub>的转移概率，需要统计A<sub>i</sub>到A<sub>j</sub>的转移次数，除以所有以A<sub>i</sub>为起始状态转变为A<sub>k</sub>的转移次数: <span class="math display">\[\widetilde{P} (A_j|A_i)=\frac{T_{A_i\to A_j}}{\sum_{k=1}^{64}T_{A_i\to A_k}}\]</span></p><ul><li>其中T<sub>Ai→Aj</sub>表示从状态A<sub>i</sub>转移到状态A<sub>j</sub>的次数。</li></ul></li><li><p>第1个密码子和最后1个密码子需要单独统计: <span class="math display">\[开头:\widetilde{P} (A_i)=\widetilde{P} (A_i|[])=\frac{T_{[]\to A_i}}{\sum_{k=1}^{64}T_{[]\to A_k}}\]</span></p><p><span class="math display">\[结尾:\widetilde{P} (A_j)=\widetilde{P} ([]|A_j)=\frac{T_{A_j\to []}}{\sum_{k=1}^{64}T_{A_k\to []}}\]</span></p><ul><li>即从训练样本序列中统计密码子A<sub>i</sub>出现在开始位置的频率和密码子A<sub>j</sub>出现在末尾的频率。</li></ul></li></ul><p>最后，利用贝叶斯公式计算后验概率： <span class="math display">\[P(C_j|A_1A_2...A_n)=\frac{P(A_1A_2...A_n|C_j)P(C_j)}{P(A_1A_2...A_n)}\]</span> 分类规则：</p><ul><li>如果P(C<sub>2</sub>|S) &gt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>2</sub></li><li>如果P(C<sub>2</sub>|S) &lt;P(C<sub>1</sub>|S)，则判断序列S属于类别C<sub>1</sub></li></ul><p>在计算P(C<sub>1</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> ) 和 P(C<sub>2</sub>|A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub> )时，引入<mark>1 阶马尔可夫链</mark>考虑三联密码子之间的依赖关系，即： <span class="math display">\[P(A_1A_2...A_n|C_j)=P(A_1|C_j)P(A_2|A_1,C_j)...P(A_n|A_{n-1},C_j)\]</span></p><ul><li>需要在编码区和非编码区分别估计出三联密码子的转移概率。</li></ul><p>如果S是编码区，那么序列<mark>S=A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>出现的概率P(S)用马氏链</mark>来刻画如下： <span class="math display">\[P(S|C_2)=P(A_1|C_2)\prod_{i=2}^{n}P(A_i|A_{i-1},C_2)\]</span></p><ul><li>若已知或给定从训练样本序列中估计的先验概率和状态转移概率，那么可直接带入公式计算序列S的似然度。<ul><li>P(A<sub>1</sub>|C<sub>2</sub>)是C<sub>2</sub>中以A<sub>1</sub>为第一个密码子的概率P(A<sub>1</sub>|[])</li><li>若考虑末尾A<sub>n</sub>转换为结束态，则还需再乘以P([]|A<sub>n</sub>)或P(A<sub>n</sub>)</li></ul></li></ul><h4 id="马尔科夫链模型的参数估计">马尔科夫链模型的参数估计：</h4><p>先验概率:</p><ul><li>序列属于编码区的先验概率P(C<sub>2</sub>)</li><li>序列属于非编码区的先验概率P(C<sub>1</sub>)</li></ul><p>状态转移概率：</p><p>需要根据训练数据, 分别估计编码区C<sub>2</sub>和非编码区C<sub>1</sub>中各个3联密码子A<sub>1</sub>A<sub>2</sub>…A<sub>n</sub>之间的状态转移概率矩阵。</p><h3 id="基于同源序列比对的方法">4.5 基于同源序列比对的方法</h3><p>基本动机：</p><ul><li>部分物种的基因组中有大量基因已被实验证实， 并在相应数据库中有注释(annotation)信息。</li><li>亲缘关系很近的生物体之间可能具有相似的基因。</li><li>用某个物种中的未知基因与亲缘关系相近的其它物种的基因作比较，对揭示未知基因的信息会有帮助。</li></ul><p>基本思路：充分利用序列同源性帮助进行基因识别问题。</p><p>比较两个基因组中的基因：计算最优剪接比对，以比较不同基因组中存在相似度很高的外显子“群岛”区域。</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110107270.png" style="zoom:50%;"></p><p>比较基因组DNA与mRNA：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611110150024.png" style="zoom:50%;"></p><h3 id="基因识别问题总结">4.6 基因识别问题总结</h3><p>基本任务：从DNA序列中识别出基因编码部分。</p><p>基本方法：基因识别问题归结为模式分类问题。</p><p>计算碱基/密码子的统计信息：</p><ul><li>在DNA的编码区和非编码区，碱基的信号特性是不相同的，比如基因编码区的周期性特征、功能位点。</li><li>在DNA的编码区和非编码区，3联密码子出现的频率是不相同的。</li><li>6联密码子的出现频率在编码区和非编码区具有差异性。<ul><li>比如: AAAAAA 在编码区出现概率为1%，而非编码区为5%。</li></ul></li></ul><p>建立识别模型： 贝叶斯决策 / 朴素贝叶斯 / 马尔科夫链 / HMM。</p><h4 id="基因识别方法的局限性">基因识别方法的局限性：</h4><p>目前的方法仅能识别蛋白质编码基因，对基因非编码部分还没有可靠的识别方法。</p><ul><li>识别原理与基因表达的真实分子机制没有多少关系。<ul><li>由于缺乏识别非编码基因的方法，无法统计在人类基因组中究竟隐藏多少非编码基因。</li></ul></li></ul><p>现有基因识别方法存在固有的保守性。</p><ul><li>不可能发现与数据库中已知基因有较大差别的基因或新基因。</li></ul><p>现有基因识别方法的最大缺陷在于忽视关于基因结构的生物学知识。</p><ul><li>从生物学家来看，现有的基因识别程序还不可靠，需要结合分子生物学、比较基因组学等其他方面研究。</li></ul><h1 id="三隐马尔可夫模型-hidden-markov-model-hmm">三、隐马尔可夫模型 (Hidden Markov Model: HMM)</h1><h2 id="hmm的定义">1.HMM的定义</h2><p>一阶阶离散HMM是一个关于离散序列的随机生成模型。</p><p>基本要素：</p><ul><li>离散明字符集合：V = {V<sub>1</sub> , …, 𝑉<sub>M</sub>}</li><li>有限隐状态集合：S = {S<sub>1</sub> , …, 𝑆<sub>N</sub>}</li><li>初始状态概率向量：<em>π</em> = (<em>π</em><sub>1</sub> , …, <em>π</em><sub>N</sub>)</li><li>状态转移概率矩阵： A = { a<sub>ij</sub>, i,j = 1, …N}</li><li>明字符生成概率矩阵： B = { b<sub>jk</sub>, j = 1, …N, k=1,...M}</li></ul><p>HMM记作<em>λ</em>=(S,V,π,A,B)或<em>λ</em>=(π,A,B)</p><ul><li>一个HMM模型是一个三元组(S, V, λ)，其中λ为模型参数的集合，S 是明字符集V是有限状态集合——每个状态可以产生明字符集中的字符。</li></ul><h2 id="评估问题">2.评估问题</h2><h3 id="前向算法">2.1 前向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\alpha(1,i)=\pi(i)b(i,o_1)\]</span></p></li><li><p>递推 <span class="math display">\[\alpha(t+1,j)=\Bigg[\sum_{i=1}^{N}\alpha(t,i)\alpha(i,j)\Bigg]b(j,o_{t+1})\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\sum_{i=1}^{N}\alpha(T,i)\]</span></p></li></ol><h3 id="前向算法例题">2.2 前向算法例题</h3><p>考虑一个包含两个字符的字符表{C, T}和包含3个状态的状态集{S<sub>1</sub>, S<sub>2</sub>, S<sub>3</sub>}，HMM的转移概率和字符生成概率如下表。请计算序列O = CCT的全概率。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">→0</th><th style="text-align: center;">→S<sub>1</sub></th><th style="text-align: center;">→S<sub>2</sub></th><th style="text-align: center;">→S<sub>3</sub></th><th style="text-align: center;">生成C</th><th style="text-align: center;">生成T</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;">1/3</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">S<sub>1</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.3</td><td style="text-align: center;">0.5</td><td style="text-align: center;">0.5</td></tr><tr class="odd"><td style="text-align: center;">S<sub>2</sub></td><td style="text-align: center;">0.2</td><td style="text-align: center;"></td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.1</td><td style="text-align: center;">0.9</td></tr><tr class="even"><td style="text-align: center;">S<sub>3</sub></td><td style="text-align: center;">0.4</td><td style="text-align: center;"></td><td style="text-align: center;">0.2</td><td style="text-align: center;">0.4</td><td style="text-align: center;">0.9</td><td style="text-align: center;">0.1</td></tr></tbody></table><p><span class="math display">\[\Rightarrow\begin{cases}\begin{aligned}\alpha(1,1)=\pi(1)b_1(C)=0.33×0.5=0.165\\\alpha(1,2)=\pi(2)b_2(C)=0.33×0.1=0.033\\\alpha(1,3)=\pi(3)b_3(C)=0.33×0.9=0.297\end{aligned}\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(2,1)=b_1(C)\sum_{i=1}^{3}\alpha(1,i)a_{i1}=0.165×0.3×0.5=0.02475\\\alpha(2,2)=b_2(C)\sum_{i=1}^{3}\alpha(1,i)a_{i2}=(0.165×0.2+0.033×0.4+0.297×0.2)×0.1=0.01056\\\alpha(2,3)=b_3(C)\sum_{i=1}^{3}\alpha(1,i)a_{i3}=(0.165×0.3+0.033×0.4+0.297×0.4)×0.9=0.16335\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow\begin{cases}\alpha(3,1)=b_1(T)\sum_{i=1}^{3}\alpha(2,i)a_{i1}=0.02475×0.3×0.5=0.0037125\\\alpha(3,2)=b_2(T)\sum_{i=1}^{3}\alpha(2,i)a_{i2}=(0.02475×0.2+0.01056×0.4+0.16335×0.2)×0.9=0.0376596\\\alpha(3,3)=b_3(T)\sum_{i=1}^{3}\alpha(2,i)a_{i3}=(0.02475×0.3+0.01056×0.4+0.16335×0.4)×0.1=0.0076989\end{cases}\]</span></p><p><span class="math display">\[\Rightarrow P(O)=P(CCT)=\sum_{i=1}^{3}\alpha(3,i)=0.0037125+0.0376596+0.0076989=0.049071\]</span></p><h3 id="后向算法">2.3 后向算法</h3><p>算法过程：</p><ol type="1"><li><p>初始化 <span class="math display">\[\beta_T(i)=1\]</span></p></li><li><p>递推 <span class="math display">\[\beta_t(i)=\sum_{j=1}^{N}a_{ij}b_j(o_{t+1})\beta_{t+1}(j)\]</span></p></li><li><p>终结 <span class="math display">\[P(O|\lambda)=\pi_ib_i(o_1)\beta_1(i)\]</span></p></li></ol><h2 id="解码问题">3.解码问题</h2><h3 id="维特比viterbi算法">3.1 维特比(Viterbi)算法</h3><p>维特比(Viterbi)算法过程：</p><ol type="1"><li><p>初始化： <span class="math display">\[\delta_1(i)=\pi_ib_i(o_1)\]</span></p></li><li><p>递归： <span class="math display">\[\delta_t(j)=\max_{1\le i\le N}[\delta_{t-1}(i)a_{ij}]*b_j(o_t)\]</span></p></li><li><p>终结： <span class="math display">\[P^*=\max_{1\le i\le N}[\delta_T(i)]\]</span></p></li><li><p>回溯： <span class="math display">\[q^*_T=arg\:\max_{1\le i\le N}[\delta_T(i)\]</span></p></li></ol><h3 id="解码问题例题">3.2 解码问题例题</h3><p>从3个盒子中随机摸出1个球，盒子中的球有黑白两个颜色，重复实验多次，观察球的颜色构成观测序列。</p><ul><li><p>隐含状态集合: {盒子1，盒子2，盒子3} = {S<sub>1</sub>,S<sub>2</sub>,S<sub>3</sub>}</p></li><li><p>观测集合：{黑球，白球} = {Black, White}</p></li><li><p>N=3,M=2</p></li><li><p>初始状态概率:<em>π</em> = (0.3 , 0.5, 0.2)<sup>T</sup></p></li><li><p>状态转移概率矩阵： <span class="math display">\[A = \begin{bmatrix}0.4 &amp; 0.4 &amp; 0.2\\0.3 &amp; 0.2 &amp; 0.5\\0.2 &amp; 0.6 &amp; 0.2\end{bmatrix}\]</span></p></li><li><p>观测生成概率矩阵： <span class="math display">\[B = \begin{bmatrix}0.2 &amp; 0.8\\0.6 &amp; 0.4\\0.4 &amp; 0.6 \end{bmatrix}\]</span></p></li><li><p>请计算观测到序列<mark>O = {o<sub>1</sub> , o<sub>2</sub>, o<sub>3</sub>} = {′黑球′ ， ‘白球’ ， ‘黑球’ }</mark>的最可能的盒子序列。</p></li></ul><p><strong>解：</strong></p><p><strong>t = 1观测到o<sub>1</sub>的概率δ<sub>1</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_1(1)=\pi_1b_{1o_1}=0.3*0.2=0.06\\\delta_1(2)=\pi_2b_{2o_1}=0.5*0.6=0.3\\\delta_1(3)=\pi_3b_{3o_1}=0.2*0.4=0.08\end{cases}\]</span> <img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120605011.png" alt="t = 1 时的观测概率示意图" style="zoom:67%;"></p><p><strong>t = 2观测到o<sub>1</sub>o<sub>2</sub>的概率δ<sub>2</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_2(1)=max[\delta_1(j)a_{j1}]b_{1o_2}=max\{\delta_1(1)a_{11},\delta_1(2)a_{21},\delta_1(3)a_{31}\}b_{1o_2}=max\{0.06*0.4,0.3*0.3,0.08*0.2\}*0.8=max\{0.024,0.09,0.016\}*0.8=0.072,同时记录t=1时的回溯为j=2(对应0.09的取值)\\\delta_2(2)=max[\delta_1(j)a_{j2}]b_{2o_2}=max\{\delta_1(1)a_{12},\delta_1(2)a_{22},\delta_1(3)a_{32}\}b_{2o_2}=max\{0.06*0.4,0.3*0.2,0.08*0.6\}*0.4=max\{0.024,0.06,0.048\}*0.4=0.024,同时记录t=1时的回溯为j=2(对应0.06的取值)\\\delta_2(3)=max[\delta_1(j)a_{j3}]b_{3o_2}=max\{\delta_1(1)a_{13},\delta_1(2)a_{23},\delta_1(3)a_{33}\}b_{3o_2}=max\{0.06*0.2,0.3*0.5,0.08*0.2\}*0.8=max\{0.012,0.15,0.016\}*0.6=0.09,同时记录t=1时的回溯为j=2(对应0.15的取值)\end{cases}\]</span> $$</p><p>$$</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614120633023.png" alt="t = 2 时的观测概率示意图" style="zoom:50%;"></p><p><strong>t = 3观测到o<sub>1</sub>o<sub>2</sub>o<sub>3</sub>的概率δ<sub>3</sub>(i)：</strong> <span class="math display">\[\Rightarrow\begin{cases}\delta_3(1)=max[\delta_2(j)a_{j1}]b_{1o_3}=max\{\delta_2(1)a_{11},\delta_2(2)a_{21},\delta_2(3)a_{31}\}b_{1o_3}=max\{0.072*0.4,0.024*0.3,0.09*0.2\}*0.2=max\{0.0288,0.0072,0.018\}*0.2=0.00576,同时记录t=2时的回溯为j=1(对应0.0288的取值)\\\delta_3(2)=max[\delta_2(j)a_{j2}]b_{2o_3}=max\{\delta_2(1)a_{12},\delta_2(2)a_{22},\delta_2(3)a_{32}\}b_{2o_3}=max\{0.072*0.4,0.024*0.2,0.09*0.6\}*0.6=max\{0.0288,0.0048,0.054\}*0.6=0.0324,同时记录t=2时的回溯为j=3(对应0.054的取值)\\\delta_3(3)=max[\delta_2(j)a_{j3}]b_{3o_3}=max\{\delta_2(1)a_{13},\delta_2(2)a_{23},\delta_2(3)a_{33}\}b_{3o_3}=max\{0.072*0.2,0.024*0.5,0.09*0.2\}*0.4=max\{0.0144,0.012,0.018\}*0.4=0.0072,同时记录t=2时的回溯为j=3(对应0.018的取值)\end{cases}\]</span> <img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230614121258299.png" alt="t = 3 时的观测概率示意图" style="zoom:50%;"></p><p>解码出的隐含状态序列是: <mark>盒子2，盒子3，盒子2</mark></p><h1 id="四系统发育分析">四、系统发育分析</h1><h2 id="系统发育树">1.系统发育树</h2><p>系统发生树：表达类群/物种/序列之间进化关系的一种树状图。</p><blockquote><p>也叫<mark>系统发育树(Phylogenetic Tree)</mark>、进化树。</p></blockquote><p>分子进化树：从DNA或蛋白质序列数据出发构建而成，用以揭示不同物种之间的进化联系的一种树状图。</p><blockquote><p>分子钟假设：两个物种的同源基因之间的差异程度与它们的共同祖先的存在时间有一定关系, 分子进化速度大体恒定。</p></blockquote><h2 id="基因树和物种树">2.基因树和物种树</h2><p>基因树(gene tree)：基于单个同源基因差异构建的系统树。</p><p>物种树(species tree)：</p><ul><li>表达某一特定类群的进化路径。</li><li>由多个基因或基因组所建立的基因树通过综合而成。</li></ul><p>基因树和物种树两者的差异：</p><ul><li>从两个不同的物种中获取的两个基因，其分化可能早于物种的分化。</li><li>基因树的拓扑结构可能与物种树不一致，因为两个或多个基因树之间很可能存在不一致之处<ul><li>如何将由多个基因或基因组建立的基因树综合成为一个物种树，是分子系统学目前所面临的一个难题。</li></ul></li></ul><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611221237122.png" alt="物种树" style="zoom: 67%;"></p><h2 id="进化树">3.进化树</h2><p>进化树由结点(node, 顶点)与分枝(branch, 边)组成。</p><p>结点分两类：</p><ul><li>叶结点代表一个分类单元（比如类群、物种或序列）。</li><li>内部结点(祖先结点)代表推断出的共同祖先, 祖先结点可以对应于一种已知的物种，也可以没有对应的物种。</li></ul><p>分枝用以显示不同的遗传路线。</p><p>进化树在本质上包含两类信息：</p><ul><li>树的拓扑信息。</li><li>分枝的长度信息。</li></ul><p>对进化树的分类：</p><ul><li>标度树、非标度树</li><li>二叉树、k-叉树</li><li>有根树、无根树</li></ul><h3 id="标度树与非标度树">3.1 标度树与非标度树</h3><p>非标度树：枝长无意义；叶结点排列整齐，内部结点可以反映进化时间的顺序。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222054188.png" alt="非标度树"><figcaption aria-hidden="true">非标度树</figcaption></figure><p>标度树：枝长有意义；分枝长度与物种/序列的进化时间成正比。</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222309737.png" alt="标度树"><figcaption aria-hidden="true">标度树</figcaption></figure><p>两种树都可在分枝上标注信息(分支长度、进化时间以及其它数值)。</p><h3 id="k-叉树">3.2 k −叉树</h3><p>k −叉树 (内部结点的分叉)：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611222638711.png" alt="k −叉树" style="zoom:67%;"></p><h3 id="进化树是否有根root">3.3 进化树是否有根(root)</h3><p>有根进化树：</p><ul><li>根表示各个物种共同的祖先。</li><li>从祖先结点只有唯一的路径进化到达叶结点。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223144654.png" alt="有根树（可以明确进化路径）"><figcaption aria-hidden="true">有根树（可以明确进化路径）</figcaption></figure><p>无根进化树：</p><ul><li>没有指定各物种的共同祖先。</li><li>没有关于进化方向的信息。</li></ul><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611223708792.png" alt="无根树（无进化方向）"><figcaption aria-hidden="true">无根树（无进化方向）</figcaption></figure><p>有些进化树构造算法产生有根树，也有些算法只能产生无根树。</p><p>无根树→有根树的转换</p><ul><li>利用一个外部类群(物种、序列)生成根。<ul><li>外部类群(outgroup)：与所有待研究类群亲缘关系都较远的类群。</li></ul></li></ul><h2 id="构建进化树的方法">4.构建进化树的方法</h2><h3 id="构建分子进化树">4.1 构建分子进化树</h3><p>推断分子进化树的基本原理：同源序列之间的差异是进化造成的，差异程度与进化时间成正比。</p><blockquote><p>分子钟假设</p></blockquote><p>构建分子进化树的基本方法：</p><ol type="1"><li>刻画多条同源序列的差异</li><li>构建反映序列间差异的树状图<ul><li>从现有数据出发, 试图<mark>推断(或重构)</mark>进化树——真实的进化树是未知的。</li></ul></li></ol><p>推断分子进化树的关键：刻画出序列之间由进化造成的与进化时间成正比的差异。</p><p>刻画序列之间差异的方法：进行序列比对，由最佳比对构造距离(或不相似度)。</p><ul><li><p>设 最佳比对中不匹配位点所占的百分<em>f</em></p><ul><li>“每100个位点上不匹配位点的数目”</li></ul></li><li><p>比如: Jukes-Cantor模型构造的距离： <span class="math display">\[d_{ij}=-\frac{3}{4}log(1-\frac{4f}{3})\]</span></p></li></ul><p>进化树构建算法：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230611233724121.png" alt="进化树构建算法"><figcaption aria-hidden="true">进化树构建算法</figcaption></figure><h3 id="非加权组算术平均法upgma">4.2 非加权组算术平均法(UPGMA)</h3><p>最早的基于距离矩阵的方法，最初产生于20世纪60年代早期。</p><ul><li>所有树重建方法中最简单的一种。</li></ul><p>算法特点：</p><ul><li>基于距离矩阵数据</li><li>使用层次式聚类算法</li></ul><p>步骤：</p><ol type="1"><li>初始化：每条序列自成一个组C<sub>i</sub>，分别对应于树中的一个叶结点。</li><li>迭代：<ul><li>寻找具有最小距离值d<sub>ij</sub>的两个组C<sub>i</sub>和C<sub>j</sub> , 合并成 一个新组C<sub>k</sub> = C<sub>i</sub>∪ C<sub>j</sub></li><li>更新C<sub>k</sub>与各旧组C<sub>ℓ</sub>的距离为d<sub>k,ℓ</sub> = (d<sub>i,ℓ</sub>+ d<sub>j,ℓ</sub>)/2</li><li>在树中增加一个分支点，同时与C<sub>i</sub>和C<sub>j</sub>相连接，<strong>两条分枝各为d<sub>i,j</sub>/2</strong></li></ul></li><li>终止：直到所有序列聚为一个组时终止，最终得到的分枝点为树的根。</li></ol><h4 id="例-利用非加权组算数平均法进行进化树构建">例: 利用非加权组算数平均法进行进化树构建</h4><p>A: GTGCTGCACGG CTCAGTATA GCATTTACCC TTCCATCTTC AGATCCTGAA</p><p>B: ACGCTGCACGG CTCAGTGCG GTGCTTACCC TCCCATCTTC AGATCCTGAA</p><p>C: GTGCTCGCAGG CTCGGCGCA GCATTTACCC TCCCATCTTC AGATCCTATC</p><p>D: GTATCACACGA CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCCTAAA</p><p>E: GTATCACATAG CTCAGCGCA GCATTTGCCC TCCCGTCTTC AGATCTAAA</p><p>1.初始化：计算序列之间的汉明距离，即对应位点上字符不同的数目</p><p>得到初始距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table><p>2.迭代：选择最近结点进行合并，更新距离矩阵，更新进化树</p><p>第1次迭代：更新距离矩阵；合并分支（叶节点）</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201442420.png" alt="第一次迭代"><figcaption aria-hidden="true">第一次迭代</figcaption></figure><p>进化树上标注进化距离：两条分枝各为d<sub><em>ij</em></sub>/2</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201549550.png" alt="第一次迭代得到进化树"><figcaption aria-hidden="true">第一次迭代得到进化树</figcaption></figure><p>第2次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201712875.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201747559.png" alt="第二次迭代得到进化树"><figcaption aria-hidden="true">第二次迭代得到进化树</figcaption></figure><p>第3次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201825651.png" alt="第二次迭代"><figcaption aria-hidden="true">第二次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612201951538.png" alt="第三次迭代得到进化树"><figcaption aria-hidden="true">第三次迭代得到进化树</figcaption></figure><blockquote><p>左侧中间结点((A,C),B) 到中间结点 (A,C)的距离是: 10/2 – 4 = 1</p></blockquote><p>第4次迭代：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202054031.png" alt="第四次迭代"><figcaption aria-hidden="true">第四次迭代</figcaption></figure><p>进化树：</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202212962.png" alt="第四次迭代得到进化树"><figcaption aria-hidden="true">第四次迭代得到进化树</figcaption></figure><p>3.算法终止：完成进化树构建</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202320043.png"></p><p>不带标度的文本表示法：(((A,C),B),(D,E))</p><p>带标度的文本表示法：(((A:4,C:4):1,B:5):2.25,(D:2.5,E:2.5):4.75)</p><figure><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612202350905.png" alt="最终进化树"><figcaption aria-hidden="true">最终进化树</figcaption></figure><ul><li><p>初始距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">9</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">11</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">12</td><td style="text-align: center;">15</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">15</td><td style="text-align: center;">18</td><td style="text-align: center;">13</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li><li><p>进化距离矩阵：</p><table><thead><tr class="header"><th style="text-align: center;">物种</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">B</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">-</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">-</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">E</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">14.5</td><td style="text-align: center;">5</td><td style="text-align: center;">-</td></tr></tbody></table></li></ul><blockquote><p>两个距离矩阵中的数值 并不严格匹配</p></blockquote><p>超度量(Ultrametric)：如果任何3个不同序列S<sub>i</sub>,S<sub>j</sub>,S<sub>k</sub>，距离函数d<sub>ij</sub>,d<sub>ik</sub>,d<sub>jk</sub>中的两个相等且不小于第3个, 则称距离函数为超度量。</p><p>若初始距离矩阵为超度量矩阵，则UPGMA算法总能产生正确的进化树。即初始距离矩阵与所构造进化树对应的距离矩阵一致。</p><h1 id="五蛋白质结构分析与预测">五、蛋白质结构分析与预测</h1><h2 id="引言蛋白质">1.引言—蛋白质</h2><p>蛋白质是由<mark>氨基酸</mark>用<mark>肽键</mark>相连接起来的线性聚合物。</p><blockquote><p>蛋白质是平均长度为200个左右的氨基酸。</p><p>大的蛋白质可以达到上千个氨基酸。</p></blockquote><p>蛋白质决定的细胞的形状与结构。</p><ul><li>细胞中蛋白质的重量占细胞干重的一半以上。</li></ul><p>蛋白质是分子识别及催化作用的主要主体，执行生物体内各种重要工作：</p><ul><li>营养物质的运输</li><li>生物反应的催化</li><li>生物体的生长和分化的控制</li><li>生物信号的识别与传递</li></ul><blockquote><p>序列决定结构，结构决定功能。</p></blockquote><p>构成蛋白质的氨基酸序列的长度不同、排列不同和空间结构不同。</p><ul><li><p>一级结构：蛋白质中相邻的氨基酸通过肽键形成一条伸展的链。</p></li><li><p>二级结构：肽链上的氨基酸残基形成局部的二级结构。</p><blockquote><p>比如α螺旋是氨基酸的单链螺旋，而β片层则由序列片段“织”形成平面片状结构。</p></blockquote></li><li><p>空间结构：各种二级结构组合形成完整的折叠结构。</p></li></ul><h2 id="蛋白质结构预测">2.蛋白质结构预测</h2><h5 id="蛋白质结构预测问题的可行性">蛋白质结构预测问题的可行性</h5><p>自然界中实际存在的蛋白质种类是<strong>有限的</strong>，可能的结构类型并不多。</p><ul><li>结构的数目并未随蛋白质氨基残基的个数呈现指数增长。</li></ul><p>存在大量同源序列，序列到结构的关系有一定规律可循。</p><ul><li>相似的序列具有相似的结构。</li></ul><h5 id="蛋白质结构预测问题的数学本质">蛋白质结构预测问题的数学本质</h5><p>寻找一种从蛋白质的氨基酸<strong>线性序列</strong>到蛋白质所有原子<strong>三维坐标</strong>的<mark>一种映射</mark>。</p><h5 id="结构预测的基本方法">结构预测的基本方法</h5><p>统计分析方法：对已知结构的蛋白质进行统计分析，建立氨基酸序列到蛋白质结构的映射模型，进而对未知结构的氨基酸序列根据映射模型直接从序列预测结构。</p><ul><li>经验参数法</li><li>相似片断法</li><li>同源方法</li></ul><p>理论分析方法：假设蛋白质分子取能量最低的空间结构，根据物理化学原理，通过理论计算(如分子力学/分子动力学)进行对氨基酸序列结构预测。</p><ul><li>从头计算法</li></ul><h2 id="蛋白质二级结构预测">3.蛋白质二级结构预测</h2><p>基本依据：每一段相邻氨基酸残基具有形成一定二级结构的倾向。</p><p>问题的本质是模式分类问题。</p><ul><li>蛋白质二级结构的构成具有比较强的统计规律。</li><li>所有蛋白质中约85%的氨基酸残基处于三种基本二级结构状态之一。<ul><li>α螺旋、β折叠和 t 转角</li></ul></li></ul><p>二级结构预测的目标：判断每一段中心的残基是否处于二级结构的三态之一。</p><blockquote><p>三态：α螺旋、β折叠和 t 转角(或其它状态)</p></blockquote><p>二级结构预测的基本思路：相似序列对应着相似的结构。</p><ul><li>相似的一段相邻氨基酸残基，对应着相似的二级结构。</li></ul><p>二级结构预测的基本过程：</p><p><img src="/2023/06/08/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6/image-20230612215417920.png" alt="二级结构预测" style="zoom:50%;"></p><p>二级结构预测可利用的信息：</p><ol type="1"><li>单个氨基酸残基统计分析</li></ol><ul><li>从数据集中提取各种残基形成特定二级结构的倾向，以此作为预测依据。</li></ul><ol start="2" type="1"><li>基于氨基酸片断的统计分析<ul><li>统计对象氨基酸片断，片断体现了中心残基所处的环境。</li><li>以残基在特定环境中形成的特定二级结构的倾向作为预测依据。</li></ul></li><li>蛋白质序列的长程信息和进化信息<ul><li>二级结构的形成一定程度上受到长程残基的影响。</li><li>蛋白质家族具有特异的残基替换模式。</li><li>存在进化保守区域，该区域变化则会导致蛋白质结构的改变。</li></ul></li></ol><h5 id="经验参数法">(1)经验参数法</h5><p>根据不同氨基酸形成特定二级结构的倾向进行结构预测。</p><ul><li>通过对已知结构的蛋白质(如蛋白质结构数据库PDB、蛋白质二级结构数据库DSSP中的蛋白质)进行统计分析，可发现各种氨基酸形成不同二级结构的倾向，从而形成一系列关于二级结构预测的规则。</li></ul><h6 id="预测二级结构的经验规则">预测二级结构的经验规则</h6><p>基本思想：在序列中寻找符合某规则的二级结构的成核位点和终止位点。</p><p>基本步骤：扫描输入的氨基酸序列，利用一组规则发现可能成为特定二级结构<strong>成核区域</strong>的短序列，然后对于<strong>成核区域</strong>进行扩展，不断扩大<strong>成核区域</strong>，直到倾向性因子小于1.0为止。</p><ul><li>α螺旋规则</li><li>β折叠规则</li><li>转角规则</li><li>重叠规则</li></ul><h5 id="相似片段法">(2)相似片段法</h5><p>基本原理：最近邻方法。</p><ul><li>相似序列具有相似的结构，将相似序列或序列的片断所对应的二级结构作为预测结果；在预测中心残基的二级结构时，以残基在特定环境形成特定二级结构的倾向作为预测依据。</li></ul><p>基本统计信息：基于氨基酸片段的统计分析。</p><ul><li>统计的对象是氨基酸片段，片段体现了中心残基所处的上下文环境。<ul><li>片段的长度通常为11~21。</li></ul></li></ul><p>实现步骤：</p><ul><li>训练阶段<ul><li>通过窗口扫描已知结构的训练序列，形成大量短片断，即训练片断。</li><li>记录这些片断中心氨基酸残基的二级结构。</li></ul></li><li>预测阶段<ul><li>利用同样大小的窗口扫描待测序列u，在每个窗口位置下的序列片断与上述训练片断比较，找出最相似的k个训练片断。<ul><li>比如 k=20，50</li></ul></li><li>取出现频率最高的训练片断的二级结构作为待测片断二级结构的预测。</li></ul></li></ul><h5 id="同源分析法">(3)同源分析法</h5><p>基本思路：</p><ul><li>将待预测的片段与数据库中已知二级结构的片段进行相似性比较。</li><li>利用打分矩阵计算出相似性得分。</li><li>根据相似性得分以及数据库中的构象态，构建出待预测片段的二级结构。</li></ul><p>适用情况：</p><ul><li>该方法对数据库中同源序列的存在非常敏感。</li><li>若数据库中有相似性大于30%的序列，则预测准确率可大幅上升。</li></ul><h2 id="蛋白质三维空间结构预测">4.蛋白质三维空间结构预测</h2><ul><li>同源模型法</li><li>线索化方法</li><li>从头预测法</li></ul><h5 id="三种方法的比较">三种方法的比较：</h5><p>同源模型法需要得到一个好的序列比对。</p><ul><li>目标蛋白质序列与模板等同部分超过60%，则完全可以找到正确的比对；如果相似程度只有20%-25%，则很难找到正确的比对；如果相似度低于20%，无法应用同源模型化方法。<ul><li>同源模型法是预测结果最可靠的方法</li></ul></li></ul><p>线索化方法需要找到远程同源蛋白。</p><ul><li>如果能够找到同一家族的远程同源蛋白质，则可以获得比较好的预测结果；如果找到的模板属于不同的家族，则预测准确性难以保证。</li></ul><p>从头预测方法</p><ul><li>需要准确的能量函数和快速搜索策略。</li><li>通常难以产生准确的预测结构。</li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>信息</tag>
      
      <tag>生物</tag>
      
      <tag>马尔可夫</tag>
      
      <tag>贝叶斯</tag>
      
      <tag>动态规划</tag>
      
      <tag>进化树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建</title>
    <link href="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li><p><a href="https://www.bilibili.com/read/cv12633102/">hexo框架+部署到github</a></p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">前期准备的一些细节问题，这个是部署到gitee的</a>，我们要部署在github，这个只用来看一些细节</p></li><li><p><a href="https://lanweixiao.gitee.io/2020/08/18/hexo+gitee%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/">一些详细资料可以看这里</a></p></li></ul><hr><p>2023/6/7 22:49 快要考试了，但是我还是想花点时间这里这个东西，等整理完这个，再去整理专业课程</p><hr><h1 id="一前期准备">一、前期准备</h1><h2 id="注意事项">1.注意事项</h2><ul><li><p>很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行</p></li><li><p>hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导</p></li><li><p>hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的</p></li></ul><h2 id="下载并安装node.js">2.下载并安装node.js</h2><p>Hexo 是基于Node.js 的博客框架，就像 Java 要依赖 JDK 环境一样。</p><ul><li>node下载地址：http://nodejs.cn/download/ ，傻瓜式安装，这里不再详述</li></ul><p><strong>NodeJS环境安装重点拓展：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 确认node.js安装成功：运行下面两个命令打印版本号即可</span><br>node -v<br>npm  -v<br><br><span class="hljs-comment"># 安装 Node.js 淘宝镜像加速器 （cnpm）</span><br>npm install -g cnpm <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 修改 node 类库默认安装位置</span><br><span class="hljs-comment"># 默认是在 C:\Users\lingStudy\AppData\Roaming\npm</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;D:\nodejs安装路径\node_global&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\nodejs安装路径\node_cache&quot;</span><br><span class="hljs-comment"># 查看修改是否成功</span><br>npm root -g<br><span class="hljs-comment"># 然后把D:\install\node\node_global配置到环境变量的 PATH 下即可</span><br><br></code></pre></td></tr></table></figure><h2 id="安装版本控制工具-git">3.安装版本控制工具 Git</h2><p>用来将本地项目托管到码云，所以还需要自己注册一个码云的账号。</p><p>下载地址：https://git-scm.com/download 学程序的，在工作中 Git 是必知必会的，还没学的建议去看看，所以这里不再详细介绍 Git。</p><p>下面是部署到gitee（码云）上所需要的配置，我们<strong>不需要</strong>进行下面的步骤：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># Git一些重要配置</span><br>git config --<span class="hljs-keyword">global</span> user.name <span class="hljs-string">&quot;lxxxxdy&quot;</span>  <span class="hljs-meta">#码云用户名</span><br>git config --<span class="hljs-keyword">global</span> user.email <span class="hljs-string">&quot;xxx83@qq.com&quot;</span>   <span class="hljs-meta">#邮箱</span><br><br><span class="hljs-meta"># 生成SSH公钥并添加到码云，实现免密码登录</span><br><span class="hljs-meta"># 1、生成公钥</span><br>ssh-keygen -t rsa<br><span class="hljs-meta"># 2、进入 C:\Users\主机名\.ssh 目录，把 id_rsa.pub 里面的信息复制到码云的 SSH公钥 中即可</span><br><br></code></pre></td></tr></table></figure><h2 id="hexo安装">4.Hexo安装</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta"># 全局安装</span><br>npm install hexo-<span class="hljs-keyword">cli</span> -g<br><span class="hljs-meta"># 查看hexo版本</span><br>hexo -v<br></code></pre></td></tr></table></figure><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM2NTUzMA==,size_16,color_FFFFFF,t_70-16861500587952.png"></p><h1 id="二配置github">二、配置github</h1><h2 id="在github上创建仓库">1.在github上创建仓库</h2><h3 id="创建">1.1 创建：</h3><ul><li><p>新建一个名为你的用户名.github.io的仓库。</p></li><li><p>比如说，如果你的github用户名是miqn，那么你就新建miqn.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 http://miqn.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p></li></ul><h3 id="注意">1.2 注意：</h3><ul><li><p>注册的邮箱一定要验证，否则不会成功；</p></li><li><p>仓库名字必须是：username.github.io，其中username是你的用户名；</p></li><li><p>仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久；</p></li><li><p>创建页面如下：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/ca3573693ec7d4b8f30b71b7f22a2003a9bac6e8.png@942w_675h_progressive-16861505570355.webp"></p></li></ul><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="绑定域名这步可省略">2.绑定域名（这步可省略）</h2><p>这里就不详细赘述了，想了解看相关资料。</p><h1 id="三配置ssh免密登录">三、配置SSH免密登录</h1><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p><ul><li><p>首先打开电脑文件夹，找到C:\86131 .ssh文件夹并删除 。</p></li><li><p>在C:\86131 文件夹下右键打开Git Bash Here输入命令：ssh-keygen -t rsa -C github邮件地址 生成.ssh秘钥，输入后连敲三次回车，出现下图情况代表成功：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8fb9a4ff9e0410bdbb1e4b89f34208ae2c6ecfd.jpg@942w_407h_progressive.webp"></p></li><li><p>最终生成了一个新的 C:\86131 .ssh文件夹，打开这个文件夹，找到.ssh_rsa.pub文件，记事本打开并复制里面的内容。</p></li><li><p>打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key，把复制的内容粘贴进去，title随便填，保存即可，我们的公钥就添加成功了，设置好如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/cae65261511e4bf7e4ea0e7838a5bfc5f3560d20.png@942w_509h_progressive.webp"></p></li><li><p>检测是否设置成功：</p><p>输入命令： $ ssh -T git@github.com # 注意邮箱地址不用改</p><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><p>Hi liuxianan! You've successfully authenticated, but GitHub does not provide shell access.</p><p>看到这个信息说明SSH已配置成功！</p></li><li><p>此时你还需要配置：</p><p>$ git config --global user.name "liuxianan"// 你的github用户名，非昵称;</p><p>$ git config --global user.email "xxx@qq.com"// 填写你的github注册邮箱。</p></li></ul><h1 id="四使用hexo搭建博客">四、使用hexo搭建博客</h1><h2 id="初始化">1.初始化</h2><p>第一步：在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是D:，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放</p><p>第二步：在D:Git Bash Here，输入hexo init 初始化</p><ul><li><p>hexo会自动下载一些文件到这个目录，包括node_modules，目录结构如下图：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230607234808122.png"></p></li></ul><p>第三步：执行以下命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的：</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f8d1a66cf00c3dfabb1bff69c531398ef0a33679.png@942w_56h_progressive.webp"></p><p>第四步：hexo s 是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考<a href="https://www.runoob.com/w3cnote/windows-finds-port-usage.html">这篇文章</a></p><h2 id="将博客部署到-github-个人主页上">2.将博客部署到 github 个人主页上</h2><p>第一步：在D:hexo-deployer-git 插件</p><ul><li><p>安装命令： npm install hexo-deployer-git --save</p></li><li><p>必须安装，否则执行hexo d 的话会报如下错误：</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/f920d62b355a1a62bb9f6f37571edfb936fc03b2.png@815w_53h_progressive.webp"></p><p>第二步：编辑D:_config.yml 文件, 在文件末尾添加如下内容:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repository:</span> git@github.com:miqn/miqn.github.io.git<br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure><ul><li>注意：其中 repository 中的内容即为 github 个人主页链接地址，具体看下图：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9cc1855324f9f968aa56d8a94a913475b3bc1d70.png@942w_437h_progressive.webp"></p><p>第三步：在D:，输入命令：hexo d 将本地 blog 推送到 github仓库，也可能需要输入 username &amp; pwd。</p><ul><li>推送成功后, 在浏览器中输入对应域名, 即可访问 https://miqn.github.io/</li></ul><h1 id="五更换主题">五、更换主题</h1><h2 id="寻找主题">1.寻找主题</h2><ul><li><p>既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。</p></li><li><p>这是hexo官网：https://hexo.io/themes/，可在里面下载主题，点击主题名即可跳转到github上，也可以直接在github上搜索主题</p></li><li><p>在这里我使用github上一个大佬的主题blinkfox/hexo-theme-matery</p></li><li><p>链接：https://github.com/blinkfox/hexo-theme-matery</p></li></ul><h2 id="下载主题">2.下载主题</h2><p>第一步：Git Bash Here中先cd到D:</p><p>第二步：再输入命令 $ git clone 主题http链接 themes/主题名称</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/dc6cf704d5d468a2f02dcd044fc4a0b4daf78960.png@942w_507h_progressive.webp"></p><p>注意：</p><ul><li>D:theme 文件夹下存放的就是博客的主题，主题是否下载成功可到该目录下查看：</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/075cf0ecdb17fd480e0a705242cf9b6cf28510ee.png@942w_225h_progressive.webp"></p><h2 id="使用主题">3.使用主题</h2><ul><li><p>打开D:_config.yml文件，在里面找到theme: landscape改为theme: blinkfox （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</p></li><li><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</p></li><li><p>再次在浏览器中输入对应域名, 即可发现主题已更换。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/b122a24f4e848f12e98c105e30e57fdc770d6690.png@942w_251h_progressive.webp"></p><h2 id="修改主题内容">4.修改主题内容</h2><p>在这里我使用的是blinkfox主题，后期相关修改参考这个<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">主题文档</a></p><ul><li><p>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的。</p></li><li><p>大致在下图的文件夹里面修改文件，记得修改后的文件需要关闭后，再在hexocode根目录右键打开Git Bash Here，输入两个命令：hexo g 重新生成，hexo s 开启本地预览服务,等修改的符合要求了，再输入 hexo d 推送到github仓库即可。</p></li><li><p>这样就可以输入网址查看更改后的内容了。</p></li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/426b2c5a296d531dcae228493e6d63868179f132.png@942w_353h_progressive.webp"></p><p>文档上没有提及的修改：</p><ul><li>返回按钮样式修改：在主题下面的 blinkfox_partial 文件夹中的 back-top.esj 文件中修改</li></ul><p>特别注意：</p><ul><li>修改生成的默认页面信息，要到主题下面的_config.yml文件里面去改，而不是根目录下的 _config.yml文件</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/312648b8eabe0b58395774e2742277f9690a94c6.png@942w_288h_progressive.webp"></p><ul><li>要把根目录下的_config.yml文件中的这些信息替换成自己的和设置中</li></ul><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9545db7dea8f6d676b15ebe2d5542fec221d22ca.png@942w_191h_progressive.webp"></p><h2 id="blinkfox主题的相关配置问题">5.blinkfox主题的相关配置问题</h2><p>配置音乐播放器：使用网易云音乐id不行，这里用的是QQ音乐</p><p>配置留言功能（利用Valine）：</p><ul><li><p>我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</p></li><li><p>注册完以后需要创建一个应用，名字可以随便起，然后 进入应用-&gt;设置-&gt;应用key，获取你的appid 和 appkey，复制到主题下面的 _config.yml 文件里面搜索 valine，填入appid 和 appkey</p></li><li><p>最后！记得在Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名 把你的域名加进去就可以了</p></li><li><p>主题页面显示的内容在主题下面的 layout 文件夹中的 contact.ejs 文件里面更改</p></li></ul><h1 id="六利用typora软件来写博客">六、利用Typora软件来写博客</h1><h2 id="typora介绍">1.Typora介绍</h2><ul><li><p>Typora–一款简单高效的Markdown编辑器，保存后直接为md格式，Markdown中点击导入就可以。</p></li><li><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式，其目标是实现易读易写，说人话就是删减版的HTML语言</p></li><li><p><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown教程</a></p></li></ul><h2 id="安装typora">2.安装Typora</h2><p><a href="https://www.typora.io/#windows">Typora官网</a></p><h2 id="写博客的步骤">3.写博客的步骤</h2><p>先创建一个md文档，使用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;文档名&quot;</span><br></code></pre></td></tr></table></figure><p>用这个命令的好处是帮我们自动生成了时间，默认生成如下内容</p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/image-20230608101831956.png"></p><p>如果没有这个内容，右键点击插入，再点击YAML Front Matter。</p><p>想要将个人博客同步到网站上，使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br></code></pre></td></tr></table></figure><p>清理缓存，接着使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>生成静态资源文件，此时可以使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>启动本地预览本地是否成功，若需要同步远端则使用</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>部署到服务器github。</p><p>补充：hexo new page 'postName'命令和hexo new 'postName'的区别？</p><ul><li>hexo new page 'My-second-blog'最终部署时生成：hexo-second-blog.html，但是它不会作为文章出现在博文目录。</li></ul><h2 id="所使用的主题的文章-front-matter-语法">4.所使用的主题的文章 Front-matter 语法</h2><p>依据使用的不同主题，一些文章功能所使用的语法可能不一样，例如写博客时给文章添加标签的语法等等，这些都要看所使用的主题的文档，例如我们这里使用的是 blinkfox 主题，打开<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">blinkfox主题文档</a>，往下翻找到" 文章 Front-matter 介绍 "即可。</p><h1 id="七如何向hexo博客中插入图片">七、如何向hexo博客中插入图片</h1><h2 id="前言">1.前言</h2><p>Hexo是个静态博客程序，使用markdown语法。而Typero是个编辑预览于一身的md编辑器。</p><p>在Typero写文章时候，如果能复制网络图片，或者是截图粘贴到Typero，并且可以<strong>直接在网站上查看该图片</strong>，这样是非常方便的。</p><h2 id="修改hexo">2.修改Hexo</h2><p>首先确认站点配置文件 _config.yml 中有 post_asset_folder:true 这个需要去手动修改</p><p>接着打开git bash，在 hexo 站点目录，执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm install https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/CodeFalling/</span>hexo-asset-image --save<br></code></pre></td></tr></table></figure><p>这样每次新建一篇文章，hexo同时会创建一个与文章名同名的文件夹，用来放图片。</p><h2 id="修改typora">3.修改Typora</h2><p>文件-&gt;偏好设置，下拉找到 <strong>图片插入</strong></p><p><img src="/2023/06/07/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5cdaf60e1fda7a3b8fb67be354a35485.png">sho</p><p>修改成上图的样子。填这个 <code>./$&#123;filename&#125;/</code></p><h1 id="八常见问题汇总">八、常见问题汇总</h1><h2 id="spawn-failed">1.spawn failed</h2><ul><li><a href="https://blog.csdn.net/m0_73820275/article/details/132088528">Hexo部署博客时出现spawn failed问题解决方法</a></li><li><a href="https://www.cnblogs.com/Lutheran/p/15915295.html">github连接报"ssh: connect to host github.com port 22: Connection timed out"错误</a></li></ul><p>首先我通过查阅资料，试了先把目录下的.deploy_git目录删除，然后使用命令<code>git config --global core.autocrlf false</code>取消git网络代理，接着依次使用hexo clean/g/d的方法，发现问题依旧没有解决，但我看我没试把.deploy_git目录和public都删除，下次可以试一试。</p><p>但是通过查阅资料，我知道了问题出在我执行hexo d时在访问github时出现了问题，所以我就追溯到安装时候的第三步即配置SSH免密登录，我输入<code>ssh -T git@github.com</code>命令时，出现了<code>ssh: connect to host github.com port 22: Connection timed out</code>的错误，通过查阅资料，我找到了解决办法。</p><p>在存放公钥私钥(id_rsa和id_rsa.pub)的文件里，新建config文本，内容如下：</p><p>第一步：打开终端并打开存放ssh的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>查看是否存在这些文件 若不存在，则可能是ssh没配置对，首先需要配置ssh（看上面第三步）很简单 若存在则在继续在终端输入以下命令新建一个文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">vim config<br></code></pre></td></tr></table></figure><p>接着输入下面内容</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host github.com<br><span class="hljs-keyword">User</span> <span class="hljs-title">注册github</span>的邮箱<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br></code></pre></td></tr></table></figure><p>最后:wq退出编辑即可 接着再执行</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>出现提示回车yes即可</p><p>验证就能顺利通过了，后面我再进行hexo d就能正常运行了。</p>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>金融领域问题匹配</title>
    <link href="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/"/>
    <url>/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲">大纲：</h1><ul><li>任务描述</li><li>数据集介绍</li><li>代码实现——CNN</li><li>代码实现——BERT</li></ul><hr><h1 id="任务描述">任务描述</h1><p>本次任务是金融领域问题匹配。 即针对中文银行领域数据中的问句对， 判定两个句子语义是否相同或者相近。</p><p>举例： &gt; Eg1:<br>&gt; Q1： “看图猜一电影名”<br>&gt; Q2： “看图猜电影”<br>&gt; Label：1</p><blockquote><p>Eg2:<br>Q1： “无线路由器怎么无线上网”<br>Q2： “无线上网卡和无线路由器怎么用”<br>Label：0</p></blockquote><p>label表示问句之间的语义是否相同。<br>若相同则标为1， 若不相同则标为0.</p><p><strong>要求：</strong> <strong>基于示例CNN及BERT代码（或自行设计算法），实现在测试集上语义相似度判断任务（要包含F1值）</strong><br><strong>另外：</strong> <strong>示例代码仅供参考，给出的参数仅仅是稍微试过的，而没经过精细化调参。</strong></p><hr><h1 id="数据集介绍">数据集介绍</h1><p>本次数据集是节选自节选自千言提供的BQ金融领域问题匹配数据集，格式为json文件。<br>数据存放位置：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/data/</span><br></code></pre></td></tr></table></figure><p>数据集概况如下：</p><table><thead><tr class="header"><th style="text-align: left;">名称</th><th>数量</th><th>标签</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">train.json</td><td>90000</td><td>有</td></tr><tr class="even"><td style="text-align: left;">dev.json</td><td>10000</td><td>有</td></tr><tr class="odd"><td style="text-align: left;">test.json</td><td>10000</td><td>有</td></tr></tbody></table><h1 id="一代码实现cnn">一、代码实现——CNN</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>CNN<br></code></pre></td></tr></table></figure><h2 id="读取数据集">1.读取数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data</span>(<span class="hljs-params">data_path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    区分训练/验证/测试集</span><br><span class="hljs-string">    @param data_path: 数据json文件存放位置</span><br><span class="hljs-string">    @return: 训练/验证/测试集</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(data_path) <span class="hljs-keyword">as</span> f:<br>        data = json.load(f)<br><br>    <span class="hljs-keyword">return</span> data<br></code></pre></td></tr></table></figure><p>同学们直接打开json文件观察数据集看到的应该是ascii码，这和数据的写入方式有关。</p><h2 id="数据预处理">2.数据预处理</h2><p>一般来说，基于CNN的文本语义相似度任务需要如下预处理过程： - 将原始文本分词并转换成以词的序列</p><ul><li><p>将词序列转换成以词编号（每个词表中的词都有唯一编号）为元素的序列</p></li><li><p>将词的编号序列中的每个元素（某个词）展开为词向量的形式。<br><strong>注意：转成词向量需要借助已经建立好的映射，文件太大就没有放进压缩包了。请大家自行下载 网址：<a href="https://pan.baidu.com/s/1ZKePwxwsDdzNrfkc6WKdGQ">百度网盘</a> OR <a href="https://www.aliyundrive.com/s/5cCC1KXqft8">阿里云盘</a></strong><br><strong>下载之后放哪儿？ 这个无关紧要，只要把hyp.py中的<code>embed_path</code>修改成存放位置即可</strong></p><blockquote><p>注意记得把“[]”去掉。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># data_preprocess.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_sentences</span>(<span class="hljs-params">dataset, vocab, is_train, <span class="hljs-built_in">repr</span>=<span class="hljs-string">&#x27;word&#x27;</span>, test_vocab=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    将输入转换为id，创建词表</span><br><span class="hljs-string">    参数pred_mode作用是控制是否返回标签</span><br><span class="hljs-string">    因为和gen_data共用一个函数，因此需要根据试验集合调整返回的参数</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-comment"># 数据读取</span><br>    question_1, question_2 = [], []<br>    max_len_1, max_len_2 = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>    punc = punctuation + <span class="hljs-string">u&#x27;1-9.,;《》？！“”‘’@#￥%…&amp;×（）——+【】&#123;&#125;;；●，。&amp;～、|\s: &#x27;</span><br><br>    seq1 = []<br>    seq2 = []<br>    label = []<br><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> dataset:<br>        seq1.append(data[<span class="hljs-string">&#x27;q1&#x27;</span>])<br>        seq2.append(data[<span class="hljs-string">&#x27;q2&#x27;</span>])<br>        label.append(<span class="hljs-built_in">int</span>(data[<span class="hljs-string">&#x27;label&#x27;</span>]))<br><br>    <span class="hljs-comment"># 数据清洗</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(label)):<br>        <span class="hljs-keyword">if</span> label[i] &gt; <span class="hljs-number">0</span>:<br>            label[i] = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            label[i] = <span class="hljs-number">0</span><br><br><br>    <span class="hljs-comment"># 对每对问句处理</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(seq1)):<br>        seq1[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq1[i])<br>        seq2[i] = re.sub(<span class="hljs-string">r&quot;[&#123;&#125;]+&quot;</span>.<span class="hljs-built_in">format</span>(punc), <span class="hljs-string">&quot; &quot;</span>, seq2[i])<br><br>        <span class="hljs-comment"># 将问句分成一个个token</span><br>        q1_tokens = split_sent(seq1[i], <span class="hljs-built_in">repr</span>)<br>        q2_tokens = split_sent(seq2[i], <span class="hljs-built_in">repr</span>)<br><br>        <span class="hljs-comment"># 获取句子最长度</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q1_tokens) &gt; max_len_1:<br>            max_len_1 = <span class="hljs-built_in">len</span>(q1_tokens)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(q2_tokens) &gt; max_len_2:<br>            max_len_2 = <span class="hljs-built_in">len</span>(q2_tokens)<br><br>        token_id1, token_id2 = [], []<br><br>        <span class="hljs-comment"># 对单个问句中的每个token进行处理</span><br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q1_tokens:<br>            <span class="hljs-comment"># repr = &#x27;word&#x27;</span><br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    <span class="hljs-comment"># 如果在训练集，就注册词库</span><br>                    <span class="hljs-comment"># eg: vocab[&#x27;word&#x27;][&#x27;我&#x27;] = 10</span><br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    <span class="hljs-comment"># 如果不是在训练集，且未在测试词库注册，则注册</span><br>                    <span class="hljs-comment"># eg&quot; test_vocab[&#x27;word&#x27;][&#x27;注册&#x27;] = 1000</span><br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-comment"># 如果这个token在词库注册了，那么就把对应的键值塞入列表</span><br>                token_id1.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id1.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id1.append(OOV_WORD_INDEX)<br>        <span class="hljs-comment"># print(&quot;-----&quot;, token_id1)</span><br>        question_1.append(token_id1)<br>        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> q2_tokens:<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                <span class="hljs-keyword">if</span> is_train:<br>                    vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>])<br>                <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span> <span class="hljs-keyword">and</span> token <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> test_vocab[<span class="hljs-built_in">repr</span>]:<br>                    test_vocab[<span class="hljs-built_in">repr</span>][token] = <span class="hljs-built_in">len</span>(vocab[<span class="hljs-built_in">repr</span>]) + <span class="hljs-built_in">len</span>(test_vocab[<span class="hljs-built_in">repr</span>])<br>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> vocab[<span class="hljs-built_in">repr</span>]:<br>                token_id2.append(vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">repr</span> == <span class="hljs-string">&#x27;word&#x27;</span>:<br>                token_id2.append(test_vocab[<span class="hljs-built_in">repr</span>][token])<br>            <span class="hljs-keyword">else</span>:<br>                token_id2.append(OOV_WORD_INDEX)<br>        question_2.append(token_id2)<br><br>    <span class="hljs-keyword">return</span> question_1, question_2, max_len_1, max_len_2, label<br><br><br></code></pre></td></tr></table></figure></p></blockquote></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">train_vocab_emb, test_vocab_emb = construct_vocab_emb(<span class="hljs-string">&quot;./experimental-data&quot;</span>, vocab[<span class="hljs-string">&#x27;word&#x27;</span>], test_vocab[<span class="hljs-string">&#x27;word&#x27;</span>], <span class="hljs-number">300</span>,<br>                                                      base_embed_path=embed_path)<br></code></pre></td></tr></table></figure><h2 id="参数设置">3.参数设置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># hyp.py</span><br>hyp = &#123;<br>    <span class="hljs-string">&#x27;embed_path&#x27;</span>: <span class="hljs-string">&#x27;[Your &quot;sgns.wiki.bigram&quot; path]&#x27;</span>, <span class="hljs-comment"># 记得修改位置</span><br>    <span class="hljs-string">&#x27;data_path&#x27;</span>: <span class="hljs-string">&#x27;../../data&#x27;</span>,<br>    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;nb_filters&#x27;</span>: <span class="hljs-number">128</span>,<br>    <span class="hljs-string">&#x27;dropout_rate&#x27;</span>: <span class="hljs-number">0.3</span>,<br>    <span class="hljs-string">&#x27;embed_size&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-string">&#x27;learning_rate&#x27;</span>: <span class="hljs-number">0.05</span>,<br>    <span class="hljs-string">&#x27;epoches&#x27;</span>: <span class="hljs-number">60</span>,<br>    <span class="hljs-string">&#x27;save_model_name&#x27;</span>: <span class="hljs-string">&quot;checkpoint_textCNN.pt&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="网络模型">4.网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">creat_model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, batch_size, vocab_size, embedding_matrix,</span><br><span class="hljs-params">                 nb_filters, embed_size=<span class="hljs-number">300</span>, dropout_rate=<span class="hljs-number">0.5</span>, num_classes=<span class="hljs-number">2</span>,</span><br><span class="hljs-params">                 kernel_dim=<span class="hljs-number">100</span>, kernel_sizes=(<span class="hljs-params"><span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span></span>)</span>):<br>        <span class="hljs-built_in">super</span>(creat_model, self).__init__()<br>        self.batch_size = batch_size<br>        self.dropout_rate = dropout_rate<br>        self.embedding_matrix = embedding_matrix<br>        self.vocab_size = vocab_size<br>        self.embed_size = embed_size<br>        self.nb_filters = nb_filters<br>        self.kernel_dim = kernel_dim<br>        self.kernel_sizes = kernel_sizes<br>        self.num_class = num_classes<br>        <span class="hljs-comment"># 词嵌入层</span><br>        self.embedding_layer = self.add_embed_layer(self.embedding_matrix, <br>                                                    self.vocab_size[<span class="hljs-string">&#x27;word&#x27;</span>], self.embed_size)<br>        <span class="hljs-comment"># CNN编码层</span><br>        self.convs = nn.ModuleList([nn.Conv2d(<span class="hljs-number">1</span>, kernel_dim, (k, self.embed_size)) <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> kernel_sizes])<br>        <span class="hljs-comment"># 输出分类层</span><br>        self.dropout_layer = nn.Dropout(self.dropout_rate)<br>        self.fc = nn.Linear(<span class="hljs-built_in">len</span>(kernel_sizes) * kernel_dim * <span class="hljs-number">2</span>, num_classes)<br>        nn.init.xavier_uniform_(self.fc.weight.data, gain=<span class="hljs-number">1</span>)<br>        nn.init.constant_(self.fc.bias.data, <span class="hljs-number">0.1</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_embed_layer</span>(<span class="hljs-params">self, vocab_emb, vocab_size, embed_size</span>):<br>        <span class="hljs-keyword">if</span> vocab_emb <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 预训练词向量</span><br>            embed_layer = nn.Embedding(vocab_size, embed_size)<br>            pretrained_weight = np.array(vocab_emb)<br>            embed_layer.weight.data.copy_(torch.from_numpy(pretrained_weight))<br>            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> embed_layer.parameters():<br>                p.requires_grad = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 随机初始化</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Embedding with random weights&quot;</span>)<br>            embed_layer = nn.Embedding(num_embeddings=vocab_size, embedding_dim=embed_size)<br>        <span class="hljs-keyword">return</span> embed_layer<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, query_word_input, doc_word_input</span>):<br>        <span class="hljs-comment"># 这里对视频中的代码做了修改，使用了多个并行的卷积</span><br>        <span class="hljs-comment"># 经过词嵌入层，获得词向量</span><br>        query_word_emb = self.embedding_layer(query_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        doc_word_emb = self.embedding_layer(doc_word_input).unsqueeze(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># print(query_word_emb.size())</span><br>        <span class="hljs-comment"># [batch_size, 1, seq_len, embedding_dim]</span><br>        <span class="hljs-comment"># 经过卷积层，和最大池化层</span><br>        query_word_emb = [F.relu(conv(query_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        query_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> query_word_emb]<br>        doc_word_emb = [F.relu(conv(doc_word_emb)).squeeze(<span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> conv <span class="hljs-keyword">in</span> self.convs]<br>        doc_word_emb = [F.max_pool1d(i, i.size(<span class="hljs-number">2</span>)).squeeze(<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> doc_word_emb]<br>        <span class="hljs-comment"># 拼接不同卷积层的特征</span><br>        query_concated = torch.cat(query_word_emb, <span class="hljs-number">1</span>)<br>        query_concated = self.dropout_layer(query_concated)<br>        doc_concated = torch.cat(doc_word_emb, <span class="hljs-number">1</span>)<br>        doc_concated = self.dropout_layer(doc_concated)<br>        <span class="hljs-comment"># 拼接query和doc</span><br>        concated = torch.cat([query_concated, doc_concated], dim=-<span class="hljs-number">1</span>)<br>        prediction = self.fc(concated)<br>        <span class="hljs-keyword">return</span> prediction<br></code></pre></td></tr></table></figure><h2 id="训练过程">5.训练过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># train_CNN.py</span><br>    <span class="hljs-comment"># ===================== TRAIN Model ======================</span><br>    <span class="hljs-comment"># ### 定义模型 ###</span><br>    model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>    model = model.to(device)<br>    <span class="hljs-comment"># 定义优化器</span><br>    opt = torch.optim.SGD(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> p: p.requires_grad, model.parameters()), lr=learning_rate,<br>                          weight_decay=<span class="hljs-number">1e-6</span>, momentum=<span class="hljs-number">0.9</span>, nesterov=<span class="hljs-literal">True</span>)<br>    lr_reducer = ReduceLROnPlateau(optimizer=opt, verbose=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;use SGD optimizer&quot;</span>)<br>    <span class="hljs-comment"># 定义损失函数</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;compile model with binary_crossentropy&quot;</span>)<br>    criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>    criterion.to(device)<br><br>    <span class="hljs-keyword">try</span>:<br>        total_start_time = time.time()<br>        best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        best_auc = <span class="hljs-literal">None</span><br>        best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>        train_auc_list, valid_auc_list = [], []<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>            epoch_start_time = time.time()<br>            <span class="hljs-comment"># 训练</span><br>            train_loss, train_fpr, train_tpr, train_auc = train_fc(model, train_dataset, train_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, opt, criterion)<br>            train_auc_list.append(train_auc)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;|start of epoch&#123;:3d&#125; | time : &#123;:2.2f&#125;s | loss &#123;:5.6f&#125; | train_auc &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                time.time() - epoch_start_time,<br>                                                                                                train_loss, train_auc))<br>            <span class="hljs-comment"># 验证集上验证性能</span><br>            val_loss, val_fpr, val_tpr, val_auc, val_f1 = validate(model, valid_dataset, valid_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>],<br>                                                                   batch_size, criterion)<br>            valid_auc_list.append(val_auc)<br>            lr_reducer.step(val_loss)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">10</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;| end of epoch &#123;:3d&#125;| time: &#123;:2.2f&#125;s | loss: &#123;:.4f&#125; |valid_auc &#123;&#125; |valid_f1 &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(epoch + <span class="hljs-number">1</span>,<br>                                                                                                          time.time() - epoch_start_time,<br>                                                                                                          val_loss,<br>                                                                                                          val_auc,<br>                                                                                                          val_f1))<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> best_auc <span class="hljs-keyword">or</span> best_auc &lt; val_auc:<br>                best_auc = val_auc<br>                best_fpr = val_fpr<br>                best_tpr = val_tpr<br>                model_state_dict = model.state_dict()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;save the best model... best_auc: %s&quot;</span> % best_auc)<br>                model_weight = hyp[<span class="hljs-string">&#x27;save_model_name&#x27;</span>]<br>                torch.save(model_state_dict, model_weight)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;train_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(train_auc_list)<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;valid_textCNN_auc.csv&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, newline=<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>                writer = csv.writer(f)<br>                writer.writerow(valid_auc_list)<br>    <span class="hljs-keyword">except</span> KeyboardInterrupt:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-&quot;</span> * <span class="hljs-number">90</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Exiting from training early | cost time: &#123;:5.2f&#125;min&quot;</span>.<span class="hljs-built_in">format</span>((time.time() - total_start_time) / <span class="hljs-number">60.0</span>))<br><br><br></code></pre></td></tr></table></figure><h2 id="测试过程">6.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># =================== Test model =====================</span><br>criterion = torch.nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>criterion.to(device)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;load best model ... &quot;</span>)<br><span class="hljs-comment"># 定义一个新的模型</span><br>new_model = creat_model(batch_size, vocab_size, merge_vocab_emb, nb_filters, embed_size, dropout_rate)<br>new_model = new_model.to(device)<br><span class="hljs-comment"># 加载最佳模型的参数赋给新建模型</span><br><span class="hljs-comment"># model_weight = &quot;checkpoint_textCNN.pt&quot;</span><br>new_model.load_state_dict(torch.load(model_weight), strict=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(model_weight)<br><span class="hljs-comment"># 测试集测试</span><br>test_loss, test_fpr, test_tpr, test_auc, test_f1 = validate(new_model, test_dataset, test_dataset[<span class="hljs-string">&#x27;sim&#x27;</span>], \<br>                                                            batch_size, criterion)<br><span class="hljs-comment"># 打印结果</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_loss:&quot;</span>, test_loss)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_auc:&quot;</span>, test_auc)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;test_f1:&#x27;</span>, test_f1)<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><p>训练： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train_CNN.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure> 测试： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python test_CNN.py<br></code></pre></td></tr></table></figure></p><hr><h1 id="二代码实现bert">二、代码实现——BERT</h1><p><em>代码目录：</em></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">web_searching<span class="hljs-regexp">/example_code/</span>BERT<br></code></pre></td></tr></table></figure><h2 id="bert介绍">1.BERT介绍</h2><p>BERT的全称为Bidirectional Encoder Representation from Transformers，是一个预训练的语言表征模型，一经问世便火爆了NLP圈子，在 11 项自然语言处理任务中均表现出惊人的成绩。</p><figure><img src="/2023/06/04/%E9%87%91%E8%9E%8D%E9%A2%86%E5%9F%9F%E9%97%AE%E9%A2%98%E5%8C%B9%E9%85%8D/image-20230604002542014.png" alt="&#39;BERT模型图&#39;"><figcaption aria-hidden="true">'BERT模型图'</figcaption></figure><p>然而，原始的BERT参数量较大，对算力有一定的要求。为此，我们在<a href="https://huggingface.co">Hugging Face</a>的模型仓库中找了一个BERT-Tiny让大家体验它的工作流程。<strong>预训练模型的下载地址在这儿：<a href="https://pan.baidu.com/s/1wlSJL7l3koc6XUsrt9bTsg?pwd=igjr">百度网盘</a> OR <a href="https://www.aliyundrive.com/s/rmHMPzyECto">阿里云盘</a></strong></p><p><strong>下载之后放哪儿？ 这个无关紧要，只要把hyp.py中的<code>pretrained_dir</code>修改成存放位置即可</strong></p><p>在本实验中，我们将两个句子拼接后输入BERT，并用BERT的<code>[CLS]</code> token进行两个句子的类别预测工作。</p><h2 id="数据预处理-1">2.数据预处理</h2><p>和CNN中的预处理类似，我们需要将输入文本转换为词向量，才能输入到模型中。但是这些步骤可以利用Hugging Face的库函数实现。这边我们给了一个demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizerFast, BertModel<br><br>pretrained_dir = <span class="hljs-string">&#x27;./pretrained_model/bert-tiny&#x27;</span><br><br>tokenizer = BertTokenizerFast.from_pretrained(pretrained_dir)<br><br>test_word = [(<span class="hljs-string">&#x27;我来自人工智能学院&#x27;</span>,<span class="hljs-string">&#x27;我在学web搜索技术&#x27;</span>), (<span class="hljs-string">&#x27;天气真好&#x27;</span>,<span class="hljs-string">&#x27;我很高兴&#x27;</span>)]<br><br>encoded_word = tokenizer(test_word, padding=<span class="hljs-string">&#x27;longest&#x27;</span>, max_length=<span class="hljs-number">32</span>)<br><span class="hljs-built_in">print</span>(encoded_word)<br><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: <br>[[<span class="hljs-number">101</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">3341</span>, <span class="hljs-number">5632</span>, <span class="hljs-number">782</span>, <span class="hljs-number">2339</span>, <span class="hljs-number">3255</span>, <span class="hljs-number">5543</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">7368</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">1762</span>, <span class="hljs-number">2110</span>, <span class="hljs-number">8353</span>, <span class="hljs-number">3017</span>, <span class="hljs-number">5164</span>, <span class="hljs-number">2825</span>, <span class="hljs-number">3318</span>, <span class="hljs-number">102</span>],<br> [<span class="hljs-number">101</span>, <span class="hljs-number">1921</span>, <span class="hljs-number">3698</span>, <span class="hljs-number">4696</span>, <span class="hljs-number">1962</span>, <span class="hljs-number">102</span>, <span class="hljs-number">2769</span>, <span class="hljs-number">2523</span>, <span class="hljs-number">7770</span>, <span class="hljs-number">1069</span>, <span class="hljs-number">102</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br> <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: <br> [[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>  [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]], <br>  <span class="hljs-string">&#x27;attention_mask&#x27;</span>: <br>  [[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],<br>   [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]&#125;<br></code></pre></td></tr></table></figure><p>其中<code>input_ids</code>表示的是输入词编号，<code>token_type_ids</code>表示token对应的句子id，第一句为0，第二句为1。<code>attention_mask</code>表示输入句子的mask，1表示原始token，0表示padding token。由于输入的句子长度不一样，我们可以控制<code>padding</code>统一将所有输入句子的编码结果用0补齐至与最长句子一致。</p><h2 id="模型结构">3.模型结构</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BERT_Tiny</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, pretrained_dir</span>):<br>        <span class="hljs-built_in">super</span>(BERT_Tiny, self).__init__()<br>        self.bert = BertModel.from_pretrained(pretrained_dir)<br>        self.drooput = nn.Dropout()<br>        self.linear = nn.Linear(<span class="hljs-number">312</span>, <span class="hljs-number">2</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, input_ids, token_type_ids, attention_mask</span>):<br><br>        outputs = self.bert(input_ids = input_ids, token_type_ids = token_type_ids, attention_mask = attention_mask)<br>        pooled_output = outputs[<span class="hljs-number">1</span>]  <span class="hljs-comment"># 取出[cls]作为两个句子的分类表征</span><br>        <span class="hljs-keyword">return</span> self.linear(self.drooput(pooled_output))<br><br></code></pre></td></tr></table></figure><h2 id="训练过程-1">4.训练过程</h2><p><strong>训练损失和f1值不会在控制台打印，而是会以txt文档的形式保存在训练目录下，请同学们自行翻阅日志</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Training ==============================</span><br><br>best_acc, best_f1, best_thresh = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>best_auc = <span class="hljs-literal">None</span><br>best_fpr, best_tpr = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>train_auc_list, valid_auc_list = [], []<br>logger.info(<span class="hljs-string">&#x27;========= Training ===========&#x27;</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(epochs, desc=<span class="hljs-string">&#x27;Epoch&#x27;</span>):<br>  epoch += <span class="hljs-number">1</span><br>  logger.info(<span class="hljs-string">f&#x27;=========== Epoch<span class="hljs-subst">&#123;epoch&#125;</span> ==========&#x27;</span>)<br>  model.train()<br>  train_loss = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> iteration, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tqdm(train_loader, desc=<span class="hljs-string">&#x27;Iteration&#x27;</span>)):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    optimizer.zero_grad()<br>    loss = criterion(output, labels)<br>    loss.backward()<br><br>    <span class="hljs-comment"># for name, parms in model.named_parameters():</span><br>    <span class="hljs-comment">#     logger.info(f&#x27;--&gt;name: &#123;name&#125; --&gt;grad_requirs: &#123;parms.requires_grad&#125; --&gt;grad_value: &#123;parms.grad&#125;&#x27;)</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> iteration % <span class="hljs-number">100</span>:<br>      logger.info(<span class="hljs-string">f&#x27;- batch: <span class="hljs-subst">&#123;iteration&#125;</span> loss: <span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>      train_loss += loss.item()<br>      optimizer.step()<br><br>      num_batches = <span class="hljs-built_in">len</span>(train_data) / batch_size<br>      batch_loss = train_loss / num_batches<br>      logger.info(<span class="hljs-string">f&#x27;train_loss: <span class="hljs-subst">&#123;batch_loss:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br><br>      logger.info(<span class="hljs-string">&#x27;=========== Evaluating on dev set ==========&#x27;</span>)<br>      model.<span class="hljs-built_in">eval</span>()<br>      y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>      corrects = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(dev_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>          input_ids, token_type_ids, attention_mask, labels = batch<br>          output = model(input_ids, token_type_ids, attention_mask)<br><br>          pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>          corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>          pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>          label = labels.data.cpu().numpy()<br><br>          <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            y_true = label<br>            y_pred = pred_label<br>            <span class="hljs-keyword">else</span>:<br>              y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>              y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>              r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>              auc = roc_auc_score(y_true, y_pred)<br>              logger.info(corrects)<br>              logger.info(thresh)<br>              acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(dev_data)<br>              logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>              <span class="hljs-keyword">if</span> best_f1 <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> f1 &gt; best_f1:<br>                best_f1 = f1<br>                logger.info(<span class="hljs-string">f&#x27;Get best dev model at epoch <span class="hljs-subst">&#123;epoch&#125;</span>, f1 <span class="hljs-subst">&#123;f1&#125;</span>&#x27;</span>)<br>                torch.save(model.state_dict(), save_model_name)<br><br></code></pre></td></tr></table></figure><h2 id="测试过程-1">5.测试过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ==================== Load model ============================</span><br>logger.info(<span class="hljs-string">&#x27;============= Loading model ==============&#x27;</span>)<br>model = BERT_Tiny(pretrained_dir=pretrained_dir)<br>model.load_state_dict(torch.load(save_model_name))<br>model.to(device)<br><br>criterion = nn.CrossEntropyLoss(ignore_index=-<span class="hljs-number">1</span>)<br>logger.info(<span class="hljs-string">&#x27;=========== Testing on test set ==========&#x27;</span>)<br>model.<span class="hljs-built_in">eval</span>()<br>y_true, y_pred = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span><br>corrects = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>  <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> tqdm(test_loader, desc=<span class="hljs-string">&#x27;Evaluating&#x27;</span>):<br>    input_ids, token_type_ids, attention_mask, labels = batch<br>    output = model(input_ids, token_type_ids, attention_mask)<br><br>    pred_labels = nn.Softmax(dim=<span class="hljs-number">1</span>)(output)<br>    corrects += (torch.<span class="hljs-built_in">max</span>(pred_labels, <span class="hljs-number">1</span>)[<span class="hljs-number">1</span>].data == labels.data).<span class="hljs-built_in">sum</span>()<br>    pred_label = pred_labels[:, <span class="hljs-number">1</span>].data.cpu().numpy()<br>    label = labels.data.cpu().numpy()<br><br>    <span class="hljs-keyword">if</span> y_true <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>      y_true = label<br>      y_pred = pred_label<br>      <span class="hljs-keyword">else</span>:<br>        y_pred = np.concatenate((y_pred, pred_label), axis=<span class="hljs-number">0</span>)<br>        y_true = np.concatenate((y_true, label), axis=<span class="hljs-number">0</span>)<br>        r, f1, thresh = r_f1_thresh(y_pred=y_pred, y_true=y_true)<br>        auc = roc_auc_score(y_true, y_pred)<br>        acc = corrects * <span class="hljs-number">100</span> / <span class="hljs-built_in">len</span>(test_data)<br>        logger.info(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;infer_acc: <span class="hljs-subst">&#123;acc:<span class="hljs-number">.2</span>f&#125;</span>, f1: <span class="hljs-subst">&#123;f1:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="使用-1">使用</h4><p>训练：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> train.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> test.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>项目</tag>
      
      <tag>Web搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于文本和图像的多媒体检索系统</title>
    <link href="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料</p></blockquote><ul><li><a href="http://www.zzvips.com/article/214469.html">在pycharm中配置pyqt5</a></li></ul><hr><p>2023/6/2 22:44 这是我基于《多媒体信息检索课程设计》所作的一个项目，涉及到了计算机视觉方面的知识，主要用到了BOW模型。代码语言为python，运行环境为pycharm。废话不多说，开始操作。</p><hr><h1 id="一所需安装的软件及库">一、所需安装的软件及库</h1><h2 id="anaconda及pycharm的安装">1.Anaconda及pycharm的安装</h2><p>详情见多媒体信息检索实验指导（一）。</p><h2 id="jieba的安装">2.jieba的安装</h2><h3 id="全自动安装">2.1 全自动安装</h3><p>在pycharm终端或cmd输入：</p><p><code>pip install jieba / pip3 install jieba</code></p><h3 id="pycharm安装">2.2 pycharm安装</h3><p>依次点击 文件-设置-项目-解释器-“加号”，接着搜索需要的库并添加。</p><h3 id="手动安装">2.3 手动安装：</h3><p>将 jieba 的整个目录放置于python的site-packages 目录中。</p><h2 id="在pycharm中配置pyqt5">3.在pycharm中配置pyqt5</h2><h3 id="pyqt5简介">3.1 PyQt5简介</h3><p>1.什么是<a href="http://www.zzvips.com/article/106394.html">GUI</a>：Graphical User Interface，图形用户界面，用于人机交互。</p><p>2.怎么设计GUI：Qt。</p><p>3.什么是Qt：Qt是一种基于C++的跨平台图形用户界面应用程序开发框架。</p><p>4.学习python的我们怎么用Qt：PyQt5模块。</p><p>5.什么是PyQt5:Qt的python接口，pyqt5对Qt进行完全封装，我们可以利用python代码设计想要的图形界面。</p><h3 id="安装pyqt5模块">3.2 安装PyQt5模块</h3><p>(包括pyqt5,pyqt5-tools,pyqt5designer）</p><p>依次点击 文件-设置-项目-解释器-“加号” 来添加。</p><h3 id="配置pyqt5设计器qt-designer及转换工具">3.3 配置PyQt5设计器（Qt Designer）及转换工具</h3><h4 id="qt-designer">(1)Qt Designer</h4><p>用途：方便我们打开设计器。</p><p>首先同样是在file里面打开settings：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046403193-6.png"></p><p>Name：我们自己给这个tool起的名字。</p><p>Program：填入designer.exe的路径，每个人路径不同，找到自己计算机上的 路径输进去。一般来说是在D:-packages.exe这里。</p><p>Working directory:填入$ProjectFileDir$，表示文件所在的项目路径。</p><h4 id="pyuic">(2)PyUIC</h4><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/0046402509-7.png"></p><p>Name:自己起的名字。</p><p>Program:python.exe所在的位置，一般在D:.exe这里。</p><p>Arguements:填入-m PyQt5.uic.pyuic $FileName$ -o $FileNameWithoutExtension$.py 是将.ui文件转化成.py文件的语句。</p><p>Working directory:$FileDir$,表示文件所在路径。</p><h2 id="pcv包的安装">4.PCV包的安装</h2><p>1.下载PCV包：https://codeload.github.com/Li-Shu14/PCV/zip/master；</p><p>2.打开Anaconda3的prompt窗口，切换到下载好的PCV包所在的路径下；</p><p>3.执行以下命令：</p><p><code>pip install PCV-master.zip</code></p><blockquote><p><strong>注：</strong> 压缩包不用解压，直接pip install即可。</p></blockquote><h2 id="vlfeat包安装">5.vlfeat包安装</h2><p>1.下载安装vlfeat包，版本0.9.20 官方下载连接：http://www.vlfeat.org/download/（注意要下载20版本，不然会出现找不到.sift文件）</p><p>2.下载完成过后，把vlfeat里win64里的vl.dll和sift.exe和vl.lib复制粘贴到项目目录下：这样子环境配置基本上已完成。</p><blockquote><p><strong>注：</strong>vlfeat0.9.21版本太高导致部分电脑提取特征为空，要用9.20版本。</p></blockquote><h2 id="pysqlite3库安装">6.pysqlite3库安装</h2><ul><li><p>访问 https://www.sqlite.org/download.html 页面，下载 Windows 版 SQLite 预编译二进制文件。</p><p>注意要下载与你 Python 版本和操作系统位数（32 位或 64 位）对应的版本。</p></li><li><p>解压缩下载的 SQLite 文件。</p><p>在解压后的文件夹中，你将看到一些静态库和工具，以及一个名为 sqlite3.dll 的共享库文件。这个文件是 <code>pysqlite3</code> 包所依赖的 SQLite 动态链接库。</p></li><li><p>访问 https://www.lfd.uci.edu/~gohlke/pythonlibs/#pysqlite 页面，找到 <code>pysqlite3</code> 的适用于你的 Python 版本和操作系统位数的安装包并下载。</p><p>下载后的文件名一般是这样的：<code>pysqlite3-x.x.x-cpXX-cpXXm-win_amd64.whl</code>，其中 <code>x.x.x</code> 是版本号，<code>cpXX</code> 是 Python 主版本和次版本号，例如 <code>cp39</code> 代表 Python 3.9，<code>win_amd64</code> 表示 64 位 Windows 平台。</p></li><li><p>在命令提示符中使用 pip 安装刚才下载的 <code>pysqlite3</code> 安装包。</p><p>进入 <code>pysqlite3</code> 安装包所在的目录，然后运行以下命令：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">`Copy Codepip install pysqlite<span class="hljs-number">3</span>-<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>.<span class="hljs-keyword">x</span>-cpXX-cpXXm-win_amd<span class="hljs-number">64</span>.whl`<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>如果你 Python 版本为 32 位，请下载适用于 32 位 Python 的安装包，并将含有 <code>win_amd64</code> 的部分替换为 <code>win32</code> 即可。</p><p>pysqlite3这个库下载比较麻烦，下载之后需要重新编译python，并且要注意pycharm中的编译环境最好设置为python所在的python.exe这个环境，否则之前安装的一些库会不在列表中。</p><p>也要注意python3版本使用的是sqlite3这个库，尽管编辑器报错的时候会提醒一个跟pysqlite2有关的错误，最后解决的方法是同时更换文件中和PCV中imagesearch.py的import，尝试更改那里即可成功。</p></blockquote><h1 id="二文本检索部分算法说明">二、文本检索部分算法说明</h1><h2 id="文本爬取">1.文本爬取</h2><p>我对https://www.8lrc.com/ 网站的经典歌词进行了爬取，并将爬取到的歌词，用’lyrics’+歌名+歌手的命名方式，以记事本的文件类型保存在了当前文件夹里。并将标题与歌词的对应关系进行了保存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lyrics_urls</span>():<br>    titles = []  <span class="hljs-comment"># 用于保存标题</span><br>    urls = []  <span class="hljs-comment"># 用于保存每首歌的链接</span><br>    qianzhui = <span class="hljs-string">&#x27;https://www.8lrc.com/&#x27;</span>  <span class="hljs-comment"># 爬取网站</span><br>    <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">50</span>):  <span class="hljs-comment"># 共49页</span><br>        link = <span class="hljs-string">&#x27;https://www.8lrc.com/jingdian/32/&#x27;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27;.htm&#x27;</span>  <span class="hljs-comment"># 每页链接</span><br>        req = requests.get(link)    <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取排行榜中的30首歌信息</span><br>        lrcList = soup.find(<span class="hljs-string">&#x27;ul&#x27;</span>, class_=<span class="hljs-string">&#x27;lrcList&#x27;</span>)<br>        lrcList = BeautifulSoup(<span class="hljs-built_in">str</span>(lrcList), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>        r = lrcList.find_all(<span class="hljs-string">&#x27;li&#x27;</span>, class_=<span class="hljs-string">&#x27;clearfix&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> r:     <span class="hljs-comment"># 对于每首歌</span><br>            lrc = BeautifulSoup(<span class="hljs-built_in">str</span>(i), <span class="hljs-string">&#x27;lxml&#x27;</span>)<br>            Singer = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGeshou&#x27;</span>).get_text()  <span class="hljs-comment"># 获取歌手名</span><br>            Song = lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get_text().split(<span class="hljs-string">&#x27;[&#x27;</span>)[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 获取歌名</span><br>            urls.append(qianzhui + lrc.find(<span class="hljs-string">&#x27;a&#x27;</span>, class_=<span class="hljs-string">&#x27;tGequ&#x27;</span>).get(<span class="hljs-string">&#x27;href&#x27;</span>))  <span class="hljs-comment"># 获取链接</span><br>            titles.append((Song + <span class="hljs-string">&#x27; &#x27;</span> + Singer).replace(<span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>))  <span class="hljs-comment"># 标题记为歌名+歌手名</span><br>    <span class="hljs-keyword">return</span> titles, urls<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">download</span>(<span class="hljs-params">titles, urls</span>):<br>    lyrics_set = &#123;&#125;  <span class="hljs-comment"># 用于保存标题与歌词的对应关系</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(urls)):  <span class="hljs-comment"># 对于每页歌词链接</span><br>        req = requests.get(urls[i])     <span class="hljs-comment"># 发起get请求</span><br>        html = req.text     <span class="hljs-comment"># 获取信息</span><br>        soup = BeautifulSoup(html, <span class="hljs-string">&#x27;lxml&#x27;</span>)  <span class="hljs-comment"># 提取内容</span><br>        <span class="hljs-keyword">if</span> soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:   <span class="hljs-comment"># 排除没有歌词或链接失效等情况</span><br>            lrc = soup.find(<span class="hljs-string">&#x27;div&#x27;</span>, class_=<span class="hljs-string">&#x27;fl&#x27;</span>).text    <span class="hljs-comment"># 获取歌词</span><br>            lrc = lrc.split(<span class="hljs-string">&#x27;编辑于&#x27;</span>)[<span class="hljs-number">0</span>]   <span class="hljs-comment"># 去掉每首歌都包含的编辑信息</span><br>            lyrics_set[titles[i]] = lrc   <span class="hljs-comment"># 保存标题与歌词的对应冠词</span><br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>((<span class="hljs-string">&#x27;lyrics&#x27;</span> + titles[i] + <span class="hljs-string">&#x27;.txt&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:  <span class="hljs-comment"># 将歌词以txt的格式下载</span><br>                f.writelines(lrc)  <span class="hljs-comment"># 写入歌词</span><br>    <span class="hljs-keyword">return</span> lyrics_set<br>titles, urls = lyrics_urls()<br>lyrics_set = download(titles, urls)<br><br></code></pre></td></tr></table></figure><h2 id="jieba分词">2.jieba分词</h2><p>使用jieba分词对每首歌进行分词并统计所有词(每个词的长度大于1)记为一个集合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">all_words = []  <span class="hljs-comment"># 用于统计所有词</span><br>    split_lyric = &#123;&#125;  <span class="hljs-comment"># 用于统计每首歌包含的词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        lyric = lyrics_set[j]  <span class="hljs-comment"># 获取歌词</span><br>        word = jieba.lcut(lyric)  <span class="hljs-comment"># 分词并返回list</span><br>        word = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> word <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(i) &gt; <span class="hljs-number">1</span>]  <span class="hljs-comment"># 去掉单字</span><br><br>        split_lyric[j] = word<br>        all_words.extend(word)<br><br>    set_all_words = <span class="hljs-built_in">set</span>(all_words)<br>    <br></code></pre></td></tr></table></figure><h2 id="倒排索引">3.倒排索引</h2><p>每个歌词文本都可以用一系列关键词来表示，如果按关键词建立到文本的倒排索引便可以实现根据关键词快速地检索到相关文本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">invert_index = &#123;&#125;  <span class="hljs-comment"># 倒排索引</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> set_all_words:  <span class="hljs-comment"># 对于每个词</span><br>        temp = []  <span class="hljs-comment"># 用于保存包含词的歌名</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> lyrics_set.keys():  <span class="hljs-comment"># 对于每首歌</span><br>            <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> split_lyric[j]:  <span class="hljs-comment"># 若词在歌中</span><br>                temp.append(j)  <span class="hljs-comment"># 保存歌名</span><br>        invert_index[i] = tempvert_index[i] = temp<br>        <br></code></pre></td></tr></table></figure><h2 id="建立vsm模型">4.建立VSM模型</h2><p>向量空间模型(Vector Space Model, VSM)可以把提取文本内容中的关键词作为向量空间中的向量，并将向量间的相似度作为衡量文本相似度的标准。</p><p>关键词的提取使用TF-IDF算法<strong>（term frequency–inverse document frequency，词频-逆文档频率）</strong>。TF是词频，表示词在文本中出现的频率；IDF是逆文档频率，表示词的常见程度。将两者相乘得到TF-IDF值，其大小表示了词对文本的重要程度，因此可以选取TF-IDF值大的作为文本的关键词。</p><p>我们取TF-IDF值最大的10个作为关键词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">VSM</span>(<span class="hljs-params">invert_index, split_lyric</span>):<br><br>    IDF = &#123;&#125;  <span class="hljs-comment"># 统计每次词的逆文档频率</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> invert_index.keys():  <span class="hljs-comment"># 对于每个词</span><br>        IDF[j] = math.log(<span class="hljs-built_in">len</span>(split_lyric) / (<span class="hljs-built_in">len</span>(invert_index[j]) + <span class="hljs-number">1</span>))<br><br>    TF = &#123;&#125;  <span class="hljs-comment"># 统计词频</span><br>    TF_IDF = &#123;&#125;   <span class="hljs-comment"># 统计TF-IDF值</span><br>    key_word = &#123;&#125;   <span class="hljs-comment"># 统计每首歌的关键词</span><br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> split_lyric.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        count = <span class="hljs-built_in">dict</span>(Counter(split_lyric[j]))   <span class="hljs-comment"># 统计每个词在歌词中的出现次数</span><br>        temp_TF = &#123;&#125;<br>        temp_TI = &#123;&#125;<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> count.keys():  <span class="hljs-comment"># 对于每次词</span><br>            temp_TF[i] = count[i] / <span class="hljs-built_in">max</span>(count.values())  <span class="hljs-comment"># 计算TF</span><br>            temp_TI[i] = temp_TF[i] * IDF[i]    <span class="hljs-comment"># 计算TF-IDF</span><br>        TF[j] = temp_TF<br>        TF_IDF[j] = temp_TI<br>        all_sorted = <span class="hljs-built_in">sorted</span>(TF_IDF[j].items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将每个词的TF-IDF值从大到小排序</span><br>        key_word[j] = [x[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> all_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> all_sorted[:<span class="hljs-number">10</span>]]    <span class="hljs-comment"># 取其中前10个作为关键词</span><br>    <span class="hljs-keyword">return</span> TF, key_word<br><br></code></pre></td></tr></table></figure><h2 id="计算余弦相似度">5.计算余弦相似度</h2><p>首先我们要获取关键词出现在歌曲里的词频：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_tf</span>(<span class="hljs-params">keyword, song</span>):<br>    kw_tf = np.zeros(<span class="hljs-built_in">len</span>(keyword))  <span class="hljs-comment"># 若歌词中不包含关键词则词频为0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> keyword:   <span class="hljs-comment"># 对于每个关键词</span><br>        <span class="hljs-keyword">if</span> song <span class="hljs-keyword">in</span> invert_index[i]:  <span class="hljs-comment"># 若歌词中包含关键词</span><br><br>            kw_tf[keyword.index(i)] = TF[song][i]   <span class="hljs-comment"># 获取关键词的词频</span><br><br>    <span class="hljs-keyword">return</span> kw_tf<br><br></code></pre></td></tr></table></figure><p>然后就可以计算余弦相似度： <span class="math display">\[cos(q,d_j)=\frac{\sum_{i=1}^{m}w_{ij}*w_{iq}}{\sqrt{\sum_{i=1}^{m}w_{ij}^2}*\sqrt{\sum_{i=1}^{m}w_{iq}^2}}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params">song1, song2</span>):<br>    keyword = <span class="hljs-built_in">set</span>(key_word[song1] + key_word[song2]) <span class="hljs-comment"># 获取两首歌的关键词集合</span><br>    keyword = <span class="hljs-built_in">list</span>(keyword)<br><br>    tf1 = get_tf(keyword, song1)<br>    tf2 = get_tf(keyword, song2)<br><br><br>    result = dot(tf1, tf2) / (norm(tf1) * norm(tf2))    <span class="hljs-comment"># 计算其余弦相似度</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h2 id="检索和输入歌曲相似度最高的十首歌曲">6. 检索和输入歌曲相似度最高的十首歌曲</h2><p>首先用get_tf函数得到输入歌曲和每首歌曲的关键词的词频，然后计算输入歌曲和每首歌曲的余弦相似度。</p><p>最后比较余弦相似度，余弦相似度越高，则该歌曲与输入歌曲的歌词越相似，输出前十首余弦相似度最大的歌曲。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">search</span>(<span class="hljs-params">song</span>):<br>    score = &#123;&#125;<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> TF.keys():  <span class="hljs-comment"># 对于每首歌</span><br>        score[j] = compare(song, j)  <span class="hljs-comment"># 获取与指定歌曲比对所得的余弦相似度作为得分</span><br>    score_sorted = <span class="hljs-built_in">sorted</span>(score.items(), key=<span class="hljs-keyword">lambda</span> item: item[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 将得分从大到小排序</span><br>    result = [x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> score_sorted <span class="hljs-keyword">if</span> x <span class="hljs-keyword">in</span> score_sorted[<span class="hljs-number">1</span>:<span class="hljs-number">11</span>]]<br><span class="hljs-comment"># 取其中得分最高的10个</span><br>    <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h1 id="三图像检索部分算法说明">三、图像检索部分算法说明</h1><h2 id="图片爬取">1.图片爬取</h2><p>我这里选择爬取百度图片，可以进行分类爬取，我这里爬取了30张猫的图片，30张花朵的图片，30张人脸图片，30张车的图片，30张轮船的图片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getPages</span>():<span class="hljs-comment">#只能得到30张图片，想得到更多图片，需要变化params[&#x27;pn&#x27;]的值。</span><br>    headers=&#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.5060.134 Safari/537.36 Edg/103.0.1264.77&quot;</span>&#125;<br>    url=<span class="hljs-string">&#x27;https://image.baidu.com/search/acjson&#x27;</span><br>    <span class="hljs-comment">#追加请求内容（负载）</span><br>    params=&#123;<br>        <span class="hljs-string">&#x27;tn&#x27;</span>:<span class="hljs-string">&#x27;resultjson_com&#x27;</span>,<br>        <span class="hljs-string">&#x27;logid&#x27;</span>:<span class="hljs-string">&#x27;5336511566462226640&#x27;</span>,<br>        <span class="hljs-string">&#x27;ipn&#x27;</span>:<span class="hljs-string">&#x27;rj&#x27;</span>,<br>        <span class="hljs-string">&#x27;ct&#x27;</span>:<span class="hljs-string">&#x27;201326592&#x27;</span>,<br>        <span class="hljs-string">&#x27;is&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;fp&#x27;</span>:<span class="hljs-string">&#x27;result&#x27;</span>,<br>        <span class="hljs-string">&#x27;fr&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;word&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cg&#x27;</span>:<span class="hljs-string">&#x27;girl&#x27;</span>,<br>        <span class="hljs-string">&#x27;queryWord&#x27;</span>:<span class="hljs-string">&#x27;suv&#x27;</span>,<br>        <span class="hljs-string">&#x27;cl&#x27;</span>:<span class="hljs-string">&#x27;2&#x27;</span>,<br>        <span class="hljs-string">&#x27;lm&#x27;</span>:<span class="hljs-string">&#x27;-1&#x27;</span>,<br>        <span class="hljs-string">&#x27;ie&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;oe&#x27;</span>:<span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>        <span class="hljs-string">&#x27;adpicid&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;st&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;z&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;ic&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;hd&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;latest&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;copyright&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;s&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;se&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;tab&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;width&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;height&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;face&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;istype&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;qc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nc&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-string">&#x27;expermode&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;nojc&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;isAsync&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span>,<br>        <span class="hljs-string">&#x27;pn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;rn&#x27;</span>:<span class="hljs-string">&#x27;30&#x27;</span>,<br>        <span class="hljs-string">&#x27;gsm&#x27;</span>:<span class="hljs-string">&#x27;1e&#x27;</span>,<br>        <span class="hljs-string">&#x27;1660570401395&#x27;</span>:<span class="hljs-string">&#x27; &#x27;</span><br>        &#125;<br>    res=requests.get(url=url,headers=headers,params=params)<br>    <span class="hljs-comment"># print(res.json())</span><br>    data=res.json()[<span class="hljs-string">&#x27;data&#x27;</span>]<br>    <span class="hljs-comment"># print(data)</span><br>    <span class="hljs-comment">#得到所有图片地址</span><br>    urlPages=[]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data:<br>        <span class="hljs-keyword">if</span> i.get(<span class="hljs-string">&#x27;thumbURL&#x27;</span>) !=<span class="hljs-literal">None</span>:<br>            urlPages.append(i[<span class="hljs-string">&#x27;thumbURL&#x27;</span>])<br>    <span class="hljs-comment"># print(urlPages)</span><br>    <span class="hljs-comment">#检测文件夹是否存在</span><br>    <span class="hljs-built_in">dir</span>=<span class="hljs-string">&#x27;D:\pycharm\picture&#x27;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-built_in">dir</span>):<br>        os.mkdir(<span class="hljs-built_in">dir</span>)<span class="hljs-comment">#创建目录方法</span><br>    <span class="hljs-comment">#向每个图片url发起请求</span><br>    x=<span class="hljs-number">70</span><br>    name1=<span class="hljs-string">&#x27;paris_invalides_00000&#x27;</span><br>    name2=<span class="hljs-string">&#x27;paris_invalides_0000&#x27;</span><br> <br>    <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> urlPages:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;下载成功&#x27;</span>)<br>        res=requests.get(url=o,headers=headers)<br>        <span class="hljs-comment">#下载到dir文件夹</span><br>        <span class="hljs-keyword">if</span> x&lt;<span class="hljs-number">10</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name1&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>,<span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br>        <span class="hljs-keyword">if</span> <span class="hljs-number">9</span>&lt;x&lt;<span class="hljs-number">100</span>:<br>            <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;<span class="hljs-built_in">dir</span>&#125;</span>/<span class="hljs-subst">&#123;name2&#125;</span><span class="hljs-subst">&#123;x&#125;</span>.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>).write(res.content)<br> <br>        x+=<span class="hljs-number">1</span><br>getPages()<br></code></pre></td></tr></table></figure><h2 id="计算机视觉中的bag-of-words基础流程">2.计算机视觉中的Bag-of-words基础流程</h2><h3 id="特征提取-sift">2.1 特征提取 （SIFT）</h3><p>过分割、密集或随机采集、关键点或稳定区域、显著区域等方式使图像形成不同的图像块，并获得各图像块处的特征。</p><h3 id="学习-视觉词典visual-vocabulary-k-means">2.2 学习 “视觉词典（visual vocabulary）” （k-means）</h3><p>在上面提取完SIFT特征的步骤后,利用K-means聚类算法将提取的SIFT特征聚类生成视觉词典。</p><p>K-means算法是度量样本间相似性的一种方法，该算法设置参数为K，把N个对象分成K个簇，簇内之间的相似度较高，而簇间的相似度较低。聚类中心有K个，视觉词典为K。</p><h3 id="针对输入特征集根据视觉词典进行量化">2.3 针对输入特征集，根据视觉词典进行量化</h3><h3 id="把输入图像转化成视觉单词visual-words的频率直方图">2.4 把输入图像转化成视觉单词（visual words）的频率直方图</h3><p>这一步骤通过对图像特征提取，然后将提取出来的特征点，根据第三步，转换为频率直方图。</p><p>这里在转换为频率直方图时候，有使用到TF-IDF，即词频(Term Frequency，TF)与逆文档频率(Inverse Document Frequency，IDF)乘积作为权值。引入这个权值的目的是为了降低一些重复特征所带来的影响。比如在BOW中，一些常用词汇譬如the，it，do等等词汇，不能体现文本内容特征，但是出现频率却很高，利用tf-idf可以降低这种不必要词汇的影响。同理，在BOF图像搜索中，图像之间也会有这样的无意义的特征出现，所以需要降低这类特征的权值。</p><h3 id="构造特征到图像的倒排表通过倒排表快速索引相关图像">2.5 构造特征到图像的倒排表，通过倒排表快速索引相关图像</h3><p>倒排表是一种逆向的查找方式，在BOW中大体的思路是通过已经提取出来的词汇，反向查找出现过这个词汇的文章。</p><h3 id="根据索引结果进行直方图匹配">2.6 根据索引结果进行直方图匹配</h3><p>当我们做完上面的步骤，就需要对直方图进行匹配。直方图的匹配给出输入图像的频率直方图，在数据库中查找K个最近邻的图像，根据这K个近邻来投票图像的分类结果。</p><h2 id="特征提取">3.特征提取</h2><p>SIFT算法的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。</p><p>特征提取及描述主要是将一些<strong>具有代表性</strong>且<strong>区分性较强</strong>的<strong>全局或局部特征</strong>从图像中进行抽取，这些特征一般是类别之间差距比较<strong>明显的特征</strong>，可以将其与其他类别区分开，其次，这些特征还要求具有<strong>较好的稳定性</strong>，并对这些特征进行描述。</p><p>通常会使用SIFT算法从图片上提取出很多特征点，每个特征点都是128维的向量，因此，如果图片足够多的话,我们会提取出一个巨大的特征向量库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_image</span>(<span class="hljs-params">imagename, resultname, params=<span class="hljs-string">&quot;--edge-thresh 10 --peak-thresh 5&quot;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Process an image and save the results in a file. &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">if</span> imagename[-<span class="hljs-number">3</span>:] != <span class="hljs-string">&#x27;pgm&#x27;</span>:<br>        <span class="hljs-comment"># create a pgm file</span><br>        im = Image.<span class="hljs-built_in">open</span>(imagename).convert(<span class="hljs-string">&#x27;L&#x27;</span>)  <span class="hljs-comment"># .convert(&#x27;L&#x27;) 将RGB图像转为灰度模式，灰度值范围[0,255]</span><br>        im.save(<span class="hljs-string">&#x27;tmp.pgm&#x27;</span>)  <span class="hljs-comment"># 将灰度值图像信息保存在.pgm文件中</span><br>        imagename = <span class="hljs-string">&#x27;tmp.pgm&#x27;</span><br><br>    cmmd = <span class="hljs-built_in">str</span>(<br>        <span class="hljs-string">&quot;D:\pycharm\picture\sift.exe &quot;</span> + imagename + <span class="hljs-string">&quot; --output=&quot;</span> + resultname +<br>        <span class="hljs-string">&quot; &quot;</span> + params)<br>    os.system(cmmd)  <span class="hljs-comment"># 执行sift可执行程序，生成resultname(test.sift)文件</span><br>    <span class="hljs-built_in">print</span><br>    <span class="hljs-string">&#x27;processed&#x27;</span>, imagename, <span class="hljs-string">&#x27;to&#x27;</span>, resultname<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_features_from_file</span>(<span class="hljs-params">filename</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Read feature properties and return in matrix form. &quot;&quot;&quot;</span><br><br>    f = loadtxt(filename)<br>    <span class="hljs-keyword">return</span> f[:, :<span class="hljs-number">4</span>], f[:, <span class="hljs-number">4</span>:]  <span class="hljs-comment"># feature locations, descriptors</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_features</span>(<span class="hljs-params">im, locs, circle=<span class="hljs-literal">True</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot; Show image with features. input: im (image as array),</span><br><span class="hljs-string">        locs (row, col, scale, orientation of each feature). &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">draw_circle</span>(<span class="hljs-params">c, r</span>):<br>        t = arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.01</span>, <span class="hljs-number">.01</span>) * <span class="hljs-number">2</span> * pi<br>        x = r * cos(t) + c[<span class="hljs-number">0</span>]<br>        y = r * sin(t) + c[<span class="hljs-number">1</span>]<br>        plot(x, y, <span class="hljs-string">&#x27;b&#x27;</span>, linewidth=<span class="hljs-number">2</span>)<br><br>    imshow(im)<br>    <span class="hljs-keyword">if</span> circle:<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> locs:<br>            draw_circle(p[:<span class="hljs-number">2</span>], p[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">else</span>:<br>        plot(locs[:, <span class="hljs-number">0</span>], locs[:, <span class="hljs-number">1</span>], <span class="hljs-string">&#x27;ob&#x27;</span>)<br>    axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_00000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>,<span class="hljs-number">100</span>):<br> <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    imname = <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.jpg&#x27;</span> <span class="hljs-comment"># 待处理图像路径</span><br><br>    process_image(imname, <span class="hljs-string">&#x27;D:/pycharm/picture/paris_invalides_0000&#x27;</span>+<span class="hljs-built_in">str</span>(i)+<span class="hljs-string">&#x27;.sift&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="生成词汇">4.生成词汇</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> vocabulary<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> pylab <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br> <br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br> <br><span class="hljs-comment"># 提取文件夹下图像的sift特征</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images):<br>    im = array(Image.<span class="hljs-built_in">open</span>(imlist[i]).convert(<span class="hljs-string">&#x27;L&#x27;</span>))<br>    sift.process_image(imlist[i], featlist[i])<br> <br><span class="hljs-comment"># 生成词汇</span><br>voc = vocabulary.Vocabulary(<span class="hljs-string">&#x27; d:/pycharm/picture/paris_louvretest&#x27;</span>)<br>voc.train(featlist, <span class="hljs-number">500</span>, <span class="hljs-number">10</span>)<br><span class="hljs-comment"># 保存词汇</span><br><span class="hljs-comment"># saving vocabulary</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    pickle.dump(voc, f)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;vocabulary is:&#x27;</span>, voc.name, voc.nbr_words)<br><br></code></pre></td></tr></table></figure><h2 id="图像索引创建数据库">5.图像索引（创建数据库）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">from</span> PCV.imagesearch <span class="hljs-keyword">import</span> imagesearch<br><span class="hljs-keyword">from</span> PCV.localdescriptors <span class="hljs-keyword">import</span> sift<br><span class="hljs-keyword">from</span> sqlite3 <span class="hljs-keyword">import</span> dbapi2 <span class="hljs-keyword">as</span> sqlite<br><span class="hljs-keyword">from</span> PCV.tools.imtools <span class="hljs-keyword">import</span> get_imlist<br><br><span class="hljs-comment"># 获取图像列表</span><br>imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>nbr_images = <span class="hljs-built_in">len</span>(imlist)<br><span class="hljs-comment"># 获取特征列表</span><br>featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br><span class="hljs-comment"># load vocabulary</span><br><span class="hljs-comment"># 载入词汇</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    voc = pickle.load(f)<br><span class="hljs-comment"># 创建索引</span><br>indx = imagesearch.Indexer(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>indx.create_tables()<br><span class="hljs-comment"># go through all images, project features on vocabulary and insert</span><br><span class="hljs-comment"># 遍历所有的图像，并将它们的特征投影到词汇上</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)[:<span class="hljs-number">1000</span>]:<br>    locs, descr = sift.read_features_from_file(featlist[i])<br>    indx.add_to_index(imlist[i], descr)<br><span class="hljs-comment"># commit to database</span><br><span class="hljs-comment"># 提交到数据库</span><br>indx.db_commit()<br><br>con = sqlite.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select count (filename) from imlist&#x27;</span>).fetchone())<br><span class="hljs-built_in">print</span> (con.execute(<span class="hljs-string">&#x27;select * from imlist&#x27;</span>).fetchone())<br><br></code></pre></td></tr></table></figure><h2 id="图像检索">6.图像检索</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">i</span>):<br>  <span class="hljs-comment"># 获取图像列表</span><br>  imlist = get_imlist(<span class="hljs-string">&#x27;d:/pycharm/picture/&#x27;</span>)<br>  nbr_images = <span class="hljs-built_in">len</span>(imlist)<br>  <span class="hljs-comment"># 获取特征列表</span><br>  featlist = [imlist[i][:-<span class="hljs-number">3</span>] + <span class="hljs-string">&#x27;sift&#x27;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nbr_images)]<br><br>  <span class="hljs-comment"># 载入词汇</span><br>  f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;d:/pycharm/picture/vocabulary.pkl&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>)<br>  voc = pickle.load(f)<br>  f.close()<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  locs, descr = sift.read_features_from_file(featlist[<span class="hljs-number">0</span>])<br>  iw = voc.project(descr)<br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;ask using a histogram...&#x27;</span>)<br>  <span class="hljs-built_in">print</span>(src.candidates_from_histogram(iw)[:<span class="hljs-number">10</span>])<br><br>  src = imagesearch.Searcher(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>, voc)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;try a query...&#x27;</span>)<br><br>  nbr_results = <span class="hljs-number">11</span><br>  res = [w[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> src.query(imlist[i-<span class="hljs-number">1</span>])[:nbr_results]]<br><br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算搜索结果得分:&quot;</span>)<br>  score=imagesearch.compute_ukbench_score(src, imlist[:<span class="hljs-number">10</span>])<br>  <span class="hljs-keyword">return</span> src, res, score<br><br></code></pre></td></tr></table></figure><h2 id="对数据库的操作">7.对数据库的操作</h2><p>我在最终运行的时候发现在图像检索时，有时会出现是个运行结果中有一两个显示不出来的问题，一开始我还以为是电脑卡顿的问题。然后我试着打印了res：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603231847152.png"></p><p>发现当运行结果中有一两个显示不出来时，res中有几个序号就大于我的图片总数，我知道了是我的数据库出现了问题，于是我用以下代码查看我的数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br>cursor = conn.cursor()<br>cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>result = cursor.fetchall()<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(row)<br>    <br>conn.close()<br><br></code></pre></td></tr></table></figure><p>发现了下面的问题，我知道了是我之前在刚刚做图像检索时尝试代码，用了其他的命名方式给图片命名，这就导致了我后来的图片没有覆盖掉数据库中这些数据，其还占据着我的数据库，但图片和sift已经被我在文件夹中删掉了，如下图所示：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232019342.png"></p><p>而我之所以运行结果中有一两个显示不出来的问题，是因为它正好匹配到了那几个占据着我的数据库但不存在于我的图片库的序号。于是想着通过删除数据库的数据，来把数据库清空，再进行一次图像索引创建数据库，就可以删掉那几个多出的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sqlite3<br><br><span class="hljs-comment"># 1.创建数据库连接</span><br>conn = sqlite3.connect(<span class="hljs-string">&#x27;d:/pycharm/picture/testImaAdd.db&#x27;</span>)<br><span class="hljs-comment"># 2.创建游标</span><br>cursor = conn.cursor()<br><br><span class="hljs-comment"># 删除数据库表记录</span><br><br>results = cursor.execute(<span class="hljs-string">&quot;DELETE  FROM imlist &quot;</span>)<br>conn.commit()  <span class="hljs-comment"># 更新数据库</span><br>results = cursor.execute(<span class="hljs-string">&quot;SELECT * FROM imlist&quot;</span>)<br>cursor.close()  <span class="hljs-comment"># 关闭cursor对象</span><br>conn.close()  <span class="hljs-comment"># 关闭数据库连接</span><br><br></code></pre></td></tr></table></figure><p>结果成功将那几个多余数据删除:</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232117000.png"></p><p>但当我很兴奋地去执行最后一步图像检索时，却出现了下面的报错：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232137227.png"></p><p>我尝试了各种办法，到处搜索，甚至还重新创建一个工程，用了一下午的时间，最终我突然想到，之所以会检索到有空的类型，是我之前删掉的那几个多余数据就变成了空的类型，我是150张图片，而数据库现在容量是153，3个位置是空的，于是我便又找了三张图片加入了进去，提取特征，生成词汇，再加入数据库，随后检索，果然成功，解决了这个问题。</p><p>最后，我一开始遇到的运行结果中有一两个显示不出来的问题也得到了解决。</p><blockquote><p>还有一个问题，导致如果匹配到前九张图片，就会显示不出来，原因是我的if语句用错了，应该是if,elif,else，而不是if,if,else。</p></blockquote><h1 id="三操作界面设计">三、操作界面设计</h1><p>利用了pyqt，点击工具中的QTdesigner，利用到了Push Button、Lable、Text Browser。</p><p>然后保存得到一个.ui文件，然后利用工具中的PyUIC，将.ui文件转换为.py文件。</p><p>将输入的歌曲和图像显示在界面上，然后输出前十个候选结果，且将余弦相似度和得分显示在界面上。</p><p>图像显示和文本显示用的方法是不同的，文本显示直接用setText即可将结果写入：</p><p><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232530108.png"></p><p>图像显示首先使用QtGui模块中的QPixmap类创建一个名为jpg的Pixmap对象，该对象表示Name路径指定的图像文件；然后使用.scaled()方法将图像缩放到与label标签具有相同的宽度和高度。这是为了确保图像适应标签的大小；最后用setPixmap()方法将缩放后的图像设置为label标签的当前图像。这将在界面上显示图像。</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232558759.png" alt="image-20230603232558759"><figcaption aria-hidden="true">image-20230603232558759</figcaption></figure><p>代码中在显示图片的输出结果时我没有用循环，只是笨拙的罗列，所以我就不都放完整代码了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow, QFileDialog, QApplication<br><span class="hljs-keyword">from</span> gui <span class="hljs-keyword">import</span> Ui_MainWindow<br><span class="hljs-keyword">from</span> PyQt5 <span class="hljs-keyword">import</span> QtGui<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyWindow</span>(QMainWindow, Ui_MainWindow):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-built_in">super</span>(MyWindow, self).__init__(parent)<br>        self.setupUi(self)<br>        self.pushButton.clicked.connect(self.<span class="hljs-built_in">open</span>)  <span class="hljs-comment"># 将点击按钮与函数open连接</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):<br>        Name, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择歌词&quot;</span>, <span class="hljs-string">&quot;./lyrics/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.txt)&quot;</span>)  <span class="hljs-comment"># 获取选择的歌曲名字</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(Name, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:    <span class="hljs-comment"># 打开所选歌曲的歌词</span><br>            data = f.read()     <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser.setText(data)      <span class="hljs-comment"># 将歌词显示在textBrowser上</span><br>        Name = <span class="hljs-built_in">str</span>(Name).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉歌名的位置信息</span><br>        Name = Name[<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉歌名的后缀(.txt)</span><br><br>        self.label.setText(Name)    <span class="hljs-comment"># 将歌名显示在label上</span><br>        self.label_4.setText(get_keyword(Name)) <span class="hljs-comment">#将歌的关键词显示在label_4上</span><br>        result = search(Name)   <span class="hljs-comment"># 检索与所选歌歌词最相似的十首歌</span><br>        best = result[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]     <span class="hljs-comment"># 最相似的一首歌</span><br>        result = <span class="hljs-string">&#x27;\n&#x27;</span>.join([<span class="hljs-built_in">str</span>(x[<span class="hljs-number">1</span>]) + <span class="hljs-number">8</span> * <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">str</span>(x[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> result])  <span class="hljs-comment"># 调整检索结果</span><br>        self.label_2.setText(result)  <span class="hljs-comment"># 将检索结果显示在label_2上</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;lyrics&#x27;</span> + best + <span class="hljs-string">&#x27;.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:   <span class="hljs-comment"># 打开相似效果最好的歌词</span><br>            data = f.read()  <span class="hljs-comment"># 获取歌词</span><br>            self.textBrowser_2.setText(data)  <span class="hljs-comment"># 将歌词显示在textBrowser_2上</span><br>        self.label_5.setText(get_keyword(best)) <span class="hljs-comment">#将歌的关键词显示在label_5上</span><br><br>        Name0, TYPE = QFileDialog.getOpenFileName(self, <span class="hljs-string">&quot;选择图片&quot;</span>, <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides/&quot;</span>, <span class="hljs-string">&quot;Text Files (*.jpg)&quot;</span>)  <span class="hljs-comment"># 获取选择的图片名字</span><br>        jpg = QtGui.QPixmap(Name0).scaled(self.label_8.width(), self.label_8.height())<br>        self.label_8.setPixmap(jpg)     <span class="hljs-comment"># 将输入图片显示在label_8上</span><br><br>        Name0 = <span class="hljs-built_in">str</span>(Name0).split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]     <span class="hljs-comment"># 去掉图片的位置信息</span><br>        Name0 = Name0[-<span class="hljs-number">6</span>:-<span class="hljs-number">4</span>]    <span class="hljs-comment"># 去掉图片的后缀(.txt)</span><br>        i=<span class="hljs-built_in">int</span>(Name0)<br>        src, res, score=get(i)<br>        self.label_10.setText(<span class="hljs-built_in">str</span>(score))  <span class="hljs-comment"># 将搜索得分显示在label_10上</span><br>        <span class="hljs-comment">#将搜索到的10张图片显示</span><br>        <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]&lt;<span class="hljs-number">10</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_00000&quot;</span>+<span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>])+<span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>        <span class="hljs-keyword">else</span>:<br>                Name1 = <span class="hljs-string">&quot;D:/pycharm/picture/paris_invalides_0000&quot;</span> + <span class="hljs-built_in">str</span>(res[<span class="hljs-number">1</span>]) + <span class="hljs-string">&quot;.jpg&quot;</span><br>                jpg1 = QtGui.QPixmap(Name1).scaled(self.label_12.width(), self.label_12.height())<br>                self.label_12.setPixmap(jpg1)<br>……<br><br></code></pre></td></tr></table></figure><h1 id="四程序运行结果图">四、程序运行结果图</h1><h2 id="歌词爬取结果">1.歌词爬取结果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603232945163.png" alt="所有歌词"><figcaption aria-hidden="true">所有歌词</figcaption></figure><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233009341.png" alt="单个歌词"><figcaption aria-hidden="true">单个歌词</figcaption></figure><h2 id="图片爬取结果">2.图片爬取结果</h2><p>猫：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233058696.png" alt="“猫”的爬取结果"><figcaption aria-hidden="true">“猫”的爬取结果</figcaption></figure><p>车：</p><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233130164.png" alt="“车”的爬取结果"><figcaption aria-hidden="true">“车”的爬取结果</figcaption></figure><p>......</p><h2 id="最终效果">3.最终效果</h2><figure><img src="/2023/06/02/%E5%9F%BA%E4%BA%8E%E6%96%87%E6%9C%AC%E5%92%8C%E5%9B%BE%E5%83%8F%E7%9A%84%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A3%80%E7%B4%A2%E7%B3%BB%E7%BB%9F/image-20230603233219873.png" alt="最终运行结果"><figcaption aria-hidden="true">最终运行结果</figcaption></figure><h2 id="总结与不足">4.总结与不足</h2><p>可以看出文本检索实现的很好，图像检索有八个正确结果，还算不错。</p><p>不足的地方一是在图像检索中，由于图像集数目不足，以及图片背景过于丰富，会导致特征采集不准确，有几个出现错误；</p><p>BOW的一个主要缺点是在用视觉单词表示图像时不包含图像特征的位置信息，而图像特征的位置信息在人脸识别图像时起到了很好的作用；</p><p>我觉得可以改进的地方，输入一张非图像库内的图像，然后再与图像库图像进行检索和匹配。且可以让文本检索和图像检索联系起来，输入文本可以既能得到相似文本，又能得到对应语义的图片，实现更强的功能。</p>]]></content>
    
    
    <categories>
      
      <category>进阶项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>专业课程</tag>
      
      <tag>多媒体</tag>
      
      <tag>项目</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SYSTEMVIEW通信原理实验</title>
    <link href="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一简单介绍">一、简单介绍</h1><h3 id="内容介绍">内容介绍</h3><ul><li>AM的调制与解调</li><li>SSB的调制与解调</li><li>FM的调制与解调</li><li>数字信号的基带传输</li><li>MASK的调制与解调</li><li>2FSK的调制与解调</li><li>2PSK的调制与解调</li><li>16QAM调制与解调</li><li>抽样定理</li></ul><h3 id="报告截图">报告截图</h3><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122412650.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122519556.png"></p><p><img src="/2023/04/19/%E5%9F%BA%E4%BA%8ESYSTEMVIEW%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C/image-20230622122608610.png"></p><h1 id="二报告和软件自行提取">二、报告和软件自行提取</h1><p>链接：https://pan.baidu.com/s/1o5ZZVY0MbFcnZWClfQXSPQ</p><p>提取码：k783</p>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程</tag>
      
      <tag>实践课</tag>
      
      <tag>systemview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>考研规划</title>
    <link href="/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/"/>
    <url>/2023/01/07/%E8%80%83%E7%A0%94%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>考研</category>
      
    </categories>
    
    
    <tags>
      
      <tag>考研</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理(Ⅰ)</title>
    <link href="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/"/>
    <url>/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要参考</p></blockquote><ul><li>视频教程<a href="https://www.bilibili.com/video/BV11x411G79C/?spm_id_from=333.880.my_history.page.click&amp;vd_source=ef3842945b0f7729a278874a86c98aa5">北邮 通信原理公开课 杨鸿文</a></li></ul><h1 id="一绪论">一、绪论</h1><h2 id="通信系统和通信网的构成">1.通信系统和通信网的构成</h2><h3 id="通信系统">1.1 通信系统</h3><p>通信系统：指点对点通信所需的全部设施</p><p>通信系统的香农模型:</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233002637.png"></p><p>信源：信息的发送者；信宿：信息的接收者。信源和信宿决定了通信系统的<strong>业务性质</strong>。例如电话系统传送语音信息，电报或数据通信系统传送代表某些信息的符号，电视系统传送活动图像的信息等。</p><p>编码：泛指把信源输出变换成适合信道传送的信号所需的设备。有信源编码、信道编码。</p><p>译码: 编码的反变换所需要的设备。</p><p>信道: 传送信息的通道。</p><p>以电信号为物理载体的通信系统（通信系统的另一种模型）：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233644437.png"></p><p>信源：</p><ul><li>模拟信源：各种传感器的输出，其存在形式一般是基带电信号；</li><li>数字信源：电脑、手机中存储的比特。</li></ul><p>信道：</p><ul><li>基带信道：一般可建模为低通型滤波器；</li><li>频带信道：一般可建模为带通型滤波器。</li></ul><p>故有这四种传输：</p><ul><li>模拟基带传输：最简单的传输</li><li>模拟频带传输：第四章</li><li>数字基带传输：第五章</li><li>数字频带传输：第六章</li></ul><h3 id="通信网">1.2 通信网</h3><p>通信网的构成：</p><ul><li><p>通信系统：终端设备（编码、译码）、传输设备（信道）；</p></li><li><p>交换设备：</p><ul><li><p>电路交换：如公共电话网，优点：实时、QoS(Quality of Service)高；缺点：信道利用率低。</p></li><li><p>分组交换：如Internet网，优点：信道利用率高；缺点：实时和QoS不易保证。</p></li></ul></li><li><p>信令和协议</p></li></ul><h3 id="信息消息信号">1.3 信息、消息、信号</h3><p>信息：要表示和传送的对象。</p><p><strong>消息</strong>：信息的表现形式，信息的数学表示形式。</p><p>信号：信号是与消息对应的某种物理量，信息的物理表示形式。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419233053555.png" alt="信息、消息、信号"><figcaption aria-hidden="true">信息、消息、信号</figcaption></figure><p>香农信息论认为：信息的多少等于无知度的大小。人们已知的消息不是信息，而好像，大概，可能之类的不确切的内容包含着信息。 <span class="math display">\[离散消息的熵定义:H(X)=-\sum{p(x)\log_2p(x)}\]</span></p><p><span class="math display">\[连续消息的熵定义:H(X)=-\int_{a}^{b}{p(x)\log_2p(x)}dx\]</span></p><ul><li>连续消息的信息量是无限的.</li><li>连续消息有无穷个状态，因此根据香农熵的定义必然为无穷大。</li></ul><h3 id="通信系统的主要性能指标">1.4 通信系统的主要性能指标</h3><ul><li><p>有效性：是指在给定信道内传输的信息量的多少</p></li><li><p>代价：资源占用情况</p></li><li><p>带宽；传输速率、频带利用率</p></li><li><p>可靠性：是指接收信息的准确度</p><ul><li>质量：失真大小</li><li>输出信噪比、调制增益；误码率、误比特率</li></ul></li><li><p>码元传输速率（R<sub>S</sub> 或R<sub>B</sub>）：码元传输速率简称传码率，也称码元速率或符号速率。它被定义为单位时间（s<sup>-1</sup>）内传输码元的数目，单位为波特，记为Baud或B。</p></li><li><p>信息传输速率（R<sub>b</sub>）：信息传输速率简称传信率，又称信息速率。它被定义为单位时间（s<sup>-1</sup>）内传递的信息量（bit数），单位是比特/秒，也记为bit / s或bps。</p></li></ul><h1 id="二确定信号分析">二、确定信号分析</h1><h2 id="傅里叶变换">1.傅里叶变换</h2><h3 id="傅里叶变换与反变换">1.1 傅里叶变换与反变换</h3><p><span class="math display">\[傅里叶变换:F(f)=\int_{-\infty}^{+\infty}{f(t)e^{-j2\pi ft}}dt\]</span></p><p><span class="math display">\[傅里叶反变换:f(t)=\int_{-\infty}^{+\infty}{F(f)e^{j2\pi ft}}df\]</span></p><h3 id="典型信号的傅里叶变换">1.2 典型信号的傅里叶变换</h3><ul><li><p>矩形脉冲信号： <span class="math display">\[E\tau sinc(t\tau)\Leftrightarrow E[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p><p><span class="math display">\[也可表示为:E\tau sinc(t\tau)\Leftrightarrow Erect(\frac{f}{\tau})\]</span></p><p><span class="math display">\[E[u(t+\frac{\tau}{2})-u(t-\frac{\tau}{2})]\Leftrightarrow E\tau sinc(f\tau)\]</span></p><p><span class="math display">\[sinc(x)=\frac{sin(\pi x)}{\pi x},Sa(x)=\frac{sin(x)}{x}\]</span></p><p><span class="math display">\[E\tau Sa(\pi t\tau)\Leftrightarrow E[u(f+\frac{\tau}{2})-u(f-\frac{\tau}{2})]\]</span></p></li></ul><p><span class="math display">\[拓展:Asinc^2(at)\Leftrightarrow\frac{A}{a}(1-\frac{|f|}{a})\]</span></p><ul><li><p>单边指数信号： <span class="math display">\[Ee^{-at}(t&gt;0,a&gt;0)\Leftrightarrow\frac{E}{a+j2\pi f}\]</span></p></li><li><p>直流信号：</p></li></ul><p><span class="math display">\[E\Leftrightarrow E\delta(f)\]</span></p><ul><li><p>单位冲激信号： <span class="math display">\[\delta(t)\Leftrightarrow 1\]</span></p></li><li><p>符号函数：</p></li></ul><p><span class="math display">\[f(t)=\begin{cases} +1，t&gt;0\\ -1， t&lt;0\end{cases},\quad F(w)=\frac{1}{j\pi f}\]</span></p><ul><li><p>阶跃函数： <span class="math display">\[  u(t)\Leftrightarrow\frac{1}{j2\pi f}+\frac{1}{2}\delta(f)  \]</span></p></li><li><p>正余弦函数： <span class="math display">\[cos(2\pi f_0)\Leftrightarrow\frac{1}{2}[\delta(f+f_0)+\delta(f-f_0)]\]</span></p><p><span class="math display">\[sin(2\pi f_0)\Leftrightarrow\frac{j}{2}[\delta(f+f_0)-\delta(f-f_0)]\]</span></p></li></ul><h3 id="傅里叶变换的性质">1.3 傅里叶变换的性质</h3><ul><li>尺度变换性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(at)\Leftrightarrow\frac{1}{|a|}F(\frac{w}{a})\]</span></p><ul><li>时移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t-t_0)\Leftrightarrow\ F(w)e^{-jwt_0}\]</span></p><blockquote><p>同号</p></blockquote><ul><li>对称性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则F(t)\Leftrightarrow 2\pi f(-w),或F(t)\Leftrightarrow f(-f)\]</span></p><p><span class="math display">\[若f(t)为偶函数,则F(t)\Leftrightarrow2\pi f(w)\]</span></p><ul><li>频移性质：</li></ul><p><span class="math display">\[若f(t)\Leftrightarrow F(w),则f(t)e^{jw_0t}\Leftrightarrow\ F(w-w_0)\]</span></p><blockquote><p>异号</p></blockquote><ul><li>微分性质：</li></ul><p><span class="math display">\[f&#39;(t)\Leftrightarrow jwF(w),\quad f^{(n)}(t)\Leftrightarrow(jw)^{n}F(w)\]</span></p><p><span class="math display">\[tf(t)\Leftrightarrow jF&#39;(w),\quad t^{n}f(t)\Leftrightarrow j^{n}F^{(n)}(w)\]</span></p><ul><li>积分性质：</li></ul><p><span class="math display">\[F(0)=0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\frac{F(w)}{jw}\]</span></p><p><span class="math display">\[F(0)\neq0时,\int_{-\infty}^{t}{f(\tau)}d\tau\Leftrightarrow\pi F(0)\delta(w)+\frac{F(w)}{jw}\]</span></p><h3 id="积化和差公式">1.4 积化和差公式</h3><p><span class="math display">\[cosacosβ=\frac{1}{2}[cos(a+β)+cos(a-β)]\]</span></p><p><span class="math display">\[sinasinβ=-\frac{1}{2}[cos(a+β)-cos(a-β)]\]</span></p><p><span class="math display">\[sinacosβ=\frac{1}{2}[sin(a+β)+sin(a-β)]\]</span></p><p><span class="math display">\[cosasinβ=\frac{1}{2}[sin(a+β)-sin(a-β)]\]</span></p><h2 id="能量谱密度与功率谱密度及相关函数">2.能量谱密度与功率谱密度及相关函数</h2><h3 id="能量信号与功率信号">2.1 能量信号与功率信号</h3><ul><li>能量信号：</li></ul><p><span class="math display">\[E_f=\int_{-\infty}^{\infty}{f^{2}(t)}dt&lt;\infty(能量有限)\]</span></p><ul><li>功率信号：</li></ul><p><span class="math display">\[P_f=\lim_{T\rightarrow+\infty}\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{f^{2}(t)}dt&lt;\infty(能量无限，功率有限)\]</span></p><h3 id="能量信号的相关函数">2.2 能量信号的相关函数</h3><ul><li>能量信号x(t)与y(t)的互相关函数</li></ul><p><span class="math display">\[R_{xy}(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt\]</span></p><p><span class="math display">\[R_{yx}(\tau)=\int_{-\infty}^{\infty}{y(t+\tau)x^{*}(t)}dt\]</span></p><ul><li>能量信号x(t)的自相关函数：</li></ul><p><span class="math display">\[R_x(\tau)=\int_{-\infty}^{\infty}{x(t+\tau)x^{*}(t)}dt\]</span></p><blockquote><p>实信号不需要共轭</p></blockquote><ul><li>相关函数的性质：</li></ul><p><span class="math display">\[共轭对称性:R_{xy}(\tau)=R^{*}_{yx}(-\tau)\]</span></p><p><span class="math display">\[R_{x}(\tau)=R^{*}_{x}(-\tau)\]</span></p><p><span class="math display">\[x(t)的能量是自相关函数在\tau=0处的值\]</span></p><ul><li><p>许瓦兹不等式： <span class="math display">\[许瓦兹不等式:\vert \int_{-\infty}^{\infty}{s_1(t)s_2^{*}(t)}dt\vert\leq\sqrt{E_1E_2}\]</span></p><p><span class="math display">\[互相关函数满足:|R_{xy}(\tau)|=|\int_{-\infty}^{\infty}{x(t+\tau)y^{*}(t)}dt|\leq\sqrt{E_xE_y}\]</span></p><p><span class="math display">\[自相关函数在\tau=0时最大:R_x(\tau)\leq R_x(0)=E_x\]</span></p></li></ul><h3 id="能量谱密度">2.3 能量谱密度</h3><p><span class="math display">\[互能量谱密度:E_{xy}(f)=X(f)Y^*(f)\]</span></p><p><span class="math display">\[能量谱密度:E_{x}(f)=X(f)X^*(f)=|X(f)|^2\]</span></p><p><span class="math display">\[能量（帕塞瓦尔定理）:E_x=\int_{-\infty}^{\infty}{|x(t)|^2}dt=\int_{-\infty}^{\infty}{|X(f)|^2}df\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是能量谱密度:R_x(\tau)\Leftrightarrow|X(f)|^2\]</span></p><h3 id="功率信号的相关函数">2.4 功率信号的相关函数</h3><p><span class="math display">\[R_x(\tau)=\overline{[x(t+\tau)x^{*}(t)]}\]</span></p><p><span class="math display">\[自相关函数在\tau=0的值是功率:R_x(0)=\overline{[x(t)x^{*}(t)]}=P_x\]</span></p><blockquote><p>其他性质可类比能量信号</p></blockquote><h3 id="功率谱密度">2.5 功率谱密度</h3><p><span class="math display">\[功率:P_x=R_x(0)=\overline{|x(t)|^2}=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|x_T(t)|^2}dt\bigg)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\infty}^{\infty}{|X_T(f)|^2}df\bigg)=\int_{-\infty}^{\infty}{\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)}df\]</span></p><p><span class="math display">\[功率谱密度:P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|X_T(f)|^2\bigg)\]</span></p><p><span class="math display">\[自相关函数的傅里叶变换是功率谱密度:R_x(\tau)\Leftrightarrow P_x(f)\]</span></p><h2 id="带宽">3.带宽</h2><h3 id="单边功率谱">3.1 单边功率谱</h3><p>从数学上来说，当我们对一个信号作傅里叶变换时，f的定义域是(-∞，+∞)，频率可正可负。</p><p>但在物理测量当中，负频率是没有意义的，f的定义域是[0，+∞)。实信号的功率谱密度或能量谱密度是对称的，故在工程中常用单边谱密度。 <span class="math display">\[P_x^单(f)=P_x(f)+P_x(-f)=2P_x(f)\qquad f\geq0\]</span></p><p><span class="math display">\[P_x=\int_{0}^{\infty}{P_x^单(f)}df\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/双边谱密度.png" alt="双边谱密度"><figcaption aria-hidden="true">双边谱密度</figcaption></figure><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/单边谱密度.png" alt="单边谱密度"><figcaption aria-hidden="true">单边谱密度</figcaption></figure><h3 id="基带信号与频带信号">3.2 基带信号与频带信号</h3><p>基带信号：信号的功率或能量主要集中在零频附近。</p><p>频带信号（带通信号）：信号的功率或能量集中在某个载频附近。</p><h3 id="带宽-1">3.3 带宽</h3><p>带宽：信号的带宽指单边谱密度的宽度。</p><ul><li><p>绝对带宽：频谱在某个区间之外为零，该区间的宽度就是绝对带宽。</p><blockquote><p>只是一种模型，一个信号若频域有限，则其时域无限，现实中的信号不可能时域无限。</p></blockquote></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/绝对带宽.png" alt="绝对带宽"><figcaption aria-hidden="true">绝对带宽</figcaption></figure><ul><li>主瓣带宽：有些信号频谱呈现出主瓣、旁瓣的特征，其带宽可采用主瓣宽度衡量。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/主瓣带宽.png" alt="主瓣带宽"><figcaption aria-hidden="true">主瓣带宽</figcaption></figure><ul><li>3dB带宽：功率谱密度从峰值下降一半（3dB)的宽度。</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/3dB带宽.png" alt="3dB带宽"><figcaption aria-hidden="true">3dB带宽</figcaption></figure><ul><li><p>等效矩形带宽：功率谱同高同面积的矩形的宽度。</p></li><li><p>按能量占比定义的带宽</p></li></ul><blockquote><p>信号平方的带宽：x(t)的绝对带宽是W，x<sup>2</sup>(t)的绝对带宽是2W。</p><p>正弦调制的带宽：x(t)的绝对带宽是W，是s(t)=x(t)cos2πf<sub>c</sub>t的绝对带宽是2W。</p></blockquote><h2 id="线性时不变系统">4.线性时不变系统</h2><h3 id="线性时不变系统-1">4.1 线性时不变系统</h3><p>复单频信号通过滤波器后还是复单频信号： <span class="math display">\[x(t)=e^{j2\pi vt},\quad y(t)=e^{j2\pi vt}H(v)\]</span> 能量（功率）谱密度： <span class="math display">\[E_y(f)=|H(f)|^2E_x(f),\quad P_y(f)=|H(f)|^2P_x(f)\]</span></p><h3 id="希尔伯特变换与解析信号">4.2 希尔伯特变换与解析信号</h3><ul><li>希尔伯特变换： <span class="math display">\[实信号x(t)的希尔波特变换\widehat{x}(t)是将x(t)通过一个特定滤波器的输出。\]</span></li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换.png" alt="希尔伯特变换"><figcaption aria-hidden="true">希尔伯特变换</figcaption></figure><p><span class="math display">\[H(f)=-j*sgn(f)=\begin{cases} -j，f&gt;0\\ j，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[h(t)=\frac{1}{\pi t}\]</span></p><p>​ 由于|H(f)|<sup>2</sup>=1，故希尔伯特变换不改变能量（功率）谱密度，不改变自相关函数。</p><p>​ 偶函数的希尔伯特变换是奇函数，奇函数的希尔伯特变换是偶函数。</p><p><span class="math display">\[x(t)与\widehat{x}(t)正交：\int_{-\infty}^{\infty} {\widehat{x}(t)x(t)}dt=0\]</span> ​ 常用希尔伯特变换对：</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/希尔伯特变换对.jpg" alt="希尔伯特变换对"><figcaption aria-hidden="true">希尔伯特变换对</figcaption></figure><ul><li><p>解析信号</p><p>实信号x(t)的解析信号z(t)定义为如下复信号：<span class="math display">\[z(t)=x(t)+j\widehat{x}(t)\]</span></p></li></ul><p><span class="math display">\[H(f)=1+j·[-j·sgn(f)]=1+sgn(f)=\begin{cases} 2，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[Z(f)=H(f)X(f)=\begin{cases} 2X(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p>​ 功率谱密度： <span class="math display">\[P_Z(f)=|1+sgn(f)|^2P_x(f)=\begin{cases} 4P_x(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><h2 id="带通信号">5.带通信号</h2><h3 id="带通信号的复包络">5.1 带通信号的复包络</h3><p>带通信号：频谱集中在某个载频f<sub>c</sub>附近，默认假设最高频率不超过2f<sub>c</sub></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通信号.png" alt="带通信号"><figcaption aria-hidden="true">带通信号</figcaption></figure><p>复包络： <span class="math display">\[实带通信号x(t)的复包络定义为:x_L(t)=z(t)e^{-j2\pi f_ct},其中z(t)=x(t)+j·\widehat{x}(t)\]</span></p><p><span class="math display">\[x_L(t)=[x(t)+j·\widehat{x}(t)]e^{-j2\pi f_ct}\]</span></p><ul><li>频谱关系</li></ul><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/基带信号、解析信号、带通信号.png" alt="基带信号、解析信号、带通信号"><figcaption aria-hidden="true">基带信号、解析信号、带通信号</figcaption></figure><ul><li><p>功率谱密度关系 <span class="math display">\[解析信号的功率谱密度:P_Z(f)=\begin{cases} 4P_x(f)，f&gt;0\\ 0，f&lt;0\end{cases}\]</span></p><p><span class="math display">\[复包络的功率谱密度:P_L(f)=P_Z(f+f_c)=\begin{cases} 4P_x(f+f_c)，|f|&lt;f_c\\ 0，else\end{cases}\]</span></p></li></ul><h3 id="带通信号的三种表示方法">5.2 带通信号的三种表示方法</h3><ul><li><p><span class="math display">\[x(t)=Re\{x_L(t)e^{j2\pi fct}\}\]</span></p></li><li><p><span class="math display">\[x(t)=x_c(t)cos2\pi f_ct-x_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[x_c(t)=Re\{x_L(t)\}\quad同相分量\]</span></p><p><span class="math display">\[x_s(t)=Im\{x_L(t)\}\quad正交分量\]</span></p><p><span class="math display">\[x_L(t)=x_c(t)+j·x_s(t)\]</span></p></li><li><p><span class="math display">\[x(t)=A(t)cos[2\pi f_ct+\varphi(t)]\]</span></p><p><span class="math display">\[A(t)=|x_L(t)|\quad包络\]</span></p><p><span class="math display">\[\varphi(t)=\angle x_L(t)\quad相位\]</span></p><p><span class="math display">\[x_L(t)=A(t)e^{j\varphi(t)}\]</span></p></li></ul><h3 id="带通系统的等效基带分析">5.3 带通系统的等效基带分析</h3><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/带通系统的等效基带分析.png" alt="带通系统的等效基带分析"> <span class="math display">\[H_e(f)=\frac{1}{2}H_L(f)=H(f+f_c),\quad h_e(t)=\frac{1}{2}h_L(t)\]</span></p><blockquote><p>例题：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/image-20230419234031223.png"></p></blockquote><h1 id="三随机过程">三、随机过程</h1><h2 id="随机过程">1.随机过程</h2><p>随机变量X：随机实验的结果是确定实数，X∈{x<sub>1</sub>,x<sub>2</sub>,…}</p><p>随机过程X(t)：随机实验的结果是确定的函数，X(t)∈{x<sub>1</sub>(t),x<sub>2</sub>(t),…}</p><p>随机过程X(t)是沿时间轴-∞&lt;t&lt;∞排列的无数个随机变量。</p><h3 id="随机过程的统计特性">1.1 随机过程的统计特性</h3><p>随机过程的数学期望： <span class="math display">\[E[X(t)]=m_X(t)\]</span> 任意随机过程可以看成是零均值随机过程与确定函数的和。</p><p>X(t)，Y(t)的互相关函数： <span class="math display">\[R_{XY}(t_1,t_2)=E[X(t_1)Y(t_2)]\]</span></p><blockquote><p>X(t)，Y(t)是两个随机过程，随便在两个过程上取两个时间，这样得到两个随机变量。</p><p>确定信号的互相关函数取平均是时间平均，随机信号的互相关函数取平均是统计平均。</p></blockquote><p>X(t)的自相关函数： <span class="math display">\[R_{X}(t_1,t_2)=E[X(t_1)X(t_2)]\]</span></p><p><span class="math display">\[\tau=t_1-t_2\]</span></p><p>平均自相关函数：对t做时间平均： <span class="math display">\[\overline{R}_X(\tau)=\overline{E[X(t+\tau)X(t)]}=E[\overline{X(t+\tau)X(t)}]\]</span></p><h3 id="随机过程的功率谱密度">1.2 随机过程的功率谱密度</h3><p>随机过程X(t)是从样本空间中随机抽出一个确定的样本函数x(t)。 <span class="math display">\[P_x(f)=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)\]</span> 每个样函数x(t)都有各自的功率谱密度。</p><p>随机抽出的不同样函数的功率谱密度可能不同。随机过程的功率谱密度定义为<strong>所有样本函数的功率谱密度的统计平均</strong>： <span class="math display">\[\overline{P}_x(f)=E[\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}|F[x_T(t)]|^2\bigg)]=\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}E[|F[x_T(t)]|^2]\bigg)\]</span> 随机过程的功率谱密度是<strong>平均</strong>自相关函数的傅氏变换。</p><h2 id="平稳随机过程">2.平稳随机过程</h2><h3 id="狭义严平稳随机过程">2.1 狭义（严）平稳随机过程</h3><p>对于任意n和t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>以及τ有分布函数： <span class="math display">\[F_n(x_1,x_2,...,x_n;t_1.t_2,...,t_n)=F_n(x_1,x_2,...,x_n,t_1+\tau,t_2+\tau,...,t_n+\tau)\]</span> 称X(t)为狭义（严）平稳随机过程。</p><h3 id="广义宽平稳随机过程">2.2 广义（宽）平稳随机过程</h3><p><span class="math display">\[满足E[X(t)]=m_X,R_X(t+\tau,t)=R_X(\tau),称X(t)为宽平稳随机过程。\]</span></p><blockquote><p>均值和自相关满足遍历性的平稳过程叫做广义遍历过程。</p><p>遍历：每个样本函数的时间平均等于随机过程（所有样本函数）的统计平均。 <span class="math display">\[例如X(t)=cos(2\pi f_0t+\theta),X(t)就是随机过程，其中\theta可以取不同的值，求m_X也就是求X(t)的统计平均，一般是对\theta根据其所属分布求平均；而样本函数x(t)也就是确定了一个X(t)，\theta值固定，对其求时间平均就是对t求平均，\lim_{T\rightarrow+\infty}\bigg(\frac{1}{T}\int_{-\frac{T}{2}}^{\frac{T}{2}}{x_T(t)}dt\bigg)这样去求\]</span></p></blockquote><ul><li><p>功率谱密度 <span class="math display">\[随机过程的功率谱密度是平均自相关函数的傅氏变换。\]</span></p><p><span class="math display">\[因为平稳过程的自相关函数与t无关，故\overline{R}_X(\tau)=R_X(\tau)\]</span></p><p><span class="math display">\[P_X(f)=\int_{-\infty}^{\infty}{R_X(\tau)e^{-j2\pi f\tau}}d\tau\]</span></p></li></ul><h3 id="联合平稳">2.3 联合平稳</h3><p>X(t)、Y(t)联合平稳：除X(t)、Y(t)各自平稳外，还满足： <span class="math display">\[E[X(t+\tau)Y(t)]=R_{XY}(\tau)\]</span></p><blockquote><p>随机变量的不相关和独立： <span class="math display">\[不相关:E[XY]=E[X]E[Y]\]</span></p><p><span class="math display">\[独立:Pr\{A,B\}=Pr\{A\}Pr\{B\},f_{XY}(x,y)=f_X(x)f_Y(y)\]</span></p><p>若独立，则不相关。反之不一定。</p></blockquote><p>两个随机过程不相关：X(t<sub>1</sub>)，Y(t<sub>2</sub>) <span class="math display">\[E[X(t_1)Y(t_2)]=E[X(t_1)]E[Y(t_2)]\]</span></p><p><span class="math display">\[R_{XY}(t_1,t_2)=m_X(t_1)m_Y(t_2)\]</span></p><p>两个随机过程在同一时刻不相关： <span class="math display">\[t_1=t_2=t,E[X(t)Y(t)]=E[X(t)]E[Y(t)]\]</span></p><p><span class="math display">\[R_{XY}(t,t)=m_X(t)m_Y(t)\]</span></p><p>零均值平稳过程的相关系数：</p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/相关系数.png"></p><blockquote><p>看互相关函数，为零则不相关（因为是零均值平稳过程）</p></blockquote><h3 id="平稳过程通过线性系统">2.4 平稳过程通过线性系统</h3><p>平稳过程通过线性系统后还是平稳过程，且输入输出联合平稳。 <span class="math display">\[m_Y=m_XH(0)\quad P_Y(f)=|H(f)|^2P_X(f)\]</span> 零均值平稳过程X(t)的希尔伯特变换是零均值平稳过程。希尔伯特变换不改变功率谱密度、自相关函数。 <span class="math display">\[X(t)与\widehat{X}(t)在同一时刻不相关\]</span></p><h3 id="复平稳过程">2.5 复平稳过程</h3><ul><li><p>一种判断方法：Z(t)的实部X(t)、虚部Y(t)联合平稳。即X(t)、Y(t)各自平稳且互相关函数与t无关。</p></li><li><p>另一种判断方法：如果复过程的均值、自相关函数、共轭相关函数与t无关，则它是复平稳过程 <span class="math display">\[E[Z(t)]=m_Z\quad 均值与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z^*(t)]=R_Z(\tau)\quad 自相关函数与t无关\]</span></p><p><span class="math display">\[E[Z(t+\tau)Z(t)]=R_{ZZ^*}(\tau)\quad 共轭相关函数与t无关\]</span></p></li></ul><h3 id="平稳带通过程的解析信号及复包络">2.6 平稳带通过程的解析信号及复包络</h3><p>零均值平稳过程X(t)的解析信号是零均值复平稳过程，且共轭不相关（共轭相关函数为0）。 <span class="math display">\[解析信号的自相关函数是R_X(\tau)的解析信号的2倍；功率谱密度是P_X(f)正频率部分的4倍。\]</span></p><p><span class="math display">\[R_Z(\tau)=2[R_X(\tau)+j·\widehat{R}_X(\tau)]\]</span></p><p>零均值平稳带通过程X(t)的复包络X<sub>L(</sub>t)=Z(t)e<sup>-j2πf_<sub>c</sub>t</sup>是零均值复平稳过程，且共轭不相关。</p><p>复包络的功率谱密度是P<sub>X</sub>(f)正频率部分的4倍向下搬移。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)是零均值联合平稳，且有相同的功率谱密度及自相关函数。</p><p>X(t)的同相分量X<sub>c</sub>(t)和正交分量X<sub>s</sub>(t)在同一时刻不相关。</p><h3 id="平稳序列和循环平稳过程">2.7 平稳序列和循环平稳过程</h3><ul><li><p>随机序列：{X<sub>n</sub>}是无限个随机变量</p></li><li><p>广义平稳序列：{X<sub>n</sub>}的均值及自相关函数与绝对时间n无关 <span class="math display">\[E[X_n]=m_X(n)=m_X,\quad n=0,\pm1,\pm2,...\]</span></p><p><span class="math display">\[E[X_{n+m}X_n]=R_X(n+m,n)=R_X(m)\]</span></p></li><li><p>循环（周期）平稳过程：均值与自相关函数是t的周期函数 <span class="math display">\[E[X(t+T)]=E[X(t)]\]</span></p><p><span class="math display">\[E[X(t+T+\tau)X(t+T)]=E[X(t+\tau)X(t)]\]</span></p><p>循环平稳过程不是平稳过程。</p></li></ul><h2 id="高斯噪声">3.高斯噪声</h2><h3 id="高斯过程">3.1 高斯过程</h3><ul><li>高斯（正态）分布：</li></ul><p><span class="math display">\[高斯随机变量X\sim N(a,\sigma^2)的概率密度函数为p_X(x)=\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{(x-a)^2}{2\sigma^2}}\]</span></p><ul><li>Q函数：</li></ul><p><span class="math display">\[定义：Q(x)=Pr\{X&gt;x\}=\frac{1}{\sqrt{2\pi}}\int_{x}^{\infty}{e^{-\frac{t^2}{2}}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1)大于x的概率\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/Q函数.png" alt="Q函数"><figcaption aria-hidden="true">Q函数</figcaption></figure><ul><li>erfc函数：</li></ul><p><span class="math display">\[定义：erfc(x)=\frac{2}{\sqrt{\pi}}\int_{x}^{\infty}{e^{-t^2}}dt\]</span></p><p><span class="math display">\[含义：X\sim N(0,1/2),|X|大于x的概率\]</span></p><p><span class="math display">\[erfc(x)=Pr\{|X|&gt;x\}=\int_{x}^{\infty}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\int_{-\infty}^{-x}{\frac{1}{\sqrt{\pi}}e^{-t^2}}dt\]</span></p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/erfc函数.png" alt="erfc函数"><figcaption aria-hidden="true">erfc函数</figcaption></figure><ul><li><p>联合高斯： <span class="math display">\[设Z_1,Z_2,...,Z_n是一组独立同分布的标准正态随机变量，Z_i\sim N(0,1)。若X_1,X_2,...,X_k中的每一个都是Z_1,Z_2,...,Z_n以及常数的线性组合，则称X_1,X_2,...,X_k服从联合高斯分布。\]</span></p><p><span class="math display">\[\begin{pmatrix}X_1  \\X_2  \\...  \\X_k  \\\end{pmatrix}=\begin{pmatrix}a_{11}&amp;a_{12}&amp;...&amp;a_{1n}  \\a_{21}&amp;a_{22}&amp;...&amp;a_{2n}  \\... &amp;...&amp;...&amp;... \\a_{k1}&amp;a_{k2}&amp;...&amp;a_{kn}  \\\end{pmatrix}\begin{pmatrix}Z_1  \\Z_2  \\...  \\Z_n  \\\end{pmatrix}+\begin{pmatrix}b_1  \\b_2  \\...  \\b_k  \\\end{pmatrix}\]</span> 若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，则X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>的各种线性组合也是联合高斯。</p><p>若X<sub>1</sub>,X<sub>2</sub>,...,X<sub>k</sub>是联合高斯，m<sub>1</sub>,m<sub>2</sub>,...,m<sub>k</sub>是常数，则m<sub>1</sub>X<sub>1</sub>,m<sub>2</sub>X<sub>2</sub>,...,m<sub>k</sub>X<sub>k</sub>是联合高斯。</p></li><li><p>高斯过程：设X(t)是随机过程，若对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，X(t<sub>1</sub>),X(t<sub>2</sub>),...X(t<sub>n</sub>)联合高斯，则称X(t)为高斯过程。</p><blockquote><p>随机过程是沿时间排列的无数个随机变量。</p></blockquote><p>设X(t)是高斯过程，m(t)是确定信号，则Y(t)=m(t)X(t)是高斯过程。</p><p>对于任意n个时刻t<sub>1</sub>,t<sub>2</sub>,...,t<sub>n</sub>，Y(t<sub>i</sub>)=m(t<sub>i</sub>)X(t<sub>i</sub>)。而m(t<sub>1</sub>),m(t<sub>2</sub>),...m(t<sub>n</sub>)是一组确定的系数，故Y(t<sub>1</sub>), Y(t<sub>2</sub>),...Y(t<sub>n</sub>)联合高斯。</p></li></ul><h3 id="高斯白噪声">3.2 高斯白噪声</h3><ul><li>理想限带高斯白噪声：带宽为B的理想限带高斯白噪声n<sub>B</sub>(t)是一种零均值平稳高斯过程。</li></ul><p><span class="math display">\[其功率谱密度为：P_{n_B}(f)=\begin{cases}\frac{N_0}{2}，f\leq B\\ 0，else\end{cases}\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度.png" alt="功率谱密度"> <span class="math display">\[其自相关函数为：R_{n_B}(\tau)=N_0B·sinc(2B\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数.png" alt="自相关函数"> <span class="math display">\[功率:P=R_{n_B}(0)=\int_{-\infty}^{\infty}{P_{n_B}(f)}df=N_0B\]</span></p><ul><li>高斯白噪声：高斯白噪声是理想限带高斯白噪声的极限：</li></ul><p><span class="math display">\[n_w(t)=\lim_{B\rightarrow+\infty}n_B(t)\]</span></p><p><span class="math display">\[P_{n_w}(f)=\frac{N_0}{2}\]</span></p><p><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/功率谱密度1.png" alt="功率谱密度"> <span class="math display">\[R_{n_w}(\tau)=\frac{N_0}{2}\delta(\tau)\]</span> <img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/自相关函数1.png" alt="自相关函数"></p><h3 id="高斯白噪声与确定信号的内积">3.3 高斯白噪声与确定信号的内积</h3><p>高斯白噪声与确定信号的内积是零均值高斯随机变量，方差为 <span class="math display">\[\frac{N_0}{2}E_g\]</span> 高斯白噪声在两个正交确定信号上的内积是两个独立的零均值高斯随机变量。</p><p>高斯白噪声在一组归一化正交函数上的投影是一组独立同分布的高斯随机变量，方差均为N<sub>0</sub>/2。</p><h3 id="窄带高斯噪声的解析信号及复包络">3.4 窄带高斯噪声的解析信号及复包络</h3><p>窄带高斯噪声：窄带高斯噪声n(t)就是高斯白噪声通过带通滤波器的输出。n(t)是带通型的零均值平稳高斯过程。 <span class="math display">\[解析信号:z(t)=n(t)+j·\widehat{n}(t)\]</span></p><p><span class="math display">\[复包络:n_L(t)=z(t)e^{-j2\pi f_ct}\]</span></p><p><span class="math display">\[同相分量:n_c(t)=Re\{n_L(t)\}\quad 正交分量:n_s(t)=Im\{n_L(t)\}\]</span></p><p><span class="math display">\[根据带通信号的表示方法:n(t)=n_c(t)cos2\pi f_ct-n_s(t)sin2\pi f_ct\]</span></p><p><span class="math display">\[n(t)的功率谱密度为P_n(f)=\frac{N_0}{2}|H(f)|^2\]</span></p><p>n(t)的解析信号z(t)是零均值平稳复高斯过程，满足共轭不相关。 <span class="math display">\[z(t)的功率谱密度为P_Z(f)=\begin{cases} 4P_n(f),f&gt;0\\ 0， f&lt;0\end{cases}\]</span></p><h3 id="窄带高斯噪声的同相分量及正交分量">3.5 窄带高斯噪声的同相分量及正交分量</h3><p>n(t)的同相分量n<sub>c</sub>(t)、正交分量n<sub>s</sub>(t)是联合平稳的零均值高斯过程，二者有相同的自相关函数和功率谱密度，在同一时刻独立。</p><blockquote><p>对于高斯过程，不相关等于独立。</p></blockquote><p><span class="math display">\[三者有相同的功率:P_{n_c}=P_{n_s}=P_{n}\]</span></p><p>n<sub>c</sub>(t)与n<sub>s</sub>(t)有相同的功率谱密度： <span class="math display">\[P_c(f)=P_s(f)=P_n(f+f_c)+P_n(f-f_c)\]</span> n(t)的包络A(t)服从瑞利分布，相位φ(t)服从均匀分布。</p><h1 id="四模拟通信系统">四、模拟通信系统</h1><p>模拟信号m(t)是模仿物理量变化的电信号，m(t)一般的特征：时间连续、取值连续。</p><blockquote><p>默认m(t)不包含直流分量，频域就体现为频谱不含f=0处的冲击δ(f)</p></blockquote><p>模拟基带信号的传输：</p><ul><li><p>基带传输： <span class="math display">\[\xrightarrow{m(t)} \boxed{基带信道}\to\]</span></p></li><li><p>频带传输: <span class="math display">\[\xrightarrow{m(t)} \boxed{调制器}\xrightarrow{s(t)}\boxed{带通信号}\xrightarrow{}\boxed{解调器}\xrightarrow{}\]</span></p></li><li><p>数字化传输： <span class="math display">\[\xrightarrow{m(t)} \boxed{数字化}\xrightarrow{}\boxed{数字传输}\xrightarrow{}\boxed{还原}\xrightarrow{}\]</span></p></li></ul><p>本章假设理想无失真信道；无失真：波形不变，可以有延迟，可以有幅度变化；默认假设K=1、t<sub>0</sub>=0。 <span class="math display">\[s(t)\xrightarrow{}\boxed{信道}\xrightarrow{}K·s(t-t_0)\]</span> 系统模型：称m(t)为调制信号，称s(t)为已调信号。</p><figure><img src="/2023/01/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86(%E2%85%A0)/系统模型.png" alt="系统模型"><figcaption aria-hidden="true">系统模型</figcaption></figure><p>模拟调制的基本思路：</p><ul><li><p>目标：发送端：把基带信号m(t)变成带通信号s(t)；</p><p>​ 接收端：从带通信号s(t)中恢复出m(t)。</p></li><li><p>思路：发送端：让s(t)的复包络s<sub>L</sub>(t)携带m(t);</p><p>​ 接收端：先取复包络，再恢复m(t)。</p></li></ul><p>模拟调制的典型方法：</p><ul><li><p>幅度类调制：复包络就是m(t)—DSB-SC</p><p>​ 包络携带m(t)—AM</p><p>​ 复包络的实部是m(t)—SSB</p></li><li><p>角度类调制：复包络的相位φ(t)与mO(t)成比例—PM</p><p>​ φ(t)的斜率与m(t)成比例—FM</p></li></ul><p>关键性能指标：</p><ul><li><p>发送端：已调信号的带宽及频谱特征，涉及对频谱资源的耗费情况。</p></li><li><p>接收端：输出信噪比： <span class="math display">\[\Big(\frac{S}{N}\Big)_o=\frac{\overline{m^2(t)}}{E[n^2_o(t)]}\]</span> 涉及对功率资源的耗费情况。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>专业课程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通信原理</tag>
      
      <tag>专业课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
